"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Stack_constructing, _LRUCache_instances, _LRUCache_max, _LRUCache_maxSize, _LRUCache_dispose, _LRUCache_onInsert, _LRUCache_disposeAfter, _LRUCache_fetchMethod, _LRUCache_memoMethod, _LRUCache_size, _LRUCache_calculatedSize, _LRUCache_keyMap, _LRUCache_keyList, _LRUCache_valList, _LRUCache_next, _LRUCache_prev, _LRUCache_head, _LRUCache_tail, _LRUCache_free, _LRUCache_disposed, _LRUCache_sizes, _LRUCache_starts, _LRUCache_ttls, _LRUCache_hasDispose, _LRUCache_hasFetchMethod, _LRUCache_hasDisposeAfter, _LRUCache_hasOnInsert, _LRUCache_initializeTTLTracking, _LRUCache_updateItemAge, _LRUCache_statusTTL, _LRUCache_setItemTTL, _LRUCache_isStale, _LRUCache_initializeSizeTracking, _LRUCache_removeItemSize, _LRUCache_addItemSize, _LRUCache_requireSize, _LRUCache_indexes, _LRUCache_rindexes, _LRUCache_isValidIndex, _LRUCache_evict, _LRUCache_backgroundFetch, _LRUCache_isBackgroundFetch, _LRUCache_connect, _LRUCache_moveToTail, _LRUCache_delete, _LRUCache_clear, _b;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs$1 = require("fs");
const path = require("path");
const SQL = require("better-sqlite3");
const crypto = require("crypto");
const require$$0 = require("zlib");
const require$$0$1 = require("util");
const require$$1 = require("string_decoder");
const require$$1$1 = require("events");
const require$$4 = require("timers");
function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
        for (const k in e) {
            if (k !== "default") {
                const d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: () => e[k]
                });
            }
        }
    }
    n.default = e;
    return Object.freeze(n);
}
function _mergeNamespaces(n, m) {
    for (var i = 0; i < m.length; i++) {
        const e = m[i];
        if (typeof e !== "string" && !Array.isArray(e)) {
            for (const k in e) {
                if (k !== "default" && !(k in n)) {
                    const d = Object.getOwnPropertyDescriptor(e, k);
                    if (d) {
                        Object.defineProperty(n, k, d.get ? d : {
                            enumerable: true,
                            get: () => e[k]
                        });
                    }
                }
            }
        }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs$1);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const db$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get all() {
        return all;
    },
    get asyncTransaction() {
        return asyncTransaction;
    },
    get cache() {
        return cache;
    },
    get closeDatabase() {
        return closeDatabase;
    },
    get deleteAccount() {
        return deleteAccount;
    },
    get deleteAll() {
        return deleteAll;
    },
    get deleteCategory() {
        return deleteCategory$1;
    },
    get deleteCategoryGroup() {
        return deleteCategoryGroup$1;
    },
    get deletePayee() {
        return deletePayee;
    },
    get deleteTag() {
        return deleteTag$1;
    },
    get deleteTransaction() {
        return deleteTransaction$2;
    },
    get deleteTransferPayee() {
        return deleteTransferPayee;
    },
    get delete_() {
        return delete_;
    },
    get execQuery() {
        return execQuery;
    },
    get findTags() {
        return findTags$1;
    },
    get first() {
        return first;
    },
    get firstSync() {
        return firstSync;
    },
    get fromDateRepr() {
        return fromDateRepr;
    },
    get getAccount() {
        return getAccount;
    },
    get getAccounts() {
        return getAccounts$2;
    },
    get getAllTags() {
        return getAllTags;
    },
    get getCategories() {
        return getCategories$3;
    },
    get getCategoriesGrouped() {
        return getCategoriesGrouped;
    },
    get getCommonPayees() {
        return getCommonPayees$1;
    },
    get getDatabase() {
        return getDatabase;
    },
    get getDatabasePath() {
        return getDatabasePath;
    },
    get getOrphanedPayees() {
        return getOrphanedPayees$1;
    },
    get getPayee() {
        return getPayee$1;
    },
    get getPayeeByName() {
        return getPayeeByName;
    },
    get getPayees() {
        return getPayees$2;
    },
    get getTags() {
        return getTags$1;
    },
    get getTransaction() {
        return getTransaction;
    },
    get getTransactions() {
        return getTransactions$1;
    },
    get insert() {
        return insert;
    },
    get insertAccount() {
        return insertAccount;
    },
    get insertCategory() {
        return insertCategory;
    },
    get insertCategoryGroup() {
        return insertCategoryGroup;
    },
    get insertPayee() {
        return insertPayee;
    },
    get insertTag() {
        return insertTag;
    },
    get insertTransaction() {
        return insertTransaction;
    },
    get insertWithSchema() {
        return insertWithSchema;
    },
    get insertWithUUID() {
        return insertWithUUID;
    },
    get loadClock() {
        return loadClock;
    },
    get mergePayees() {
        return mergePayees$1;
    },
    get moveAccount() {
        return moveAccount$1;
    },
    get moveCategory() {
        return moveCategory$1;
    },
    get moveCategoryGroup() {
        return moveCategoryGroup$1;
    },
    get openDatabase() {
        return openDatabase;
    },
    get run() {
        return run;
    },
    get runQuery() {
        return runQuery;
    },
    get select() {
        return select;
    },
    get selectFirstWithSchema() {
        return selectFirstWithSchema;
    },
    get selectWithSchema() {
        return selectWithSchema;
    },
    get setDatabase() {
        return setDatabase;
    },
    get syncGetOrphanedPayees() {
        return syncGetOrphanedPayees;
    },
    get toDateRepr() {
        return toDateRepr;
    },
    get transaction() {
        return transaction;
    },
    get update() {
        return update;
    },
    get updateAccount() {
        return updateAccount$1;
    },
    get updateCategory() {
        return updateCategory$1;
    },
    get updateCategoryGroup() {
        return updateCategoryGroup$1;
    },
    get updatePayee() {
        return updatePayee;
    },
    get updateTag() {
        return updateTag$1;
    },
    get updateTransaction() {
        return updateTransaction$2;
    },
    get updateWithSchema() {
        return updateWithSchema;
    }
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var googleProtobuf$1 = {};
var hasRequiredGoogleProtobuf;
function requireGoogleProtobuf() {
    if (hasRequiredGoogleProtobuf)
        return googleProtobuf$1;
    hasRequiredGoogleProtobuf = 1;
    (function (exports2) {
        var aa = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {
            a != Array.prototype && a != Object.prototype && (a[b] = c.value);
        }, e = "undefined" != typeof window && window === googleProtobuf$1 ? googleProtobuf$1 : "undefined" != typeof commonjsGlobal && null != commonjsGlobal ? commonjsGlobal : googleProtobuf$1;
        function ba(a, b) {
            if (b) {
                var c = e;
                a = a.split(".");
                for (var d = 0; d < a.length - 1; d++) {
                    var f2 = a[d];
                    f2 in c || (c[f2] = {});
                    c = c[f2];
                }
                a = a[a.length - 1];
                d = c[a];
                b = b(d);
                b != d && null != b && aa(c, a, { configurable: true, writable: true, value: b });
            }
        }
        function ca2(a) {
            var b = 0;
            return function () {
                return b < a.length ? { done: false, value: a[b++] } : { done: true };
            };
        }
        function da2() {
            da2 = function () {
            };
            e.Symbol || (e.Symbol = ea);
        }
        function fa(a, b) {
            this.a = a;
            aa(this, "description", { configurable: true, writable: true, value: b });
        }
        fa.prototype.toString = function () {
            return this.a;
        };
        var ea = /* @__PURE__ */ function () {
            function a(c) {
                if (this instanceof a)
                    throw new TypeError("Symbol is not a constructor");
                return new fa("jscomp_symbol_" + (c || "") + "_" + b++, c);
            }
            var b = 0;
            return a;
        }();
        function ha() {
            da2();
            var a = e.Symbol.iterator;
            a || (a = e.Symbol.iterator = e.Symbol("Symbol.iterator"));
            "function" != typeof Array.prototype[a] && aa(Array.prototype, a, { configurable: true, writable: true, value: function () {
                    return ia(ca2(this));
                } });
            ha = function () {
            };
        }
        function ia(a) {
            ha();
            a = { next: a };
            a[e.Symbol.iterator] = function () {
                return this;
            };
            return a;
        }
        function ja2(a, b) {
            ha();
            a instanceof String && (a += "");
            var c = 0, d = { next: function () {
                    if (c < a.length) {
                        var f2 = c++;
                        return { value: b(f2, a[f2]), done: false };
                    }
                    d.next = function () {
                        return { done: true, value: void 0 };
                    };
                    return d.next();
                } };
            d[Symbol.iterator] = function () {
                return d;
            };
            return d;
        }
        ba("Array.prototype.entries", function (a) {
            return a ? a : function () {
                return ja2(this, function (b, c) {
                    return [b, c];
                });
            };
        });
        var ka2 = googleProtobuf$1 || self;
        function g(a, b, c) {
            a = a.split(".");
            c = c || ka2;
            a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
            for (var d; a.length && (d = a.shift());)
                a.length || void 0 === b ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b;
        }
        function k(a) {
            var b = typeof a;
            if ("object" == b)
                if (a) {
                    if (a instanceof Array)
                        return "array";
                    if (a instanceof Object)
                        return b;
                    var c = Object.prototype.toString.call(a);
                    if ("[object Window]" == c)
                        return "object";
                    if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
                        return "array";
                    if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
                        return "function";
                }
                else
                    return "null";
            else if ("function" == b && "undefined" == typeof a.call)
                return "object";
            return b;
        }
        function la(a) {
            var b = typeof a;
            return "object" == b && null != a || "function" == b;
        }
        function ma(a, b, c) {
            g(a, b, c);
        }
        function na(a, b) {
            function c() {
            }
            c.prototype = b.prototype;
            a.prototype = new c();
            a.prototype.constructor = a;
        }
        var oa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
        function pa(a, b) {
            for (var c, d, f2 = 1; f2 < arguments.length; f2++) {
                d = arguments[f2];
                for (c in d)
                    a[c] = d[c];
                for (var h = 0; h < oa.length; h++)
                    c = oa[h], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
            }
        }
        var qa = Array.prototype.forEach ? function (a, b) {
            Array.prototype.forEach.call(a, b, void 0);
        } : function (a, b) {
            for (var c = a.length, d = "string" === typeof a ? a.split("") : a, f2 = 0; f2 < c; f2++)
                f2 in d && b.call(void 0, d[f2], f2, a);
        }, l = Array.prototype.map ? function (a, b) {
            return Array.prototype.map.call(a, b, void 0);
        } : function (a, b) {
            for (var c = a.length, d = Array(c), f2 = "string" === typeof a ? a.split("") : a, h = 0; h < c; h++)
                h in f2 && (d[h] = b.call(void 0, f2[h], h, a));
            return d;
        };
        function ra(a, b, c) {
            return 2 >= arguments.length ? Array.prototype.slice.call(a, b) : Array.prototype.slice.call(a, b, c);
        }
        function sa(a, b, c, d) {
            var f2 = "Assertion failed";
            if (c) {
                f2 += ": " + c;
                var h = d;
            }
            else
                a && (f2 += ": " + a, h = b);
            throw Error(f2, h || []);
        }
        function n(a, b, c) {
            for (var d = [], f2 = 2; f2 < arguments.length; ++f2)
                d[f2 - 2] = arguments[f2];
            a || sa("", null, b, d);
            return a;
        }
        function ta2(a, b, c) {
            for (var d = [], f2 = 2; f2 < arguments.length; ++f2)
                d[f2 - 2] = arguments[f2];
            "string" !== typeof a && sa("Expected string but got %s: %s.", [k(a), a], b, d);
        }
        function ua(a, b, c) {
            for (var d = [], f2 = 2; f2 < arguments.length; ++f2)
                d[f2 - 2] = arguments[f2];
            Array.isArray(a) || sa("Expected array but got %s: %s.", [k(a), a], b, d);
        }
        function p(a, b) {
            for (var c = [], d = 1; d < arguments.length; ++d)
                c[d - 1] = arguments[d];
            throw Error("Failure" + (a ? ": " + a : ""), c);
        }
        function q2(a, b, c, d) {
            for (var f2 = [], h = 3; h < arguments.length; ++h)
                f2[h - 3] = arguments[h];
            a instanceof b || sa("Expected instanceof %s but got %s.", [va(b), va(a)], c, f2);
        }
        function va(a) {
            return a instanceof Function ? a.displayName || a.name || "unknown type name" : a instanceof Object ? a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a) : null === a ? "null" : typeof a;
        }
        function r(a, b) {
            this.c = a;
            this.b = b;
            this.a = {};
            this.arrClean = true;
            if (0 < this.c.length) {
                for (a = 0; a < this.c.length; a++) {
                    b = this.c[a];
                    var c = b[0];
                    this.a[c.toString()] = new wa(c, b[1]);
                }
                this.arrClean = true;
            }
        }
        g("jspb.Map", r, void 0);
        r.prototype.g = function () {
            if (this.arrClean) {
                if (this.b) {
                    var a = this.a, b;
                    for (b in a)
                        if (Object.prototype.hasOwnProperty.call(a, b)) {
                            var c = a[b].a;
                            c && c.g();
                        }
                }
            }
            else {
                this.c.length = 0;
                a = u(this);
                a.sort();
                for (b = 0; b < a.length; b++) {
                    var d = this.a[a[b]];
                    (c = d.a) && c.g();
                    this.c.push([d.key, d.value]);
                }
                this.arrClean = true;
            }
            return this.c;
        };
        r.prototype.toArray = r.prototype.g;
        r.prototype.Mc = function (a, b) {
            for (var c = this.g(), d = [], f2 = 0; f2 < c.length; f2++) {
                var h = this.a[c[f2][0].toString()];
                v(this, h);
                var m = h.a;
                m ? (n(b), d.push([h.key, b(a, m)])) : d.push([h.key, h.value]);
            }
            return d;
        };
        r.prototype.toObject = r.prototype.Mc;
        r.fromObject = function (a, b, c) {
            b = new r([], b);
            for (var d = 0; d < a.length; d++) {
                var f2 = a[d][0], h = c(a[d][1]);
                b.set(f2, h);
            }
            return b;
        };
        function w(a) {
            this.a = 0;
            this.b = a;
        }
        w.prototype.next = function () {
            return this.a < this.b.length ? { done: false, value: this.b[this.a++] } : { done: true, value: void 0 };
        };
        "undefined" != typeof Symbol && (w.prototype[Symbol.iterator] = function () {
            return this;
        });
        r.prototype.Jb = function () {
            return u(this).length;
        };
        r.prototype.getLength = r.prototype.Jb;
        r.prototype.clear = function () {
            this.a = {};
            this.arrClean = false;
        };
        r.prototype.clear = r.prototype.clear;
        r.prototype.Cb = function (a) {
            a = a.toString();
            var b = this.a.hasOwnProperty(a);
            delete this.a[a];
            this.arrClean = false;
            return b;
        };
        r.prototype.del = r.prototype.Cb;
        r.prototype.Eb = function () {
            var a = [], b = u(this);
            b.sort();
            for (var c = 0; c < b.length; c++) {
                var d = this.a[b[c]];
                a.push([d.key, d.value]);
            }
            return a;
        };
        r.prototype.getEntryList = r.prototype.Eb;
        r.prototype.entries = function () {
            var a = [], b = u(this);
            b.sort();
            for (var c = 0; c < b.length; c++) {
                var d = this.a[b[c]];
                a.push([d.key, v(this, d)]);
            }
            return new w(a);
        };
        r.prototype.entries = r.prototype.entries;
        r.prototype.keys = function () {
            var a = [], b = u(this);
            b.sort();
            for (var c = 0; c < b.length; c++)
                a.push(this.a[b[c]].key);
            return new w(a);
        };
        r.prototype.keys = r.prototype.keys;
        r.prototype.values = function () {
            var a = [], b = u(this);
            b.sort();
            for (var c = 0; c < b.length; c++)
                a.push(v(this, this.a[b[c]]));
            return new w(a);
        };
        r.prototype.values = r.prototype.values;
        r.prototype.forEach = function (a, b) {
            var c = u(this);
            c.sort();
            for (var d = 0; d < c.length; d++) {
                var f2 = this.a[c[d]];
                a.call(b, v(this, f2), f2.key, this);
            }
        };
        r.prototype.forEach = r.prototype.forEach;
        r.prototype.set = function (a, b) {
            var c = new wa(a);
            this.b ? (c.a = b, c.value = b.g()) : c.value = b;
            this.a[a.toString()] = c;
            this.arrClean = false;
            return this;
        };
        r.prototype.set = r.prototype.set;
        function v(a, b) {
            return a.b ? (b.a || (b.a = new a.b(b.value)), b.a) : b.value;
        }
        r.prototype.get = function (a) {
            if (a = this.a[a.toString()])
                return v(this, a);
        };
        r.prototype.get = r.prototype.get;
        r.prototype.has = function (a) {
            return a.toString() in this.a;
        };
        r.prototype.has = r.prototype.has;
        r.prototype.Jc = function (a, b, c, d, f2) {
            var h = u(this);
            h.sort();
            for (var m = 0; m < h.length; m++) {
                var t2 = this.a[h[m]];
                b.Va(a);
                c.call(b, 1, t2.key);
                this.b ? d.call(b, 2, v(this, t2), f2) : d.call(b, 2, t2.value);
                b.Ya();
            }
        };
        r.prototype.serializeBinary = r.prototype.Jc;
        r.deserializeBinary = function (a, b, c, d, f2, h, m) {
            for (; b.oa() && !b.bb();) {
                var t2 = b.c;
                1 == t2 ? h = c.call(b) : 2 == t2 && (a.b ? (n(f2), m || (m = new a.b()), d.call(b, m, f2)) : m = d.call(b));
            }
            n(void 0 != h);
            n(void 0 != m);
            a.set(h, m);
        };
        function u(a) {
            a = a.a;
            var b = [], c;
            for (c in a)
                Object.prototype.hasOwnProperty.call(a, c) && b.push(c);
            return b;
        }
        function wa(a, b) {
            this.key = a;
            this.value = b;
            this.a = void 0;
        }
        function xa(a) {
            if (8192 >= a.length)
                return String.fromCharCode.apply(null, a);
            for (var b = "", c = 0; c < a.length; c += 8192)
                b += String.fromCharCode.apply(null, ra(a, c, c + 8192));
            return b;
        }
        var ya = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" }, za = { "'": "\\'" };
        var Aa = {}, x = null;
        function Ba(a, b) {
            void 0 === b && (b = 0);
            Ca();
            b = Aa[b];
            for (var c = [], d = 0; d < a.length; d += 3) {
                var f2 = a[d], h = d + 1 < a.length, m = h ? a[d + 1] : 0, t2 = d + 2 < a.length, B = t2 ? a[d + 2] : 0, M = f2 >> 2;
                f2 = (f2 & 3) << 4 | m >> 4;
                m = (m & 15) << 2 | B >> 6;
                B &= 63;
                t2 || (B = 64, h || (m = 64));
                c.push(b[M], b[f2], b[m] || "", b[B] || "");
            }
            return c.join("");
        }
        function Da(a) {
            var b = a.length, c = 3 * b / 4;
            c % 3 ? c = Math.floor(c) : -1 != "=.".indexOf(a[b - 1]) && (c = -1 != "=.".indexOf(a[b - 2]) ? c - 2 : c - 1);
            var d = new Uint8Array(c), f2 = 0;
            Ea(a, function (h) {
                d[f2++] = h;
            });
            return d.subarray(0, f2);
        }
        function Ea(a, b) {
            function c(B) {
                for (; d < a.length;) {
                    var M = a.charAt(d++), La = x[M];
                    if (null != La)
                        return La;
                    if (!/^[\s\xa0]*$/.test(M))
                        throw Error("Unknown base64 encoding at char: " + M);
                }
                return B;
            }
            Ca();
            for (var d = 0;;) {
                var f2 = c(-1), h = c(0), m = c(64), t2 = c(64);
                if (64 === t2 && -1 === f2)
                    break;
                b(f2 << 2 | h >> 4);
                64 != m && (b(h << 4 & 240 | m >> 2), 64 != t2 && b(m << 6 & 192 | t2));
            }
        }
        function Ca() {
            if (!x) {
                x = {};
                for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++) {
                    var d = a.concat(b[c].split(""));
                    Aa[c] = d;
                    for (var f2 = 0; f2 < d.length; f2++) {
                        var h = d[f2];
                        void 0 === x[h] && (x[h] = f2);
                    }
                }
            }
        }
        g("jspb.ConstBinaryMessage", function () {
        }, void 0);
        g("jspb.BinaryMessage", function () {
        }, void 0);
        g("jspb.BinaryConstants.FieldType", { yb: -1, ee: 1, FLOAT: 2, ke: 3, te: 4, je: 5, xb: 6, wb: 7, BOOL: 8, re: 9, ie: 10, le: 11, ce: 12, se: 13, ge: 14, me: 15, ne: 16, oe: 17, pe: 18, he: 30, ve: 31 }, void 0);
        g("jspb.BinaryConstants.WireType", { yb: -1, ue: 0, xb: 1, de: 2, qe: 3, fe: 4, wb: 5 }, void 0);
        g("jspb.BinaryConstants.FieldTypeToWireType", function (a) {
            switch (a) {
                case 5:
                case 3:
                case 13:
                case 4:
                case 17:
                case 18:
                case 8:
                case 14:
                case 31:
                    return 0;
                case 1:
                case 6:
                case 16:
                case 30:
                    return 1;
                case 9:
                case 11:
                case 12:
                    return 2;
                case 2:
                case 7:
                case 15:
                    return 5;
                default:
                    return -1;
            }
        }, void 0);
        g("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0);
        g("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0);
        g("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0);
        g("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0);
        g("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0);
        g("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0);
        g("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0);
        g("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0);
        g("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0);
        g("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0);
        g("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0);
        g("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0);
        g("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0);
        g("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0);
        g("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
        var y = 0, z = 0;
        g("jspb.utils.getSplit64Low", function () {
            return y;
        }, void 0);
        g("jspb.utils.getSplit64High", function () {
            return z;
        }, void 0);
        function Fa(a) {
            var b = a >>> 0;
            a = Math.floor((a - b) / 4294967296) >>> 0;
            y = b;
            z = a;
        }
        g("jspb.utils.splitUint64", Fa, void 0);
        function A(a) {
            var b = 0 > a;
            a = Math.abs(a);
            var c = a >>> 0;
            a = Math.floor((a - c) / 4294967296);
            a >>>= 0;
            b && (a = ~a >>> 0, c = (~c >>> 0) + 1, 4294967295 < c && (c = 0, a++, 4294967295 < a && (a = 0)));
            y = c;
            z = a;
        }
        g("jspb.utils.splitInt64", A, void 0);
        function Ga(a) {
            var b = 0 > a;
            a = 2 * Math.abs(a);
            Fa(a);
            a = y;
            var c = z;
            b && (0 == a ? 0 == c ? c = a = 4294967295 : (c--, a = 4294967295) : a--);
            y = a;
            z = c;
        }
        g("jspb.utils.splitZigzag64", Ga, void 0);
        function Ha(a) {
            var b = 0 > a ? 1 : 0;
            a = b ? -a : a;
            if (0 === a)
                0 < 1 / a ? y = z = 0 : (z = 0, y = 2147483648);
            else if (isNaN(a))
                z = 0, y = 2147483647;
            else if (34028234663852886e22 < a)
                z = 0, y = (b << 31 | 2139095040) >>> 0;
            else if (11754943508222875e-54 > a)
                a = Math.round(a / Math.pow(2, -149)), z = 0, y = (b << 31 | a) >>> 0;
            else {
                var c = Math.floor(Math.log(a) / Math.LN2);
                a *= Math.pow(2, -c);
                a = Math.round(8388608 * a);
                16777216 <= a && ++c;
                z = 0;
                y = (b << 31 | c + 127 << 23 | a & 8388607) >>> 0;
            }
        }
        g("jspb.utils.splitFloat32", Ha, void 0);
        function Ia(a) {
            var b = 0 > a ? 1 : 0;
            a = b ? -a : a;
            if (0 === a)
                z = 0 < 1 / a ? 0 : 2147483648, y = 0;
            else if (isNaN(a))
                z = 2147483647, y = 4294967295;
            else if (17976931348623157e292 < a)
                z = (b << 31 | 2146435072) >>> 0, y = 0;
            else if (22250738585072014e-324 > a)
                a /= Math.pow(2, -1074), z = (b << 31 | a / 4294967296) >>> 0, y = a >>> 0;
            else {
                var c = a, d = 0;
                if (2 <= c)
                    for (; 2 <= c && 1023 > d;)
                        d++, c /= 2;
                else
                    for (; 1 > c && -1022 < d;)
                        c *= 2, d--;
                a *= Math.pow(2, -d);
                z = (b << 31 | d + 1023 << 20 | 1048576 * a & 1048575) >>> 0;
                y = 4503599627370496 * a >>> 0;
            }
        }
        g("jspb.utils.splitFloat64", Ia, void 0);
        function C(a) {
            var b = a.charCodeAt(4), c = a.charCodeAt(5), d = a.charCodeAt(6), f2 = a.charCodeAt(7);
            y = a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24) >>> 0;
            z = b + (c << 8) + (d << 16) + (f2 << 24) >>> 0;
        }
        g("jspb.utils.splitHash64", C, void 0);
        function D(a, b) {
            return 4294967296 * b + (a >>> 0);
        }
        g("jspb.utils.joinUint64", D, void 0);
        function E(a, b) {
            var c = b & 2147483648;
            c && (a = ~a + 1 >>> 0, b = ~b >>> 0, 0 == a && (b = b + 1 >>> 0));
            a = D(a, b);
            return c ? -a : a;
        }
        g("jspb.utils.joinInt64", E, void 0);
        function Ja(a, b, c) {
            var d = b >> 31;
            return c(a << 1 ^ d, (b << 1 | a >>> 31) ^ d);
        }
        g("jspb.utils.toZigzag64", Ja, void 0);
        function Ka(a, b) {
            return Ma(a, b, E);
        }
        g("jspb.utils.joinZigzag64", Ka, void 0);
        function Ma(a, b, c) {
            var d = -(a & 1);
            return c((a >>> 1 | b << 31) ^ d, b >>> 1 ^ d);
        }
        g("jspb.utils.fromZigzag64", Ma, void 0);
        function Na(a) {
            var b = 2 * (a >> 31) + 1, c = a >>> 23 & 255;
            a &= 8388607;
            return 255 == c ? a ? NaN : Infinity * b : 0 == c ? b * Math.pow(2, -149) * a : b * Math.pow(2, c - 150) * (a + Math.pow(2, 23));
        }
        g("jspb.utils.joinFloat32", Na, void 0);
        function Oa(a, b) {
            var c = 2 * (b >> 31) + 1, d = b >>> 20 & 2047;
            a = 4294967296 * (b & 1048575) + a;
            return 2047 == d ? a ? NaN : Infinity * c : 0 == d ? c * Math.pow(2, -1074) * a : c * Math.pow(2, d - 1075) * (a + 4503599627370496);
        }
        g("jspb.utils.joinFloat64", Oa, void 0);
        function Pa(a, b) {
            return String.fromCharCode(a >>> 0 & 255, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255, b >>> 0 & 255, b >>> 8 & 255, b >>> 16 & 255, b >>> 24 & 255);
        }
        g("jspb.utils.joinHash64", Pa, void 0);
        g("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
        function F(a, b) {
            function c(f2, h) {
                f2 = f2 ? String(f2) : "";
                return h ? "0000000".slice(f2.length) + f2 : f2;
            }
            if (2097151 >= b)
                return "" + D(a, b);
            var d = (a >>> 24 | b << 8) >>> 0 & 16777215;
            b = b >> 16 & 65535;
            a = (a & 16777215) + 6777216 * d + 6710656 * b;
            d += 8147497 * b;
            b *= 2;
            1e7 <= a && (d += Math.floor(a / 1e7), a %= 1e7);
            1e7 <= d && (b += Math.floor(d / 1e7), d %= 1e7);
            return c(b, 0) + c(d, b) + c(a, 1);
        }
        g("jspb.utils.joinUnsignedDecimalString", F, void 0);
        function G(a, b) {
            var c = b & 2147483648;
            c && (a = ~a + 1 >>> 0, b = ~b + (0 == a ? 1 : 0) >>> 0);
            a = F(a, b);
            return c ? "-" + a : a;
        }
        g("jspb.utils.joinSignedDecimalString", G, void 0);
        function Qa(a, b) {
            C(a);
            a = y;
            var c = z;
            return b ? G(a, c) : F(a, c);
        }
        g("jspb.utils.hash64ToDecimalString", Qa, void 0);
        g("jspb.utils.hash64ArrayToDecimalStrings", function (a, b) {
            for (var c = Array(a.length), d = 0; d < a.length; d++)
                c[d] = Qa(a[d], b);
            return c;
        }, void 0);
        function H(a) {
            function b(m, t2) {
                for (var B = 0; 8 > B && (1 !== m || 0 < t2); B++)
                    t2 = m * f2[B] + t2, f2[B] = t2 & 255, t2 >>>= 8;
            }
            function c() {
                for (var m = 0; 8 > m; m++)
                    f2[m] = ~f2[m] & 255;
            }
            n(0 < a.length);
            var d = false;
            "-" === a[0] && (d = true, a = a.slice(1));
            for (var f2 = [0, 0, 0, 0, 0, 0, 0, 0], h = 0; h < a.length; h++)
                b(10, a.charCodeAt(h) - 48);
            d && (c(), b(1, 1));
            return xa(f2);
        }
        g("jspb.utils.decimalStringToHash64", H, void 0);
        g("jspb.utils.splitDecimalString", function (a) {
            C(H(a));
        }, void 0);
        function Ra(a) {
            return String.fromCharCode(10 > a ? 48 + a : 87 + a);
        }
        function Sa(a) {
            return 97 <= a ? a - 97 + 10 : a - 48;
        }
        g("jspb.utils.hash64ToHexString", function (a) {
            var b = Array(18);
            b[0] = "0";
            b[1] = "x";
            for (var c = 0; 8 > c; c++) {
                var d = a.charCodeAt(7 - c);
                b[2 * c + 2] = Ra(d >> 4);
                b[2 * c + 3] = Ra(d & 15);
            }
            return b.join("");
        }, void 0);
        g("jspb.utils.hexStringToHash64", function (a) {
            a = a.toLowerCase();
            n(18 == a.length);
            n("0" == a[0]);
            n("x" == a[1]);
            for (var b = "", c = 0; 8 > c; c++)
                b = String.fromCharCode(16 * Sa(a.charCodeAt(2 * c + 2)) + Sa(a.charCodeAt(2 * c + 3))) + b;
            return b;
        }, void 0);
        g("jspb.utils.hash64ToNumber", function (a, b) {
            C(a);
            a = y;
            var c = z;
            return b ? E(a, c) : D(a, c);
        }, void 0);
        g("jspb.utils.numberToHash64", function (a) {
            A(a);
            return Pa(y, z);
        }, void 0);
        g("jspb.utils.countVarints", function (a, b, c) {
            for (var d = 0, f2 = b; f2 < c; f2++)
                d += a[f2] >> 7;
            return c - b - d;
        }, void 0);
        g("jspb.utils.countVarintFields", function (a, b, c, d) {
            var f2 = 0;
            d *= 8;
            if (128 > d)
                for (; b < c && a[b++] == d;)
                    for (f2++;;) {
                        var h = a[b++];
                        if (0 == (h & 128))
                            break;
                    }
            else
                for (; b < c;) {
                    for (h = d; 128 < h;) {
                        if (a[b] != (h & 127 | 128))
                            return f2;
                        b++;
                        h >>= 7;
                    }
                    if (a[b++] != h)
                        break;
                    for (f2++; h = a[b++], 0 != (h & 128);)
                        ;
                }
            return f2;
        }, void 0);
        function Ta(a, b, c, d, f2) {
            var h = 0;
            if (128 > d)
                for (; b < c && a[b++] == d;)
                    h++, b += f2;
            else
                for (; b < c;) {
                    for (var m = d; 128 < m;) {
                        if (a[b++] != (m & 127 | 128))
                            return h;
                        m >>= 7;
                    }
                    if (a[b++] != m)
                        break;
                    h++;
                    b += f2;
                }
            return h;
        }
        g("jspb.utils.countFixed32Fields", function (a, b, c, d) {
            return Ta(a, b, c, 8 * d + 5, 4);
        }, void 0);
        g("jspb.utils.countFixed64Fields", function (a, b, c, d) {
            return Ta(a, b, c, 8 * d + 1, 8);
        }, void 0);
        g("jspb.utils.countDelimitedFields", function (a, b, c, d) {
            var f2 = 0;
            for (d = 8 * d + 2; b < c;) {
                for (var h = d; 128 < h;) {
                    if (a[b++] != (h & 127 | 128))
                        return f2;
                    h >>= 7;
                }
                if (a[b++] != h)
                    break;
                f2++;
                for (var m = 0, t2 = 1; h = a[b++], m += (h & 127) * t2, t2 *= 128, 0 != (h & 128);)
                    ;
                b += m;
            }
            return f2;
        }, void 0);
        g("jspb.utils.debugBytesToTextFormat", function (a) {
            var b = '"';
            if (a) {
                a = Ua(a);
                for (var c = 0; c < a.length; c++)
                    b += "\\x", 16 > a[c] && (b += "0"), b += a[c].toString(16);
            }
            return b + '"';
        }, void 0);
        g("jspb.utils.debugScalarToTextFormat", function (a) {
            if ("string" === typeof a) {
                a = String(a);
                for (var b = ['"'], c = 0; c < a.length; c++) {
                    var d = a.charAt(c), f2 = d.charCodeAt(0), h = c + 1, m;
                    if (!(m = ya[d])) {
                        if (!(31 < f2 && 127 > f2))
                            if (f2 = d, f2 in za)
                                d = za[f2];
                            else if (f2 in ya)
                                d = za[f2] = ya[f2];
                            else {
                                m = f2.charCodeAt(0);
                                if (31 < m && 127 > m)
                                    d = f2;
                                else {
                                    if (256 > m) {
                                        if (d = "\\x", 16 > m || 256 < m)
                                            d += "0";
                                    }
                                    else
                                        d = "\\u", 4096 > m && (d += "0");
                                    d += m.toString(16).toUpperCase();
                                }
                                d = za[f2] = d;
                            }
                        m = d;
                    }
                    b[h] = m;
                }
                b.push('"');
                a = b.join("");
            }
            else
                a = a.toString();
            return a;
        }, void 0);
        g("jspb.utils.stringToByteArray", function (a) {
            for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) {
                var d = a.charCodeAt(c);
                if (255 < d)
                    throw Error("Conversion error: string contains codepoint outside of byte range");
                b[c] = d;
            }
            return b;
        }, void 0);
        function Ua(a) {
            if (a.constructor === Uint8Array)
                return a;
            if (a.constructor === ArrayBuffer)
                return new Uint8Array(a);
            if (a.constructor === Array)
                return new Uint8Array(a);
            if (a.constructor === String)
                return Da(a);
            if (a instanceof Uint8Array)
                return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
            p("Type not convertible to Uint8Array.");
            return new Uint8Array(0);
        }
        g("jspb.utils.byteSourceToUint8Array", Ua, void 0);
        function I(a, b, c) {
            this.b = null;
            this.a = this.c = this.h = 0;
            this.v = false;
            a && this.H(a, b, c);
        }
        g("jspb.BinaryDecoder", I, void 0);
        var Va = [];
        I.getInstanceCacheLength = function () {
            return Va.length;
        };
        function Wa(a, b, c) {
            if (Va.length) {
                var d = Va.pop();
                a && d.H(a, b, c);
                return d;
            }
            return new I(a, b, c);
        }
        I.alloc = Wa;
        I.prototype.Ca = function () {
            this.clear();
            100 > Va.length && Va.push(this);
        };
        I.prototype.free = I.prototype.Ca;
        I.prototype.clone = function () {
            return Wa(this.b, this.h, this.c - this.h);
        };
        I.prototype.clone = I.prototype.clone;
        I.prototype.clear = function () {
            this.b = null;
            this.a = this.c = this.h = 0;
            this.v = false;
        };
        I.prototype.clear = I.prototype.clear;
        I.prototype.Y = function () {
            return this.b;
        };
        I.prototype.getBuffer = I.prototype.Y;
        I.prototype.H = function (a, b, c) {
            this.b = Ua(a);
            this.h = void 0 !== b ? b : 0;
            this.c = void 0 !== c ? this.h + c : this.b.length;
            this.a = this.h;
        };
        I.prototype.setBlock = I.prototype.H;
        I.prototype.Db = function () {
            return this.c;
        };
        I.prototype.getEnd = I.prototype.Db;
        I.prototype.setEnd = function (a) {
            this.c = a;
        };
        I.prototype.setEnd = I.prototype.setEnd;
        I.prototype.reset = function () {
            this.a = this.h;
        };
        I.prototype.reset = I.prototype.reset;
        I.prototype.B = function () {
            return this.a;
        };
        I.prototype.getCursor = I.prototype.B;
        I.prototype.Ma = function (a) {
            this.a = a;
        };
        I.prototype.setCursor = I.prototype.Ma;
        I.prototype.advance = function (a) {
            this.a += a;
            n(this.a <= this.c);
        };
        I.prototype.advance = I.prototype.advance;
        I.prototype.ya = function () {
            return this.a == this.c;
        };
        I.prototype.atEnd = I.prototype.ya;
        I.prototype.Qb = function () {
            return this.a > this.c;
        };
        I.prototype.pastEnd = I.prototype.Qb;
        I.prototype.getError = function () {
            return this.v || 0 > this.a || this.a > this.c;
        };
        I.prototype.getError = I.prototype.getError;
        I.prototype.w = function (a) {
            for (var b = 128, c = 0, d = 0, f2 = 0; 4 > f2 && 128 <= b; f2++)
                b = this.b[this.a++], c |= (b & 127) << 7 * f2;
            128 <= b && (b = this.b[this.a++], c |= (b & 127) << 28, d |= (b & 127) >> 4);
            if (128 <= b)
                for (f2 = 0; 5 > f2 && 128 <= b; f2++)
                    b = this.b[this.a++], d |= (b & 127) << 7 * f2 + 3;
            if (128 > b)
                return a(c >>> 0, d >>> 0);
            p("Failed to read varint, encoding is invalid.");
            this.v = true;
        };
        I.prototype.readSplitVarint64 = I.prototype.w;
        I.prototype.ea = function (a) {
            return this.w(function (b, c) {
                return Ma(b, c, a);
            });
        };
        I.prototype.readSplitZigzagVarint64 = I.prototype.ea;
        I.prototype.ta = function (a) {
            var b = this.b, c = this.a;
            this.a += 8;
            for (var d = 0, f2 = 0, h = c + 7; h >= c; h--)
                d = d << 8 | b[h], f2 = f2 << 8 | b[h + 4];
            return a(d, f2);
        };
        I.prototype.readSplitFixed64 = I.prototype.ta;
        I.prototype.kb = function () {
            for (; this.b[this.a] & 128;)
                this.a++;
            this.a++;
        };
        I.prototype.skipVarint = I.prototype.kb;
        I.prototype.mb = function (a) {
            for (; 128 < a;)
                this.a--, a >>>= 7;
            this.a--;
        };
        I.prototype.unskipVarint = I.prototype.mb;
        I.prototype.o = function () {
            var a = this.b;
            var b = a[this.a];
            var c = b & 127;
            if (128 > b)
                return this.a += 1, n(this.a <= this.c), c;
            b = a[this.a + 1];
            c |= (b & 127) << 7;
            if (128 > b)
                return this.a += 2, n(this.a <= this.c), c;
            b = a[this.a + 2];
            c |= (b & 127) << 14;
            if (128 > b)
                return this.a += 3, n(this.a <= this.c), c;
            b = a[this.a + 3];
            c |= (b & 127) << 21;
            if (128 > b)
                return this.a += 4, n(this.a <= this.c), c;
            b = a[this.a + 4];
            c |= (b & 15) << 28;
            if (128 > b)
                return this.a += 5, n(this.a <= this.c), c >>> 0;
            this.a += 5;
            128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && n(false);
            n(this.a <= this.c);
            return c;
        };
        I.prototype.readUnsignedVarint32 = I.prototype.o;
        I.prototype.da = function () {
            return ~~this.o();
        };
        I.prototype.readSignedVarint32 = I.prototype.da;
        I.prototype.O = function () {
            return this.o().toString();
        };
        I.prototype.Ea = function () {
            return this.da().toString();
        };
        I.prototype.readSignedVarint32String = I.prototype.Ea;
        I.prototype.Ia = function () {
            var a = this.o();
            return a >>> 1 ^ -(a & 1);
        };
        I.prototype.readZigzagVarint32 = I.prototype.Ia;
        I.prototype.Ga = function () {
            return this.w(D);
        };
        I.prototype.readUnsignedVarint64 = I.prototype.Ga;
        I.prototype.Ha = function () {
            return this.w(F);
        };
        I.prototype.readUnsignedVarint64String = I.prototype.Ha;
        I.prototype.sa = function () {
            return this.w(E);
        };
        I.prototype.readSignedVarint64 = I.prototype.sa;
        I.prototype.Fa = function () {
            return this.w(G);
        };
        I.prototype.readSignedVarint64String = I.prototype.Fa;
        I.prototype.Ja = function () {
            return this.w(Ka);
        };
        I.prototype.readZigzagVarint64 = I.prototype.Ja;
        I.prototype.fb = function () {
            return this.ea(Pa);
        };
        I.prototype.readZigzagVarintHash64 = I.prototype.fb;
        I.prototype.Ka = function () {
            return this.ea(G);
        };
        I.prototype.readZigzagVarint64String = I.prototype.Ka;
        I.prototype.Gc = function () {
            var a = this.b[this.a];
            this.a += 1;
            n(this.a <= this.c);
            return a;
        };
        I.prototype.readUint8 = I.prototype.Gc;
        I.prototype.Ec = function () {
            var a = this.b[this.a], b = this.b[this.a + 1];
            this.a += 2;
            n(this.a <= this.c);
            return a << 0 | b << 8;
        };
        I.prototype.readUint16 = I.prototype.Ec;
        I.prototype.m = function () {
            var a = this.b[this.a], b = this.b[this.a + 1], c = this.b[this.a + 2], d = this.b[this.a + 3];
            this.a += 4;
            n(this.a <= this.c);
            return (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
        };
        I.prototype.readUint32 = I.prototype.m;
        I.prototype.ga = function () {
            var a = this.m(), b = this.m();
            return D(a, b);
        };
        I.prototype.readUint64 = I.prototype.ga;
        I.prototype.ha = function () {
            var a = this.m(), b = this.m();
            return F(a, b);
        };
        I.prototype.readUint64String = I.prototype.ha;
        I.prototype.Xb = function () {
            var a = this.b[this.a];
            this.a += 1;
            n(this.a <= this.c);
            return a << 24 >> 24;
        };
        I.prototype.readInt8 = I.prototype.Xb;
        I.prototype.Vb = function () {
            var a = this.b[this.a], b = this.b[this.a + 1];
            this.a += 2;
            n(this.a <= this.c);
            return (a << 0 | b << 8) << 16 >> 16;
        };
        I.prototype.readInt16 = I.prototype.Vb;
        I.prototype.P = function () {
            var a = this.b[this.a], b = this.b[this.a + 1], c = this.b[this.a + 2], d = this.b[this.a + 3];
            this.a += 4;
            n(this.a <= this.c);
            return a << 0 | b << 8 | c << 16 | d << 24;
        };
        I.prototype.readInt32 = I.prototype.P;
        I.prototype.ba = function () {
            var a = this.m(), b = this.m();
            return E(a, b);
        };
        I.prototype.readInt64 = I.prototype.ba;
        I.prototype.ca = function () {
            var a = this.m(), b = this.m();
            return G(a, b);
        };
        I.prototype.readInt64String = I.prototype.ca;
        I.prototype.aa = function () {
            var a = this.m();
            return Na(a);
        };
        I.prototype.readFloat = I.prototype.aa;
        I.prototype.Z = function () {
            var a = this.m(), b = this.m();
            return Oa(a, b);
        };
        I.prototype.readDouble = I.prototype.Z;
        I.prototype.pa = function () {
            return !!this.b[this.a++];
        };
        I.prototype.readBool = I.prototype.pa;
        I.prototype.ra = function () {
            return this.da();
        };
        I.prototype.readEnum = I.prototype.ra;
        I.prototype.fa = function (a) {
            var b = this.b, c = this.a;
            a = c + a;
            for (var d = [], f2 = ""; c < a;) {
                var h = b[c++];
                if (128 > h)
                    d.push(h);
                else if (192 > h)
                    continue;
                else if (224 > h) {
                    var m = b[c++];
                    d.push((h & 31) << 6 | m & 63);
                }
                else if (240 > h) {
                    m = b[c++];
                    var t2 = b[c++];
                    d.push((h & 15) << 12 | (m & 63) << 6 | t2 & 63);
                }
                else if (248 > h) {
                    m = b[c++];
                    t2 = b[c++];
                    var B = b[c++];
                    h = (h & 7) << 18 | (m & 63) << 12 | (t2 & 63) << 6 | B & 63;
                    h -= 65536;
                    d.push((h >> 10 & 1023) + 55296, (h & 1023) + 56320);
                }
                8192 <= d.length && (f2 += String.fromCharCode.apply(null, d), d.length = 0);
            }
            f2 += xa(d);
            this.a = c;
            return f2;
        };
        I.prototype.readString = I.prototype.fa;
        I.prototype.Dc = function () {
            var a = this.o();
            return this.fa(a);
        };
        I.prototype.readStringWithLength = I.prototype.Dc;
        I.prototype.qa = function (a) {
            if (0 > a || this.a + a > this.b.length)
                return this.v = true, p("Invalid byte length!"), new Uint8Array(0);
            var b = this.b.subarray(this.a, this.a + a);
            this.a += a;
            n(this.a <= this.c);
            return b;
        };
        I.prototype.readBytes = I.prototype.qa;
        I.prototype.ia = function () {
            return this.w(Pa);
        };
        I.prototype.readVarintHash64 = I.prototype.ia;
        I.prototype.$ = function () {
            var a = this.b, b = this.a, c = a[b], d = a[b + 1], f2 = a[b + 2], h = a[b + 3], m = a[b + 4], t2 = a[b + 5], B = a[b + 6];
            a = a[b + 7];
            this.a += 8;
            return String.fromCharCode(c, d, f2, h, m, t2, B, a);
        };
        I.prototype.readFixedHash64 = I.prototype.$;
        function J(a, b, c) {
            this.a = Wa(a, b, c);
            this.O = this.a.B();
            this.b = this.c = -1;
            this.h = false;
            this.v = null;
        }
        g("jspb.BinaryReader", J, void 0);
        var K = [];
        J.clearInstanceCache = function () {
            K = [];
        };
        J.getInstanceCacheLength = function () {
            return K.length;
        };
        function Xa(a, b, c) {
            if (K.length) {
                var d = K.pop();
                a && d.a.H(a, b, c);
                return d;
            }
            return new J(a, b, c);
        }
        J.alloc = Xa;
        J.prototype.zb = Xa;
        J.prototype.alloc = J.prototype.zb;
        J.prototype.Ca = function () {
            this.a.clear();
            this.b = this.c = -1;
            this.h = false;
            this.v = null;
            100 > K.length && K.push(this);
        };
        J.prototype.free = J.prototype.Ca;
        J.prototype.Fb = function () {
            return this.O;
        };
        J.prototype.getFieldCursor = J.prototype.Fb;
        J.prototype.B = function () {
            return this.a.B();
        };
        J.prototype.getCursor = J.prototype.B;
        J.prototype.Y = function () {
            return this.a.Y();
        };
        J.prototype.getBuffer = J.prototype.Y;
        J.prototype.Hb = function () {
            return this.c;
        };
        J.prototype.getFieldNumber = J.prototype.Hb;
        J.prototype.Lb = function () {
            return this.b;
        };
        J.prototype.getWireType = J.prototype.Lb;
        J.prototype.Mb = function () {
            return 2 == this.b;
        };
        J.prototype.isDelimited = J.prototype.Mb;
        J.prototype.bb = function () {
            return 4 == this.b;
        };
        J.prototype.isEndGroup = J.prototype.bb;
        J.prototype.getError = function () {
            return this.h || this.a.getError();
        };
        J.prototype.getError = J.prototype.getError;
        J.prototype.H = function (a, b, c) {
            this.a.H(a, b, c);
            this.b = this.c = -1;
        };
        J.prototype.setBlock = J.prototype.H;
        J.prototype.reset = function () {
            this.a.reset();
            this.b = this.c = -1;
        };
        J.prototype.reset = J.prototype.reset;
        J.prototype.advance = function (a) {
            this.a.advance(a);
        };
        J.prototype.advance = J.prototype.advance;
        J.prototype.oa = function () {
            if (this.a.ya())
                return false;
            if (this.getError())
                return p("Decoder hit an error"), false;
            this.O = this.a.B();
            var a = this.a.o(), b = a >>> 3;
            a &= 7;
            if (0 != a && 5 != a && 1 != a && 2 != a && 3 != a && 4 != a)
                return p("Invalid wire type: %s (at position %s)", a, this.O), this.h = true, false;
            this.c = b;
            this.b = a;
            return true;
        };
        J.prototype.nextField = J.prototype.oa;
        J.prototype.Oa = function () {
            this.a.mb(this.c << 3 | this.b);
        };
        J.prototype.unskipHeader = J.prototype.Oa;
        J.prototype.Lc = function () {
            var a = this.c;
            for (this.Oa(); this.oa() && this.c == a;)
                this.C();
            this.a.ya() || this.Oa();
        };
        J.prototype.skipMatchingFields = J.prototype.Lc;
        J.prototype.lb = function () {
            0 != this.b ? (p("Invalid wire type for skipVarintField"), this.C()) : this.a.kb();
        };
        J.prototype.skipVarintField = J.prototype.lb;
        J.prototype.gb = function () {
            if (2 != this.b)
                p("Invalid wire type for skipDelimitedField"), this.C();
            else {
                var a = this.a.o();
                this.a.advance(a);
            }
        };
        J.prototype.skipDelimitedField = J.prototype.gb;
        J.prototype.hb = function () {
            5 != this.b ? (p("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4);
        };
        J.prototype.skipFixed32Field = J.prototype.hb;
        J.prototype.ib = function () {
            1 != this.b ? (p("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8);
        };
        J.prototype.skipFixed64Field = J.prototype.ib;
        J.prototype.jb = function () {
            var a = this.c;
            do {
                if (!this.oa()) {
                    p("Unmatched start-group tag: stream EOF");
                    this.h = true;
                    break;
                }
                if (4 == this.b) {
                    this.c != a && (p("Unmatched end-group tag"), this.h = true);
                    break;
                }
                this.C();
            } while (1);
        };
        J.prototype.skipGroup = J.prototype.jb;
        J.prototype.C = function () {
            switch (this.b) {
                case 0:
                    this.lb();
                    break;
                case 1:
                    this.ib();
                    break;
                case 2:
                    this.gb();
                    break;
                case 5:
                    this.hb();
                    break;
                case 3:
                    this.jb();
                    break;
                default:
                    p("Invalid wire encoding for field.");
            }
        };
        J.prototype.skipField = J.prototype.C;
        J.prototype.Hc = function (a, b) {
            null === this.v && (this.v = {});
            n(!this.v[a]);
            this.v[a] = b;
        };
        J.prototype.registerReadCallback = J.prototype.Hc;
        J.prototype.Ic = function (a) {
            n(null !== this.v);
            a = this.v[a];
            n(a);
            return a(this);
        };
        J.prototype.runReadCallback = J.prototype.Ic;
        J.prototype.Yb = function (a, b) {
            n(2 == this.b);
            var c = this.a.c, d = this.a.o();
            d = this.a.B() + d;
            this.a.setEnd(d);
            b(a, this);
            this.a.Ma(d);
            this.a.setEnd(c);
        };
        J.prototype.readMessage = J.prototype.Yb;
        J.prototype.Ub = function (a, b, c) {
            n(3 == this.b);
            n(this.c == a);
            c(b, this);
            this.h || 4 == this.b || (p("Group submessage did not end with an END_GROUP tag"), this.h = true);
        };
        J.prototype.readGroup = J.prototype.Ub;
        J.prototype.Gb = function () {
            n(2 == this.b);
            var a = this.a.o(), b = this.a.B(), c = b + a;
            a = Wa(this.a.Y(), b, a);
            this.a.Ma(c);
            return a;
        };
        J.prototype.getFieldDecoder = J.prototype.Gb;
        J.prototype.P = function () {
            n(0 == this.b);
            return this.a.da();
        };
        J.prototype.readInt32 = J.prototype.P;
        J.prototype.Wb = function () {
            n(0 == this.b);
            return this.a.Ea();
        };
        J.prototype.readInt32String = J.prototype.Wb;
        J.prototype.ba = function () {
            n(0 == this.b);
            return this.a.sa();
        };
        J.prototype.readInt64 = J.prototype.ba;
        J.prototype.ca = function () {
            n(0 == this.b);
            return this.a.Fa();
        };
        J.prototype.readInt64String = J.prototype.ca;
        J.prototype.m = function () {
            n(0 == this.b);
            return this.a.o();
        };
        J.prototype.readUint32 = J.prototype.m;
        J.prototype.Fc = function () {
            n(0 == this.b);
            return this.a.O();
        };
        J.prototype.readUint32String = J.prototype.Fc;
        J.prototype.ga = function () {
            n(0 == this.b);
            return this.a.Ga();
        };
        J.prototype.readUint64 = J.prototype.ga;
        J.prototype.ha = function () {
            n(0 == this.b);
            return this.a.Ha();
        };
        J.prototype.readUint64String = J.prototype.ha;
        J.prototype.zc = function () {
            n(0 == this.b);
            return this.a.Ia();
        };
        J.prototype.readSint32 = J.prototype.zc;
        J.prototype.Ac = function () {
            n(0 == this.b);
            return this.a.Ja();
        };
        J.prototype.readSint64 = J.prototype.Ac;
        J.prototype.Bc = function () {
            n(0 == this.b);
            return this.a.Ka();
        };
        J.prototype.readSint64String = J.prototype.Bc;
        J.prototype.Rb = function () {
            n(5 == this.b);
            return this.a.m();
        };
        J.prototype.readFixed32 = J.prototype.Rb;
        J.prototype.Sb = function () {
            n(1 == this.b);
            return this.a.ga();
        };
        J.prototype.readFixed64 = J.prototype.Sb;
        J.prototype.Tb = function () {
            n(1 == this.b);
            return this.a.ha();
        };
        J.prototype.readFixed64String = J.prototype.Tb;
        J.prototype.vc = function () {
            n(5 == this.b);
            return this.a.P();
        };
        J.prototype.readSfixed32 = J.prototype.vc;
        J.prototype.wc = function () {
            n(5 == this.b);
            return this.a.P().toString();
        };
        J.prototype.readSfixed32String = J.prototype.wc;
        J.prototype.xc = function () {
            n(1 == this.b);
            return this.a.ba();
        };
        J.prototype.readSfixed64 = J.prototype.xc;
        J.prototype.yc = function () {
            n(1 == this.b);
            return this.a.ca();
        };
        J.prototype.readSfixed64String = J.prototype.yc;
        J.prototype.aa = function () {
            n(5 == this.b);
            return this.a.aa();
        };
        J.prototype.readFloat = J.prototype.aa;
        J.prototype.Z = function () {
            n(1 == this.b);
            return this.a.Z();
        };
        J.prototype.readDouble = J.prototype.Z;
        J.prototype.pa = function () {
            n(0 == this.b);
            return !!this.a.o();
        };
        J.prototype.readBool = J.prototype.pa;
        J.prototype.ra = function () {
            n(0 == this.b);
            return this.a.sa();
        };
        J.prototype.readEnum = J.prototype.ra;
        J.prototype.fa = function () {
            n(2 == this.b);
            var a = this.a.o();
            return this.a.fa(a);
        };
        J.prototype.readString = J.prototype.fa;
        J.prototype.qa = function () {
            n(2 == this.b);
            var a = this.a.o();
            return this.a.qa(a);
        };
        J.prototype.readBytes = J.prototype.qa;
        J.prototype.ia = function () {
            n(0 == this.b);
            return this.a.ia();
        };
        J.prototype.readVarintHash64 = J.prototype.ia;
        J.prototype.Cc = function () {
            n(0 == this.b);
            return this.a.fb();
        };
        J.prototype.readSintHash64 = J.prototype.Cc;
        J.prototype.w = function (a) {
            n(0 == this.b);
            return this.a.w(a);
        };
        J.prototype.readSplitVarint64 = J.prototype.w;
        J.prototype.ea = function (a) {
            n(0 == this.b);
            return this.a.w(function (b, c) {
                return Ma(b, c, a);
            });
        };
        J.prototype.readSplitZigzagVarint64 = J.prototype.ea;
        J.prototype.$ = function () {
            n(1 == this.b);
            return this.a.$();
        };
        J.prototype.readFixedHash64 = J.prototype.$;
        J.prototype.ta = function (a) {
            n(1 == this.b);
            return this.a.ta(a);
        };
        J.prototype.readSplitFixed64 = J.prototype.ta;
        function L(a, b) {
            n(2 == a.b);
            var c = a.a.o();
            c = a.a.B() + c;
            for (var d = []; a.a.B() < c;)
                d.push(b.call(a.a));
            return d;
        }
        J.prototype.gc = function () {
            return L(this, this.a.da);
        };
        J.prototype.readPackedInt32 = J.prototype.gc;
        J.prototype.hc = function () {
            return L(this, this.a.Ea);
        };
        J.prototype.readPackedInt32String = J.prototype.hc;
        J.prototype.ic = function () {
            return L(this, this.a.sa);
        };
        J.prototype.readPackedInt64 = J.prototype.ic;
        J.prototype.jc = function () {
            return L(this, this.a.Fa);
        };
        J.prototype.readPackedInt64String = J.prototype.jc;
        J.prototype.qc = function () {
            return L(this, this.a.o);
        };
        J.prototype.readPackedUint32 = J.prototype.qc;
        J.prototype.rc = function () {
            return L(this, this.a.O);
        };
        J.prototype.readPackedUint32String = J.prototype.rc;
        J.prototype.sc = function () {
            return L(this, this.a.Ga);
        };
        J.prototype.readPackedUint64 = J.prototype.sc;
        J.prototype.tc = function () {
            return L(this, this.a.Ha);
        };
        J.prototype.readPackedUint64String = J.prototype.tc;
        J.prototype.nc = function () {
            return L(this, this.a.Ia);
        };
        J.prototype.readPackedSint32 = J.prototype.nc;
        J.prototype.oc = function () {
            return L(this, this.a.Ja);
        };
        J.prototype.readPackedSint64 = J.prototype.oc;
        J.prototype.pc = function () {
            return L(this, this.a.Ka);
        };
        J.prototype.readPackedSint64String = J.prototype.pc;
        J.prototype.bc = function () {
            return L(this, this.a.m);
        };
        J.prototype.readPackedFixed32 = J.prototype.bc;
        J.prototype.cc = function () {
            return L(this, this.a.ga);
        };
        J.prototype.readPackedFixed64 = J.prototype.cc;
        J.prototype.dc = function () {
            return L(this, this.a.ha);
        };
        J.prototype.readPackedFixed64String = J.prototype.dc;
        J.prototype.kc = function () {
            return L(this, this.a.P);
        };
        J.prototype.readPackedSfixed32 = J.prototype.kc;
        J.prototype.lc = function () {
            return L(this, this.a.ba);
        };
        J.prototype.readPackedSfixed64 = J.prototype.lc;
        J.prototype.mc = function () {
            return L(this, this.a.ca);
        };
        J.prototype.readPackedSfixed64String = J.prototype.mc;
        J.prototype.fc = function () {
            return L(this, this.a.aa);
        };
        J.prototype.readPackedFloat = J.prototype.fc;
        J.prototype.$b = function () {
            return L(this, this.a.Z);
        };
        J.prototype.readPackedDouble = J.prototype.$b;
        J.prototype.Zb = function () {
            return L(this, this.a.pa);
        };
        J.prototype.readPackedBool = J.prototype.Zb;
        J.prototype.ac = function () {
            return L(this, this.a.ra);
        };
        J.prototype.readPackedEnum = J.prototype.ac;
        J.prototype.uc = function () {
            return L(this, this.a.ia);
        };
        J.prototype.readPackedVarintHash64 = J.prototype.uc;
        J.prototype.ec = function () {
            return L(this, this.a.$);
        };
        J.prototype.readPackedFixedHash64 = J.prototype.ec;
        function Ya(a, b, c, d, f2) {
            this.ma = a;
            this.Ba = b;
            this.la = c;
            this.Na = d;
            this.na = f2;
        }
        g("jspb.ExtensionFieldInfo", Ya, void 0);
        function Za(a, b, c, d, f2, h) {
            this.Za = a;
            this.za = b;
            this.Aa = c;
            this.Wa = d;
            this.Ab = f2;
            this.Nb = h;
        }
        g("jspb.ExtensionFieldBinaryInfo", Za, void 0);
        Ya.prototype.F = function () {
            return !!this.la;
        };
        Ya.prototype.isMessageType = Ya.prototype.F;
        function N() {
        }
        g("jspb.Message", N, void 0);
        N.GENERATE_TO_OBJECT = true;
        N.GENERATE_FROM_OBJECT = true;
        var $a = "function" == typeof Uint8Array;
        N.prototype.Ib = function () {
            return this.b;
        };
        N.prototype.getJsPbMessageId = N.prototype.Ib;
        N.initialize = function (a, b, c, d, f2, h) {
            a.f = null;
            b || (b = c ? [c] : []);
            a.b = c ? String(c) : void 0;
            a.D = 0 === c ? -1 : 0;
            a.u = b;
            a: {
                c = a.u.length;
                b = -1;
                if (c && (b = c - 1, c = a.u[b], !(null === c || "object" != typeof c || Array.isArray(c) || $a && c instanceof Uint8Array))) {
                    a.G = b - a.D;
                    a.i = c;
                    break a;
                }
                -1 < d ? (a.G = Math.max(d, b + 1 - a.D), a.i = null) : a.G = Number.MAX_VALUE;
            }
            a.a = {};
            if (f2)
                for (d = 0; d < f2.length; d++)
                    b = f2[d], b < a.G ? (b += a.D, a.u[b] = a.u[b] || ab) : (bb(a), a.i[b] = a.i[b] || ab);
            if (h && h.length)
                for (d = 0; d < h.length; d++)
                    cb(a, h[d]);
        };
        var ab = Object.freeze ? Object.freeze([]) : [];
        function bb(a) {
            var b = a.G + a.D;
            a.u[b] || (a.i = a.u[b] = {});
        }
        function db2(a, b, c) {
            for (var d = [], f2 = 0; f2 < a.length; f2++)
                d[f2] = b.call(a[f2], c, a[f2]);
            return d;
        }
        N.toObjectList = db2;
        N.toObjectExtension = function (a, b, c, d, f2) {
            for (var h in c) {
                var m = c[h], t2 = d.call(a, m);
                if (null != t2) {
                    for (var B in m.Ba)
                        if (m.Ba.hasOwnProperty(B))
                            break;
                    b[B] = m.Na ? m.na ? db2(t2, m.Na, f2) : m.Na(f2, t2) : t2;
                }
            }
        };
        N.serializeBinaryExtensions = function (a, b, c, d) {
            for (var f2 in c) {
                var h = c[f2], m = h.Za;
                if (!h.Aa)
                    throw Error("Message extension present that was generated without binary serialization support");
                var t2 = d.call(a, m);
                if (null != t2)
                    if (m.F())
                        if (h.Wa)
                            h.Aa.call(b, m.ma, t2, h.Wa);
                        else
                            throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
                    else
                        h.Aa.call(b, m.ma, t2);
            }
        };
        N.readBinaryExtension = function (a, b, c, d, f2) {
            var h = c[b.c];
            if (h) {
                c = h.Za;
                if (!h.za)
                    throw Error("Deserializing extension whose generated code does not support binary format");
                if (c.F()) {
                    var m = new c.la();
                    h.za.call(b, m, h.Ab);
                }
                else
                    m = h.za.call(b);
                c.na && !h.Nb ? (b = d.call(a, c)) ? b.push(m) : f2.call(a, c, [m]) : f2.call(a, c, m);
            }
            else
                b.C();
        };
        function O(a, b) {
            if (b < a.G) {
                b += a.D;
                var c = a.u[b];
                return c === ab ? a.u[b] = [] : c;
            }
            if (a.i)
                return c = a.i[b], c === ab ? a.i[b] = [] : c;
        }
        N.getField = O;
        N.getRepeatedField = function (a, b) {
            return O(a, b);
        };
        function eb(a, b) {
            a = O(a, b);
            return null == a ? a : +a;
        }
        N.getOptionalFloatingPointField = eb;
        function fb(a, b) {
            a = O(a, b);
            return null == a ? a : !!a;
        }
        N.getBooleanField = fb;
        N.getRepeatedFloatingPointField = function (a, b) {
            var c = O(a, b);
            a.a || (a.a = {});
            if (!a.a[b]) {
                for (var d = 0; d < c.length; d++)
                    c[d] = +c[d];
                a.a[b] = true;
            }
            return c;
        };
        N.getRepeatedBooleanField = function (a, b) {
            var c = O(a, b);
            a.a || (a.a = {});
            if (!a.a[b]) {
                for (var d = 0; d < c.length; d++)
                    c[d] = !!c[d];
                a.a[b] = true;
            }
            return c;
        };
        function gb(a) {
            if (null == a || "string" === typeof a)
                return a;
            if ($a && a instanceof Uint8Array)
                return Ba(a);
            p("Cannot coerce to b64 string: " + k(a));
            return null;
        }
        N.bytesAsB64 = gb;
        function hb(a) {
            if (null == a || a instanceof Uint8Array)
                return a;
            if ("string" === typeof a)
                return Da(a);
            p("Cannot coerce to Uint8Array: " + k(a));
            return null;
        }
        N.bytesAsU8 = hb;
        N.bytesListAsB64 = function (a) {
            ib(a);
            return a.length && "string" !== typeof a[0] ? l(a, gb) : a;
        };
        N.bytesListAsU8 = function (a) {
            ib(a);
            return !a.length || a[0] instanceof Uint8Array ? a : l(a, hb);
        };
        function ib(a) {
            if (a && 1 < a.length) {
                var b = k(a[0]);
                qa(a, function (c) {
                    k(c) != b && p("Inconsistent type in JSPB repeated field array. Got " + k(c) + " expected " + b);
                });
            }
        }
        function jb(a, b, c) {
            a = O(a, b);
            return null == a ? c : a;
        }
        N.getFieldWithDefault = jb;
        N.getBooleanFieldWithDefault = function (a, b, c) {
            a = fb(a, b);
            return null == a ? c : a;
        };
        N.getFloatingPointFieldWithDefault = function (a, b, c) {
            a = eb(a, b);
            return null == a ? c : a;
        };
        N.getFieldProto3 = jb;
        N.getMapField = function (a, b, c, d) {
            a.f || (a.f = {});
            if (b in a.f)
                return a.f[b];
            var f2 = O(a, b);
            if (!f2) {
                if (c)
                    return;
                f2 = [];
                P(a, b, f2);
            }
            return a.f[b] = new r(f2, d);
        };
        function P(a, b, c) {
            q2(a, N);
            b < a.G ? a.u[b + a.D] = c : (bb(a), a.i[b] = c);
            return a;
        }
        N.setField = P;
        N.setProto3IntField = function (a, b, c) {
            return Q(a, b, c, 0);
        };
        N.setProto3FloatField = function (a, b, c) {
            return Q(a, b, c, 0);
        };
        N.setProto3BooleanField = function (a, b, c) {
            return Q(a, b, c, false);
        };
        N.setProto3StringField = function (a, b, c) {
            return Q(a, b, c, "");
        };
        N.setProto3BytesField = function (a, b, c) {
            return Q(a, b, c, "");
        };
        N.setProto3EnumField = function (a, b, c) {
            return Q(a, b, c, 0);
        };
        N.setProto3StringIntField = function (a, b, c) {
            return Q(a, b, c, "0");
        };
        function Q(a, b, c, d) {
            q2(a, N);
            c !== d ? P(a, b, c) : b < a.G ? a.u[b + a.D] = null : (bb(a), delete a.i[b]);
            return a;
        }
        N.addToRepeatedField = function (a, b, c, d) {
            q2(a, N);
            b = O(a, b);
            void 0 != d ? b.splice(d, 0, c) : b.push(c);
            return a;
        };
        function kb(a, b, c, d) {
            q2(a, N);
            (c = cb(a, c)) && c !== b && void 0 !== d && (a.f && c in a.f && (a.f[c] = void 0), P(a, c, void 0));
            return P(a, b, d);
        }
        N.setOneofField = kb;
        function cb(a, b) {
            for (var c, d, f2 = 0; f2 < b.length; f2++) {
                var h = b[f2], m = O(a, h);
                null != m && (c = h, d = m, P(a, h, void 0));
            }
            return c ? (P(a, c, d), c) : 0;
        }
        N.computeOneofCase = cb;
        N.getWrapperField = function (a, b, c, d) {
            a.f || (a.f = {});
            if (!a.f[c]) {
                var f2 = O(a, c);
                if (d || f2)
                    a.f[c] = new b(f2);
            }
            return a.f[c];
        };
        N.getRepeatedWrapperField = function (a, b, c) {
            lb2(a, b, c);
            b = a.f[c];
            b == ab && (b = a.f[c] = []);
            return b;
        };
        function lb2(a, b, c) {
            a.f || (a.f = {});
            if (!a.f[c]) {
                for (var d = O(a, c), f2 = [], h = 0; h < d.length; h++)
                    f2[h] = new b(d[h]);
                a.f[c] = f2;
            }
        }
        N.setWrapperField = function (a, b, c) {
            q2(a, N);
            a.f || (a.f = {});
            var d = c ? c.g() : c;
            a.f[b] = c;
            return P(a, b, d);
        };
        N.setOneofWrapperField = function (a, b, c, d) {
            q2(a, N);
            a.f || (a.f = {});
            var f2 = d ? d.g() : d;
            a.f[b] = d;
            return kb(a, b, c, f2);
        };
        N.setRepeatedWrapperField = function (a, b, c) {
            q2(a, N);
            a.f || (a.f = {});
            c = c || [];
            for (var d = [], f2 = 0; f2 < c.length; f2++)
                d[f2] = c[f2].g();
            a.f[b] = c;
            return P(a, b, d);
        };
        N.addToRepeatedWrapperField = function (a, b, c, d, f2) {
            lb2(a, d, b);
            var h = a.f[b];
            h || (h = a.f[b] = []);
            c = c ? c : new d();
            a = O(a, b);
            void 0 != f2 ? (h.splice(f2, 0, c), a.splice(f2, 0, c.g())) : (h.push(c), a.push(c.g()));
            return c;
        };
        N.toMap = function (a, b, c, d) {
            for (var f2 = {}, h = 0; h < a.length; h++)
                f2[b.call(a[h])] = c ? c.call(a[h], d, a[h]) : a[h];
            return f2;
        };
        function mb(a) {
            if (a.f)
                for (var b in a.f) {
                    var c = a.f[b];
                    if (Array.isArray(c))
                        for (var d = 0; d < c.length; d++)
                            c[d] && c[d].g();
                    else
                        c && c.g();
                }
        }
        N.prototype.g = function () {
            mb(this);
            return this.u;
        };
        N.prototype.toArray = N.prototype.g;
        N.prototype.toString = function () {
            mb(this);
            return this.u.toString();
        };
        N.prototype.getExtension = function (a) {
            if (this.i) {
                this.f || (this.f = {});
                var b = a.ma;
                if (a.na) {
                    if (a.F())
                        return this.f[b] || (this.f[b] = l(this.i[b] || [], function (c) {
                            return new a.la(c);
                        })), this.f[b];
                }
                else if (a.F())
                    return !this.f[b] && this.i[b] && (this.f[b] = new a.la(this.i[b])), this.f[b];
                return this.i[b];
            }
        };
        N.prototype.getExtension = N.prototype.getExtension;
        N.prototype.Kc = function (a, b) {
            this.f || (this.f = {});
            bb(this);
            var c = a.ma;
            a.na ? (b = b || [], a.F() ? (this.f[c] = b, this.i[c] = l(b, function (d) {
                return d.g();
            })) : this.i[c] = b) : a.F() ? (this.f[c] = b, this.i[c] = b ? b.g() : b) : this.i[c] = b;
            return this;
        };
        N.prototype.setExtension = N.prototype.Kc;
        N.difference = function (a, b) {
            if (!(a instanceof b.constructor))
                throw Error("Messages have different types.");
            var c = a.g();
            b = b.g();
            var d = [], f2 = 0, h = c.length > b.length ? c.length : b.length;
            a.b && (d[0] = a.b, f2 = 1);
            for (; f2 < h; f2++)
                nb2(c[f2], b[f2]) || (d[f2] = b[f2]);
            return new a.constructor(d);
        };
        N.equals = function (a, b) {
            return a == b || !(!a || !b) && a instanceof b.constructor && nb2(a.g(), b.g());
        };
        function ob(a, b) {
            a = a || {};
            b = b || {};
            var c = {}, d;
            for (d in a)
                c[d] = 0;
            for (d in b)
                c[d] = 0;
            for (d in c)
                if (!nb2(a[d], b[d]))
                    return false;
            return true;
        }
        N.compareExtensions = ob;
        function nb2(a, b) {
            if (a == b)
                return true;
            if (!la(a) || !la(b))
                return "number" === typeof a && isNaN(a) || "number" === typeof b && isNaN(b) ? String(a) == String(b) : false;
            if (a.constructor != b.constructor)
                return false;
            if ($a && a.constructor === Uint8Array) {
                if (a.length != b.length)
                    return false;
                for (var c = 0; c < a.length; c++)
                    if (a[c] != b[c])
                        return false;
                return true;
            }
            if (a.constructor === Array) {
                var d = void 0, f2 = void 0, h = Math.max(a.length, b.length);
                for (c = 0; c < h; c++) {
                    var m = a[c], t2 = b[c];
                    m && m.constructor == Object && (n(void 0 === d), n(c === a.length - 1), d = m, m = void 0);
                    t2 && t2.constructor == Object && (n(void 0 === f2), n(c === b.length - 1), f2 = t2, t2 = void 0);
                    if (!nb2(m, t2))
                        return false;
                }
                return d || f2 ? (d = d || {}, f2 = f2 || {}, ob(d, f2)) : true;
            }
            if (a.constructor === Object)
                return ob(a, b);
            throw Error("Invalid type in JSPB array");
        }
        N.compareFields = nb2;
        N.prototype.Bb = function () {
            return pb(this);
        };
        N.prototype.cloneMessage = N.prototype.Bb;
        N.prototype.clone = function () {
            return pb(this);
        };
        N.prototype.clone = N.prototype.clone;
        N.clone = function (a) {
            return pb(a);
        };
        function pb(a) {
            return new a.constructor(qb(a.g()));
        }
        N.copyInto = function (a, b) {
            q2(a, N);
            q2(b, N);
            n(a.constructor == b.constructor, "Copy source and target message should have the same type.");
            a = pb(a);
            for (var c = b.g(), d = a.g(), f2 = c.length = 0; f2 < d.length; f2++)
                c[f2] = d[f2];
            b.f = a.f;
            b.i = a.i;
        };
        function qb(a) {
            if (Array.isArray(a)) {
                for (var b = Array(a.length), c = 0; c < a.length; c++) {
                    var d = a[c];
                    null != d && (b[c] = "object" == typeof d ? qb(n(d)) : d);
                }
                return b;
            }
            if ($a && a instanceof Uint8Array)
                return new Uint8Array(a);
            b = {};
            for (c in a)
                d = a[c], null != d && (b[c] = "object" == typeof d ? qb(n(d)) : d);
            return b;
        }
        N.registerMessageType = function (a, b) {
            b.we = a;
        };
        var R = { dump: function (a) {
                q2(a, N, "jspb.Message instance expected");
                n(a.getExtension, "Only unobfuscated and unoptimized compilation modes supported.");
                return R.X(a);
            } };
        g("jspb.debug.dump", R.dump, void 0);
        R.X = function (a) {
            var b = k(a);
            if ("number" == b || "string" == b || "boolean" == b || "null" == b || "undefined" == b || "undefined" !== typeof Uint8Array && a instanceof Uint8Array)
                return a;
            if ("array" == b)
                return ua(a), l(a, R.X);
            if (a instanceof r) {
                var c = {};
                a = a.entries();
                for (var d = a.next(); !d.done; d = a.next())
                    c[d.value[0]] = R.X(d.value[1]);
                return c;
            }
            q2(a, N, "Only messages expected: " + a);
            b = a.constructor;
            var f2 = { $name: b.name || b.displayName };
            for (t2 in b.prototype) {
                var h = /^get([A-Z]\w*)/.exec(t2);
                if (h && "getExtension" != t2 && "getJsPbMessageId" != t2) {
                    var m = "has" + h[1];
                    if (!a[m] || a[m]())
                        m = a[t2](), f2[R.$a(h[1])] = R.X(m);
                }
            }
            if (a.extensionObject_)
                return f2.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", f2;
            for (d in b.extensions)
                if (/^\d+$/.test(d)) {
                    m = b.extensions[d];
                    var t2 = a.getExtension(m);
                    h = void 0;
                    m = m.Ba;
                    var B = [], M = 0;
                    for (h in m)
                        B[M++] = h;
                    h = B[0];
                    null != t2 && (c || (c = f2.$extensions = {}), c[R.$a(h)] = R.X(t2));
                }
            return f2;
        };
        R.$a = function (a) {
            return a.replace(/^[A-Z]/, function (b) {
                return b.toLowerCase();
            });
        };
        function S() {
            this.a = [];
        }
        g("jspb.BinaryEncoder", S, void 0);
        S.prototype.length = function () {
            return this.a.length;
        };
        S.prototype.length = S.prototype.length;
        S.prototype.end = function () {
            var a = this.a;
            this.a = [];
            return a;
        };
        S.prototype.end = S.prototype.end;
        S.prototype.l = function (a, b) {
            n(a == Math.floor(a));
            n(b == Math.floor(b));
            n(0 <= a && 4294967296 > a);
            for (n(0 <= b && 4294967296 > b); 0 < b || 127 < a;)
                this.a.push(a & 127 | 128), a = (a >>> 7 | b << 25) >>> 0, b >>>= 7;
            this.a.push(a);
        };
        S.prototype.writeSplitVarint64 = S.prototype.l;
        S.prototype.A = function (a, b) {
            n(a == Math.floor(a));
            n(b == Math.floor(b));
            n(0 <= a && 4294967296 > a);
            n(0 <= b && 4294967296 > b);
            this.s(a);
            this.s(b);
        };
        S.prototype.writeSplitFixed64 = S.prototype.A;
        S.prototype.j = function (a) {
            n(a == Math.floor(a));
            for (n(0 <= a && 4294967296 > a); 127 < a;)
                this.a.push(a & 127 | 128), a >>>= 7;
            this.a.push(a);
        };
        S.prototype.writeUnsignedVarint32 = S.prototype.j;
        S.prototype.M = function (a) {
            n(a == Math.floor(a));
            n(-2147483648 <= a && 2147483648 > a);
            if (0 <= a)
                this.j(a);
            else {
                for (var b = 0; 9 > b; b++)
                    this.a.push(a & 127 | 128), a >>= 7;
                this.a.push(1);
            }
        };
        S.prototype.writeSignedVarint32 = S.prototype.M;
        S.prototype.va = function (a) {
            n(a == Math.floor(a));
            n(0 <= a && 18446744073709552e3 > a);
            A(a);
            this.l(y, z);
        };
        S.prototype.writeUnsignedVarint64 = S.prototype.va;
        S.prototype.ua = function (a) {
            n(a == Math.floor(a));
            n(-9223372036854776e3 <= a && 9223372036854776e3 > a);
            A(a);
            this.l(y, z);
        };
        S.prototype.writeSignedVarint64 = S.prototype.ua;
        S.prototype.wa = function (a) {
            n(a == Math.floor(a));
            n(-2147483648 <= a && 2147483648 > a);
            this.j((a << 1 ^ a >> 31) >>> 0);
        };
        S.prototype.writeZigzagVarint32 = S.prototype.wa;
        S.prototype.xa = function (a) {
            n(a == Math.floor(a));
            n(-9223372036854776e3 <= a && 9223372036854776e3 > a);
            Ga(a);
            this.l(y, z);
        };
        S.prototype.writeZigzagVarint64 = S.prototype.xa;
        S.prototype.Ta = function (a) {
            this.W(H(a));
        };
        S.prototype.writeZigzagVarint64String = S.prototype.Ta;
        S.prototype.W = function (a) {
            var b = this;
            C(a);
            Ja(y, z, function (c, d) {
                b.l(c >>> 0, d >>> 0);
            });
        };
        S.prototype.writeZigzagVarintHash64 = S.prototype.W;
        S.prototype.be = function (a) {
            n(a == Math.floor(a));
            n(0 <= a && 256 > a);
            this.a.push(a >>> 0 & 255);
        };
        S.prototype.writeUint8 = S.prototype.be;
        S.prototype.ae = function (a) {
            n(a == Math.floor(a));
            n(0 <= a && 65536 > a);
            this.a.push(a >>> 0 & 255);
            this.a.push(a >>> 8 & 255);
        };
        S.prototype.writeUint16 = S.prototype.ae;
        S.prototype.s = function (a) {
            n(a == Math.floor(a));
            n(0 <= a && 4294967296 > a);
            this.a.push(a >>> 0 & 255);
            this.a.push(a >>> 8 & 255);
            this.a.push(a >>> 16 & 255);
            this.a.push(a >>> 24 & 255);
        };
        S.prototype.writeUint32 = S.prototype.s;
        S.prototype.V = function (a) {
            n(a == Math.floor(a));
            n(0 <= a && 18446744073709552e3 > a);
            Fa(a);
            this.s(y);
            this.s(z);
        };
        S.prototype.writeUint64 = S.prototype.V;
        S.prototype.Qc = function (a) {
            n(a == Math.floor(a));
            n(-128 <= a && 128 > a);
            this.a.push(a >>> 0 & 255);
        };
        S.prototype.writeInt8 = S.prototype.Qc;
        S.prototype.Pc = function (a) {
            n(a == Math.floor(a));
            n(-32768 <= a && 32768 > a);
            this.a.push(a >>> 0 & 255);
            this.a.push(a >>> 8 & 255);
        };
        S.prototype.writeInt16 = S.prototype.Pc;
        S.prototype.S = function (a) {
            n(a == Math.floor(a));
            n(-2147483648 <= a && 2147483648 > a);
            this.a.push(a >>> 0 & 255);
            this.a.push(a >>> 8 & 255);
            this.a.push(a >>> 16 & 255);
            this.a.push(a >>> 24 & 255);
        };
        S.prototype.writeInt32 = S.prototype.S;
        S.prototype.T = function (a) {
            n(a == Math.floor(a));
            n(-9223372036854776e3 <= a && 9223372036854776e3 > a);
            A(a);
            this.A(y, z);
        };
        S.prototype.writeInt64 = S.prototype.T;
        S.prototype.ka = function (a) {
            n(a == Math.floor(a));
            n(-9223372036854776e3 <= +a && 9223372036854776e3 > +a);
            C(H(a));
            this.A(y, z);
        };
        S.prototype.writeInt64String = S.prototype.ka;
        S.prototype.L = function (a) {
            n(Infinity === a || -Infinity === a || isNaN(a) || -34028234663852886e22 <= a && 34028234663852886e22 >= a);
            Ha(a);
            this.s(y);
        };
        S.prototype.writeFloat = S.prototype.L;
        S.prototype.J = function (a) {
            n(Infinity === a || -Infinity === a || isNaN(a) || -17976931348623157e292 <= a && 17976931348623157e292 >= a);
            Ia(a);
            this.s(y);
            this.s(z);
        };
        S.prototype.writeDouble = S.prototype.J;
        S.prototype.I = function (a) {
            n("boolean" === typeof a || "number" === typeof a);
            this.a.push(a ? 1 : 0);
        };
        S.prototype.writeBool = S.prototype.I;
        S.prototype.R = function (a) {
            n(a == Math.floor(a));
            n(-2147483648 <= a && 2147483648 > a);
            this.M(a);
        };
        S.prototype.writeEnum = S.prototype.R;
        S.prototype.ja = function (a) {
            this.a.push.apply(this.a, a);
        };
        S.prototype.writeBytes = S.prototype.ja;
        S.prototype.N = function (a) {
            C(a);
            this.l(y, z);
        };
        S.prototype.writeVarintHash64 = S.prototype.N;
        S.prototype.K = function (a) {
            C(a);
            this.s(y);
            this.s(z);
        };
        S.prototype.writeFixedHash64 = S.prototype.K;
        S.prototype.U = function (a) {
            var b = this.a.length;
            ta2(a);
            for (var c = 0; c < a.length; c++) {
                var d = a.charCodeAt(c);
                if (128 > d)
                    this.a.push(d);
                else if (2048 > d)
                    this.a.push(d >> 6 | 192), this.a.push(d & 63 | 128);
                else if (65536 > d)
                    if (55296 <= d && 56319 >= d && c + 1 < a.length) {
                        var f2 = a.charCodeAt(c + 1);
                        56320 <= f2 && 57343 >= f2 && (d = 1024 * (d - 55296) + f2 - 56320 + 65536, this.a.push(d >> 18 | 240), this.a.push(d >> 12 & 63 | 128), this.a.push(d >> 6 & 63 | 128), this.a.push(d & 63 | 128), c++);
                    }
                    else
                        this.a.push(d >> 12 | 224), this.a.push(d >> 6 & 63 | 128), this.a.push(d & 63 | 128);
            }
            return this.a.length - b;
        };
        S.prototype.writeString = S.prototype.U;
        function T(a, b) {
            this.lo = a;
            this.hi = b;
        }
        g("jspb.arith.UInt64", T, void 0);
        T.prototype.cmp = function (a) {
            return this.hi < a.hi || this.hi == a.hi && this.lo < a.lo ? -1 : this.hi == a.hi && this.lo == a.lo ? 0 : 1;
        };
        T.prototype.cmp = T.prototype.cmp;
        T.prototype.La = function () {
            return new T((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
        };
        T.prototype.rightShift = T.prototype.La;
        T.prototype.Da = function () {
            return new T(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
        };
        T.prototype.leftShift = T.prototype.Da;
        T.prototype.cb = function () {
            return !!(this.hi & 2147483648);
        };
        T.prototype.msb = T.prototype.cb;
        T.prototype.Ob = function () {
            return !!(this.lo & 1);
        };
        T.prototype.lsb = T.prototype.Ob;
        T.prototype.Ua = function () {
            return 0 == this.lo && 0 == this.hi;
        };
        T.prototype.zero = T.prototype.Ua;
        T.prototype.add = function (a) {
            return new T((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
        };
        T.prototype.add = T.prototype.add;
        T.prototype.sub = function (a) {
            return new T((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
        };
        T.prototype.sub = T.prototype.sub;
        function rb(a, b) {
            var c = a & 65535;
            a >>>= 16;
            var d = b & 65535, f2 = b >>> 16;
            b = c * d + 65536 * (c * f2 & 65535) + 65536 * (a * d & 65535);
            for (c = a * f2 + (c * f2 >>> 16) + (a * d >>> 16); 4294967296 <= b;)
                b -= 4294967296, c += 1;
            return new T(b >>> 0, c >>> 0);
        }
        T.mul32x32 = rb;
        T.prototype.eb = function (a) {
            var b = rb(this.lo, a);
            a = rb(this.hi, a);
            a.hi = a.lo;
            a.lo = 0;
            return b.add(a);
        };
        T.prototype.mul = T.prototype.eb;
        T.prototype.Xa = function (a) {
            if (0 == a)
                return [];
            var b = new T(0, 0), c = new T(this.lo, this.hi);
            a = new T(a, 0);
            for (var d = new T(1, 0); !a.cb();)
                a = a.Da(), d = d.Da();
            for (; !d.Ua();)
                0 >= a.cmp(c) && (b = b.add(d), c = c.sub(a)), a = a.La(), d = d.La();
            return [b, c];
        };
        T.prototype.div = T.prototype.Xa;
        T.prototype.toString = function () {
            for (var a = "", b = this; !b.Ua();) {
                b = b.Xa(10);
                var c = b[0];
                a = b[1].lo + a;
                b = c;
            }
            "" == a && (a = "0");
            return a;
        };
        T.prototype.toString = T.prototype.toString;
        function U(a) {
            for (var b = new T(0, 0), c = new T(0, 0), d = 0; d < a.length; d++) {
                if ("0" > a[d] || "9" < a[d])
                    return null;
                c.lo = parseInt(a[d], 10);
                b = b.eb(10).add(c);
            }
            return b;
        }
        T.fromString = U;
        T.prototype.clone = function () {
            return new T(this.lo, this.hi);
        };
        T.prototype.clone = T.prototype.clone;
        function V(a, b) {
            this.lo = a;
            this.hi = b;
        }
        g("jspb.arith.Int64", V, void 0);
        V.prototype.add = function (a) {
            return new V((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
        };
        V.prototype.add = V.prototype.add;
        V.prototype.sub = function (a) {
            return new V((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
        };
        V.prototype.sub = V.prototype.sub;
        V.prototype.clone = function () {
            return new V(this.lo, this.hi);
        };
        V.prototype.clone = V.prototype.clone;
        V.prototype.toString = function () {
            var a = 0 != (this.hi & 2147483648), b = new T(this.lo, this.hi);
            a && (b = new T(0, 0).sub(b));
            return (a ? "-" : "") + b.toString();
        };
        V.prototype.toString = V.prototype.toString;
        function sb(a) {
            var b = 0 < a.length && "-" == a[0];
            b && (a = a.substring(1));
            a = U(a);
            if (null === a)
                return null;
            b && (a = new T(0, 0).sub(a));
            return new V(a.lo, a.hi);
        }
        V.fromString = sb;
        function W() {
            this.c = [];
            this.b = 0;
            this.a = new S();
            this.h = [];
        }
        g("jspb.BinaryWriter", W, void 0);
        function tb(a, b) {
            var c = a.a.end();
            a.c.push(c);
            a.c.push(b);
            a.b += c.length + b.length;
        }
        function X(a, b) {
            Y(a, b, 2);
            b = a.a.end();
            a.c.push(b);
            a.b += b.length;
            b.push(a.b);
            return b;
        }
        function Z(a, b) {
            var c = b.pop();
            c = a.b + a.a.length() - c;
            for (n(0 <= c); 127 < c;)
                b.push(c & 127 | 128), c >>>= 7, a.b++;
            b.push(c);
            a.b++;
        }
        W.prototype.pb = function (a, b, c) {
            tb(this, a.subarray(b, c));
        };
        W.prototype.writeSerializedMessage = W.prototype.pb;
        W.prototype.Pb = function (a, b, c) {
            null != a && null != b && null != c && this.pb(a, b, c);
        };
        W.prototype.maybeWriteSerializedMessage = W.prototype.Pb;
        W.prototype.reset = function () {
            this.c = [];
            this.a.end();
            this.b = 0;
            this.h = [];
        };
        W.prototype.reset = W.prototype.reset;
        W.prototype.ab = function () {
            n(0 == this.h.length);
            for (var a = new Uint8Array(this.b + this.a.length()), b = this.c, c = b.length, d = 0, f2 = 0; f2 < c; f2++) {
                var h = b[f2];
                a.set(h, d);
                d += h.length;
            }
            b = this.a.end();
            a.set(b, d);
            d += b.length;
            n(d == a.length);
            this.c = [a];
            return a;
        };
        W.prototype.getResultBuffer = W.prototype.ab;
        W.prototype.Kb = function (a) {
            return Ba(this.ab(), a);
        };
        W.prototype.getResultBase64String = W.prototype.Kb;
        W.prototype.Va = function (a) {
            this.h.push(X(this, a));
        };
        W.prototype.beginSubMessage = W.prototype.Va;
        W.prototype.Ya = function () {
            n(0 <= this.h.length);
            Z(this, this.h.pop());
        };
        W.prototype.endSubMessage = W.prototype.Ya;
        function Y(a, b, c) {
            n(1 <= b && b == Math.floor(b));
            a.a.j(8 * b + c);
        }
        W.prototype.Nc = function (a, b, c) {
            switch (a) {
                case 1:
                    this.J(b, c);
                    break;
                case 2:
                    this.L(b, c);
                    break;
                case 3:
                    this.T(b, c);
                    break;
                case 4:
                    this.V(b, c);
                    break;
                case 5:
                    this.S(b, c);
                    break;
                case 6:
                    this.Qa(b, c);
                    break;
                case 7:
                    this.Pa(b, c);
                    break;
                case 8:
                    this.I(b, c);
                    break;
                case 9:
                    this.U(b, c);
                    break;
                case 10:
                    p("Group field type not supported in writeAny()");
                    break;
                case 11:
                    p("Message field type not supported in writeAny()");
                    break;
                case 12:
                    this.ja(b, c);
                    break;
                case 13:
                    this.s(b, c);
                    break;
                case 14:
                    this.R(b, c);
                    break;
                case 15:
                    this.Ra(b, c);
                    break;
                case 16:
                    this.Sa(b, c);
                    break;
                case 17:
                    this.rb(b, c);
                    break;
                case 18:
                    this.sb(b, c);
                    break;
                case 30:
                    this.K(b, c);
                    break;
                case 31:
                    this.N(b, c);
                    break;
                default:
                    p("Invalid field type in writeAny()");
            }
        };
        W.prototype.writeAny = W.prototype.Nc;
        function ub(a, b, c) {
            null != c && (Y(a, b, 0), a.a.j(c));
        }
        function vb(a, b, c) {
            null != c && (Y(a, b, 0), a.a.M(c));
        }
        W.prototype.S = function (a, b) {
            null != b && (n(-2147483648 <= b && 2147483648 > b), vb(this, a, b));
        };
        W.prototype.writeInt32 = W.prototype.S;
        W.prototype.ob = function (a, b) {
            null != b && (b = parseInt(b, 10), n(-2147483648 <= b && 2147483648 > b), vb(this, a, b));
        };
        W.prototype.writeInt32String = W.prototype.ob;
        W.prototype.T = function (a, b) {
            null != b && (n(-9223372036854776e3 <= b && 9223372036854776e3 > b), null != b && (Y(this, a, 0), this.a.ua(b)));
        };
        W.prototype.writeInt64 = W.prototype.T;
        W.prototype.ka = function (a, b) {
            null != b && (b = sb(b), Y(this, a, 0), this.a.l(b.lo, b.hi));
        };
        W.prototype.writeInt64String = W.prototype.ka;
        W.prototype.s = function (a, b) {
            null != b && (n(0 <= b && 4294967296 > b), ub(this, a, b));
        };
        W.prototype.writeUint32 = W.prototype.s;
        W.prototype.ub = function (a, b) {
            null != b && (b = parseInt(b, 10), n(0 <= b && 4294967296 > b), ub(this, a, b));
        };
        W.prototype.writeUint32String = W.prototype.ub;
        W.prototype.V = function (a, b) {
            null != b && (n(0 <= b && 18446744073709552e3 > b), null != b && (Y(this, a, 0), this.a.va(b)));
        };
        W.prototype.writeUint64 = W.prototype.V;
        W.prototype.vb = function (a, b) {
            null != b && (b = U(b), Y(this, a, 0), this.a.l(b.lo, b.hi));
        };
        W.prototype.writeUint64String = W.prototype.vb;
        W.prototype.rb = function (a, b) {
            null != b && (n(-2147483648 <= b && 2147483648 > b), null != b && (Y(this, a, 0), this.a.wa(b)));
        };
        W.prototype.writeSint32 = W.prototype.rb;
        W.prototype.sb = function (a, b) {
            null != b && (n(-9223372036854776e3 <= b && 9223372036854776e3 > b), null != b && (Y(this, a, 0), this.a.xa(b)));
        };
        W.prototype.writeSint64 = W.prototype.sb;
        W.prototype.$d = function (a, b) {
            null != b && null != b && (Y(this, a, 0), this.a.W(b));
        };
        W.prototype.writeSintHash64 = W.prototype.$d;
        W.prototype.Zd = function (a, b) {
            null != b && null != b && (Y(this, a, 0), this.a.Ta(b));
        };
        W.prototype.writeSint64String = W.prototype.Zd;
        W.prototype.Pa = function (a, b) {
            null != b && (n(0 <= b && 4294967296 > b), Y(this, a, 5), this.a.s(b));
        };
        W.prototype.writeFixed32 = W.prototype.Pa;
        W.prototype.Qa = function (a, b) {
            null != b && (n(0 <= b && 18446744073709552e3 > b), Y(this, a, 1), this.a.V(b));
        };
        W.prototype.writeFixed64 = W.prototype.Qa;
        W.prototype.nb = function (a, b) {
            null != b && (b = U(b), Y(this, a, 1), this.a.A(b.lo, b.hi));
        };
        W.prototype.writeFixed64String = W.prototype.nb;
        W.prototype.Ra = function (a, b) {
            null != b && (n(-2147483648 <= b && 2147483648 > b), Y(this, a, 5), this.a.S(b));
        };
        W.prototype.writeSfixed32 = W.prototype.Ra;
        W.prototype.Sa = function (a, b) {
            null != b && (n(-9223372036854776e3 <= b && 9223372036854776e3 > b), Y(this, a, 1), this.a.T(b));
        };
        W.prototype.writeSfixed64 = W.prototype.Sa;
        W.prototype.qb = function (a, b) {
            null != b && (b = sb(b), Y(this, a, 1), this.a.A(b.lo, b.hi));
        };
        W.prototype.writeSfixed64String = W.prototype.qb;
        W.prototype.L = function (a, b) {
            null != b && (Y(this, a, 5), this.a.L(b));
        };
        W.prototype.writeFloat = W.prototype.L;
        W.prototype.J = function (a, b) {
            null != b && (Y(this, a, 1), this.a.J(b));
        };
        W.prototype.writeDouble = W.prototype.J;
        W.prototype.I = function (a, b) {
            null != b && (n("boolean" === typeof b || "number" === typeof b), Y(this, a, 0), this.a.I(b));
        };
        W.prototype.writeBool = W.prototype.I;
        W.prototype.R = function (a, b) {
            null != b && (n(-2147483648 <= b && 2147483648 > b), Y(this, a, 0), this.a.M(b));
        };
        W.prototype.writeEnum = W.prototype.R;
        W.prototype.U = function (a, b) {
            null != b && (a = X(this, a), this.a.U(b), Z(this, a));
        };
        W.prototype.writeString = W.prototype.U;
        W.prototype.ja = function (a, b) {
            null != b && (b = Ua(b), Y(this, a, 2), this.a.j(b.length), tb(this, b));
        };
        W.prototype.writeBytes = W.prototype.ja;
        W.prototype.Rc = function (a, b, c) {
            null != b && (a = X(this, a), c(b, this), Z(this, a));
        };
        W.prototype.writeMessage = W.prototype.Rc;
        W.prototype.Sc = function (a, b, c) {
            null != b && (Y(this, 1, 3), Y(this, 2, 0), this.a.M(a), a = X(this, 3), c(b, this), Z(this, a), Y(this, 1, 4));
        };
        W.prototype.writeMessageSet = W.prototype.Sc;
        W.prototype.Oc = function (a, b, c) {
            null != b && (Y(this, a, 3), c(b, this), Y(this, a, 4));
        };
        W.prototype.writeGroup = W.prototype.Oc;
        W.prototype.K = function (a, b) {
            null != b && (n(8 == b.length), Y(this, a, 1), this.a.K(b));
        };
        W.prototype.writeFixedHash64 = W.prototype.K;
        W.prototype.N = function (a, b) {
            null != b && (n(8 == b.length), Y(this, a, 0), this.a.N(b));
        };
        W.prototype.writeVarintHash64 = W.prototype.N;
        W.prototype.A = function (a, b, c) {
            Y(this, a, 1);
            this.a.A(b, c);
        };
        W.prototype.writeSplitFixed64 = W.prototype.A;
        W.prototype.l = function (a, b, c) {
            Y(this, a, 0);
            this.a.l(b, c);
        };
        W.prototype.writeSplitVarint64 = W.prototype.l;
        W.prototype.tb = function (a, b, c) {
            Y(this, a, 0);
            var d = this.a;
            Ja(b, c, function (f2, h) {
                d.l(f2 >>> 0, h >>> 0);
            });
        };
        W.prototype.writeSplitZigzagVarint64 = W.prototype.tb;
        W.prototype.Ed = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    vb(this, a, b[c]);
        };
        W.prototype.writeRepeatedInt32 = W.prototype.Ed;
        W.prototype.Fd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.ob(a, b[c]);
        };
        W.prototype.writeRepeatedInt32String = W.prototype.Fd;
        W.prototype.Gd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    null != d && (Y(this, a, 0), this.a.ua(d));
                }
        };
        W.prototype.writeRepeatedInt64 = W.prototype.Gd;
        W.prototype.Qd = function (a, b, c, d) {
            if (null != b)
                for (var f2 = 0; f2 < b.length; f2++)
                    this.A(a, c(b[f2]), d(b[f2]));
        };
        W.prototype.writeRepeatedSplitFixed64 = W.prototype.Qd;
        W.prototype.Rd = function (a, b, c, d) {
            if (null != b)
                for (var f2 = 0; f2 < b.length; f2++)
                    this.l(a, c(b[f2]), d(b[f2]));
        };
        W.prototype.writeRepeatedSplitVarint64 = W.prototype.Rd;
        W.prototype.Sd = function (a, b, c, d) {
            if (null != b)
                for (var f2 = 0; f2 < b.length; f2++)
                    this.tb(a, c(b[f2]), d(b[f2]));
        };
        W.prototype.writeRepeatedSplitZigzagVarint64 = W.prototype.Sd;
        W.prototype.Hd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.ka(a, b[c]);
        };
        W.prototype.writeRepeatedInt64String = W.prototype.Hd;
        W.prototype.Ud = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    ub(this, a, b[c]);
        };
        W.prototype.writeRepeatedUint32 = W.prototype.Ud;
        W.prototype.Vd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.ub(a, b[c]);
        };
        W.prototype.writeRepeatedUint32String = W.prototype.Vd;
        W.prototype.Wd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    null != d && (Y(this, a, 0), this.a.va(d));
                }
        };
        W.prototype.writeRepeatedUint64 = W.prototype.Wd;
        W.prototype.Xd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.vb(a, b[c]);
        };
        W.prototype.writeRepeatedUint64String = W.prototype.Xd;
        W.prototype.Md = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    null != d && (Y(this, a, 0), this.a.wa(d));
                }
        };
        W.prototype.writeRepeatedSint32 = W.prototype.Md;
        W.prototype.Nd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    null != d && (Y(this, a, 0), this.a.xa(d));
                }
        };
        W.prototype.writeRepeatedSint64 = W.prototype.Nd;
        W.prototype.Od = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    null != d && (Y(this, a, 0), this.a.Ta(d));
                }
        };
        W.prototype.writeRepeatedSint64String = W.prototype.Od;
        W.prototype.Pd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    null != d && (Y(this, a, 0), this.a.W(d));
                }
        };
        W.prototype.writeRepeatedSintHash64 = W.prototype.Pd;
        W.prototype.yd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.Pa(a, b[c]);
        };
        W.prototype.writeRepeatedFixed32 = W.prototype.yd;
        W.prototype.zd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.Qa(a, b[c]);
        };
        W.prototype.writeRepeatedFixed64 = W.prototype.zd;
        W.prototype.Ad = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.nb(a, b[c]);
        };
        W.prototype.writeRepeatedFixed64String = W.prototype.Ad;
        W.prototype.Jd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.Ra(a, b[c]);
        };
        W.prototype.writeRepeatedSfixed32 = W.prototype.Jd;
        W.prototype.Kd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.Sa(a, b[c]);
        };
        W.prototype.writeRepeatedSfixed64 = W.prototype.Kd;
        W.prototype.Ld = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.qb(a, b[c]);
        };
        W.prototype.writeRepeatedSfixed64String = W.prototype.Ld;
        W.prototype.Cd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.L(a, b[c]);
        };
        W.prototype.writeRepeatedFloat = W.prototype.Cd;
        W.prototype.wd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.J(a, b[c]);
        };
        W.prototype.writeRepeatedDouble = W.prototype.wd;
        W.prototype.ud = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.I(a, b[c]);
        };
        W.prototype.writeRepeatedBool = W.prototype.ud;
        W.prototype.xd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.R(a, b[c]);
        };
        W.prototype.writeRepeatedEnum = W.prototype.xd;
        W.prototype.Td = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.U(a, b[c]);
        };
        W.prototype.writeRepeatedString = W.prototype.Td;
        W.prototype.vd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.ja(a, b[c]);
        };
        W.prototype.writeRepeatedBytes = W.prototype.vd;
        W.prototype.Id = function (a, b, c) {
            if (null != b)
                for (var d = 0; d < b.length; d++) {
                    var f2 = X(this, a);
                    c(b[d], this);
                    Z(this, f2);
                }
        };
        W.prototype.writeRepeatedMessage = W.prototype.Id;
        W.prototype.Dd = function (a, b, c) {
            if (null != b)
                for (var d = 0; d < b.length; d++)
                    Y(this, a, 3), c(b[d], this), Y(this, a, 4);
        };
        W.prototype.writeRepeatedGroup = W.prototype.Dd;
        W.prototype.Bd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.K(a, b[c]);
        };
        W.prototype.writeRepeatedFixedHash64 = W.prototype.Bd;
        W.prototype.Yd = function (a, b) {
            if (null != b)
                for (var c = 0; c < b.length; c++)
                    this.N(a, b[c]);
        };
        W.prototype.writeRepeatedVarintHash64 = W.prototype.Yd;
        W.prototype.ad = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.M(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedInt32 = W.prototype.ad;
        W.prototype.bd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.M(parseInt(b[c], 10));
                Z(this, a);
            }
        };
        W.prototype.writePackedInt32String = W.prototype.bd;
        W.prototype.cd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.ua(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedInt64 = W.prototype.cd;
        W.prototype.md = function (a, b, c, d) {
            if (null != b) {
                a = X(this, a);
                for (var f2 = 0; f2 < b.length; f2++)
                    this.a.A(c(b[f2]), d(b[f2]));
                Z(this, a);
            }
        };
        W.prototype.writePackedSplitFixed64 = W.prototype.md;
        W.prototype.nd = function (a, b, c, d) {
            if (null != b) {
                a = X(this, a);
                for (var f2 = 0; f2 < b.length; f2++)
                    this.a.l(c(b[f2]), d(b[f2]));
                Z(this, a);
            }
        };
        W.prototype.writePackedSplitVarint64 = W.prototype.nd;
        W.prototype.od = function (a, b, c, d) {
            if (null != b) {
                a = X(this, a);
                for (var f2 = this.a, h = 0; h < b.length; h++)
                    Ja(c(b[h]), d(b[h]), function (m, t2) {
                        f2.l(m >>> 0, t2 >>> 0);
                    });
                Z(this, a);
            }
        };
        W.prototype.writePackedSplitZigzagVarint64 = W.prototype.od;
        W.prototype.dd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++) {
                    var d = sb(b[c]);
                    this.a.l(d.lo, d.hi);
                }
                Z(this, a);
            }
        };
        W.prototype.writePackedInt64String = W.prototype.dd;
        W.prototype.pd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.j(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedUint32 = W.prototype.pd;
        W.prototype.qd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.j(parseInt(b[c], 10));
                Z(this, a);
            }
        };
        W.prototype.writePackedUint32String = W.prototype.qd;
        W.prototype.rd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.va(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedUint64 = W.prototype.rd;
        W.prototype.sd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++) {
                    var d = U(b[c]);
                    this.a.l(d.lo, d.hi);
                }
                Z(this, a);
            }
        };
        W.prototype.writePackedUint64String = W.prototype.sd;
        W.prototype.hd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.wa(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedSint32 = W.prototype.hd;
        W.prototype.jd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.xa(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedSint64 = W.prototype.jd;
        W.prototype.kd = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.W(H(b[c]));
                Z(this, a);
            }
        };
        W.prototype.writePackedSint64String = W.prototype.kd;
        W.prototype.ld = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.W(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedSintHash64 = W.prototype.ld;
        W.prototype.Wc = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(4 * b.length), a = 0; a < b.length; a++)
                    this.a.s(b[a]);
        };
        W.prototype.writePackedFixed32 = W.prototype.Wc;
        W.prototype.Xc = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(8 * b.length), a = 0; a < b.length; a++)
                    this.a.V(b[a]);
        };
        W.prototype.writePackedFixed64 = W.prototype.Xc;
        W.prototype.Yc = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(8 * b.length), a = 0; a < b.length; a++) {
                    var c = U(b[a]);
                    this.a.A(c.lo, c.hi);
                }
        };
        W.prototype.writePackedFixed64String = W.prototype.Yc;
        W.prototype.ed = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(4 * b.length), a = 0; a < b.length; a++)
                    this.a.S(b[a]);
        };
        W.prototype.writePackedSfixed32 = W.prototype.ed;
        W.prototype.fd = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(8 * b.length), a = 0; a < b.length; a++)
                    this.a.T(b[a]);
        };
        W.prototype.writePackedSfixed64 = W.prototype.fd;
        W.prototype.gd = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(8 * b.length), a = 0; a < b.length; a++)
                    this.a.ka(b[a]);
        };
        W.prototype.writePackedSfixed64String = W.prototype.gd;
        W.prototype.$c = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(4 * b.length), a = 0; a < b.length; a++)
                    this.a.L(b[a]);
        };
        W.prototype.writePackedFloat = W.prototype.$c;
        W.prototype.Uc = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(8 * b.length), a = 0; a < b.length; a++)
                    this.a.J(b[a]);
        };
        W.prototype.writePackedDouble = W.prototype.Uc;
        W.prototype.Tc = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(b.length), a = 0; a < b.length; a++)
                    this.a.I(b[a]);
        };
        W.prototype.writePackedBool = W.prototype.Tc;
        W.prototype.Vc = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.R(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedEnum = W.prototype.Vc;
        W.prototype.Zc = function (a, b) {
            if (null != b && b.length)
                for (Y(this, a, 2), this.a.j(8 * b.length), a = 0; a < b.length; a++)
                    this.a.K(b[a]);
        };
        W.prototype.writePackedFixedHash64 = W.prototype.Zc;
        W.prototype.td = function (a, b) {
            if (null != b && b.length) {
                a = X(this, a);
                for (var c = 0; c < b.length; c++)
                    this.a.N(b[c]);
                Z(this, a);
            }
        };
        W.prototype.writePackedVarintHash64 = W.prototype.td;
        exports2.debug = R, exports2.Map = r, exports2.Message = N, exports2.BinaryReader = J, exports2.BinaryWriter = W, exports2.ExtensionFieldInfo = Ya, exports2.ExtensionFieldBinaryInfo = Za, exports2.exportSymbol = ma, exports2.inherits = na, exports2.object = { extend: pa }, exports2.typeOf = k;
    })(googleProtobuf$1);
    return googleProtobuf$1;
}
var googleProtobufExports = requireGoogleProtobuf();
const googleProtobuf = /* @__PURE__ */ getDefaultExportFromCjs(googleProtobufExports);
const jspb$1 = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: googleProtobuf
}, [googleProtobufExports]);
if (typeof globalThis !== "undefined") {
    if (typeof globalThis.require === "undefined") {
        globalThis.require = (moduleId) => {
            switch (moduleId) {
                case "google-protobuf":
                    return jspb$1;
                default:
                    throw new Error(`Module not found: ${moduleId}. Add to polyfills if needed.`);
            }
        };
    }
}
if (typeof global !== "undefined") {
    if (typeof global.require === "undefined") {
        global.require = globalThis.require;
    }
}
let send$2;
function override(sendImplementation) {
    send$2 = sendImplementation;
}
var errCode;
var hasRequiredErrCode;
function requireErrCode() {
    if (hasRequiredErrCode)
        return errCode;
    hasRequiredErrCode = 1;
    function assign(obj, props) {
        for (const key in props) {
            Object.defineProperty(obj, key, {
                value: props[key],
                enumerable: true,
                configurable: true
            });
        }
        return obj;
    }
    function createError(err, code, props) {
        if (!err || typeof err === "string") {
            throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
            props = {};
        }
        if (typeof code === "object") {
            props = code;
            code = void 0;
        }
        if (code != null) {
            props.code = code;
        }
        try {
            return assign(err, props);
        }
        catch (_) {
            props.message = err.message;
            props.stack = err.stack;
            const ErrClass = function () {
            };
            ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
            return assign(new ErrClass(), props);
        }
    }
    errCode = createError;
    return errCode;
}
var retry$1 = {};
var retry_operation;
var hasRequiredRetry_operation;
function requireRetry_operation() {
    if (hasRequiredRetry_operation)
        return retry_operation;
    hasRequiredRetry_operation = 1;
    function RetryOperation(timeouts, options2) {
        if (typeof options2 === "boolean") {
            options2 = { forever: options2 };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options2 || {};
        this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        if (this._options.forever) {
            this._cachedTimeouts = this._timeouts.slice(0);
        }
    }
    retry_operation = RetryOperation;
    RetryOperation.prototype.reset = function () {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function () {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function (err) {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        if (!err) {
            return false;
        }
        var currentTime = ( /* @__PURE__ */new Date()).getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
            this._errors.unshift(new Error("RetryOperation timeout occurred"));
            return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === void 0) {
            if (this._cachedTimeouts) {
                this._errors.splice(this._errors.length - 1, this._errors.length);
                this._timeouts = this._cachedTimeouts.slice(0);
                timeout = this._timeouts.shift();
            }
            else {
                return false;
            }
        }
        var self2 = this;
        var timer = setTimeout(function () {
            self2._attempts++;
            if (self2._operationTimeoutCb) {
                self2._timeout = setTimeout(function () {
                    self2._operationTimeoutCb(self2._attempts);
                }, self2._operationTimeout);
                if (self2._options.unref) {
                    self2._timeout.unref();
                }
            }
            self2._fn(self2._attempts);
        }, timeout);
        if (this._options.unref) {
            timer.unref();
        }
        return true;
    };
    RetryOperation.prototype.attempt = function (fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
            if (timeoutOps.timeout) {
                this._operationTimeout = timeoutOps.timeout;
            }
            if (timeoutOps.cb) {
                this._operationTimeoutCb = timeoutOps.cb;
            }
        }
        var self2 = this;
        if (this._operationTimeoutCb) {
            this._timeout = setTimeout(function () {
                self2._operationTimeoutCb();
            }, self2._operationTimeout);
        }
        this._operationStart = ( /* @__PURE__ */new Date()).getTime();
        this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function (fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
    };
    RetryOperation.prototype.start = function (fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function () {
        return this._errors;
    };
    RetryOperation.prototype.attempts = function () {
        return this._attempts;
    };
    RetryOperation.prototype.mainError = function () {
        if (this._errors.length === 0) {
            return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
            var error = this._errors[i];
            var message2 = error.message;
            var count = (counts[message2] || 0) + 1;
            counts[message2] = count;
            if (count >= mainErrorCount) {
                mainError = error;
                mainErrorCount = count;
            }
        }
        return mainError;
    };
    return retry_operation;
}
var hasRequiredRetry$1;
function requireRetry$1() {
    if (hasRequiredRetry$1)
        return retry$1;
    hasRequiredRetry$1 = 1;
    (function (exports2) {
        var RetryOperation = requireRetry_operation();
        exports2.operation = function (options2) {
            var timeouts = exports2.timeouts(options2);
            return new RetryOperation(timeouts, {
                forever: options2 && options2.forever,
                unref: options2 && options2.unref,
                maxRetryTime: options2 && options2.maxRetryTime
            });
        };
        exports2.timeouts = function (options2) {
            if (options2 instanceof Array) {
                return [].concat(options2);
            }
            var opts = {
                retries: 10,
                factor: 2,
                minTimeout: 1 * 1e3,
                maxTimeout: Infinity,
                randomize: false
            };
            for (var key in options2) {
                opts[key] = options2[key];
            }
            if (opts.minTimeout > opts.maxTimeout) {
                throw new Error("minTimeout is greater than maxTimeout");
            }
            var timeouts = [];
            for (var i = 0; i < opts.retries; i++) {
                timeouts.push(this.createTimeout(i, opts));
            }
            if (options2 && options2.forever && !timeouts.length) {
                timeouts.push(this.createTimeout(i, opts));
            }
            timeouts.sort(function (a, b) {
                return a - b;
            });
            return timeouts;
        };
        exports2.createTimeout = function (attempt, opts) {
            var random2 = opts.randomize ? Math.random() + 1 : 1;
            var timeout = Math.round(random2 * opts.minTimeout * Math.pow(opts.factor, attempt));
            timeout = Math.min(timeout, opts.maxTimeout);
            return timeout;
        };
        exports2.wrap = function (obj, options2, methods2) {
            if (options2 instanceof Array) {
                methods2 = options2;
                options2 = null;
            }
            if (!methods2) {
                methods2 = [];
                for (var key in obj) {
                    if (typeof obj[key] === "function") {
                        methods2.push(key);
                    }
                }
            }
            for (var i = 0; i < methods2.length; i++) {
                var method = methods2[i];
                var original = obj[method];
                obj[method] = function retryWrapper(original2) {
                    var op = exports2.operation(options2);
                    var args = Array.prototype.slice.call(arguments, 1);
                    var callback = args.pop();
                    args.push(function (err) {
                        if (op.retry(err)) {
                            return;
                        }
                        if (err) {
                            arguments[0] = op.mainError();
                        }
                        callback.apply(this, arguments);
                    });
                    op.attempt(function () {
                        original2.apply(obj, args);
                    });
                }.bind(obj, original);
                obj[method].options = options2;
            }
        };
    })(retry$1);
    return retry$1;
}
var retry;
var hasRequiredRetry;
function requireRetry() {
    if (hasRequiredRetry)
        return retry;
    hasRequiredRetry = 1;
    retry = requireRetry$1();
    return retry;
}
var promiseRetry_1;
var hasRequiredPromiseRetry;
function requirePromiseRetry() {
    if (hasRequiredPromiseRetry)
        return promiseRetry_1;
    hasRequiredPromiseRetry = 1;
    var errcode = requireErrCode();
    var retry2 = requireRetry();
    var hasOwn = Object.prototype.hasOwnProperty;
    function isRetryError(err) {
        return err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried");
    }
    function promiseRetry2(fn, options2) {
        var temp;
        var operation;
        if (typeof fn === "object" && typeof options2 === "function") {
            temp = options2;
            options2 = fn;
            fn = temp;
        }
        operation = retry2.operation(options2);
        return new Promise(function (resolve, reject) {
            operation.attempt(function (number2) {
                Promise.resolve().then(function () {
                    return fn(function (err) {
                        if (isRetryError(err)) {
                            err = err.retried;
                        }
                        throw errcode(new Error("Retrying"), "EPROMISERETRY", { retried: err });
                    }, number2);
                }).then(resolve, function (err) {
                    if (isRetryError(err)) {
                        err = err.retried;
                        if (operation.retry(err || new Error())) {
                            return;
                        }
                    }
                    reject(err);
                });
            });
        });
    }
    promiseRetry_1 = promiseRetry2;
    return promiseRetry_1;
}
var promiseRetryExports = requirePromiseRetry();
const promiseRetry = /* @__PURE__ */ getDefaultExportFromCjs(promiseRetryExports);
let documentDir;
const _setDocumentDir = (dir) => documentDir = dir;
const getDocumentDir = () => {
    if (!documentDir) {
        throw new Error("Document directory is not set");
    }
    return documentDir;
};
const getBudgetDir = (id2) => {
    if (!id2) {
        throw new Error("getDocumentDir: id is falsy: " + id2);
    }
    if (id2.match(/[^A-Za-z0-9\-_]/)) {
        throw new Error(`Invalid budget id ${id2}. Check the id of your budget in the Advanced section of the settings page.`);
    }
    return path.join(getDocumentDir(), id2);
};
let rootPath = path__namespace.join(__dirname, "..", "..", "..", "..");
switch (path__namespace.basename(__filename)) {
    case "bundle.api.js":
        rootPath = path__namespace.join(__dirname, "..");
        break;
    case "bundle.desktop.js":
        rootPath = path__namespace.join(__dirname, "..", "..");
        break;
}
const init$4 = () => {
};
const getDataDir = () => {
    if (!process.env.ACTUAL_DATA_DIR) {
        throw new Error("ACTUAL_DATA_DIR env variable is required");
    }
    return process.env.ACTUAL_DATA_DIR;
};
const bundledDatabasePath = path__namespace.join(rootPath, "default-db.sqlite");
const migrationsPath = path__namespace.join(rootPath, "migrations");
const demoBudgetPath = path__namespace.join(rootPath, "demo-budget");
const join$1 = path__namespace.join;
const basename = (filepath) => path__namespace.basename(filepath);
const listDir = (filepath) => new Promise((resolve, reject) => {
    fs__namespace.readdir(filepath, (err, files) => {
        if (err) {
            reject(err);
        }
        else {
            resolve(files);
        }
    });
});
const exists = (filepath) => new Promise((resolve) => {
    fs__namespace.access(filepath, fs__namespace.constants.F_OK, (err) => {
        return resolve(!err);
    });
});
const mkdir = (filepath) => new Promise((resolve, reject) => {
    fs__namespace.mkdir(filepath, (err) => {
        if (err) {
            reject(err);
        }
        else {
            resolve(void 0);
        }
    });
});
const size = (filepath) => new Promise((resolve, reject) => {
    fs__namespace.stat(filepath, (err, stats) => {
        if (err) {
            reject(err);
        }
        else {
            resolve(stats.size);
        }
    });
});
const copyFile = (frompath, topath) => {
    return new Promise((resolve, reject) => {
        const readStream = fs__namespace.createReadStream(frompath);
        const writeStream = fs__namespace.createWriteStream(topath);
        readStream.on("error", reject);
        writeStream.on("error", reject);
        writeStream.on("open", () => readStream.pipe(writeStream));
        writeStream.once("close", () => resolve(true));
    });
};
const readFile = (filepath, encoding = "utf8") => {
    if (encoding === "binary") {
        encoding = null;
    }
    return new Promise((resolve, reject) => {
        fs__namespace.readFile(filepath, encoding, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
};
const writeFile = async (filepath, contents) => {
    try {
        await promiseRetry((retry2, attempt) => {
            return new Promise((resolve, reject) => {
                fs__namespace.writeFile(filepath, contents, "utf8", (err) => {
                    if (err) {
                        console.error(`Failed to write to ${filepath}. Attempted ${attempt} times. Something is locking the file - potentially a virus scanner or backup software.`);
                        reject(err);
                    }
                    else {
                        if (attempt > 1) {
                            console.info(`Successfully recovered from file lock. It took ${attempt} retries`);
                        }
                        resolve(void 0);
                    }
                });
            }).catch(retry2);
        }, {
            retries: 20,
            minTimeout: 100,
            maxTimeout: 500,
            factor: 1.5
        });
        return void 0;
    }
    catch (err) {
        console.error(`Unable to recover from file lock on file ${filepath}`);
        throw err;
    }
};
const removeFile$1 = (filepath) => {
    return new Promise(function (resolve, reject) {
        fs__namespace.unlink(filepath, (err) => {
            return err ? reject(err) : resolve(void 0);
        });
    });
};
const removeDir = (dirpath) => {
    return new Promise(function (resolve, reject) {
        fs__namespace.rmdir(dirpath, (err) => {
            return err ? reject(err) : resolve(void 0);
        });
    });
};
const removeDirRecursively = async (dirpath) => {
    if (await exists(dirpath)) {
        for (const file of await listDir(dirpath)) {
            const fullpath = join$1(dirpath, file);
            if (fs__namespace.statSync(fullpath).isDirectory()) {
                await removeDirRecursively(fullpath);
            }
            else {
                await removeFile$1(fullpath);
            }
        }
        await removeDir(dirpath);
    }
};
const getModifiedTime = (filepath) => {
    return new Promise(function (resolve, reject) {
        fs__namespace.stat(filepath, (err, stats) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(new Date(stats.mtime));
            }
        });
    });
};
const fs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    _setDocumentDir,
    basename,
    bundledDatabasePath,
    copyFile,
    demoBudgetPath,
    exists,
    getBudgetDir,
    getDataDir,
    getDocumentDir,
    getModifiedTime,
    init: init$4,
    join: join$1,
    listDir,
    migrationsPath,
    mkdir,
    readFile,
    removeDir,
    removeDirRecursively,
    removeFile: removeFile$1,
    size,
    writeFile
}, Symbol.toStringTag, { value: "Module" }));
const getStorePath = () => path.join(getDataDir(), "global-store.json");
let store;
let persisted = true;
const init$3 = function ({ persist = true } = {}) {
    if (persist) {
        try {
            store = JSON.parse(fs__namespace.readFileSync(getStorePath(), "utf8"));
        }
        catch (e) {
            store = {};
        }
    }
    else {
        store = {};
    }
    persisted = persist;
};
function _saveStore() {
    if (persisted) {
        return new Promise(function (resolve, reject) {
            fs__namespace.writeFile(getStorePath(), JSON.stringify(store), "utf8", function (err) {
                return err ? reject(err) : resolve();
            });
        });
    }
}
const getItem = function (key) {
    return new Promise(function (resolve) {
        return resolve(store[key]);
    });
};
const setItem = function (key, value) {
    store[key] = value;
    return _saveStore();
};
const removeItem = function (key) {
    delete store[key];
    return _saveStore();
};
async function multiGet(keys2) {
    const results = keys2.map((key) => [key, store[key]]);
    return results.reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
    }, {});
}
const multiRemove = function (keys2) {
    keys2.forEach(function (key) {
        delete store[key];
    });
    return _saveStore();
};
const init$2 = function () {
};
const send$1 = function () {
};
let verboseMode = true;
function setVerboseMode(verbose) {
    verboseMode = verbose;
}
const logger = {
    info: (...args) => {
        if (verboseMode) {
            console.log(...args);
        }
    },
    warn: (...args) => {
        console.warn(...args);
    },
    log: (...args) => {
        if (verboseMode) {
            console.log(...args);
        }
    },
    error: (...args) => {
        console.error(...args);
    },
    debug: (...args) => {
        if (verboseMode) {
            console.debug(...args);
        }
    },
    group: (...args) => {
        if (verboseMode) {
            console.group(...args);
        }
    },
    groupEnd: () => {
        if (verboseMode) {
            console.groupEnd();
        }
    }
};
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        crypto.randomFillSync(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const native = { randomUUID: crypto.randomUUID };
function v4(options2, buf, offset) {
    if (native.randomUUID && true && !options2) {
        return native.randomUUID();
    }
    options2 = options2 || {};
    const rnds = options2.random ?? options2.rng?.() ?? rng();
    if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
}
function getNormalisedString(value) {
    return value.toLowerCase().normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "");
}
function normalise(value) {
    if (!value) {
        return null;
    }
    return getNormalisedString(value);
}
const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const warned = /* @__PURE__ */ new Set();
const PROCESS = typeof process === "object" && !!process ? process : {};
const emitWarning = (msg, type2, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
    AS = class AbortSignal {
        constructor() {
            this._onabort = [];
            this.aborted = false;
        }
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    AC = class AbortController {
        constructor() {
            this.signal = new AS();
            warnACPolyfill();
        }
        abort(reason) {
            if (this.signal.aborted)
                return;
            this.signal.reason = reason;
            this.signal.aborted = true;
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
}
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
const getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
    constructor(size2) {
        super(size2);
        this.fill(0);
    }
}
class Stack {
    static create(max2) {
        const HeapCls = getUintArray(max2);
        if (!HeapCls)
            return [];
        __classPrivateFieldSet(_a, _a, true, "f", _Stack_constructing);
        const s = new _a(max2, HeapCls);
        __classPrivateFieldSet(_a, _a, false, "f", _Stack_constructing);
        return s;
    }
    constructor(max2, HeapCls) {
        if (!__classPrivateFieldGet(_a, _a, "f", _Stack_constructing)) {
            throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max2);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
_a = Stack;
// private constructor
_Stack_constructing = { value: false };
class LRUCache {
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: __classPrivateFieldGet(c, _LRUCache_starts, "f"),
            ttls: __classPrivateFieldGet(c, _LRUCache_ttls, "f"),
            sizes: __classPrivateFieldGet(c, _LRUCache_sizes, "f"),
            keyMap: __classPrivateFieldGet(c, _LRUCache_keyMap, "f"),
            keyList: __classPrivateFieldGet(c, _LRUCache_keyList, "f"),
            valList: __classPrivateFieldGet(c, _LRUCache_valList, "f"),
            next: __classPrivateFieldGet(c, _LRUCache_next, "f"),
            prev: __classPrivateFieldGet(c, _LRUCache_prev, "f"),
            get head() {
                return __classPrivateFieldGet(c, _LRUCache_head, "f");
            },
            get tail() {
                return __classPrivateFieldGet(c, _LRUCache_tail, "f");
            },
            free: __classPrivateFieldGet(c, _LRUCache_free, "f"),
            // methods
            isBackgroundFetch: (p) => __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(c, p),
            backgroundFetch: (k, index, options2, context) => __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_backgroundFetch).call(c, k, index, options2, context),
            moveToTail: (index) => __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_moveToTail).call(c, index),
            indexes: (options2) => __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_indexes).call(c, options2),
            rindexes: (options2) => __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_rindexes).call(c, options2),
            isStale: (index) => __classPrivateFieldGet(c, _LRUCache_isStale, "f").call(c, index)
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return __classPrivateFieldGet(this, _LRUCache_max, "f");
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return __classPrivateFieldGet(this, _LRUCache_maxSize, "f");
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return __classPrivateFieldGet(this, _LRUCache_calculatedSize, "f");
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return __classPrivateFieldGet(this, _LRUCache_size, "f");
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return __classPrivateFieldGet(this, _LRUCache_fetchMethod, "f");
    }
    get memoMethod() {
        return __classPrivateFieldGet(this, _LRUCache_memoMethod, "f");
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return __classPrivateFieldGet(this, _LRUCache_dispose, "f");
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return __classPrivateFieldGet(this, _LRUCache_onInsert, "f");
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f");
    }
    constructor(options2) {
        _LRUCache_instances.add(this);
        // options that cannot be changed without disaster
        _LRUCache_max.set(this, void 0);
        _LRUCache_maxSize.set(this, void 0);
        _LRUCache_dispose.set(this, void 0);
        _LRUCache_onInsert.set(this, void 0);
        _LRUCache_disposeAfter.set(this, void 0);
        _LRUCache_fetchMethod.set(this, void 0);
        _LRUCache_memoMethod.set(this, void 0);
        // computed properties
        _LRUCache_size.set(this, void 0);
        _LRUCache_calculatedSize.set(this, void 0);
        _LRUCache_keyMap.set(this, void 0);
        _LRUCache_keyList.set(this, void 0);
        _LRUCache_valList.set(this, void 0);
        _LRUCache_next.set(this, void 0);
        _LRUCache_prev.set(this, void 0);
        _LRUCache_head.set(this, void 0);
        _LRUCache_tail.set(this, void 0);
        _LRUCache_free.set(this, void 0);
        _LRUCache_disposed.set(this, void 0);
        _LRUCache_sizes.set(this, void 0);
        _LRUCache_starts.set(this, void 0);
        _LRUCache_ttls.set(this, void 0);
        _LRUCache_hasDispose.set(this, void 0);
        _LRUCache_hasFetchMethod.set(this, void 0);
        _LRUCache_hasDisposeAfter.set(this, void 0);
        _LRUCache_hasOnInsert.set(this, void 0);
        // conditionally set private methods related to TTL
        _LRUCache_updateItemAge.set(this, () => {
        });
        _LRUCache_statusTTL.set(this, () => {
        });
        _LRUCache_setItemTTL.set(this, () => {
        });
        /* c8 ignore stop */
        _LRUCache_isStale.set(this, () => false);
        _LRUCache_removeItemSize.set(this, (_i) => {
        });
        _LRUCache_addItemSize.set(this, (_i, _s, _st) => {
        });
        _LRUCache_requireSize.set(this, (_k, _v, size2, sizeCalculation) => {
            if (size2 || sizeCalculation) {
                throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
            }
            return 0;
        });
        /**
         * A String value that is used in the creation of the default string
         * description of an object. Called by the built-in method
         * `Object.prototype.toString`.
         */
        this[_b] = "LRUCache";
        const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert: onInsert2, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options2;
        if (max2 !== 0 && !isPosInt(max2)) {
            throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max2 ? getUintArray(max2) : Array;
        if (!UintArray) {
            throw new Error("invalid max value: " + max2);
        }
        __classPrivateFieldSet(this, _LRUCache_max, max2, "f");
        __classPrivateFieldSet(this, _LRUCache_maxSize, maxSize, "f");
        this.maxEntrySize = maxEntrySize || __classPrivateFieldGet(this, _LRUCache_maxSize, "f");
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!__classPrivateFieldGet(this, _LRUCache_maxSize, "f") && !this.maxEntrySize) {
                throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
            }
            if (typeof this.sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation set to non-function");
            }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
            throw new TypeError("memoMethod must be a function if defined");
        }
        __classPrivateFieldSet(this, _LRUCache_memoMethod, memoMethod, "f");
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
            throw new TypeError("fetchMethod must be a function if specified");
        }
        __classPrivateFieldSet(this, _LRUCache_fetchMethod, fetchMethod, "f");
        __classPrivateFieldSet(this, _LRUCache_hasFetchMethod, !!fetchMethod, "f");
        __classPrivateFieldSet(this, _LRUCache_keyMap, /* @__PURE__ */ new Map(), "f");
        __classPrivateFieldSet(this, _LRUCache_keyList, new Array(max2).fill(void 0), "f");
        __classPrivateFieldSet(this, _LRUCache_valList, new Array(max2).fill(void 0), "f");
        __classPrivateFieldSet(this, _LRUCache_next, new UintArray(max2), "f");
        __classPrivateFieldSet(this, _LRUCache_prev, new UintArray(max2), "f");
        __classPrivateFieldSet(this, _LRUCache_head, 0, "f");
        __classPrivateFieldSet(this, _LRUCache_tail, 0, "f");
        __classPrivateFieldSet(this, _LRUCache_free, Stack.create(max2), "f");
        __classPrivateFieldSet(this, _LRUCache_size, 0, "f");
        __classPrivateFieldSet(this, _LRUCache_calculatedSize, 0, "f");
        if (typeof dispose === "function") {
            __classPrivateFieldSet(this, _LRUCache_dispose, dispose, "f");
        }
        if (typeof onInsert2 === "function") {
            __classPrivateFieldSet(this, _LRUCache_onInsert, onInsert2, "f");
        }
        if (typeof disposeAfter === "function") {
            __classPrivateFieldSet(this, _LRUCache_disposeAfter, disposeAfter, "f");
            __classPrivateFieldSet(this, _LRUCache_disposed, [], "f");
        }
        else {
            __classPrivateFieldSet(this, _LRUCache_disposeAfter, void 0, "f");
            __classPrivateFieldSet(this, _LRUCache_disposed, void 0, "f");
        }
        __classPrivateFieldSet(this, _LRUCache_hasDispose, !!__classPrivateFieldGet(this, _LRUCache_dispose, "f"), "f");
        __classPrivateFieldSet(this, _LRUCache_hasOnInsert, !!__classPrivateFieldGet(this, _LRUCache_onInsert, "f"), "f");
        __classPrivateFieldSet(this, _LRUCache_hasDisposeAfter, !!__classPrivateFieldGet(this, _LRUCache_disposeAfter, "f"), "f");
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
            if (__classPrivateFieldGet(this, _LRUCache_maxSize, "f") !== 0) {
                if (!isPosInt(__classPrivateFieldGet(this, _LRUCache_maxSize, "f"))) {
                    throw new TypeError("maxSize must be a positive integer if specified");
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError("maxEntrySize must be a positive integer if specified");
            }
            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_initializeSizeTracking).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError("ttl must be a positive integer if specified");
            }
            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_initializeTTLTracking).call(this);
        }
        if (__classPrivateFieldGet(this, _LRUCache_max, "f") === 0 && this.ttl === 0 && __classPrivateFieldGet(this, _LRUCache_maxSize, "f") === 0) {
            throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__classPrivateFieldGet(this, _LRUCache_max, "f") && !__classPrivateFieldGet(this, _LRUCache_maxSize, "f")) {
            const code = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
                emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return __classPrivateFieldGet(this, _LRUCache_keyMap, "f").has(key) ? Infinity : 0;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this)) {
            if (__classPrivateFieldGet(this, _LRUCache_valList, "f")[i] !== void 0 && __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i] !== void 0 && !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i])) {
                yield [__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this)) {
            if (__classPrivateFieldGet(this, _LRUCache_valList, "f")[i] !== void 0 && __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i] !== void 0 && !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i])) {
                yield [__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this)) {
            const k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i];
            if (k !== void 0 && !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this)) {
            const k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i];
            if (k !== void 0 && !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this)) {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            if (v !== void 0 && !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i])) {
                yield __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this)) {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            if (v !== void 0 && !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i])) {
                yield __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [(_LRUCache_max = new WeakMap(), _LRUCache_maxSize = new WeakMap(), _LRUCache_dispose = new WeakMap(), _LRUCache_onInsert = new WeakMap(), _LRUCache_disposeAfter = new WeakMap(), _LRUCache_fetchMethod = new WeakMap(), _LRUCache_memoMethod = new WeakMap(), _LRUCache_size = new WeakMap(), _LRUCache_calculatedSize = new WeakMap(), _LRUCache_keyMap = new WeakMap(), _LRUCache_keyList = new WeakMap(), _LRUCache_valList = new WeakMap(), _LRUCache_next = new WeakMap(), _LRUCache_prev = new WeakMap(), _LRUCache_head = new WeakMap(), _LRUCache_tail = new WeakMap(), _LRUCache_free = new WeakMap(), _LRUCache_disposed = new WeakMap(), _LRUCache_sizes = new WeakMap(), _LRUCache_starts = new WeakMap(), _LRUCache_ttls = new WeakMap(), _LRUCache_hasDispose = new WeakMap(), _LRUCache_hasFetchMethod = new WeakMap(), _LRUCache_hasDisposeAfter = new WeakMap(), _LRUCache_hasOnInsert = new WeakMap(), _LRUCache_updateItemAge = new WeakMap(), _LRUCache_statusTTL = new WeakMap(), _LRUCache_setItemTTL = new WeakMap(), _LRUCache_isStale = new WeakMap(), _LRUCache_removeItemSize = new WeakMap(), _LRUCache_addItemSize = new WeakMap(), _LRUCache_requireSize = new WeakMap(), _LRUCache_instances = new WeakSet(), _LRUCache_initializeTTLTracking = function _LRUCache_initializeTTLTracking() {
        const ttls = new ZeroArray(__classPrivateFieldGet(this, _LRUCache_max, "f"));
        const starts = new ZeroArray(__classPrivateFieldGet(this, _LRUCache_max, "f"));
        __classPrivateFieldSet(this, _LRUCache_ttls, ttls, "f");
        __classPrivateFieldSet(this, _LRUCache_starts, starts, "f");
        __classPrivateFieldSet(this, _LRUCache_setItemTTL, (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t2 = setTimeout(() => {
                    if (__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index)) {
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index], "expire");
                    }
                }, ttl + 1);
                if (t2.unref) {
                    t2.unref();
                }
            }
        }, "f");
        __classPrivateFieldSet(this, _LRUCache_updateItemAge, (index) => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        }, "f");
        __classPrivateFieldSet(this, _LRUCache_statusTTL, (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        }, "f");
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t2 = setTimeout(() => cachedNow = 0, this.ttlResolution);
                if (t2.unref) {
                    t2.unref();
                }
            }
            return n;
        };
        this.getRemainingTTL = (key) => {
            const index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(key);
            if (index === void 0) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        __classPrivateFieldSet(this, _LRUCache_isStale, (index) => {
            const s = starts[index];
            const t2 = ttls[index];
            return !!t2 && !!s && (cachedNow || getNow()) - s > t2;
        }, "f");
    }, _LRUCache_initializeSizeTracking = function _LRUCache_initializeSizeTracking() {
        const sizes = new ZeroArray(__classPrivateFieldGet(this, _LRUCache_max, "f"));
        __classPrivateFieldSet(this, _LRUCache_calculatedSize, 0, "f");
        __classPrivateFieldSet(this, _LRUCache_sizes, sizes, "f");
        __classPrivateFieldSet(this, _LRUCache_removeItemSize, (index) => {
            __classPrivateFieldSet(this, _LRUCache_calculatedSize, __classPrivateFieldGet(this, _LRUCache_calculatedSize, "f") - sizes[index], "f");
            sizes[index] = 0;
        }, "f");
        __classPrivateFieldSet(this, _LRUCache_requireSize, (k, v, size2, sizeCalculation) => {
            if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                return 0;
            }
            if (!isPosInt(size2)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== "function") {
                        throw new TypeError("sizeCalculation must be a function");
                    }
                    size2 = sizeCalculation(v, k);
                    if (!isPosInt(size2)) {
                        throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                    }
                }
                else {
                    throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
                }
            }
            return size2;
        }, "f");
        __classPrivateFieldSet(this, _LRUCache_addItemSize, (index, size2, status) => {
            sizes[index] = size2;
            if (__classPrivateFieldGet(this, _LRUCache_maxSize, "f")) {
                const maxSize = __classPrivateFieldGet(this, _LRUCache_maxSize, "f") - sizes[index];
                while (__classPrivateFieldGet(this, _LRUCache_calculatedSize, "f") > maxSize) {
                    __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this, true);
                }
            }
            __classPrivateFieldSet(this, _LRUCache_calculatedSize, __classPrivateFieldGet(this, _LRUCache_calculatedSize, "f") + sizes[index], "f");
            if (status) {
                status.entrySize = size2;
                status.totalCalculatedSize = __classPrivateFieldGet(this, _LRUCache_calculatedSize, "f");
            }
        }, "f");
    }, _LRUCache_indexes = function* _LRUCache_indexes({ allowStale = this.allowStale } = {}) {
        if (__classPrivateFieldGet(this, _LRUCache_size, "f")) {
            for (let i = __classPrivateFieldGet(this, _LRUCache_tail, "f"); true;) {
                if (!__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isValidIndex).call(this, i)) {
                    break;
                }
                if (allowStale || !__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, i)) {
                    yield i;
                }
                if (i === __classPrivateFieldGet(this, _LRUCache_head, "f")) {
                    break;
                }
                else {
                    i = __classPrivateFieldGet(this, _LRUCache_prev, "f")[i];
                }
            }
        }
    }, _LRUCache_rindexes = function* _LRUCache_rindexes({ allowStale = this.allowStale } = {}) {
        if (__classPrivateFieldGet(this, _LRUCache_size, "f")) {
            for (let i = __classPrivateFieldGet(this, _LRUCache_head, "f"); true;) {
                if (!__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isValidIndex).call(this, i)) {
                    break;
                }
                if (allowStale || !__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, i)) {
                    yield i;
                }
                if (i === __classPrivateFieldGet(this, _LRUCache_tail, "f")) {
                    break;
                }
                else {
                    i = __classPrivateFieldGet(this, _LRUCache_next, "f")[i];
                }
            }
        }
    }, _LRUCache_isValidIndex = function _LRUCache_isValidIndex(index) {
        return index !== void 0 && __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(__classPrivateFieldGet(this, _LRUCache_keyList, "f")[index]) === index;
    }, Symbol.iterator)]() {
        return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this)) {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            const value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
            if (value === void 0)
                continue;
            if (fn(value, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], this)) {
                return this.get(__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this)) {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            const value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
            if (value === void 0)
                continue;
            fn.call(thisp, value, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this)) {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            const value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
            if (value === void 0)
                continue;
            fn.call(thisp, value, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this, { allowStale: true })) {
            if (__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, i)) {
                __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], "expire");
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(key);
        if (i === void 0)
            return void 0;
        const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
        const value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
            return void 0;
        const entry = { value };
        if (__classPrivateFieldGet(this, _LRUCache_ttls, "f") && __classPrivateFieldGet(this, _LRUCache_starts, "f")) {
            const ttl = __classPrivateFieldGet(this, _LRUCache_ttls, "f")[i];
            const start = __classPrivateFieldGet(this, _LRUCache_starts, "f")[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (__classPrivateFieldGet(this, _LRUCache_sizes, "f")) {
            entry.size = __classPrivateFieldGet(this, _LRUCache_sizes, "f")[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this, { allowStale: true })) {
            const key = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i];
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
            const value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
            if (value === void 0 || key === void 0)
                continue;
            const entry = { value };
            if (__classPrivateFieldGet(this, _LRUCache_ttls, "f") && __classPrivateFieldGet(this, _LRUCache_starts, "f")) {
                entry.ttl = __classPrivateFieldGet(this, _LRUCache_ttls, "f")[i];
                const age = perf.now() - __classPrivateFieldGet(this, _LRUCache_starts, "f")[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (__classPrivateFieldGet(this, _LRUCache_sizes, "f")) {
                entry.size = __classPrivateFieldGet(this, _LRUCache_sizes, "f")[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        var _c;
        if (v === void 0) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size2 = __classPrivateFieldGet(this, _LRUCache_requireSize, "f").call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size2 > this.maxEntrySize) {
            if (status) {
                status.set = "miss";
                status.maxEntrySizeExceeded = true;
            }
            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, k, "set");
            return this;
        }
        let index = __classPrivateFieldGet(this, _LRUCache_size, "f") === 0 ? void 0 : __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
        if (index === void 0) {
            index = __classPrivateFieldGet(this, _LRUCache_size, "f") === 0 ? __classPrivateFieldGet(this, _LRUCache_tail, "f") : __classPrivateFieldGet(this, _LRUCache_free, "f").length !== 0 ? __classPrivateFieldGet(this, _LRUCache_free, "f").pop() : __classPrivateFieldGet(this, _LRUCache_size, "f") === __classPrivateFieldGet(this, _LRUCache_max, "f") ? __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this, false) : __classPrivateFieldGet(this, _LRUCache_size, "f");
            __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index] = k;
            __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = v;
            __classPrivateFieldGet(this, _LRUCache_keyMap, "f").set(k, index);
            __classPrivateFieldGet(this, _LRUCache_next, "f")[__classPrivateFieldGet(this, _LRUCache_tail, "f")] = index;
            __classPrivateFieldGet(this, _LRUCache_prev, "f")[index] = __classPrivateFieldGet(this, _LRUCache_tail, "f");
            __classPrivateFieldSet(this, _LRUCache_tail, index, "f");
            __classPrivateFieldSet(this, _LRUCache_size, (_c = __classPrivateFieldGet(this, _LRUCache_size, "f"), _c++, _c), "f");
            __classPrivateFieldGet(this, _LRUCache_addItemSize, "f").call(this, index, size2, status);
            if (status)
                status.set = "add";
            noUpdateTTL = false;
            if (__classPrivateFieldGet(this, _LRUCache_hasOnInsert, "f")) {
                __classPrivateFieldGet(this, _LRUCache_onInsert, "f")?.call(this, v, k, "add");
            }
        }
        else {
            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToTail).call(this, index);
            const oldVal = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
            if (v !== oldVal) {
                if (__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f") && __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, oldVal)) {
                    oldVal.__abortController.abort(new Error("replaced"));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== void 0 && !noDisposeOnSet) {
                        if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                            __classPrivateFieldGet(this, _LRUCache_dispose, "f")?.call(this, s, k, "set");
                        }
                        if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                            __classPrivateFieldGet(this, _LRUCache_disposed, "f")?.push([s, k, "set"]);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_dispose, "f")?.call(this, oldVal, k, "set");
                    }
                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_disposed, "f")?.push([oldVal, k, "set"]);
                    }
                }
                __classPrivateFieldGet(this, _LRUCache_removeItemSize, "f").call(this, index);
                __classPrivateFieldGet(this, _LRUCache_addItemSize, "f").call(this, index, size2, status);
                __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = v;
                if (status) {
                    status.set = "replace";
                    const oldValue = oldVal && __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== void 0)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = "update";
            }
            if (__classPrivateFieldGet(this, _LRUCache_hasOnInsert, "f")) {
                this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
            }
        }
        if (ttl !== 0 && !__classPrivateFieldGet(this, _LRUCache_ttls, "f")) {
            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_initializeTTLTracking).call(this);
        }
        if (__classPrivateFieldGet(this, _LRUCache_ttls, "f")) {
            if (!noUpdateTTL) {
                __classPrivateFieldGet(this, _LRUCache_setItemTTL, "f").call(this, index, ttl, start);
            }
            if (status)
                __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
        }
        if (!noDisposeOnSet && __classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")) {
            const dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
            let task;
            while (task = dt?.shift()) {
                __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")?.call(this, ...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (__classPrivateFieldGet(this, _LRUCache_size, "f")) {
                const val2 = __classPrivateFieldGet(this, _LRUCache_valList, "f")[__classPrivateFieldGet(this, _LRUCache_head, "f")];
                __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this, true);
                if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, val2)) {
                    if (val2.__staleWhileFetching) {
                        return val2.__staleWhileFetching;
                    }
                }
                else if (val2 !== void 0) {
                    return val2;
                }
            }
        }
        finally {
            if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")) {
                const dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
                let task;
                while (task = dt?.shift()) {
                    __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")?.call(this, ...task);
                }
            }
        }
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
        if (index !== void 0) {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
            if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) && v.__staleWhileFetching === void 0) {
                return false;
            }
            if (!__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index)) {
                if (updateAgeOnHas) {
                    __classPrivateFieldGet(this, _LRUCache_updateItemAge, "f").call(this, index);
                }
                if (status) {
                    status.has = "hit";
                    __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                }
                return true;
            }
            else if (status) {
                status.has = "stale";
                __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
            }
        }
        else if (status) {
            status.has = "miss";
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
        if (index === void 0 || !allowStale && __classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index)) {
            return;
        }
        const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
        return __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size: size2 = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
        if (!__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f")) {
            if (status)
                status.fetch = "get";
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
            });
        }
        const options2 = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size: size2,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
        };
        let index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
        if (index === void 0) {
            if (status)
                status.fetch = "miss";
            const p = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_backgroundFetch).call(this, k, index, options2, context);
            return p.__returned = p;
        }
        else {
            const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
            if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                const stale = allowStale && v.__staleWhileFetching !== void 0;
                if (status) {
                    status.fetch = "inflight";
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : v.__returned = v;
            }
            const isStale = __classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = "hit";
                __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToTail).call(this, index);
                if (updateAgeOnGet) {
                    __classPrivateFieldGet(this, _LRUCache_updateItemAge, "f").call(this, index);
                }
                if (status)
                    __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                return v;
            }
            const p = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_backgroundFetch).call(this, k, index, options2, context);
            const hasStale = p.__staleWhileFetching !== void 0;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? "stale" : "refresh";
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
            throw new Error("fetch() returned undefined");
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = __classPrivateFieldGet(this, _LRUCache_memoMethod, "f");
        if (!memoMethod) {
            throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options2 } = memoOptions;
        const v = this.get(k, options2);
        if (!forceRefresh && v !== void 0)
            return v;
        const vv = memoMethod(k, v, {
            options: options2,
            context
        });
        this.set(k, vv, options2);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
        if (index !== void 0) {
            const value = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
            const fetching = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, value);
            if (status)
                __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
            if (__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index)) {
                if (status)
                    status.get = "stale";
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, k, "expire");
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : void 0;
                }
                else {
                    if (status && allowStale && value.__staleWhileFetching !== void 0) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : void 0;
                }
            }
            else {
                if (status)
                    status.get = "hit";
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToTail).call(this, index);
                if (updateAgeOnGet) {
                    __classPrivateFieldGet(this, _LRUCache_updateItemAge, "f").call(this, index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = "miss";
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, k, "delete");
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_clear).call(this, "delete");
    }
}
_b = Symbol.toStringTag, _LRUCache_evict = function _LRUCache_evict(free) {
    var _c;
    const head = __classPrivateFieldGet(this, _LRUCache_head, "f");
    const k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[head];
    const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[head];
    if (__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f") && __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
    }
    else if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f") || __classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
        if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
            __classPrivateFieldGet(this, _LRUCache_dispose, "f")?.call(this, v, k, "evict");
        }
        if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
            __classPrivateFieldGet(this, _LRUCache_disposed, "f")?.push([v, k, "evict"]);
        }
    }
    __classPrivateFieldGet(this, _LRUCache_removeItemSize, "f").call(this, head);
    if (free) {
        __classPrivateFieldGet(this, _LRUCache_keyList, "f")[head] = void 0;
        __classPrivateFieldGet(this, _LRUCache_valList, "f")[head] = void 0;
        __classPrivateFieldGet(this, _LRUCache_free, "f").push(head);
    }
    if (__classPrivateFieldGet(this, _LRUCache_size, "f") === 1) {
        __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldSet(this, _LRUCache_tail, 0, "f"), "f");
        __classPrivateFieldGet(this, _LRUCache_free, "f").length = 0;
    }
    else {
        __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldGet(this, _LRUCache_next, "f")[head], "f");
    }
    __classPrivateFieldGet(this, _LRUCache_keyMap, "f").delete(k);
    __classPrivateFieldSet(this, _LRUCache_size, (_c = __classPrivateFieldGet(this, _LRUCache_size, "f"), _c--, _c), "f");
    return head;
}, _LRUCache_backgroundFetch = function _LRUCache_backgroundFetch(k, index, options2, context) {
    const v = index === void 0 ? void 0 : __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
    if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
        return v;
    }
    const ac = new AC();
    const { signal } = options2;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
    });
    const fetchOpts = {
        signal: ac.signal,
        options: options2,
        context
    };
    const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options2.ignoreFetchAbort && v2 !== void 0;
        if (options2.status) {
            if (aborted && !updateCache) {
                options2.status.fetchAborted = true;
                options2.status.fetchError = ac.signal.reason;
                if (ignoreAbort)
                    options2.status.fetchAbortIgnored = true;
            }
            else {
                options2.status.fetchResolved = true;
            }
        }
        if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (__classPrivateFieldGet(this, _LRUCache_valList, "f")[index] === p) {
            if (v2 === void 0) {
                if (bf2.__staleWhileFetching) {
                    __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = bf2.__staleWhileFetching;
                }
                else {
                    __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, k, "fetch");
                }
            }
            else {
                if (options2.status)
                    options2.status.fetchUpdated = true;
                this.set(k, v2, fetchOpts.options);
            }
        }
        return v2;
    };
    const eb = (er) => {
        if (options2.status) {
            options2.status.fetchRejected = true;
            options2.status.fetchError = er;
        }
        return fetchFail(er);
    };
    const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
        const noDelete = allowStale || options2.noDeleteOnFetchRejection;
        const bf2 = p;
        if (__classPrivateFieldGet(this, _LRUCache_valList, "f")[index] === p) {
            const del2 = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del2) {
                __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_delete).call(this, k, "fetch");
            }
            else if (!allowStaleAborted) {
                __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = bf2.__staleWhileFetching;
            }
        }
        if (allowStale) {
            if (options2.status && bf2.__staleWhileFetching !== void 0) {
                options2.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
        }
        else if (bf2.__returned === bf2) {
            throw er;
        }
    };
    const pcall = (res, rej) => {
        const fmp = __classPrivateFieldGet(this, _LRUCache_fetchMethod, "f")?.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
            if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
                res(void 0);
                if (options2.allowStaleOnFetchAbort) {
                    res = (v2) => cb(v2, true);
                }
            }
        });
    };
    if (options2.status)
        options2.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
    });
    if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
    }
    else {
        __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = bf;
    }
    return bf;
}, _LRUCache_isBackgroundFetch = function _LRUCache_isBackgroundFetch(p) {
    if (!__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f"))
        return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
}, _LRUCache_connect = function _LRUCache_connect(p, n) {
    __classPrivateFieldGet(this, _LRUCache_prev, "f")[n] = p;
    __classPrivateFieldGet(this, _LRUCache_next, "f")[p] = n;
}, _LRUCache_moveToTail = function _LRUCache_moveToTail(index) {
    if (index !== __classPrivateFieldGet(this, _LRUCache_tail, "f")) {
        if (index === __classPrivateFieldGet(this, _LRUCache_head, "f")) {
            __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldGet(this, _LRUCache_next, "f")[index], "f");
        }
        else {
            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_connect).call(this, __classPrivateFieldGet(this, _LRUCache_prev, "f")[index], __classPrivateFieldGet(this, _LRUCache_next, "f")[index]);
        }
        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_connect).call(this, __classPrivateFieldGet(this, _LRUCache_tail, "f"), index);
        __classPrivateFieldSet(this, _LRUCache_tail, index, "f");
    }
}, _LRUCache_delete = function _LRUCache_delete(k, reason) {
    var _c;
    let deleted = false;
    if (__classPrivateFieldGet(this, _LRUCache_size, "f") !== 0) {
        const index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
        if (index !== void 0) {
            deleted = true;
            if (__classPrivateFieldGet(this, _LRUCache_size, "f") === 1) {
                __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_clear).call(this, reason);
            }
            else {
                __classPrivateFieldGet(this, _LRUCache_removeItemSize, "f").call(this, index);
                const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                    v.__abortController.abort(new Error("deleted"));
                }
                else if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f") || __classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                    if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_dispose, "f")?.call(this, v, k, reason);
                    }
                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_disposed, "f")?.push([v, k, reason]);
                    }
                }
                __classPrivateFieldGet(this, _LRUCache_keyMap, "f").delete(k);
                __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index] = void 0;
                __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = void 0;
                if (index === __classPrivateFieldGet(this, _LRUCache_tail, "f")) {
                    __classPrivateFieldSet(this, _LRUCache_tail, __classPrivateFieldGet(this, _LRUCache_prev, "f")[index], "f");
                }
                else if (index === __classPrivateFieldGet(this, _LRUCache_head, "f")) {
                    __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldGet(this, _LRUCache_next, "f")[index], "f");
                }
                else {
                    const pi = __classPrivateFieldGet(this, _LRUCache_prev, "f")[index];
                    __classPrivateFieldGet(this, _LRUCache_next, "f")[pi] = __classPrivateFieldGet(this, _LRUCache_next, "f")[index];
                    const ni = __classPrivateFieldGet(this, _LRUCache_next, "f")[index];
                    __classPrivateFieldGet(this, _LRUCache_prev, "f")[ni] = __classPrivateFieldGet(this, _LRUCache_prev, "f")[index];
                }
                __classPrivateFieldSet(this, _LRUCache_size, (_c = __classPrivateFieldGet(this, _LRUCache_size, "f"), _c--, _c), "f");
                __classPrivateFieldGet(this, _LRUCache_free, "f").push(index);
            }
        }
    }
    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")?.length) {
        const dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
        let task;
        while (task = dt?.shift()) {
            __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")?.call(this, ...task);
        }
    }
    return deleted;
}, _LRUCache_clear = function _LRUCache_clear(reason) {
    for (const index of __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this, { allowStale: true })) {
        const v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
        if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
            v.__abortController.abort(new Error("deleted"));
        }
        else {
            const k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index];
            if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                __classPrivateFieldGet(this, _LRUCache_dispose, "f")?.call(this, v, k, reason);
            }
            if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                __classPrivateFieldGet(this, _LRUCache_disposed, "f")?.push([v, k, reason]);
            }
        }
    }
    __classPrivateFieldGet(this, _LRUCache_keyMap, "f").clear();
    __classPrivateFieldGet(this, _LRUCache_valList, "f").fill(void 0);
    __classPrivateFieldGet(this, _LRUCache_keyList, "f").fill(void 0);
    if (__classPrivateFieldGet(this, _LRUCache_ttls, "f") && __classPrivateFieldGet(this, _LRUCache_starts, "f")) {
        __classPrivateFieldGet(this, _LRUCache_ttls, "f").fill(0);
        __classPrivateFieldGet(this, _LRUCache_starts, "f").fill(0);
    }
    if (__classPrivateFieldGet(this, _LRUCache_sizes, "f")) {
        __classPrivateFieldGet(this, _LRUCache_sizes, "f").fill(0);
    }
    __classPrivateFieldSet(this, _LRUCache_head, 0, "f");
    __classPrivateFieldSet(this, _LRUCache_tail, 0, "f");
    __classPrivateFieldGet(this, _LRUCache_free, "f").length = 0;
    __classPrivateFieldSet(this, _LRUCache_calculatedSize, 0, "f");
    __classPrivateFieldSet(this, _LRUCache_size, 0, "f");
    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")) {
        const dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
        let task;
        while (task = dt?.shift()) {
            __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")?.call(this, ...task);
        }
    }
};
const likePatternCache = new LRUCache({ max: 500 });
function unicodeLike(pattern, value) {
    if (!pattern) {
        return 0;
    }
    if (!value) {
        value = "";
    }
    let cachedRegExp = likePatternCache.get(pattern);
    if (!cachedRegExp) {
        const processedPattern = pattern.replace(/[.*+^${}()|[\]\\]/g, "\\$&").replaceAll("?", ".").replaceAll("%", ".*");
        cachedRegExp = new RegExp(processedPattern, "i");
        likePatternCache.set(pattern, cachedRegExp);
    }
    return cachedRegExp.test(value) ? 1 : 0;
}
function verifyParamTypes(sql, arr) {
    arr.forEach((val2) => {
        if (typeof val2 !== "string" && typeof val2 !== "number" && val2 !== null) {
            console.log(sql, arr);
            throw new Error("Invalid field type " + val2 + " for sql " + sql);
        }
    });
}
async function init$1() {
}
function prepare(db2, sql) {
    return db2.prepare(sql);
}
function runQuery$1(db2, sql, params = [], fetchAll2 = false) {
    if (params) {
        verifyParamTypes(sql, params);
    }
    let stmt;
    try {
        stmt = typeof sql === "string" ? db2.prepare(sql) : sql;
    }
    catch (e) {
        console.log("error", sql);
        throw e;
    }
    if (fetchAll2) {
        try {
            const result = stmt.all(...params);
            return result;
        }
        catch (e) {
            console.log("error", sql);
            throw e;
        }
    }
    else {
        try {
            const info = stmt.run(...params);
            return { changes: info.changes, insertId: info.lastInsertRowid };
        }
        catch (e) {
            throw e;
        }
    }
}
function execQuery$2(db2, sql) {
    db2.exec(sql);
}
function transaction$1(db2, fn) {
    db2.transaction(fn)();
}
let transactionDepth = 0;
async function asyncTransaction$1(db2, fn) {
    if (transactionDepth === 0) {
        db2.exec("BEGIN TRANSACTION");
    }
    transactionDepth++;
    try {
        await fn();
    }
    finally {
        transactionDepth--;
        if (transactionDepth === 0) {
            db2.exec("COMMIT");
        }
    }
}
function regexp(regex2, text) {
    return new RegExp(regex2).test(text || "") ? 1 : 0;
}
function openDatabase$1(pathOrBuffer) {
    const db2 = new SQL(pathOrBuffer);
    db2.function("UNICODE_LOWER", { deterministic: true }, (arg) => arg?.toLowerCase());
    db2.function("UNICODE_UPPER", { deterministic: true }, (arg) => arg?.toUpperCase());
    db2.function("UNICODE_LIKE", { deterministic: true }, unicodeLike);
    db2.function("REGEXP", { deterministic: true }, regexp);
    db2.function("NORMALISE", { deterministic: true }, normalise);
    return db2;
}
function closeDatabase$1(db2) {
    return db2.close();
}
async function exportDatabase(db2) {
    const name = `${process.env.ACTUAL_DATA_DIR}/backup-for-export-${v4()}.db`;
    await db2.backup(name);
    const data = await readFile(name, "binary");
    await removeFile$1(name);
    return data;
}
class Query {
    constructor(state) {
        this.state = {
            tableOptions: state.tableOptions || {},
            filterExpressions: state.filterExpressions || [],
            selectExpressions: state.selectExpressions || [],
            groupExpressions: state.groupExpressions || [],
            orderExpressions: state.orderExpressions || [],
            calculation: false,
            rawMode: false,
            withDead: false,
            validateRefs: true,
            limit: null,
            offset: null,
            ...state
        };
    }
    filter(expr) {
        return new Query({
            ...this.state,
            filterExpressions: [...this.state.filterExpressions, expr]
        });
    }
    unfilter(exprs) {
        if (!exprs) {
            return new Query({
                ...this.state,
                filterExpressions: []
            });
        }
        const exprSet = new Set(exprs);
        return new Query({
            ...this.state,
            filterExpressions: this.state.filterExpressions.filter((expr) => !exprSet.has(Object.keys(expr)[0]))
        });
    }
    select(exprs = []) {
        if (!Array.isArray(exprs)) {
            exprs = [exprs];
        }
        return new Query({
            ...this.state,
            selectExpressions: exprs,
            calculation: false
        });
    }
    calculate(expr) {
        return new Query({
            ...this.state,
            selectExpressions: [{ result: expr }],
            calculation: true
        });
    }
    groupBy(exprs) {
        if (!Array.isArray(exprs)) {
            exprs = [exprs];
        }
        return new Query({
            ...this.state,
            groupExpressions: [...this.state.groupExpressions, ...exprs]
        });
    }
    orderBy(exprs) {
        if (!Array.isArray(exprs)) {
            exprs = [exprs];
        }
        return new Query({
            ...this.state,
            orderExpressions: [...this.state.orderExpressions, ...exprs]
        });
    }
    limit(num2) {
        return new Query({ ...this.state, limit: num2 });
    }
    offset(num2) {
        return new Query({ ...this.state, offset: num2 });
    }
    raw() {
        return new Query({ ...this.state, rawMode: true });
    }
    withDead() {
        return new Query({ ...this.state, withDead: true });
    }
    withoutValidatedRefs() {
        return new Query({ ...this.state, validateRefs: false });
    }
    options(opts) {
        return new Query({ ...this.state, tableOptions: opts });
    }
    reset() {
        return q(this.state.table);
    }
    serialize() {
        return this.state;
    }
    serializeAsString() {
        return JSON.stringify(this.serialize());
    }
}
function q(table) {
    return new Query({ table });
}
const isString$1 = (obj) => typeof obj === "string";
const defer = () => {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
};
const makeString = (object) => {
    if (object == null)
        return "";
    return "" + object;
};
const copy = (a, s, t2) => {
    a.forEach((m) => {
        if (s[m])
            t2[m] = s[m];
    });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString$1(object);
const getLastOfPath = (object, path2, Empty) => {
    const stack = !isString$1(path2) ? path2 : path2.split(".");
    let stackIndex = 0;
    while (stackIndex < stack.length - 1) {
        if (canNotTraverseDeeper(object))
            return {};
        const key = cleanKey(stack[stackIndex]);
        if (!object[key] && Empty)
            object[key] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key)) {
            object = object[key];
        }
        else {
            object = {};
        }
        ++stackIndex;
    }
    if (canNotTraverseDeeper(object))
        return {};
    return {
        obj: object,
        k: cleanKey(stack[stackIndex])
    };
};
const setPath = (object, path2, newValue) => {
    const { obj, k } = getLastOfPath(object, path2, Object);
    if (obj !== void 0 || path2.length === 1) {
        obj[k] = newValue;
        return;
    }
    let e = path2[path2.length - 1];
    let p = path2.slice(0, path2.length - 1);
    let last2 = getLastOfPath(object, p, Object);
    while (last2.obj === void 0 && p.length) {
        e = `${p[p.length - 1]}.${e}`;
        p = p.slice(0, p.length - 1);
        last2 = getLastOfPath(object, p, Object);
        if (last2?.obj && typeof last2.obj[`${last2.k}.${e}`] !== "undefined") {
            last2.obj = void 0;
        }
    }
    last2.obj[`${last2.k}.${e}`] = newValue;
};
const pushPath = (object, path2, newValue, concat) => {
    const { obj, k } = getLastOfPath(object, path2, Object);
    obj[k] = obj[k] || [];
    obj[k].push(newValue);
};
const getPath = (object, path2) => {
    const { obj, k } = getLastOfPath(object, path2);
    if (!obj)
        return void 0;
    if (!Object.prototype.hasOwnProperty.call(obj, k))
        return void 0;
    return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
    const value = getPath(data, key);
    if (value !== void 0) {
        return value;
    }
    return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
    for (const prop in source) {
        if (prop !== "__proto__" && prop !== "constructor") {
            if (prop in target) {
                if (isString$1(target[prop]) || target[prop] instanceof String || isString$1(source[prop]) || source[prop] instanceof String) {
                    if (overwrite)
                        target[prop] = source[prop];
                }
                else {
                    deepExtend(target[prop], source[prop], overwrite);
                }
            }
            else {
                target[prop] = source[prop];
            }
        }
    }
    return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};
const escape$1 = (data) => {
    if (isString$1(data)) {
        return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
    }
    return data;
};
class RegExpCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.regExpMap = /* @__PURE__ */ new Map();
        this.regExpQueue = [];
    }
    getRegExp(pattern) {
        const regExpFromCache = this.regExpMap.get(pattern);
        if (regExpFromCache !== void 0) {
            return regExpFromCache;
        }
        const regExpNew = new RegExp(pattern);
        if (this.regExpQueue.length === this.capacity) {
            this.regExpMap.delete(this.regExpQueue.shift());
        }
        this.regExpMap.set(pattern, regExpNew);
        this.regExpQueue.push(pattern);
        return regExpNew;
    }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
    nsSeparator = nsSeparator || "";
    keySeparator = keySeparator || "";
    const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
    if (possibleChars.length === 0)
        return true;
    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
    let matched = !r.test(key);
    if (!matched) {
        const ki = key.indexOf(keySeparator);
        if (ki > 0 && !r.test(key.substring(0, ki))) {
            matched = true;
        }
    }
    return matched;
};
const deepFind = (obj, path2, keySeparator = ".") => {
    if (!obj)
        return void 0;
    if (obj[path2]) {
        if (!Object.prototype.hasOwnProperty.call(obj, path2))
            return void 0;
        return obj[path2];
    }
    const tokens = path2.split(keySeparator);
    let current = obj;
    for (let i = 0; i < tokens.length;) {
        if (!current || typeof current !== "object") {
            return void 0;
        }
        let next;
        let nextPath = "";
        for (let j = i; j < tokens.length; ++j) {
            if (j !== i) {
                nextPath += keySeparator;
            }
            nextPath += tokens[j];
            next = current[nextPath];
            if (next !== void 0) {
                if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
                    continue;
                }
                i += j - i + 1;
                break;
            }
        }
        current = next;
    }
    return current;
};
const getCleanedCode = (code) => code?.replace("_", "-");
const consoleLogger = {
    type: "logger",
    log(args) {
        this.output("log", args);
    },
    warn(args) {
        this.output("warn", args);
    },
    error(args) {
        this.output("error", args);
    },
    output(type2, args) {
        console?.[type2]?.apply?.(console, args);
    }
};
class Logger {
    constructor(concreteLogger, options2 = {}) {
        this.init(concreteLogger, options2);
    }
    init(concreteLogger, options2 = {}) {
        this.prefix = options2.prefix || "i18next:";
        this.logger = concreteLogger || consoleLogger;
        this.options = options2;
        this.debug = options2.debug;
    }
    log(...args) {
        return this.forward(args, "log", "", true);
    }
    warn(...args) {
        return this.forward(args, "warn", "", true);
    }
    error(...args) {
        return this.forward(args, "error", "");
    }
    deprecate(...args) {
        return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
    forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug)
            return null;
        if (isString$1(args[0]))
            args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
    }
    create(moduleName) {
        return new Logger(this.logger, {
            ...{
                prefix: `${this.prefix}:${moduleName}:`
            },
            ...this.options
        });
    }
    clone(options2) {
        options2 = options2 || this.options;
        options2.prefix = options2.prefix || this.prefix;
        return new Logger(this.logger, options2);
    }
}
var baseLogger = new Logger();
class EventEmitter {
    constructor() {
        this.observers = {};
    }
    on(events, listener) {
        events.split(" ").forEach((event) => {
            if (!this.observers[event])
                this.observers[event] = /* @__PURE__ */ new Map();
            const numListeners = this.observers[event].get(listener) || 0;
            this.observers[event].set(listener, numListeners + 1);
        });
        return this;
    }
    off(event, listener) {
        if (!this.observers[event])
            return;
        if (!listener) {
            delete this.observers[event];
            return;
        }
        this.observers[event].delete(listener);
    }
    emit(event, ...args) {
        if (this.observers[event]) {
            const cloned = Array.from(this.observers[event].entries());
            cloned.forEach(([observer, numTimesAdded]) => {
                for (let i = 0; i < numTimesAdded; i++) {
                    observer(...args);
                }
            });
        }
        if (this.observers["*"]) {
            const cloned = Array.from(this.observers["*"].entries());
            cloned.forEach(([observer, numTimesAdded]) => {
                for (let i = 0; i < numTimesAdded; i++) {
                    observer.apply(observer, [event, ...args]);
                }
            });
        }
    }
}
class ResourceStore extends EventEmitter {
    constructor(data, options2 = {
        ns: ["translation"],
        defaultNS: "translation"
    }) {
        super();
        this.data = data || {};
        this.options = options2;
        if (this.options.keySeparator === void 0) {
            this.options.keySeparator = ".";
        }
        if (this.options.ignoreJSONStructure === void 0) {
            this.options.ignoreJSONStructure = true;
        }
    }
    addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
        }
    }
    removeNamespaces(ns) {
        const index = this.options.ns.indexOf(ns);
        if (index > -1) {
            this.options.ns.splice(index, 1);
        }
    }
    getResource(lng, ns, key, options2 = {}) {
        const keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path2;
        if (lng.indexOf(".") > -1) {
            path2 = lng.split(".");
        }
        else {
            path2 = [lng, ns];
            if (key) {
                if (Array.isArray(key)) {
                    path2.push(...key);
                }
                else if (isString$1(key) && keySeparator) {
                    path2.push(...key.split(keySeparator));
                }
                else {
                    path2.push(key);
                }
            }
        }
        const result = getPath(this.data, path2);
        if (!result && !ns && !key && lng.indexOf(".") > -1) {
            lng = path2[0];
            ns = path2[1];
            key = path2.slice(2).join(".");
        }
        if (result || !ignoreJSONStructure || !isString$1(key))
            return result;
        return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
    }
    addResource(lng, ns, key, value, options2 = {
        silent: false
    }) {
        const keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
        let path2 = [lng, ns];
        if (key)
            path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf(".") > -1) {
            path2 = lng.split(".");
            value = ns;
            ns = path2[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path2, value);
        if (!options2.silent)
            this.emit("added", lng, ns, key, value);
    }
    addResources(lng, ns, resources, options2 = {
        silent: false
    }) {
        for (const m in resources) {
            if (isString$1(resources[m]) || Array.isArray(resources[m]))
                this.addResource(lng, ns, m, resources[m], {
                    silent: true
                });
        }
        if (!options2.silent)
            this.emit("added", lng, ns, resources);
    }
    addResourceBundle(lng, ns, resources, deep, overwrite, options2 = {
        silent: false,
        skipCopy: false
    }) {
        let path2 = [lng, ns];
        if (lng.indexOf(".") > -1) {
            path2 = lng.split(".");
            deep = resources;
            resources = ns;
            ns = path2[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path2) || {};
        if (!options2.skipCopy)
            resources = JSON.parse(JSON.stringify(resources));
        if (deep) {
            deepExtend(pack, resources, overwrite);
        }
        else {
            pack = {
                ...pack,
                ...resources
            };
        }
        setPath(this.data, path2, pack);
        if (!options2.silent)
            this.emit("added", lng, ns, resources);
    }
    removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit("removed", lng, ns);
    }
    hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== void 0;
    }
    getResourceBundle(lng, ns) {
        if (!ns)
            ns = this.options.defaultNS;
        return this.getResource(lng, ns);
    }
    getDataByLanguage(lng) {
        return this.data[lng];
    }
    hasLanguageSomeTranslations(lng) {
        const data = this.getDataByLanguage(lng);
        const n = data && Object.keys(data) || [];
        return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
    }
    toJSON() {
        return this.data;
    }
}
var postProcessor = {
    processors: {},
    addPostProcessor(module2) {
        this.processors[module2.name] = module2;
    },
    handle(processors2, value, key, options2, translator) {
        processors2.forEach((processor) => {
            value = this.processors[processor]?.process(value, key, options2, translator) ?? value;
        });
        return value;
    }
};
const checkedLoadedFor = {};
const shouldHandleAsObject = (res) => !isString$1(res) && typeof res !== "boolean" && typeof res !== "number";
class Translator extends EventEmitter {
    constructor(services, options2 = {}) {
        super();
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
        this.options = options2;
        if (this.options.keySeparator === void 0) {
            this.options.keySeparator = ".";
        }
        this.logger = baseLogger.create("translator");
    }
    changeLanguage(lng) {
        if (lng)
            this.language = lng;
    }
    exists(key, o = {
        interpolation: {}
    }) {
        const opt = {
            ...o
        };
        if (key == null)
            return false;
        const resolved = this.resolve(key, opt);
        return resolved?.res !== void 0;
    }
    extractFromKey(key, opt) {
        let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0)
            nsSeparator = ":";
        const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
        let namespaces = opt.ns || this.options.defaultNS || [];
        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
            const m = key.match(this.interpolator.nestingRegexp);
            if (m && m.length > 0) {
                return {
                    key,
                    namespaces: isString$1(namespaces) ? [namespaces] : namespaces
                };
            }
            const parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
                namespaces = parts.shift();
            key = parts.join(keySeparator);
        }
        return {
            key,
            namespaces: isString$1(namespaces) ? [namespaces] : namespaces
        };
    }
    translate(keys2, o, lastKey) {
        let opt = typeof o === "object" ? {
            ...o
        } : o;
        if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
            opt = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (typeof options === "object")
            opt = {
                ...opt
            };
        if (!opt)
            opt = {};
        if (keys2 == null)
            return "";
        if (!Array.isArray(keys2))
            keys2 = [String(keys2)];
        const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
        const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
        const { key, namespaces } = this.extractFromKey(keys2[keys2.length - 1], opt);
        const namespace = namespaces[namespaces.length - 1];
        let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0)
            nsSeparator = ":";
        const lng = opt.lng || this.language;
        const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng?.toLowerCase() === "cimode") {
            if (appendNamespaceToCIMode) {
                if (returnDetails) {
                    return {
                        res: `${namespace}${nsSeparator}${key}`,
                        usedKey: key,
                        exactUsedKey: key,
                        usedLng: lng,
                        usedNS: namespace,
                        usedParams: this.getUsedParamsDetails(opt)
                    };
                }
                return `${namespace}${nsSeparator}${key}`;
            }
            if (returnDetails) {
                return {
                    res: key,
                    usedKey: key,
                    exactUsedKey: key,
                    usedLng: lng,
                    usedNS: namespace,
                    usedParams: this.getUsedParamsDetails(opt)
                };
            }
            return key;
        }
        const resolved = this.resolve(keys2, opt);
        let res = resolved?.res;
        const resUsedKey = resolved?.usedKey || key;
        const resExactUsedKey = resolved?.exactUsedKey || key;
        const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
        const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const needsPluralHandling = opt.count !== void 0 && !isString$1(opt.count);
        const hasDefaultValue = Translator.hasDefaultValue(opt);
        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
        const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
            ordinal: false
        }) : "";
        const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
        const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
        let resForObjHndl = res;
        if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
            resForObjHndl = defaultValue;
        }
        const handleAsObject = shouldHandleAsObject(resForObjHndl);
        const resType = Object.prototype.toString.apply(resForObjHndl);
        if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(resForObjHndl))) {
            if (!opt.returnObjects && !this.options.returnObjects) {
                if (!this.options.returnedObjectHandler) {
                    this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                }
                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
                    ...opt,
                    ns: namespaces
                }) : `key '${key} (${this.language})' returned an object instead of string.`;
                if (returnDetails) {
                    resolved.res = r;
                    resolved.usedParams = this.getUsedParamsDetails(opt);
                    return resolved;
                }
                return r;
            }
            if (keySeparator) {
                const resTypeIsArray = Array.isArray(resForObjHndl);
                const copy2 = resTypeIsArray ? [] : {};
                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                for (const m in resForObjHndl) {
                    if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;
                        if (hasDefaultValue && !res) {
                            copy2[m] = this.translate(deepKey, {
                                ...opt,
                                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : void 0,
                                ...{
                                    joinArrays: false,
                                    ns: namespaces
                                }
                            });
                        }
                        else {
                            copy2[m] = this.translate(deepKey, {
                                ...opt,
                                ...{
                                    joinArrays: false,
                                    ns: namespaces
                                }
                            });
                        }
                        if (copy2[m] === deepKey)
                            copy2[m] = resForObjHndl[m];
                    }
                }
                res = copy2;
            }
        }
        else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
            res = res.join(joinArrays);
            if (res)
                res = this.extendTranslation(res, keys2, opt, lastKey);
        }
        else {
            let usedDefault = false;
            let usedKey = false;
            if (!this.isValidLookup(res) && hasDefaultValue) {
                usedDefault = true;
                res = defaultValue;
            }
            if (!this.isValidLookup(res)) {
                usedKey = true;
                res = key;
            }
            const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
                this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
                if (keySeparator) {
                    const fk = this.resolve(key, {
                        ...opt,
                        keySeparator: false
                    });
                    if (fk && fk.res)
                        this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
                }
                let lngs = [];
                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
                if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
                    for (let i = 0; i < fallbackLngs.length; i++) {
                        lngs.push(fallbackLngs[i]);
                    }
                }
                else if (this.options.saveMissingTo === "all") {
                    lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
                }
                else {
                    lngs.push(opt.lng || this.language);
                }
                const send2 = (l, k, specificDefaultValue) => {
                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                    if (this.options.missingKeyHandler) {
                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);
                    }
                    else if (this.backendConnector?.saveMissing) {
                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);
                    }
                    this.emit("missingKey", l, namespace, k, res);
                };
                if (this.options.saveMissing) {
                    if (this.options.saveMissingPlurals && needsPluralHandling) {
                        lngs.forEach((language) => {
                            const suffixes2 = this.pluralResolver.getSuffixes(language, opt);
                            if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes2.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                                suffixes2.push(`${this.options.pluralSeparator}zero`);
                            }
                            suffixes2.forEach((suffix) => {
                                send2([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
                            });
                        });
                    }
                    else {
                        send2(lngs, key, defaultValue);
                    }
                }
            }
            res = this.extendTranslation(res, keys2, opt, resolved, lastKey);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
                res = `${namespace}${nsSeparator}${key}`;
            }
            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
                res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
            }
        }
        if (returnDetails) {
            resolved.res = res;
            resolved.usedParams = this.getUsedParamsDetails(opt);
            return resolved;
        }
        return res;
    }
    extendTranslation(res, key, opt, resolved, lastKey) {
        if (this.i18nFormat?.parse) {
            res = this.i18nFormat.parse(res, {
                ...this.options.interpolation.defaultVariables,
                ...opt
            }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                resolved
            });
        }
        else if (!opt.skipInterpolation) {
            if (opt.interpolation)
                this.interpolator.init({
                    ...opt,
                    ...{
                        interpolation: {
                            ...this.options.interpolation,
                            ...opt.interpolation
                        }
                    }
                });
            const skipOnVariables = isString$1(res) && (opt?.interpolation?.skipOnVariables !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            let nestBef;
            if (skipOnVariables) {
                const nb2 = res.match(this.interpolator.nestingRegexp);
                nestBef = nb2 && nb2.length;
            }
            let data = opt.replace && !isString$1(opt.replace) ? opt.replace : opt;
            if (this.options.interpolation.defaultVariables)
                data = {
                    ...this.options.interpolation.defaultVariables,
                    ...data
                };
            res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
            if (skipOnVariables) {
                const na = res.match(this.interpolator.nestingRegexp);
                const nestAft = na && na.length;
                if (nestBef < nestAft)
                    opt.nest = false;
            }
            if (!opt.lng && resolved && resolved.res)
                opt.lng = this.language || resolved.usedLng;
            if (opt.nest !== false)
                res = this.interpolator.nest(res, (...args) => {
                    if (lastKey?.[0] === args[0] && !opt.context) {
                        this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
                        return null;
                    }
                    return this.translate(...args, key);
                }, opt);
            if (opt.interpolation)
                this.interpolator.reset();
        }
        const postProcess = opt.postProcess || this.options.postProcess;
        const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
        if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
                i18nResolved: {
                    ...resolved,
                    usedParams: this.getUsedParamsDetails(opt)
                },
                ...opt
            } : opt, this);
        }
        return res;
    }
    resolve(keys2, opt = {}) {
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (isString$1(keys2))
            keys2 = [keys2];
        keys2.forEach((k) => {
            if (this.isValidLookup(found))
                return;
            const extracted = this.extractFromKey(k, opt);
            const key = extracted.key;
            usedKey = key;
            let namespaces = extracted.namespaces;
            if (this.options.fallbackNS)
                namespaces = namespaces.concat(this.options.fallbackNS);
            const needsPluralHandling = opt.count !== void 0 && !isString$1(opt.count);
            const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
            const needsContextHandling = opt.context !== void 0 && (isString$1(opt.context) || typeof opt.context === "number") && opt.context !== "";
            const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
            namespaces.forEach((ns) => {
                if (this.isValidLookup(found))
                    return;
                usedNS = ns;
                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;
                    this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
                }
                codes.forEach((code) => {
                    if (this.isValidLookup(found))
                        return;
                    usedLng = code;
                    const finalKeys = [key];
                    if (this.i18nFormat?.addLookupKeys) {
                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
                    }
                    else {
                        let pluralSuffix;
                        if (needsPluralHandling)
                            pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
                        const zeroSuffix = `${this.options.pluralSeparator}zero`;
                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                        if (needsPluralHandling) {
                            finalKeys.push(key + pluralSuffix);
                            if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                            }
                            if (needsZeroSuffixLookup) {
                                finalKeys.push(key + zeroSuffix);
                            }
                        }
                        if (needsContextHandling) {
                            const contextKey = `${key}${this.options.contextSeparator}${opt.context}`;
                            finalKeys.push(contextKey);
                            if (needsPluralHandling) {
                                finalKeys.push(contextKey + pluralSuffix);
                                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                                }
                                if (needsZeroSuffixLookup) {
                                    finalKeys.push(contextKey + zeroSuffix);
                                }
                            }
                        }
                    }
                    let possibleKey;
                    while (possibleKey = finalKeys.pop()) {
                        if (!this.isValidLookup(found)) {
                            exactUsedKey = possibleKey;
                            found = this.getResource(code, ns, possibleKey, opt);
                        }
                    }
                });
            });
        });
        return {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
        };
    }
    isValidLookup(res) {
        return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
    getResource(code, ns, key, options2 = {}) {
        if (this.i18nFormat?.getResource)
            return this.i18nFormat.getResource(code, ns, key, options2);
        return this.resourceStore.getResource(code, ns, key, options2);
    }
    getUsedParamsDetails(options2 = {}) {
        const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
        const useOptionsReplaceForData = options2.replace && !isString$1(options2.replace);
        let data = useOptionsReplaceForData ? options2.replace : options2;
        if (useOptionsReplaceForData && typeof options2.count !== "undefined") {
            data.count = options2.count;
        }
        if (this.options.interpolation.defaultVariables) {
            data = {
                ...this.options.interpolation.defaultVariables,
                ...data
            };
        }
        if (!useOptionsReplaceForData) {
            data = {
                ...data
            };
            for (const key of optionsKeys) {
                delete data[key];
            }
        }
        return data;
    }
    static hasDefaultValue(options2) {
        const prefix = "defaultValue";
        for (const option in options2) {
            if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && void 0 !== options2[option]) {
                return true;
            }
        }
        return false;
    }
}
class LanguageUtil {
    constructor(options2) {
        this.options = options2;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger.create("languageUtils");
    }
    getScriptPartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf("-") < 0)
            return null;
        const p = code.split("-");
        if (p.length === 2)
            return null;
        p.pop();
        if (p[p.length - 1].toLowerCase() === "x")
            return null;
        return this.formatLanguageCode(p.join("-"));
    }
    getLanguagePartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf("-") < 0)
            return code;
        const p = code.split("-");
        return this.formatLanguageCode(p[0]);
    }
    formatLanguageCode(code) {
        if (isString$1(code) && code.indexOf("-") > -1) {
            let formattedCode;
            try {
                formattedCode = Intl.getCanonicalLocales(code)[0];
            }
            catch (e) {
            }
            if (formattedCode && this.options.lowerCaseLng) {
                formattedCode = formattedCode.toLowerCase();
            }
            if (formattedCode)
                return formattedCode;
            if (this.options.lowerCaseLng) {
                return code.toLowerCase();
            }
            return code;
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
    isSupportedCode(code) {
        if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
            code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
    getBestMatchFromCodes(codes) {
        if (!codes)
            return null;
        let found;
        codes.forEach((code) => {
            if (found)
                return;
            const cleanedLng = this.formatLanguageCode(code);
            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
                found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
            codes.forEach((code) => {
                if (found)
                    return;
                const lngScOnly = this.getScriptPartFromCode(code);
                if (this.isSupportedCode(lngScOnly))
                    return found = lngScOnly;
                const lngOnly = this.getLanguagePartFromCode(code);
                if (this.isSupportedCode(lngOnly))
                    return found = lngOnly;
                found = this.options.supportedLngs.find((supportedLng) => {
                    if (supportedLng === lngOnly)
                        return supportedLng;
                    if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
                        return;
                    if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly)
                        return supportedLng;
                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1)
                        return supportedLng;
                });
            });
        }
        if (!found)
            found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
    }
    getFallbackCodes(fallbacks, code) {
        if (!fallbacks)
            return [];
        if (typeof fallbacks === "function")
            fallbacks = fallbacks(code);
        if (isString$1(fallbacks))
            fallbacks = [fallbacks];
        if (Array.isArray(fallbacks))
            return fallbacks;
        if (!code)
            return fallbacks.default || [];
        let found = fallbacks[code];
        if (!found)
            found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found)
            found = fallbacks[this.formatLanguageCode(code)];
        if (!found)
            found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found)
            found = fallbacks.default;
        return found || [];
    }
    toResolveHierarchy(code, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
        const codes = [];
        const addCode = (c) => {
            if (!c)
                return;
            if (this.isSupportedCode(c)) {
                codes.push(c);
            }
            else {
                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
            }
        };
        if (isString$1(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
            if (this.options.load !== "languageOnly")
                addCode(this.formatLanguageCode(code));
            if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
                addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== "currentOnly")
                addCode(this.getLanguagePartFromCode(code));
        }
        else if (isString$1(code)) {
            addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach((fc) => {
            if (codes.indexOf(fc) < 0)
                addCode(this.formatLanguageCode(fc));
        });
        return codes;
    }
}
const suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
};
const dummyRule = {
    select: (count) => count === 1 ? "one" : "other",
    resolvedOptions: () => ({
        pluralCategories: ["one", "other"]
    })
};
class PluralResolver {
    constructor(languageUtils, options2 = {}) {
        this.languageUtils = languageUtils;
        this.options = options2;
        this.logger = baseLogger.create("pluralResolver");
        this.pluralRulesCache = {};
    }
    addRule(lng, obj) {
        this.rules[lng] = obj;
    }
    clearCache() {
        this.pluralRulesCache = {};
    }
    getRule(code, options2 = {}) {
        const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
        const type2 = options2.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
            cleanedCode,
            type: type2
        });
        if (cacheKey in this.pluralRulesCache) {
            return this.pluralRulesCache[cacheKey];
        }
        let rule;
        try {
            rule = new Intl.PluralRules(cleanedCode, {
                type: type2
            });
        }
        catch (err) {
            if (!Intl) {
                this.logger.error("No Intl support, please use an Intl polyfill!");
                return dummyRule;
            }
            if (!code.match(/-|_/))
                return dummyRule;
            const lngPart = this.languageUtils.getLanguagePartFromCode(code);
            rule = this.getRule(lngPart, options2);
        }
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
    }
    needsPlural(code, options2 = {}) {
        let rule = this.getRule(code, options2);
        if (!rule)
            rule = this.getRule("dev", options2);
        return rule?.resolvedOptions().pluralCategories.length > 1;
    }
    getPluralFormsOfKey(code, key, options2 = {}) {
        return this.getSuffixes(code, options2).map((suffix) => `${key}${suffix}`);
    }
    getSuffixes(code, options2 = {}) {
        let rule = this.getRule(code, options2);
        if (!rule)
            rule = this.getRule("dev", options2);
        if (!rule)
            return [];
        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options2.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    getSuffix(code, count, options2 = {}) {
        const rule = this.getRule(code, options2);
        if (rule) {
            return `${this.options.prepend}${options2.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
        }
        this.logger.warn(`no plural rule found for: ${code}`);
        return this.getSuffix("dev", count, options2);
    }
}
const deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
    let path2 = getPathWithDefaults(data, defaultData, key);
    if (!path2 && ignoreJSONStructure && isString$1(key)) {
        path2 = deepFind(data, key, keySeparator);
        if (path2 === void 0)
            path2 = deepFind(defaultData, key, keySeparator);
    }
    return path2;
};
const regexSafe = (val2) => val2.replace(/\$/g, "$$$$");
class Interpolator {
    constructor(options2 = {}) {
        this.logger = baseLogger.create("interpolator");
        this.options = options2;
        this.format = options2?.interpolation?.format || ((value) => value);
        this.init(options2);
    }
    init(options2 = {}) {
        if (!options2.interpolation)
            options2.interpolation = {
                escapeValue: true
            };
        const { escape: escape$1$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options2.interpolation;
        this.escape = escape$1$1 !== void 0 ? escape$1$1 : escape$1;
        this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
        this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
        this.formatSeparator = formatSeparator || ",";
        this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
        this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
        this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
        this.maxReplaces = maxReplaces || 1e3;
        this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
        this.resetRegExp();
    }
    reset() {
        if (this.options)
            this.init(this.options);
    }
    resetRegExp() {
        const getOrResetRegExp = (existingRegExp, pattern) => {
            if (existingRegExp?.source === pattern) {
                existingRegExp.lastIndex = 0;
                return existingRegExp;
            }
            return new RegExp(pattern, "g");
        };
        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
    }
    interpolate(str, data, lng, options2) {
        let match2;
        let value;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        const handleFormat = (key) => {
            if (key.indexOf(this.formatSeparator) < 0) {
                const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
                return this.alwaysFormat ? this.format(path2, void 0, lng, {
                    ...options2,
                    ...data,
                    interpolationkey: key
                }) : path2;
            }
            const p = key.split(this.formatSeparator);
            const k = p.shift().trim();
            const f2 = p.join(this.formatSeparator).trim();
            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
                ...options2,
                ...data,
                interpolationkey: k
            });
        };
        this.resetRegExp();
        const missingInterpolationHandler = options2?.missingInterpolationHandler || this.options.missingInterpolationHandler;
        const skipOnVariables = options2?.interpolation?.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        const todos = [{
                regex: this.regexpUnescape,
                safeValue: (val2) => regexSafe(val2)
            }, {
                regex: this.regexp,
                safeValue: (val2) => this.escapeValue ? regexSafe(this.escape(val2)) : regexSafe(val2)
            }];
        todos.forEach((todo) => {
            replaces = 0;
            while (match2 = todo.regex.exec(str)) {
                const matchedVar = match2[1].trim();
                value = handleFormat(matchedVar);
                if (value === void 0) {
                    if (typeof missingInterpolationHandler === "function") {
                        const temp = missingInterpolationHandler(str, match2, options2);
                        value = isString$1(temp) ? temp : "";
                    }
                    else if (options2 && Object.prototype.hasOwnProperty.call(options2, matchedVar)) {
                        value = "";
                    }
                    else if (skipOnVariables) {
                        value = match2[0];
                        continue;
                    }
                    else {
                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
                        value = "";
                    }
                }
                else if (!isString$1(value) && !this.useRawValueToEscape) {
                    value = makeString(value);
                }
                const safeValue = todo.safeValue(value);
                str = str.replace(match2[0], safeValue);
                if (skipOnVariables) {
                    todo.regex.lastIndex += value.length;
                    todo.regex.lastIndex -= match2[0].length;
                }
                else {
                    todo.regex.lastIndex = 0;
                }
                replaces++;
                if (replaces >= this.maxReplaces) {
                    break;
                }
            }
        });
        return str;
    }
    nest(str, fc, options2 = {}) {
        let match2;
        let value;
        let clonedOptions;
        const handleHasOptions = (key, inheritedOptions) => {
            const sep = this.nestingOptionsSeparator;
            if (key.indexOf(sep) < 0)
                return key;
            const c = key.split(new RegExp(`${sep}[ ]*{`));
            let optionsString = `{${c[1]}`;
            key = c[0];
            optionsString = this.interpolate(optionsString, clonedOptions);
            const matchedSingleQuotes = optionsString.match(/'/g);
            const matchedDoubleQuotes = optionsString.match(/"/g);
            if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
                optionsString = optionsString.replace(/'/g, '"');
            }
            try {
                clonedOptions = JSON.parse(optionsString);
                if (inheritedOptions)
                    clonedOptions = {
                        ...inheritedOptions,
                        ...clonedOptions
                    };
            }
            catch (e) {
                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
                return `${key}${sep}${optionsString}`;
            }
            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1)
                delete clonedOptions.defaultValue;
            return key;
        };
        while (match2 = this.nestingRegexp.exec(str)) {
            let formatters2 = [];
            clonedOptions = {
                ...options2
            };
            clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
            clonedOptions.applyPostProcessor = false;
            delete clonedOptions.defaultValue;
            let doReduce = false;
            if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
                const r = match2[1].split(this.formatSeparator).map((elem) => elem.trim());
                match2[1] = r.shift();
                formatters2 = r;
                doReduce = true;
            }
            value = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
            if (value && match2[0] === str && !isString$1(value))
                return value;
            if (!isString$1(value))
                value = makeString(value);
            if (!value) {
                this.logger.warn(`missed to resolve ${match2[1]} for nesting ${str}`);
                value = "";
            }
            if (doReduce) {
                value = formatters2.reduce((v, f2) => this.format(v, f2, options2.lng, {
                    ...options2,
                    interpolationkey: match2[1].trim()
                }), value.trim());
            }
            str = str.replace(match2[0], value);
            this.regexp.lastIndex = 0;
        }
        return str;
    }
}
const parseFormatStr = (formatStr) => {
    let formatName = formatStr.toLowerCase().trim();
    const formatOptions = {};
    if (formatStr.indexOf("(") > -1) {
        const p = formatStr.split("(");
        formatName = p[0].toLowerCase().trim();
        const optStr = p[1].substring(0, p[1].length - 1);
        if (formatName === "currency" && optStr.indexOf(":") < 0) {
            if (!formatOptions.currency)
                formatOptions.currency = optStr.trim();
        }
        else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
            if (!formatOptions.range)
                formatOptions.range = optStr.trim();
        }
        else {
            const opts = optStr.split(";");
            opts.forEach((opt) => {
                if (opt) {
                    const [key, ...rest] = opt.split(":");
                    const val2 = rest.join(":").trim().replace(/^'+|'+$/g, "");
                    const trimmedKey = key.trim();
                    if (!formatOptions[trimmedKey])
                        formatOptions[trimmedKey] = val2;
                    if (val2 === "false")
                        formatOptions[trimmedKey] = false;
                    if (val2 === "true")
                        formatOptions[trimmedKey] = true;
                    if (!isNaN(val2))
                        formatOptions[trimmedKey] = parseInt(val2, 10);
                }
            });
        }
    }
    return {
        formatName,
        formatOptions
    };
};
const createCachedFormatter = (fn) => {
    const cache2 = {};
    return (v, l, o) => {
        let optForCache = o;
        if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
            optForCache = {
                ...optForCache,
                [o.interpolationkey]: void 0
            };
        }
        const key = l + JSON.stringify(optForCache);
        let frm = cache2[key];
        if (!frm) {
            frm = fn(getCleanedCode(l), o);
            cache2[key] = frm;
        }
        return frm(v);
    };
};
const createNonCachedFormatter = (fn) => (v, l, o) => fn(getCleanedCode(l), o)(v);
class Formatter {
    constructor(options2 = {}) {
        this.logger = baseLogger.create("formatter");
        this.options = options2;
        this.init(options2);
    }
    init(services, options2 = {
        interpolation: {}
    }) {
        this.formatSeparator = options2.interpolation.formatSeparator || ",";
        const cf = options2.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
        this.formats = {
            number: cf((lng, opt) => {
                const formatter = new Intl.NumberFormat(lng, {
                    ...opt
                });
                return (val2) => formatter.format(val2);
            }),
            currency: cf((lng, opt) => {
                const formatter = new Intl.NumberFormat(lng, {
                    ...opt,
                    style: "currency"
                });
                return (val2) => formatter.format(val2);
            }),
            datetime: cf((lng, opt) => {
                const formatter = new Intl.DateTimeFormat(lng, {
                    ...opt
                });
                return (val2) => formatter.format(val2);
            }),
            relativetime: cf((lng, opt) => {
                const formatter = new Intl.RelativeTimeFormat(lng, {
                    ...opt
                });
                return (val2) => formatter.format(val2, opt.range || "day");
            }),
            list: cf((lng, opt) => {
                const formatter = new Intl.ListFormat(lng, {
                    ...opt
                });
                return (val2) => formatter.format(val2);
            })
        };
    }
    add(name, fc) {
        this.formats[name.toLowerCase().trim()] = fc;
    }
    addCached(name, fc) {
        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
    format(value, format2, lng, options2 = {}) {
        const formats = format2.split(this.formatSeparator);
        if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
            const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
            formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
        }
        const result = formats.reduce((mem, f2) => {
            const { formatName, formatOptions } = parseFormatStr(f2);
            if (this.formats[formatName]) {
                let formatted = mem;
                try {
                    const valOptions = options2?.formatParams?.[options2.interpolationkey] || {};
                    const l = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
                    formatted = this.formats[formatName](mem, l, {
                        ...formatOptions,
                        ...options2,
                        ...valOptions
                    });
                }
                catch (error) {
                    this.logger.warn(error);
                }
                return formatted;
            }
            else {
                this.logger.warn(`there was no format function for ${formatName}`);
            }
            return mem;
        }, value);
        return result;
    }
}
const removePending = (q2, name) => {
    if (q2.pending[name] !== void 0) {
        delete q2.pending[name];
        q2.pendingCount--;
    }
};
class Connector extends EventEmitter {
    constructor(backend, store2, services, options2 = {}) {
        super();
        this.backend = backend;
        this.store = store2;
        this.services = services;
        this.languageUtils = services.languageUtils;
        this.options = options2;
        this.logger = baseLogger.create("backendConnector");
        this.waitingReads = [];
        this.maxParallelReads = options2.maxParallelReads || 10;
        this.readingCalls = 0;
        this.maxRetries = options2.maxRetries >= 0 ? options2.maxRetries : 5;
        this.retryTimeout = options2.retryTimeout >= 1 ? options2.retryTimeout : 350;
        this.state = {};
        this.queue = [];
        this.backend?.init?.(services, options2.backend, options2);
    }
    queueLoad(languages, namespaces, options2, callback) {
        const toLoad = {};
        const pending = {};
        const toLoadLanguages = {};
        const toLoadNamespaces = {};
        languages.forEach((lng) => {
            let hasAllNamespaces = true;
            namespaces.forEach((ns) => {
                const name = `${lng}|${ns}`;
                if (!options2.reload && this.store.hasResourceBundle(lng, ns)) {
                    this.state[name] = 2;
                }
                else if (this.state[name] < 0)
                    ;
                else if (this.state[name] === 1) {
                    if (pending[name] === void 0)
                        pending[name] = true;
                }
                else {
                    this.state[name] = 1;
                    hasAllNamespaces = false;
                    if (pending[name] === void 0)
                        pending[name] = true;
                    if (toLoad[name] === void 0)
                        toLoad[name] = true;
                    if (toLoadNamespaces[ns] === void 0)
                        toLoadNamespaces[ns] = true;
                }
            });
            if (!hasAllNamespaces)
                toLoadLanguages[lng] = true;
        });
        if (Object.keys(toLoad).length || Object.keys(pending).length) {
            this.queue.push({
                pending,
                pendingCount: Object.keys(pending).length,
                loaded: {},
                errors: [],
                callback
            });
        }
        return {
            toLoad: Object.keys(toLoad),
            pending: Object.keys(pending),
            toLoadLanguages: Object.keys(toLoadLanguages),
            toLoadNamespaces: Object.keys(toLoadNamespaces)
        };
    }
    loaded(name, err, data) {
        const s = name.split("|");
        const lng = s[0];
        const ns = s[1];
        if (err)
            this.emit("failedLoading", lng, ns, err);
        if (!err && data) {
            this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
                skipCopy: true
            });
        }
        this.state[name] = err ? -1 : 2;
        if (err && data)
            this.state[name] = 0;
        const loaded = {};
        this.queue.forEach((q2) => {
            pushPath(q2.loaded, [lng], ns);
            removePending(q2, name);
            if (err)
                q2.errors.push(err);
            if (q2.pendingCount === 0 && !q2.done) {
                Object.keys(q2.loaded).forEach((l) => {
                    if (!loaded[l])
                        loaded[l] = {};
                    const loadedKeys = q2.loaded[l];
                    if (loadedKeys.length) {
                        loadedKeys.forEach((n) => {
                            if (loaded[l][n] === void 0)
                                loaded[l][n] = true;
                        });
                    }
                });
                q2.done = true;
                if (q2.errors.length) {
                    q2.callback(q2.errors);
                }
                else {
                    q2.callback();
                }
            }
        });
        this.emit("loaded", loaded);
        this.queue = this.queue.filter((q2) => !q2.done);
    }
    read(lng, ns, fcName, tried = 0, wait2 = this.retryTimeout, callback) {
        if (!lng.length)
            return callback(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng,
                ns,
                fcName,
                tried,
                wait: wait2,
                callback
            });
            return;
        }
        this.readingCalls++;
        const resolver = (err, data) => {
            this.readingCalls--;
            if (this.waitingReads.length > 0) {
                const next = this.waitingReads.shift();
                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
            }
            if (err && data && tried < this.maxRetries) {
                setTimeout(() => {
                    this.read.call(this, lng, ns, fcName, tried + 1, wait2 * 2, callback);
                }, wait2);
                return;
            }
            callback(err, data);
        };
        const fc = this.backend[fcName].bind(this.backend);
        if (fc.length === 2) {
            try {
                const r = fc(lng, ns);
                if (r && typeof r.then === "function") {
                    r.then((data) => resolver(null, data)).catch(resolver);
                }
                else {
                    resolver(null, r);
                }
            }
            catch (err) {
                resolver(err);
            }
            return;
        }
        return fc(lng, ns, resolver);
    }
    prepareLoading(languages, namespaces, options2 = {}, callback) {
        if (!this.backend) {
            this.logger.warn("No backend was added via i18next.use. Will not load resources.");
            return callback && callback();
        }
        if (isString$1(languages))
            languages = this.languageUtils.toResolveHierarchy(languages);
        if (isString$1(namespaces))
            namespaces = [namespaces];
        const toLoad = this.queueLoad(languages, namespaces, options2, callback);
        if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length)
                callback();
            return null;
        }
        toLoad.toLoad.forEach((name) => {
            this.loadOne(name);
        });
    }
    load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
    }
    reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
            reload: true
        }, callback);
    }
    loadOne(name, prefix = "") {
        const s = name.split("|");
        const lng = s[0];
        const ns = s[1];
        this.read(lng, ns, "read", void 0, void 0, (err, data) => {
            if (err)
                this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
            if (!err && data)
                this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
            this.loaded(name, err, data);
        });
    }
    saveMissing(languages, namespace, key, fallbackValue, isUpdate, options2 = {}, clb = () => {
    }) {
        if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
            this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return;
        }
        if (key === void 0 || key === null || key === "")
            return;
        if (this.backend?.create) {
            const opts = {
                ...options2,
                isUpdate
            };
            const fc = this.backend.create.bind(this.backend);
            if (fc.length < 6) {
                try {
                    let r;
                    if (fc.length === 5) {
                        r = fc(languages, namespace, key, fallbackValue, opts);
                    }
                    else {
                        r = fc(languages, namespace, key, fallbackValue);
                    }
                    if (r && typeof r.then === "function") {
                        r.then((data) => clb(null, data)).catch(clb);
                    }
                    else {
                        clb(null, r);
                    }
                }
                catch (err) {
                    clb(err);
                }
            }
            else {
                fc(languages, namespace, key, fallbackValue, clb, opts);
            }
        }
        if (!languages || !languages[0])
            return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
}
const get$4 = () => ({
    debug: false,
    initAsync: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: (args) => {
        let ret = {};
        if (typeof args[1] === "object")
            ret = args[1];
        if (isString$1(args[1]))
            ret.defaultValue = args[1];
        if (isString$1(args[2]))
            ret.tDescription = args[2];
        if (typeof args[2] === "object" || typeof args[3] === "object") {
            const options2 = args[3] || args[2];
            Object.keys(options2).forEach((key) => {
                ret[key] = options2[key];
            });
        }
        return ret;
    },
    interpolation: {
        escapeValue: true,
        format: (value) => value,
        prefix: "{{",
        suffix: "}}",
        formatSeparator: ",",
        unescapePrefix: "-",
        nestingPrefix: "$t(",
        nestingSuffix: ")",
        nestingOptionsSeparator: ",",
        maxReplaces: 1e3,
        skipOnVariables: true
    },
    cacheInBuiltFormats: true
});
const transformOptions = (options2) => {
    if (isString$1(options2.ns))
        options2.ns = [options2.ns];
    if (isString$1(options2.fallbackLng))
        options2.fallbackLng = [options2.fallbackLng];
    if (isString$1(options2.fallbackNS))
        options2.fallbackNS = [options2.fallbackNS];
    if (options2.supportedLngs?.indexOf?.("cimode") < 0) {
        options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
    }
    if (typeof options2.initImmediate === "boolean")
        options2.initAsync = options2.initImmediate;
    return options2;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
    mems.forEach((mem) => {
        if (typeof inst[mem] === "function") {
            inst[mem] = inst[mem].bind(inst);
        }
    });
};
class I18n extends EventEmitter {
    constructor(options2 = {}, callback) {
        super();
        this.options = transformOptions(options2);
        this.services = {};
        this.logger = baseLogger;
        this.modules = {
            external: []
        };
        bindMemberFunctions(this);
        if (callback && !this.isInitialized && !options2.isClone) {
            if (!this.options.initAsync) {
                this.init(options2, callback);
                return this;
            }
            setTimeout(() => {
                this.init(options2, callback);
            }, 0);
        }
    }
    init(options2 = {}, callback) {
        this.isInitializing = true;
        if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
        }
        if (options2.defaultNS == null && options2.ns) {
            if (isString$1(options2.ns)) {
                options2.defaultNS = options2.ns;
            }
            else if (options2.ns.indexOf("translation") < 0) {
                options2.defaultNS = options2.ns[0];
            }
        }
        const defOpts = get$4();
        this.options = {
            ...defOpts,
            ...this.options,
            ...transformOptions(options2)
        };
        this.options.interpolation = {
            ...defOpts.interpolation,
            ...this.options.interpolation
        };
        if (options2.keySeparator !== void 0) {
            this.options.userDefinedKeySeparator = options2.keySeparator;
        }
        if (options2.nsSeparator !== void 0) {
            this.options.userDefinedNsSeparator = options2.nsSeparator;
        }
        const createClassOnDemand = (ClassOrObject) => {
            if (!ClassOrObject)
                return null;
            if (typeof ClassOrObject === "function")
                return new ClassOrObject();
            return ClassOrObject;
        };
        if (!this.options.isClone) {
            if (this.modules.logger) {
                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
            }
            else {
                baseLogger.init(null, this.options);
            }
            let formatter;
            if (this.modules.formatter) {
                formatter = this.modules.formatter;
            }
            else {
                formatter = Formatter;
            }
            const lu = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources, this.options);
            const s = this.services;
            s.logger = baseLogger;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver(lu, {
                prepend: this.options.pluralSeparator,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
                s.formatter = createClassOnDemand(formatter);
                s.formatter.init(s, this.options);
                this.options.interpolation.format = s.formatter.format.bind(s.formatter);
            }
            s.interpolator = new Interpolator(this.options);
            s.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on("*", (event, ...args) => {
                this.emit(event, ...args);
            });
            if (this.modules.languageDetector) {
                s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                if (s.languageDetector.init)
                    s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                if (s.i18nFormat.init)
                    s.i18nFormat.init(this);
            }
            this.translator = new Translator(this.services, this.options);
            this.translator.on("*", (event, ...args) => {
                this.emit(event, ...args);
            });
            this.modules.external.forEach((m) => {
                if (m.init)
                    m.init(this);
            });
        }
        this.format = this.options.interpolation.format;
        if (!callback)
            callback = noop;
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            if (codes.length > 0 && codes[0] !== "dev")
                this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
            this.logger.warn("init: no languageDetector is used and no lng is defined");
        }
        const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
        storeApi.forEach((fcName) => {
            this[fcName] = (...args) => this.store[fcName](...args);
        });
        const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
        storeApiChained.forEach((fcName) => {
            this[fcName] = (...args) => {
                this.store[fcName](...args);
                return this;
            };
        });
        const deferred = defer();
        const load = () => {
            const finish = (err, t2) => {
                this.isInitializing = false;
                if (this.isInitialized && !this.initializedStoreOnce)
                    this.logger.warn("init: i18next is already initialized. You should call init just once!");
                this.isInitialized = true;
                if (!this.options.isClone)
                    this.logger.log("initialized", this.options);
                this.emit("initialized", this.options);
                deferred.resolve(t2);
                callback(err, t2);
            };
            if (this.languages && !this.isInitialized)
                return finish(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initAsync) {
            load();
        }
        else {
            setTimeout(load, 0);
        }
        return deferred;
    }
    loadResources(language, callback = noop) {
        let usedCallback = callback;
        const usedLng = isString$1(language) ? language : this.language;
        if (typeof language === "function")
            usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
                return usedCallback();
            const toLoad = [];
            const append = (lng) => {
                if (!lng)
                    return;
                if (lng === "cimode")
                    return;
                const lngs = this.services.languageUtils.toResolveHierarchy(lng);
                lngs.forEach((l) => {
                    if (l === "cimode")
                        return;
                    if (toLoad.indexOf(l) < 0)
                        toLoad.push(l);
                });
            };
            if (!usedLng) {
                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                fallbacks.forEach((l) => append(l));
            }
            else {
                append(usedLng);
            }
            this.options.preload?.forEach?.((l) => append(l));
            this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
                if (!e && !this.resolvedLanguage && this.language)
                    this.setResolvedLanguage(this.language);
                usedCallback(e);
            });
        }
        else {
            usedCallback(null);
        }
    }
    reloadResources(lngs, ns, callback) {
        const deferred = defer();
        if (typeof lngs === "function") {
            callback = lngs;
            lngs = void 0;
        }
        if (typeof ns === "function") {
            callback = ns;
            ns = void 0;
        }
        if (!lngs)
            lngs = this.languages;
        if (!ns)
            ns = this.options.ns;
        if (!callback)
            callback = noop;
        this.services.backendConnector.reload(lngs, ns, (err) => {
            deferred.resolve();
            callback(err);
        });
        return deferred;
    }
    use(module2) {
        if (!module2)
            throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!module2.type)
            throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        if (module2.type === "backend") {
            this.modules.backend = module2;
        }
        if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
            this.modules.logger = module2;
        }
        if (module2.type === "languageDetector") {
            this.modules.languageDetector = module2;
        }
        if (module2.type === "i18nFormat") {
            this.modules.i18nFormat = module2;
        }
        if (module2.type === "postProcessor") {
            postProcessor.addPostProcessor(module2);
        }
        if (module2.type === "formatter") {
            this.modules.formatter = module2;
        }
        if (module2.type === "3rdParty") {
            this.modules.external.push(module2);
        }
        return this;
    }
    setResolvedLanguage(l) {
        if (!l || !this.languages)
            return;
        if (["cimode", "dev"].indexOf(l) > -1)
            return;
        for (let li = 0; li < this.languages.length; li++) {
            const lngInLngs = this.languages[li];
            if (["cimode", "dev"].indexOf(lngInLngs) > -1)
                continue;
            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                this.resolvedLanguage = lngInLngs;
                break;
            }
        }
        if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {
            this.resolvedLanguage = l;
            this.languages.unshift(l);
        }
    }
    changeLanguage(lng, callback) {
        this.isLanguageChangingTo = lng;
        const deferred = defer();
        this.emit("languageChanging", lng);
        const setLngProps = (l) => {
            this.language = l;
            this.languages = this.services.languageUtils.toResolveHierarchy(l);
            this.resolvedLanguage = void 0;
            this.setResolvedLanguage(l);
        };
        const done = (err, l) => {
            if (l) {
                if (this.isLanguageChangingTo === lng) {
                    setLngProps(l);
                    this.translator.changeLanguage(l);
                    this.isLanguageChangingTo = void 0;
                    this.emit("languageChanged", l);
                    this.logger.log("languageChanged", l);
                }
            }
            else {
                this.isLanguageChangingTo = void 0;
            }
            deferred.resolve((...args) => this.t(...args));
            if (callback)
                callback(err, (...args) => this.t(...args));
        };
        const setLng = (lngs) => {
            if (!lng && !lngs && this.services.languageDetector)
                lngs = [];
            const fl = isString$1(lngs) ? lngs : lngs && lngs[0];
            const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString$1(lngs) ? [lngs] : lngs);
            if (l) {
                if (!this.language) {
                    setLngProps(l);
                }
                if (!this.translator.language)
                    this.translator.changeLanguage(l);
                this.services.languageDetector?.cacheUserLanguage?.(l);
            }
            this.loadResources(l, (err) => {
                done(err, l);
            });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
        }
        else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            if (this.services.languageDetector.detect.length === 0) {
                this.services.languageDetector.detect().then(setLng);
            }
            else {
                this.services.languageDetector.detect(setLng);
            }
        }
        else {
            setLng(lng);
        }
        return deferred;
    }
    getFixedT(lng, ns, keyPrefix) {
        const fixedT = (key, opts, ...rest) => {
            let o;
            if (typeof opts !== "object") {
                o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
            }
            else {
                o = {
                    ...opts
                };
            }
            o.lng = o.lng || fixedT.lng;
            o.lngs = o.lngs || fixedT.lngs;
            o.ns = o.ns || fixedT.ns;
            if (o.keyPrefix !== "")
                o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
            const keySeparator = this.options.keySeparator || ".";
            let resultKey;
            if (o.keyPrefix && Array.isArray(key)) {
                resultKey = key.map((k) => `${o.keyPrefix}${keySeparator}${k}`);
            }
            else {
                resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
            }
            return this.t(resultKey, o);
        };
        if (isString$1(lng)) {
            fixedT.lng = lng;
        }
        else {
            fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
    }
    t(...args) {
        return this.translator?.translate(...args);
    }
    exists(...args) {
        return this.translator?.exists(...args);
    }
    setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
    }
    hasLoadedNamespace(ns, options2 = {}) {
        if (!this.isInitialized) {
            this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
            return false;
        }
        if (!this.languages || !this.languages.length) {
            this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
            return false;
        }
        const lng = options2.lng || this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === "cimode")
            return true;
        const loadNotPending = (l, n) => {
            const loadState = this.services.backendConnector.state[`${l}|${n}`];
            return loadState === -1 || loadState === 0 || loadState === 2;
        };
        if (options2.precheck) {
            const preResult = options2.precheck(this, loadNotPending);
            if (preResult !== void 0)
                return preResult;
        }
        if (this.hasResourceBundle(lng, ns))
            return true;
        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
            return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
            return true;
        return false;
    }
    loadNamespaces(ns, callback) {
        const deferred = defer();
        if (!this.options.ns) {
            if (callback)
                callback();
            return Promise.resolve();
        }
        if (isString$1(ns))
            ns = [ns];
        ns.forEach((n) => {
            if (this.options.ns.indexOf(n) < 0)
                this.options.ns.push(n);
        });
        this.loadResources((err) => {
            deferred.resolve();
            if (callback)
                callback(err);
        });
        return deferred;
    }
    loadLanguages(lngs, callback) {
        const deferred = defer();
        if (isString$1(lngs))
            lngs = [lngs];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
        if (!newLngs.length) {
            if (callback)
                callback();
            return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err) => {
            deferred.resolve();
            if (callback)
                callback(err);
        });
        return deferred;
    }
    dir(lng) {
        if (!lng)
            lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
        if (!lng)
            return "rtl";
        const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
        const languageUtils = this.services?.languageUtils || new LanguageUtil(get$4());
        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
    static createInstance(options2 = {}, callback) {
        return new I18n(options2, callback);
    }
    cloneInstance(options2 = {}, callback = noop) {
        const forkResourceStore = options2.forkResourceStore;
        if (forkResourceStore)
            delete options2.forkResourceStore;
        const mergedOptions = {
            ...this.options,
            ...options2,
            ...{
                isClone: true
            }
        };
        const clone = new I18n(mergedOptions);
        if (options2.debug !== void 0 || options2.prefix !== void 0) {
            clone.logger = clone.logger.clone(options2);
        }
        const membersToCopy = ["store", "services", "language"];
        membersToCopy.forEach((m) => {
            clone[m] = this[m];
        });
        clone.services = {
            ...this.services
        };
        clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        if (forkResourceStore) {
            const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
                prev[l] = {
                    ...this.store.data[l]
                };
                prev[l] = Object.keys(prev[l]).reduce((acc, n) => {
                    acc[n] = {
                        ...prev[l][n]
                    };
                    return acc;
                }, prev[l]);
                return prev;
            }, {});
            clone.store = new ResourceStore(clonedData, mergedOptions);
            clone.services.resourceStore = clone.store;
        }
        clone.translator = new Translator(clone.services, mergedOptions);
        clone.translator.on("*", (event, ...args) => {
            clone.emit(event, ...args);
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = mergedOptions;
        clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        return clone;
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        };
    }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
const t = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const captureException = function (exc) {
    console.error("[Exception]", exc);
};
const captureBreadcrumb = function (crumb) {
};
function isPreviewEnvironment() {
    return String(process.env.REACT_APP_NETLIFY) === "true";
}
function isDevelopmentEnvironment() {
    return process.env.NODE_ENV === "development";
}
function isNonProductionEnvironment() {
    return isPreviewEnvironment() || isDevelopmentEnvironment();
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const millisecondsInSecond = 1e3;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
    if (typeof date === "function")
        return date(value);
    if (date && typeof date === "object" && constructFromSymbol in date)
        return date[constructFromSymbol](value);
    if (date instanceof Date)
        return new date.constructor(value);
    return new Date(value);
}
function toDate(argument, context) {
    return constructFrom(context || argument, argument);
}
function addDays$1(date, amount, options2) {
    const _date = toDate(date, options2?.in);
    if (isNaN(amount))
        return constructFrom(options2?.in || date, NaN);
    if (!amount)
        return _date;
    _date.setDate(_date.getDate() + amount);
    return _date;
}
function addMonths$1(date, amount, options2) {
    const _date = toDate(date, options2?.in);
    if (isNaN(amount))
        return constructFrom(date, NaN);
    if (!amount) {
        return _date;
    }
    const dayOfMonth = _date.getDate();
    const endOfDesiredMonth = constructFrom(date, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
        return endOfDesiredMonth;
    }
    else {
        _date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
        return _date;
    }
}
function isWeekend(date, options2) {
    const day = toDate(date, options2?.in).getDay();
    return day === 0 || day === 6;
}
let defaultOptions = {};
function getDefaultOptions$1() {
    return defaultOptions;
}
function startOfWeek(date, options2) {
    const defaultOptions2 = getDefaultOptions$1();
    const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const _date = toDate(date, options2?.in);
    const day = _date.getDay();
    const diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff2);
    _date.setHours(0, 0, 0, 0);
    return _date;
}
function startOfISOWeek(date, options2) {
    return startOfWeek(date, { ...options2, weekStartsOn: 1 });
}
function getISOWeekYear(date, options2) {
    const _date = toDate(date, options2?.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
    }
    else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
    }
    else {
        return year - 1;
    }
}
function getTimezoneOffsetInMilliseconds(date) {
    const _date = toDate(date);
    const utcDate = new Date(Date.UTC(_date.getFullYear(), _date.getMonth(), _date.getDate(), _date.getHours(), _date.getMinutes(), _date.getSeconds(), _date.getMilliseconds()));
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
    const normalize = constructFrom.bind(null, context || dates.find((date) => typeof date === "object"));
    return dates.map(normalize);
}
function startOfDay(date, options2) {
    const _date = toDate(date, options2?.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
}
function differenceInCalendarDays$1(laterDate, earlierDate, options2) {
    const [laterDate_, earlierDate_] = normalizeDates(options2?.in, laterDate, earlierDate);
    const laterStartOfDay = startOfDay(laterDate_);
    const earlierStartOfDay = startOfDay(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfISOWeekYear(date, options2) {
    const year = getISOWeekYear(date, options2);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
}
function addWeeks$1(date, amount, options2) {
    return addDays$1(date, amount * 7, options2);
}
function addYears$1(date, amount, options2) {
    return addMonths$1(date, amount * 12, options2);
}
function max$1(dates, options2) {
    let result;
    let context = options2?.in;
    dates.forEach((date) => {
        if (!context && typeof date === "object")
            context = constructFrom.bind(null, date);
        const date_ = toDate(date, context);
        if (!result || result < date_ || isNaN(+date_))
            result = date_;
    });
    return constructFrom(context, result || NaN);
}
function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date) {
    return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}
function differenceInCalendarMonths$1(laterDate, earlierDate, options2) {
    const [laterDate_, earlierDate_] = normalizeDates(options2?.in, laterDate, earlierDate);
    const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
    const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
    return yearsDiff * 12 + monthsDiff;
}
function differenceInDays(laterDate, earlierDate, options2) {
    const [laterDate_, earlierDate_] = normalizeDates(options2?.in, laterDate, earlierDate);
    const sign2 = compareLocalAsc(laterDate_, earlierDate_);
    const difference = Math.abs(differenceInCalendarDays$1(laterDate_, earlierDate_));
    laterDate_.setDate(laterDate_.getDate() - sign2 * difference);
    const isLastDayNotFull = Number(compareLocalAsc(laterDate_, earlierDate_) === -sign2);
    const result = sign2 * (difference - isLastDayNotFull);
    return result === 0 ? 0 : result;
}
function compareLocalAsc(laterDate, earlierDate) {
    const diff2 = laterDate.getFullYear() - earlierDate.getFullYear() || laterDate.getMonth() - earlierDate.getMonth() || laterDate.getDate() - earlierDate.getDate() || laterDate.getHours() - earlierDate.getHours() || laterDate.getMinutes() - earlierDate.getMinutes() || laterDate.getSeconds() - earlierDate.getSeconds() || laterDate.getMilliseconds() - earlierDate.getMilliseconds();
    if (diff2 < 0)
        return -1;
    if (diff2 > 0)
        return 1;
    return diff2;
}
function differenceInMilliseconds(laterDate, earlierDate) {
    return +toDate(laterDate) - +toDate(earlierDate);
}
function endOfMonth(date, options2) {
    const _date = toDate(date, options2?.in);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
}
function startOfMonth(date, options2) {
    const _date = toDate(date, options2?.in);
    _date.setDate(1);
    _date.setHours(0, 0, 0, 0);
    return _date;
}
function startOfYear(date, options2) {
    const date_ = toDate(date, options2?.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
}
const formatDistanceLocale$1j = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
};
const formatDistance$1k = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$1j[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "in " + result;
        }
        else {
            return result + " ago";
        }
    }
    return result;
};
function buildFormatLongFn(args) {
    return (options2 = {}) => {
        const width = options2.width ? String(options2.width) : args.defaultWidth;
        const format2 = args.formats[width] || args.formats[args.defaultWidth];
        return format2;
    };
}
const dateFormats$1s = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$1s = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1s = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1s = {
    date: buildFormatLongFn({
        formats: dateFormats$1s,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1s,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1s,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1k = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
};
const formatRelative$1k = (token, _date, _baseDate, _options) => formatRelativeLocale$1k[token];
function buildLocalizeFn(args) {
    return (value, options2) => {
        const context = options2?.context ? String(options2.context) : "standalone";
        let valuesArray;
        if (context === "formatting" && args.formattingValues) {
            const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            const width = options2?.width ? String(options2.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        }
        else {
            const defaultWidth = args.defaultWidth;
            const width = options2?.width ? String(options2.width) : args.defaultWidth;
            valuesArray = args.values[width] || args.values[defaultWidth];
        }
        const index = args.argumentCallback ? args.argumentCallback(value) : value;
        return valuesArray[index];
    };
}
const eraValues$1k = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
};
const quarterValues$1k = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues$1k = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ],
    wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ]
};
const dayValues$1k = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ]
};
const dayPeriodValues$1k = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
};
const formattingDayPeriodValues$14 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
};
const ordinalNumber$1k = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number2 + "st";
            case 2:
                return number2 + "nd";
            case 3:
                return number2 + "rd";
        }
    }
    return number2 + "th";
};
const localize$1k = {
    ordinalNumber: ordinalNumber$1k,
    era: buildLocalizeFn({
        values: eraValues$1k,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1k,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1k,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1k,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1k,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$14,
        defaultFormattingWidth: "wide"
    })
};
function buildMatchFn(args) {
    return (string, options2 = {}) => {
        const width = options2.width;
        const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        const matchResult = string.match(matchPattern);
        if (!matchResult) {
            return null;
        }
        const matchedString = matchResult[0];
        const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString)));
        let value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options2.valueCallback ? (
        // [TODO] -- I challenge you to fix the type
        options2.valueCallback(value)) : value;
        const rest = string.slice(matchedString.length);
        return { value, rest };
    };
}
function findKey(object, predicate) {
    for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
            return key;
        }
    }
    return void 0;
}
function findIndex(array, predicate) {
    for (let key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
            return key;
        }
    }
    return void 0;
}
function buildMatchPatternFn(args) {
    return (string, options2 = {}) => {
        const matchResult = string.match(args.matchPattern);
        if (!matchResult)
            return null;
        const matchedString = matchResult[0];
        const parseResult = string.match(args.parsePattern);
        if (!parseResult)
            return null;
        let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options2.valueCallback ? options2.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return { value, rest };
    };
}
const matchOrdinalNumberPattern$1j = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1j = /\d+/i;
const matchEraPatterns$1j = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns$1j = {
    any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$1j = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns$1j = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1j = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns$1j = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$1j = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns$1j = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$1j = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1j = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
const match$1j = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1j,
        parsePattern: parseOrdinalNumberPattern$1j,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1j,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1j,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1j,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1j,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1j,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1j,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1j,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1j,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1j,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1j,
        defaultParseWidth: "any"
    })
};
const enUS = {
    code: "en-US",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$1s,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function getDayOfYear(date, options2) {
    const _date = toDate(date, options2?.in);
    const diff2 = differenceInCalendarDays$1(_date, startOfYear(_date));
    const dayOfYear = diff2 + 1;
    return dayOfYear;
}
function getISOWeek(date, options2) {
    const _date = toDate(date, options2?.in);
    const diff2 = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff2 / millisecondsInWeek) + 1;
}
function getWeekYear(date, options2) {
    const _date = toDate(date, options2?.in);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions$1();
    const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const firstWeekOfNextYear = constructFrom(options2?.in || date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options2);
    const firstWeekOfThisYear = constructFrom(options2?.in || date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options2);
    if (+_date >= +startOfNextYear) {
        return year + 1;
    }
    else if (+_date >= +startOfThisYear) {
        return year;
    }
    else {
        return year - 1;
    }
}
function startOfWeekYear(date, options2) {
    const defaultOptions2 = getDefaultOptions$1();
    const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const year = getWeekYear(date, options2);
    const firstWeek = constructFrom(options2?.in || date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options2);
    return _date;
}
function getWeek(date, options2) {
    const _date = toDate(date, options2?.in);
    const diff2 = +startOfWeek(_date, options2) - +startOfWeekYear(_date, options2);
    return Math.round(diff2 / millisecondsInWeek) + 1;
}
function addLeadingZeros(number2, targetLength) {
    const sign2 = number2 < 0 ? "-" : "";
    const output = Math.abs(number2).toString().padStart(targetLength, "0");
    return sign2 + output;
}
const lightFormatters = {
    // Year
    y(date, token) {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M(date, token) {
        const month = date.getMonth();
        return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d(date, token) {
        return addLeadingZeros(date.getDate(), token.length);
    },
    // AM or PM
    a(date, token) {
        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
            case "a":
            case "aa":
                return dayPeriodEnumValue.toUpperCase();
            case "aaa":
                return dayPeriodEnumValue;
            case "aaaaa":
                return dayPeriodEnumValue[0];
            case "aaaa":
            default:
                return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
    },
    // Hour [1-12]
    h(date, token) {
        return addLeadingZeros(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H(date, token) {
        return addLeadingZeros(date.getHours(), token.length);
    },
    // Minute
    m(date, token) {
        return addLeadingZeros(date.getMinutes(), token.length);
    },
    // Second
    s(date, token) {
        return addLeadingZeros(date.getSeconds(), token.length);
    },
    // Fraction of second
    S(date, token) {
        const numberOfDigits = token.length;
        const milliseconds = date.getMilliseconds();
        const fractionalSeconds = Math.trunc(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
    }
};
const dayPeriodEnum = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
};
const formatters = {
    // Era
    G: function (date, token, localize2) {
        const era = date.getFullYear() > 0 ? 1 : 0;
        switch (token) {
            // AD, BC
            case "G":
            case "GG":
            case "GGG":
                return localize2.era(era, { width: "abbreviated" });
            // A, B
            case "GGGGG":
                return localize2.era(era, { width: "narrow" });
            // Anno Domini, Before Christ
            case "GGGG":
            default:
                return localize2.era(era, { width: "wide" });
        }
    },
    // Year
    y: function (date, token, localize2) {
        if (token === "yo") {
            const signedYear = date.getFullYear();
            const year = signedYear > 0 ? signedYear : 1 - signedYear;
            return localize2.ordinalNumber(year, { unit: "year" });
        }
        return lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function (date, token, localize2, options2) {
        const signedWeekYear = getWeekYear(date, options2);
        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
            const twoDigitYear = weekYear % 100;
            return addLeadingZeros(twoDigitYear, 2);
        }
        if (token === "Yo") {
            return localize2.ordinalNumber(weekYear, { unit: "year" });
        }
        return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function (date, token) {
        const isoWeekYear = getISOWeekYear(date);
        return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function (date, token) {
        const year = date.getFullYear();
        return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function (date, token, localize2) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
            // 1, 2, 3, 4
            case "Q":
                return String(quarter);
            // 01, 02, 03, 04
            case "QQ":
                return addLeadingZeros(quarter, 2);
            // 1st, 2nd, 3rd, 4th
            case "Qo":
                return localize2.ordinalNumber(quarter, { unit: "quarter" });
            // Q1, Q2, Q3, Q4
            case "QQQ":
                return localize2.quarter(quarter, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "QQQQQ":
                return localize2.quarter(quarter, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1st quarter, 2nd quarter, ...
            case "QQQQ":
            default:
                return localize2.quarter(quarter, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone quarter
    q: function (date, token, localize2) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
            // 1, 2, 3, 4
            case "q":
                return String(quarter);
            // 01, 02, 03, 04
            case "qq":
                return addLeadingZeros(quarter, 2);
            // 1st, 2nd, 3rd, 4th
            case "qo":
                return localize2.ordinalNumber(quarter, { unit: "quarter" });
            // Q1, Q2, Q3, Q4
            case "qqq":
                return localize2.quarter(quarter, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "qqqqq":
                return localize2.quarter(quarter, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1st quarter, 2nd quarter, ...
            case "qqqq":
            default:
                return localize2.quarter(quarter, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // Month
    M: function (date, token, localize2) {
        const month = date.getMonth();
        switch (token) {
            case "M":
            case "MM":
                return lightFormatters.M(date, token);
            // 1st, 2nd, ..., 12th
            case "Mo":
                return localize2.ordinalNumber(month + 1, { unit: "month" });
            // Jan, Feb, ..., Dec
            case "MMM":
                return localize2.month(month, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // J, F, ..., D
            case "MMMMM":
                return localize2.month(month, {
                    width: "narrow",
                    context: "formatting"
                });
            // January, February, ..., December
            case "MMMM":
            default:
                return localize2.month(month, { width: "wide", context: "formatting" });
        }
    },
    // Stand-alone month
    L: function (date, token, localize2) {
        const month = date.getMonth();
        switch (token) {
            // 1, 2, ..., 12
            case "L":
                return String(month + 1);
            // 01, 02, ..., 12
            case "LL":
                return addLeadingZeros(month + 1, 2);
            // 1st, 2nd, ..., 12th
            case "Lo":
                return localize2.ordinalNumber(month + 1, { unit: "month" });
            // Jan, Feb, ..., Dec
            case "LLL":
                return localize2.month(month, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // J, F, ..., D
            case "LLLLL":
                return localize2.month(month, {
                    width: "narrow",
                    context: "standalone"
                });
            // January, February, ..., December
            case "LLLL":
            default:
                return localize2.month(month, { width: "wide", context: "standalone" });
        }
    },
    // Local week of year
    w: function (date, token, localize2, options2) {
        const week2 = getWeek(date, options2);
        if (token === "wo") {
            return localize2.ordinalNumber(week2, { unit: "week" });
        }
        return addLeadingZeros(week2, token.length);
    },
    // ISO week of year
    I: function (date, token, localize2) {
        const isoWeek = getISOWeek(date);
        if (token === "Io") {
            return localize2.ordinalNumber(isoWeek, { unit: "week" });
        }
        return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function (date, token, localize2) {
        if (token === "do") {
            return localize2.ordinalNumber(date.getDate(), { unit: "date" });
        }
        return lightFormatters.d(date, token);
    },
    // Day of year
    D: function (date, token, localize2) {
        const dayOfYear = getDayOfYear(date);
        if (token === "Do") {
            return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
        }
        return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function (date, token, localize2) {
        const dayOfWeek = date.getDay();
        switch (token) {
            // Tue
            case "E":
            case "EE":
            case "EEE":
                return localize2.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "EEEEE":
                return localize2.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "EEEEEE":
                return localize2.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "EEEE":
            default:
                return localize2.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Local day of week
    e: function (date, token, localize2, options2) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
        switch (token) {
            // Numerical value (Nth day of week with current locale or weekStartsOn)
            case "e":
                return String(localDayOfWeek);
            // Padded numerical value
            case "ee":
                return addLeadingZeros(localDayOfWeek, 2);
            // 1st, 2nd, ..., 7th
            case "eo":
                return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
            case "eee":
                return localize2.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "eeeee":
                return localize2.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "eeeeee":
                return localize2.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "eeee":
            default:
                return localize2.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone local day of week
    c: function (date, token, localize2, options2) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
        switch (token) {
            // Numerical value (same as in `e`)
            case "c":
                return String(localDayOfWeek);
            // Padded numerical value
            case "cc":
                return addLeadingZeros(localDayOfWeek, token.length);
            // 1st, 2nd, ..., 7th
            case "co":
                return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
            case "ccc":
                return localize2.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // T
            case "ccccc":
                return localize2.day(dayOfWeek, {
                    width: "narrow",
                    context: "standalone"
                });
            // Tu
            case "cccccc":
                return localize2.day(dayOfWeek, {
                    width: "short",
                    context: "standalone"
                });
            // Tuesday
            case "cccc":
            default:
                return localize2.day(dayOfWeek, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // ISO day of week
    i: function (date, token, localize2) {
        const dayOfWeek = date.getDay();
        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
            // 2
            case "i":
                return String(isoDayOfWeek);
            // 02
            case "ii":
                return addLeadingZeros(isoDayOfWeek, token.length);
            // 2nd
            case "io":
                return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
            // Tue
            case "iii":
                return localize2.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "iiiii":
                return localize2.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "iiiiii":
                return localize2.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "iiii":
            default:
                return localize2.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // AM or PM
    a: function (date, token, localize2) {
        const hours = date.getHours();
        const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
            case "a":
            case "aa":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "aaa":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "aaaaa":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // AM, PM, midnight, noon
    b: function (date, token, localize2) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours === 12) {
            dayPeriodEnumValue = dayPeriodEnum.noon;
        }
        else if (hours === 0) {
            dayPeriodEnumValue = dayPeriodEnum.midnight;
        }
        else {
            dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
            case "b":
            case "bb":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "bbb":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "bbbbb":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function (date, token, localize2) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours >= 17) {
            dayPeriodEnumValue = dayPeriodEnum.evening;
        }
        else if (hours >= 12) {
            dayPeriodEnumValue = dayPeriodEnum.afternoon;
        }
        else if (hours >= 4) {
            dayPeriodEnumValue = dayPeriodEnum.morning;
        }
        else {
            dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
            case "B":
            case "BB":
            case "BBB":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "BBBBB":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return localize2.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Hour [1-12]
    h: function (date, token, localize2) {
        if (token === "ho") {
            let hours = date.getHours() % 12;
            if (hours === 0)
                hours = 12;
            return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function (date, token, localize2) {
        if (token === "Ho") {
            return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
        }
        return lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function (date, token, localize2) {
        const hours = date.getHours() % 12;
        if (token === "Ko") {
            return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function (date, token, localize2) {
        let hours = date.getHours();
        if (hours === 0)
            hours = 24;
        if (token === "ko") {
            return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function (date, token, localize2) {
        if (token === "mo") {
            return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
        }
        return lightFormatters.m(date, token);
    },
    // Second
    s: function (date, token, localize2) {
        if (token === "so") {
            return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
        }
        return lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function (date, token) {
        return lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function (date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        if (timezoneOffset === 0) {
            return "Z";
        }
        switch (token) {
            // Hours and optional minutes
            case "X":
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
            // Hours, minutes and optional seconds without `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `XX`
            case "XXXX":
            case "XX":
                return formatTimezone(timezoneOffset);
            // Hours, minutes and optional seconds with `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `XXX`
            case "XXXXX":
            case "XXX":
            // Hours and minutes with `:` delimiter
            default:
                return formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function (date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
            // Hours and optional minutes
            case "x":
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
            // Hours, minutes and optional seconds without `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `xx`
            case "xxxx":
            case "xx":
                return formatTimezone(timezoneOffset);
            // Hours, minutes and optional seconds with `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `xxx`
            case "xxxxx":
            case "xxx":
            // Hours and minutes with `:` delimiter
            default:
                return formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (GMT)
    O: function (date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
            // Short
            case "O":
            case "OO":
            case "OOO":
                return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            // Long
            case "OOOO":
            default:
                return "GMT" + formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (specific non-location)
    z: function (date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
            // Short
            case "z":
            case "zz":
            case "zzz":
                return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            // Long
            case "zzzz":
            default:
                return "GMT" + formatTimezone(timezoneOffset, ":");
        }
    },
    // Seconds timestamp
    t: function (date, token, _localize) {
        const timestamp = Math.trunc(+date / 1e3);
        return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function (date, token, _localize) {
        return addLeadingZeros(+date, token.length);
    }
};
function formatTimezoneShort(offset, delimiter = "") {
    const sign2 = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
        return sign2 + String(hours);
    }
    return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
        const sign2 = offset > 0 ? "-" : "+";
        return sign2 + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
}
function formatTimezone(offset, delimiter = "") {
    const sign2 = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign2 + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
        case "P":
            return formatLong2.date({ width: "short" });
        case "PP":
            return formatLong2.date({ width: "medium" });
        case "PPP":
            return formatLong2.date({ width: "long" });
        case "PPPP":
        default:
            return formatLong2.date({ width: "full" });
    }
};
const timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
        case "p":
            return formatLong2.time({ width: "short" });
        case "pp":
            return formatLong2.time({ width: "medium" });
        case "ppp":
            return formatLong2.time({ width: "long" });
        case "pppp":
        default:
            return formatLong2.time({ width: "full" });
    }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
        return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
        case "P":
            dateTimeFormat = formatLong2.dateTime({ width: "short" });
            break;
        case "PP":
            dateTimeFormat = formatLong2.dateTime({ width: "medium" });
            break;
        case "PPP":
            dateTimeFormat = formatLong2.dateTime({ width: "long" });
            break;
        case "PPPP":
        default:
            dateTimeFormat = formatLong2.dateTime({ width: "full" });
            break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
    const _message = message(token, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token))
        throw new RangeError(_message);
}
function message(token, format2, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp$1 = /^'([^]*?)'?$/;
const doubleQuoteRegExp$1 = /''/g;
const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format$1(date, formatStr, options2) {
    const defaultOptions2 = getDefaultOptions$1();
    const locale = options2?.locale ?? defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = options2?.firstWeekContainsDate ?? options2?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const originalDate = toDate(date, options2?.in);
    if (!isValid(originalDate)) {
        throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp$1).map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
            const longFormatter = longFormatters[firstCharacter];
            return longFormatter(substring, locale.formatLong);
        }
        return substring;
    }).join("").match(formattingTokensRegExp$1).map((substring) => {
        if (substring === "''") {
            return { isToken: false, value: "'" };
        }
        const firstCharacter = substring[0];
        if (firstCharacter === "'") {
            return { isToken: false, value: cleanEscapedString$1(substring) };
        }
        if (formatters[firstCharacter]) {
            return { isToken: true, value: substring };
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
        parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
    };
    return parts.map((part) => {
        if (!part.isToken)
            return part.value;
        const token = part.value;
        if (!options2?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options2?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
            warnOrThrowProtectedError(token, formatStr, String(date));
        }
        const formatter = formatters[token[0]];
        return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
}
function cleanEscapedString$1(input) {
    const matched = input.match(escapedStringRegExp$1);
    if (!matched) {
        return input;
    }
    return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function getDate(date, options2) {
    return toDate(date, options2?.in).getDate();
}
function getDay$1(date, options2) {
    return toDate(date, options2?.in).getDay();
}
function getDefaultOptions() {
    return Object.assign({}, getDefaultOptions$1());
}
function getISODay(date, options2) {
    const day = toDate(date, options2?.in).getDay();
    return day === 0 ? 7 : day;
}
function isAfter$1(date, dateToCompare) {
    return +toDate(date) > +toDate(dateToCompare);
}
function isBefore$1(date, dateToCompare) {
    return +toDate(date) < +toDate(dateToCompare);
}
function transpose(date, constructor) {
    const date_ = isConstructor(constructor) ? new constructor(0) : constructFrom(constructor, 0);
    date_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    date_.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    return date_;
}
function isConstructor(constructor) {
    return typeof constructor === "function" && constructor.prototype?.constructor === constructor;
}
const TIMEZONE_UNIT_PRIORITY = 10;
class Setter {
    constructor() {
        this.subPriority = 0;
    }
    validate(_utcDate, _options) {
        return true;
    }
}
class ValueSetter extends Setter {
    constructor(value, validateValue, setValue, priority, subPriority) {
        super();
        this.value = value;
        this.validateValue = validateValue;
        this.setValue = setValue;
        this.priority = priority;
        if (subPriority) {
            this.subPriority = subPriority;
        }
    }
    validate(date, options2) {
        return this.validateValue(date, this.value, options2);
    }
    set(date, flags, options2) {
        return this.setValue(date, flags, this.value, options2);
    }
}
class DateTimezoneSetter extends Setter {
    constructor(context, reference) {
        super();
        this.priority = TIMEZONE_UNIT_PRIORITY;
        this.subPriority = -1;
        this.context = context || ((date) => constructFrom(reference, date));
    }
    set(date, flags) {
        if (flags.timestampIsSet)
            return date;
        return constructFrom(date, transpose(date, this.context));
    }
}
class Parser {
    run(dateString, token, match2, options2) {
        const result = this.parse(dateString, token, match2, options2);
        if (!result) {
            return null;
        }
        return {
            setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
            rest: result.rest
        };
    }
    validate(_utcDate, _value, _options) {
        return true;
    }
}
class EraParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 140;
        this.incompatibleTokens = ["R", "u", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            // AD, BC
            case "G":
            case "GG":
            case "GGG":
                return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
            // A, B
            case "GGGGG":
                return match2.era(dateString, { width: "narrow" });
            // Anno Domini, Before Christ
            case "GGGG":
            default:
                return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
        }
    }
    set(date, flags, value) {
        flags.era = value;
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
const numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59
    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/
    // 0 to 9999, -0 to -9999
};
const timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
        return parseFnResult;
    }
    return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
    };
}
function parseNumericPattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) {
        return null;
    }
    return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseTimezonePattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) {
        return null;
    }
    if (matchResult[0] === "Z") {
        return {
            value: 0,
            rest: dateString.slice(1)
        };
    }
    const sign2 = matchResult[1] === "+" ? 1 : -1;
    const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
        value: sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
    switch (n) {
        case 1:
            return parseNumericPattern(numericPatterns.singleDigit, dateString);
        case 2:
            return parseNumericPattern(numericPatterns.twoDigits, dateString);
        case 3:
            return parseNumericPattern(numericPatterns.threeDigits, dateString);
        case 4:
            return parseNumericPattern(numericPatterns.fourDigits, dateString);
        default:
            return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
}
function parseNDigitsSigned(n, dateString) {
    switch (n) {
        case 1:
            return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
        case 2:
            return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
        case 3:
            return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
        case 4:
            return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
        default:
            return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
}
function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
        case "morning":
            return 4;
        case "evening":
            return 17;
        case "pm":
        case "noon":
        case "afternoon":
            return 12;
        case "am":
        case "midnight":
        case "night":
        default:
            return 0;
    }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    const isCommonEra = currentYear > 0;
    const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    let result;
    if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
    }
    else {
        const rangeEnd = absCurrentYear + 50;
        const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
        const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
class YearParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 130;
        this.incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
    }
    parse(dateString, token, match2) {
        const valueCallback = (year) => ({
            year,
            isTwoDigitYear: token === "yy"
        });
        switch (token) {
            case "y":
                return mapValue(parseNDigits(4, dateString), valueCallback);
            case "yo":
                return mapValue(match2.ordinalNumber(dateString, {
                    unit: "year"
                }), valueCallback);
            default:
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
    }
    validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
    }
    set(date, flags, value) {
        const currentYear = date.getFullYear();
        if (value.isTwoDigitYear) {
            const normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setFullYear(normalizedTwoDigitYear, 0, 1);
            date.setHours(0, 0, 0, 0);
            return date;
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class LocalWeekYearParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 130;
        this.incompatibleTokens = [
            "y",
            "R",
            "u",
            "Q",
            "q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "i",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        const valueCallback = (year) => ({
            year,
            isTwoDigitYear: token === "YY"
        });
        switch (token) {
            case "Y":
                return mapValue(parseNDigits(4, dateString), valueCallback);
            case "Yo":
                return mapValue(match2.ordinalNumber(dateString, {
                    unit: "year"
                }), valueCallback);
            default:
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
    }
    validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
    }
    set(date, flags, value, options2) {
        const currentYear = getWeekYear(date, options2);
        if (value.isTwoDigitYear) {
            const normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setFullYear(normalizedTwoDigitYear, 0, options2.firstWeekContainsDate);
            date.setHours(0, 0, 0, 0);
            return startOfWeek(date, options2);
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, options2.firstWeekContainsDate);
        date.setHours(0, 0, 0, 0);
        return startOfWeek(date, options2);
    }
}
class ISOWeekYearParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 130;
        this.incompatibleTokens = [
            "G",
            "y",
            "Y",
            "u",
            "Q",
            "q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token) {
        if (token === "R") {
            return parseNDigitsSigned(4, dateString);
        }
        return parseNDigitsSigned(token.length, dateString);
    }
    set(date, _flags, value) {
        const firstWeekOfYear = constructFrom(date, 0);
        firstWeekOfYear.setFullYear(value, 0, 4);
        firstWeekOfYear.setHours(0, 0, 0, 0);
        return startOfISOWeek(firstWeekOfYear);
    }
}
class ExtendedYearParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 130;
        this.incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
    }
    parse(dateString, token) {
        if (token === "u") {
            return parseNDigitsSigned(4, dateString);
        }
        return parseNDigitsSigned(token.length, dateString);
    }
    set(date, _flags, value) {
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class QuarterParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 120;
        this.incompatibleTokens = [
            "Y",
            "R",
            "q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        switch (token) {
            // 1, 2, 3, 4
            case "Q":
            case "QQ":
                return parseNDigits(token.length, dateString);
            // 1st, 2nd, 3rd, 4th
            case "Qo":
                return match2.ordinalNumber(dateString, { unit: "quarter" });
            // Q1, Q2, Q3, Q4
            case "QQQ":
                return match2.quarter(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.quarter(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "QQQQQ":
                return match2.quarter(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1st quarter, 2nd quarter, ...
            case "QQQQ":
            default:
                return match2.quarter(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match2.quarter(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.quarter(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 4;
    }
    set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class StandAloneQuarterParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 120;
        this.incompatibleTokens = [
            "Y",
            "R",
            "Q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        switch (token) {
            // 1, 2, 3, 4
            case "q":
            case "qq":
                return parseNDigits(token.length, dateString);
            // 1st, 2nd, 3rd, 4th
            case "qo":
                return match2.ordinalNumber(dateString, { unit: "quarter" });
            // Q1, Q2, Q3, Q4
            case "qqq":
                return match2.quarter(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match2.quarter(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "qqqqq":
                return match2.quarter(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1st quarter, 2nd quarter, ...
            case "qqqq":
            default:
                return match2.quarter(dateString, {
                    width: "wide",
                    context: "standalone"
                }) || match2.quarter(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match2.quarter(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 4;
    }
    set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class MonthParser extends Parser {
    constructor() {
        super(...arguments);
        this.incompatibleTokens = [
            "Y",
            "R",
            "q",
            "Q",
            "L",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ];
        this.priority = 110;
    }
    parse(dateString, token, match2) {
        const valueCallback = (value) => value - 1;
        switch (token) {
            // 1, 2, ..., 12
            case "M":
                return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
            // 01, 02, ..., 12
            case "MM":
                return mapValue(parseNDigits(2, dateString), valueCallback);
            // 1st, 2nd, ..., 12th
            case "Mo":
                return mapValue(match2.ordinalNumber(dateString, {
                    unit: "month"
                }), valueCallback);
            // Jan, Feb, ..., Dec
            case "MMM":
                return match2.month(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.month(dateString, { width: "narrow", context: "formatting" });
            // J, F, ..., D
            case "MMMMM":
                return match2.month(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // January, February, ..., December
            case "MMMM":
            default:
                return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.month(dateString, { width: "narrow", context: "formatting" });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class StandAloneMonthParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 110;
        this.incompatibleTokens = [
            "Y",
            "R",
            "q",
            "Q",
            "M",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        const valueCallback = (value) => value - 1;
        switch (token) {
            // 1, 2, ..., 12
            case "L":
                return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
            // 01, 02, ..., 12
            case "LL":
                return mapValue(parseNDigits(2, dateString), valueCallback);
            // 1st, 2nd, ..., 12th
            case "Lo":
                return mapValue(match2.ordinalNumber(dateString, {
                    unit: "month"
                }), valueCallback);
            // Jan, Feb, ..., Dec
            case "LLL":
                return match2.month(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match2.month(dateString, { width: "narrow", context: "standalone" });
            // J, F, ..., D
            case "LLLLL":
                return match2.month(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // January, February, ..., December
            case "LLLL":
            default:
                return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match2.month(dateString, { width: "narrow", context: "standalone" });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
function setWeek(date, week2, options2) {
    const date_ = toDate(date, options2?.in);
    const diff2 = getWeek(date_, options2) - week2;
    date_.setDate(date_.getDate() - diff2 * 7);
    return toDate(date_, options2?.in);
}
class LocalWeekParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 100;
        this.incompatibleTokens = [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "i",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "w":
                return parseNumericPattern(numericPatterns.week, dateString);
            case "wo":
                return match2.ordinalNumber(dateString, { unit: "week" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 53;
    }
    set(date, _flags, value, options2) {
        return startOfWeek(setWeek(date, value, options2), options2);
    }
}
function setISOWeek(date, week2, options2) {
    const _date = toDate(date, options2?.in);
    const diff2 = getISOWeek(_date, options2) - week2;
    _date.setDate(_date.getDate() - diff2 * 7);
    return _date;
}
class ISOWeekParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 100;
        this.incompatibleTokens = [
            "y",
            "Y",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "I":
                return parseNumericPattern(numericPatterns.week, dateString);
            case "Io":
                return match2.ordinalNumber(dateString, { unit: "week" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 53;
    }
    set(date, _flags, value) {
        return startOfISOWeek(setISOWeek(date, value));
    }
}
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
class DateParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 90;
        this.subPriority = 1;
        this.incompatibleTokens = [
            "Y",
            "R",
            "q",
            "Q",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "d":
                return parseNumericPattern(numericPatterns.date, dateString);
            case "do":
                return match2.ordinalNumber(dateString, { unit: "date" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear2 = isLeapYearIndex$1(year);
        const month = date.getMonth();
        if (isLeapYear2) {
            return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        }
        else {
            return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
    }
    set(date, _flags, value) {
        date.setDate(value);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class DayOfYearParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 90;
        this.subpriority = 1;
        this.incompatibleTokens = [
            "Y",
            "R",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "E",
            "i",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "D":
            case "DD":
                return parseNumericPattern(numericPatterns.dayOfYear, dateString);
            case "Do":
                return match2.ordinalNumber(dateString, { unit: "date" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear2 = isLeapYearIndex$1(year);
        if (isLeapYear2) {
            return value >= 1 && value <= 366;
        }
        else {
            return value >= 1 && value <= 365;
        }
    }
    set(date, _flags, value) {
        date.setMonth(0, value);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
function setDay(date, day, options2) {
    const defaultOptions2 = getDefaultOptions$1();
    const weekStartsOn = options2?.weekStartsOn ?? options2?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const date_ = toDate(date, options2?.in);
    const currentDay2 = date_.getDay();
    const remainder = day % 7;
    const dayIndex = (remainder + 7) % 7;
    const delta = 7 - weekStartsOn;
    const diff2 = day < 0 || day > 6 ? day - (currentDay2 + delta) % 7 : (dayIndex + delta) % 7 - (currentDay2 + delta) % 7;
    return addDays$1(date_, diff2, options2);
}
class DayParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 90;
        this.incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            // Tue
            case "E":
            case "EE":
            case "EEE":
                return match2.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
            // T
            case "EEEEE":
                return match2.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "EEEEEE":
                return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
            // Tuesday
            case "EEEE":
            default:
                return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options2) {
        date = setDay(date, value, options2);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class LocalDayParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 90;
        this.incompatibleTokens = [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "E",
            "i",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2, options2) {
        const valueCallback = (value) => {
            const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
            // 3
            case "e":
            case "ee":
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            // 3rd
            case "eo":
                return mapValue(match2.ordinalNumber(dateString, {
                    unit: "day"
                }), valueCallback);
            // Tue
            case "eee":
                return match2.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
            // T
            case "eeeee":
                return match2.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "eeeeee":
                return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
            // Tuesday
            case "eeee":
            default:
                return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options2) {
        date = setDay(date, value, options2);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class StandAloneLocalDayParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 90;
        this.incompatibleTokens = [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "E",
            "i",
            "e",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2, options2) {
        const valueCallback = (value) => {
            const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
            // 3
            case "c":
            case "cc":
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            // 3rd
            case "co":
                return mapValue(match2.ordinalNumber(dateString, {
                    unit: "day"
                }), valueCallback);
            // Tue
            case "ccc":
                return match2.day(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
            // T
            case "ccccc":
                return match2.day(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // Tu
            case "cccccc":
                return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
            // Tuesday
            case "cccc":
            default:
                return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options2) {
        date = setDay(date, value, options2);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
function setISODay(date, day, options2) {
    const date_ = toDate(date, options2?.in);
    const currentDay2 = getISODay(date_, options2);
    const diff2 = day - currentDay2;
    return addDays$1(date_, diff2, options2);
}
class ISODayParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 90;
        this.incompatibleTokens = [
            "y",
            "Y",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "E",
            "e",
            "c",
            "t",
            "T"
        ];
    }
    parse(dateString, token, match2) {
        const valueCallback = (value) => {
            if (value === 0) {
                return 7;
            }
            return value;
        };
        switch (token) {
            // 2
            case "i":
            case "ii":
                return parseNDigits(token.length, dateString);
            // 2nd
            case "io":
                return match2.ordinalNumber(dateString, { unit: "day" });
            // Tue
            case "iii":
                return mapValue(match2.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match2.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
            // T
            case "iiiii":
                return mapValue(match2.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
            // Tu
            case "iiiiii":
                return mapValue(match2.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match2.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
            // Tuesday
            case "iiii":
            default:
                return mapValue(match2.day(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match2.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match2.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 7;
    }
    set(date, _flags, value) {
        date = setISODay(date, value);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
class AMPMParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 80;
        this.incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "a":
            case "aa":
            case "aaa":
                return match2.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaaa":
                return match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return match2.dayPeriod(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    set(date, _flags, value) {
        date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
    }
}
class AMPMMidnightParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 80;
        this.incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "b":
            case "bb":
            case "bbb":
                return match2.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbbb":
                return match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return match2.dayPeriod(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    set(date, _flags, value) {
        date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
    }
}
class DayPeriodParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 80;
        this.incompatibleTokens = ["a", "b", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "B":
            case "BB":
            case "BBB":
                return match2.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBBB":
                return match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return match2.dayPeriod(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match2.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    set(date, _flags, value) {
        date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
    }
}
class Hour1to12Parser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 70;
        this.incompatibleTokens = ["H", "K", "k", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "h":
                return parseNumericPattern(numericPatterns.hour12h, dateString);
            case "ho":
                return match2.ordinalNumber(dateString, { unit: "hour" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 12;
    }
    set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) {
            date.setHours(value + 12, 0, 0, 0);
        }
        else if (!isPM && value === 12) {
            date.setHours(0, 0, 0, 0);
        }
        else {
            date.setHours(value, 0, 0, 0);
        }
        return date;
    }
}
class Hour0to23Parser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 70;
        this.incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "H":
                return parseNumericPattern(numericPatterns.hour23h, dateString);
            case "Ho":
                return match2.ordinalNumber(dateString, { unit: "hour" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 23;
    }
    set(date, _flags, value) {
        date.setHours(value, 0, 0, 0);
        return date;
    }
}
class Hour0To11Parser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 70;
        this.incompatibleTokens = ["h", "H", "k", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "K":
                return parseNumericPattern(numericPatterns.hour11h, dateString);
            case "Ko":
                return match2.ordinalNumber(dateString, { unit: "hour" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) {
            date.setHours(value + 12, 0, 0, 0);
        }
        else {
            date.setHours(value, 0, 0, 0);
        }
        return date;
    }
}
class Hour1To24Parser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 70;
        this.incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "k":
                return parseNumericPattern(numericPatterns.hour24h, dateString);
            case "ko":
                return match2.ordinalNumber(dateString, { unit: "hour" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 24;
    }
    set(date, _flags, value) {
        const hours = value <= 24 ? value % 24 : value;
        date.setHours(hours, 0, 0, 0);
        return date;
    }
}
class MinuteParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 60;
        this.incompatibleTokens = ["t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "m":
                return parseNumericPattern(numericPatterns.minute, dateString);
            case "mo":
                return match2.ordinalNumber(dateString, { unit: "minute" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 59;
    }
    set(date, _flags, value) {
        date.setMinutes(value, 0, 0);
        return date;
    }
}
class SecondParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 50;
        this.incompatibleTokens = ["t", "T"];
    }
    parse(dateString, token, match2) {
        switch (token) {
            case "s":
                return parseNumericPattern(numericPatterns.second, dateString);
            case "so":
                return match2.ordinalNumber(dateString, { unit: "second" });
            default:
                return parseNDigits(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 59;
    }
    set(date, _flags, value) {
        date.setSeconds(value, 0);
        return date;
    }
}
class FractionOfSecondParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 30;
        this.incompatibleTokens = ["t", "T"];
    }
    parse(dateString, token) {
        const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
    set(date, _flags, value) {
        date.setMilliseconds(value);
        return date;
    }
}
class ISOTimezoneWithZParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 10;
        this.incompatibleTokens = ["t", "T", "x"];
    }
    parse(dateString, token) {
        switch (token) {
            case "X":
                return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "XX":
                return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "XXXX":
                return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "XXXXX":
                return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "XXX":
            default:
                return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
    }
    set(date, flags, value) {
        if (flags.timestampIsSet)
            return date;
        return constructFrom(date, date.getTime() - getTimezoneOffsetInMilliseconds(date) - value);
    }
}
class ISOTimezoneParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 10;
        this.incompatibleTokens = ["t", "T", "X"];
    }
    parse(dateString, token) {
        switch (token) {
            case "x":
                return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "xx":
                return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "xxxx":
                return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "xxxxx":
                return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "xxx":
            default:
                return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
    }
    set(date, flags, value) {
        if (flags.timestampIsSet)
            return date;
        return constructFrom(date, date.getTime() - getTimezoneOffsetInMilliseconds(date) - value);
    }
}
class TimestampSecondsParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 40;
        this.incompatibleTokens = "*";
    }
    parse(dateString) {
        return parseAnyDigitsSigned(dateString);
    }
    set(date, _flags, value) {
        return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
    }
}
class TimestampMillisecondsParser extends Parser {
    constructor() {
        super(...arguments);
        this.priority = 20;
        this.incompatibleTokens = "*";
    }
    parse(dateString) {
        return parseAnyDigitsSigned(dateString);
    }
    set(date, _flags, value) {
        return [constructFrom(date, value), { timestampIsSet: true }];
    }
}
const parsers = {
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser()
};
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse$1(dateStr, formatStr, referenceDate, options2) {
    const invalidDate = () => constructFrom(referenceDate, NaN);
    const defaultOptions2 = getDefaultOptions();
    const locale = defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const subFnOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
    };
    const setters = [new DateTimezoneSetter(options2?.in, referenceDate)];
    const tokens = formatStr.match(longFormattingTokensRegExp).map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter in longFormatters) {
            const longFormatter = longFormatters[firstCharacter];
            return longFormatter(substring, locale.formatLong);
        }
        return substring;
    }).join("").match(formattingTokensRegExp);
    const usedTokens = [];
    for (let token of tokens) {
        if (isProtectedWeekYearToken(token)) {
            warnOrThrowProtectedError(token, formatStr, dateStr);
        }
        if (isProtectedDayOfYearToken(token)) {
            warnOrThrowProtectedError(token, formatStr, dateStr);
        }
        const firstCharacter = token[0];
        const parser2 = parsers[firstCharacter];
        if (parser2) {
            const { incompatibleTokens } = parser2;
            if (Array.isArray(incompatibleTokens)) {
                const incompatibleToken = usedTokens.find((usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter);
                if (incompatibleToken) {
                    throw new RangeError(`The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`);
                }
            }
            else if (parser2.incompatibleTokens === "*" && usedTokens.length > 0) {
                throw new RangeError(`The format string mustn't contain \`${token}\` and any other token at the same time`);
            }
            usedTokens.push({ token: firstCharacter, fullToken: token });
            const parseResult = parser2.run(dateStr, token, locale.match, subFnOptions);
            if (!parseResult) {
                return invalidDate();
            }
            setters.push(parseResult.setter);
            dateStr = parseResult.rest;
        }
        else {
            if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
                throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
            }
            if (token === "''") {
                token = "'";
            }
            else if (firstCharacter === "'") {
                token = cleanEscapedString(token);
            }
            if (dateStr.indexOf(token) === 0) {
                dateStr = dateStr.slice(token.length);
            }
            else {
                return invalidDate();
            }
        }
    }
    if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
        return invalidDate();
    }
    const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index, array) => array.indexOf(priority) === index).map((priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)).map((setterArray) => setterArray[0]);
    let date = toDate(referenceDate, options2?.in);
    if (isNaN(+date))
        return invalidDate();
    const flags = {};
    for (const setter of uniquePrioritySetters) {
        if (!setter.validate(date, subFnOptions)) {
            return invalidDate();
        }
        const result = setter.set(date, flags, subFnOptions);
        if (Array.isArray(result)) {
            date = result[0];
            Object.assign(flags, result[1]);
        }
        else {
            date = result;
        }
    }
    return date;
}
function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function isSameWeek(laterDate, earlierDate, options2) {
    const [laterDate_, earlierDate_] = normalizeDates(options2?.in, laterDate, earlierDate);
    return +startOfWeek(laterDate_, options2) === +startOfWeek(earlierDate_, options2);
}
function subDays$1(date, amount, options2) {
    return addDays$1(date, -amount, options2);
}
function nextDay(date, day, options2) {
    let delta = day - getDay$1(date, options2);
    if (delta <= 0)
        delta += 7;
    return addDays$1(date, delta, options2);
}
function nextMonday(date, options2) {
    return nextDay(date, 1, options2);
}
function parseISO(argument, options2) {
    const invalidDate = () => constructFrom(options2?.in, NaN);
    const additionalDigits = 2;
    const dateStrings = splitDateString(argument);
    let date;
    if (dateStrings.date) {
        const parseYearResult = parseYear$1(dateStrings.date, additionalDigits);
        date = parseDate$2(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(+date))
        return invalidDate();
    const timestamp = +date;
    let time = 0;
    let offset;
    if (dateStrings.time) {
        time = parseTime(dateStrings.time);
        if (isNaN(time))
            return invalidDate();
    }
    if (dateStrings.timezone) {
        offset = parseTimezone(dateStrings.timezone);
        if (isNaN(offset))
            return invalidDate();
    }
    else {
        const tmpDate = new Date(timestamp + time);
        const result = toDate(0, options2?.in);
        result.setFullYear(tmpDate.getUTCFullYear(), tmpDate.getUTCMonth(), tmpDate.getUTCDate());
        result.setHours(tmpDate.getUTCHours(), tmpDate.getUTCMinutes(), tmpDate.getUTCSeconds(), tmpDate.getUTCMilliseconds());
        return result;
    }
    return toDate(timestamp + time + offset, options2?.in);
}
const patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
};
const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
    const dateStrings = {};
    const array = dateString.split(patterns.dateTimeDelimiter);
    let timeString;
    if (array.length > 2) {
        return dateStrings;
    }
    if (/:/.test(array[0])) {
        timeString = array[0];
    }
    else {
        dateStrings.date = array[0];
        timeString = array[1];
        if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
        }
    }
    if (timeString) {
        const token = patterns.timezone.exec(timeString);
        if (token) {
            dateStrings.time = timeString.replace(token[1], "");
            dateStrings.timezone = token[1];
        }
        else {
            dateStrings.time = timeString;
        }
    }
    return dateStrings;
}
function parseYear$1(dateString, additionalDigits) {
    const regex2 = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    const captures = dateString.match(regex2);
    if (!captures)
        return { year: NaN, restDateString: "" };
    const year = captures[1] ? parseInt(captures[1]) : null;
    const century = captures[2] ? parseInt(captures[2]) : null;
    return {
        year: century === null ? year : century * 100,
        restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
}
function parseDate$2(dateString, year) {
    if (year === null)
        return /* @__PURE__ */ new Date(NaN);
    const captures = dateString.match(dateRegex);
    if (!captures)
        return /* @__PURE__ */ new Date(NaN);
    const isWeekDate = !!captures[4];
    const dayOfYear = parseDateUnit(captures[1]);
    const month = parseDateUnit(captures[2]) - 1;
    const day = parseDateUnit(captures[3]);
    const week2 = parseDateUnit(captures[4]);
    const dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
        if (!validateWeekDate(year, week2, dayOfWeek)) {
            return /* @__PURE__ */ new Date(NaN);
        }
        return dayOfISOWeekYear(year, week2, dayOfWeek);
    }
    else {
        const date = /* @__PURE__ */ new Date(0);
        if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
            return /* @__PURE__ */ new Date(NaN);
        }
        date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
        return date;
    }
}
function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
    const captures = timeString.match(timeRegex);
    if (!captures)
        return NaN;
    const hours = parseTimeUnit(captures[1]);
    const minutes = parseTimeUnit(captures[2]);
    const seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
        return NaN;
    }
    return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
    if (timezoneString === "Z")
        return 0;
    const captures = timezoneString.match(timezoneRegex);
    if (!captures)
        return 0;
    const sign2 = captures[1] === "+" ? -1 : 1;
    const hours = parseInt(captures[2]);
    const minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
        return NaN;
    }
    return sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week2, day) {
    const date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    const fourthOfJanuaryDay = date.getUTCDay() || 7;
    const diff2 = (week2 - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff2);
    return date;
}
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week2, day) {
    return week2 >= 1 && week2 <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
        return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
}
function previousDay(date, day, options2) {
    let delta = getDay$1(date, options2) - day;
    if (delta <= 0)
        delta += 7;
    return subDays$1(date, delta, options2);
}
function previousFriday(date, options2) {
    return previousDay(date, 5, options2);
}
function subMonths$1(date, amount, options2) {
    return addMonths$1(date, -amount, options2);
}
function subWeeks$1(date, amount, options2) {
    return addWeeks$1(date, -amount, options2);
}
function subYears(date, amount, options2) {
    return addYears$1(date, -amount, options2);
}
const os = require("os");
os.platform() === "win32";
os.platform() === "darwin";
os.platform() === "linux";
const isPlaywright = false;
const isBrowser = false;
function _parse(value) {
    if (typeof value === "string") {
        const [year, month, day] = value.split("-");
        if (day != null) {
            return new Date(parseInt(year), parseInt(month) - 1, parseInt(day), 12);
        }
        else if (month != null) {
            return new Date(parseInt(year), parseInt(month) - 1, 1, 12);
        }
        else {
            return new Date(parseInt(year), 0, 1, 12);
        }
    }
    if (typeof value === "number") {
        return new Date(value);
    }
    return value;
}
const parseDate$1 = _parse;
function yearFromDate(date) {
    return format$1(_parse(date), "yyyy");
}
function monthFromDate(date) {
    return format$1(_parse(date), "yyyy-MM");
}
function dayFromDate(date) {
    return format$1(_parse(date), "yyyy-MM-dd");
}
function currentMonth() {
    if (global.IS_TESTING || isPlaywright) {
        return global.currentMonth || "2017-01";
    }
    else {
        return format$1(/* @__PURE__ */ new Date(), "yyyy-MM");
    }
}
function currentDate() {
    if (global.IS_TESTING || isPlaywright) {
        return parse$1(currentDay(), "yyyy-MM-dd", /* @__PURE__ */ new Date());
    }
    return /* @__PURE__ */ new Date();
}
function currentDay() {
    if (global.IS_TESTING || isPlaywright) {
        return "2017-01-01";
    }
    else {
        return format$1(/* @__PURE__ */ new Date(), "yyyy-MM-dd");
    }
}
function nextMonth(month) {
    return format$1(addMonths$1(_parse(month), 1), "yyyy-MM");
}
function prevMonth(month) {
    return format$1(subMonths$1(_parse(month), 1), "yyyy-MM");
}
function addYears(year, n) {
    return format$1(addYears$1(_parse(year), n), "yyyy");
}
function addMonths(month, n) {
    return format$1(addMonths$1(_parse(month), n), "yyyy-MM");
}
function addWeeks(date, n) {
    return format$1(addWeeks$1(_parse(date), n), "yyyy-MM-dd");
}
function differenceInCalendarMonths(month1, month2) {
    return differenceInCalendarMonths$1(_parse(month1), _parse(month2));
}
function differenceInCalendarDays(month1, month2) {
    return differenceInCalendarDays$1(_parse(month1), _parse(month2));
}
function subMonths(month, n) {
    return format$1(subMonths$1(_parse(month), n), "yyyy-MM");
}
function subWeeks(date, n) {
    return format$1(subWeeks$1(_parse(date), n), "yyyy-MM-dd");
}
function addDays(day, n) {
    return format$1(addDays$1(_parse(day), n), "yyyy-MM-dd");
}
function subDays(day, n) {
    return format$1(subDays$1(_parse(day), n), "yyyy-MM-dd");
}
function isBefore(month1, month2) {
    return isBefore$1(_parse(month1), _parse(month2));
}
function isAfter(month1, month2) {
    return isAfter$1(_parse(month1), _parse(month2));
}
function bounds(month) {
    return {
        start: parseInt(format$1(startOfMonth(_parse(month)), "yyyyMMdd")),
        end: parseInt(format$1(endOfMonth(_parse(month)), "yyyyMMdd"))
    };
}
function _range(start, end, inclusive = false) {
    const months = [];
    let month = monthFromDate(start);
    const endMonth = monthFromDate(end);
    while (isBefore$1(_parse(month), _parse(endMonth))) {
        months.push(month);
        month = addMonths(month, 1);
    }
    if (inclusive) {
        months.push(month);
    }
    return months;
}
function range$1(start, end) {
    return _range(start, end);
}
function rangeInclusive(start, end) {
    return _range(start, end, true);
}
function getMonth(day) {
    return day.slice(0, 7);
}
function getDay(day) {
    return Number(format$1(_parse(day), "dd"));
}
function getMonthEnd(day) {
    return subDays(nextMonth(day.slice(0, 7)) + "-01", 1);
}
function sheetForMonth(month) {
    return "budget" + month.replace("-", "");
}
function format(month, format2, locale) {
    return format$1(_parse(month), format2, { locale });
}
function last(arr) {
    return arr[arr.length - 1];
}
function getChangedValues(obj1, obj2) {
    const diff2 = {};
    const keys2 = Object.keys(obj2);
    let hasChanged = false;
    if (obj1.id) {
        diff2.id = obj1.id;
    }
    for (let i = 0; i < keys2.length; i++) {
        const key = keys2[i];
        if (obj1[key] !== obj2[key]) {
            diff2[key] = obj2[key];
            hasChanged = true;
        }
    }
    return hasChanged ? diff2 : null;
}
function hasFieldsChanged(obj1, obj2, fields) {
    let changed = false;
    for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        if (obj1[field] !== obj2[field]) {
            changed = true;
            break;
        }
    }
    return changed;
}
function partitionByField(data, field) {
    const res = /* @__PURE__ */ new Map();
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const key = item[field];
        const items = res.get(key) || [];
        items.push(item);
        res.set(key, items);
    }
    return res;
}
function groupBy(data, field) {
    const res = /* @__PURE__ */ new Map();
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const key = item[field];
        const existing = res.get(key) || [];
        res.set(key, existing.concat([item]));
    }
    return res;
}
function _groupById(data) {
    const res = /* @__PURE__ */ new Map();
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        res.set(item.id, item);
    }
    return res;
}
function diffItems(items, newItems) {
    const grouped = _groupById(items);
    const newGrouped = _groupById(newItems);
    const added = [];
    const updated = [];
    const deleted = items.filter((item) => !newGrouped.has(item.id)).map((item) => ({ id: item.id }));
    newItems.forEach((newItem) => {
        const item = grouped.get(newItem.id);
        if (!item) {
            added.push(newItem);
        }
        else {
            const changes = getChangedValues(item, newItem);
            if (changes) {
                updated.push(changes);
            }
        }
    });
    return { added, updated, deleted };
}
function groupById(data) {
    if (!data) {
        return {};
    }
    const res = {};
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        res[item.id] = item;
    }
    return res;
}
function setIn(map, keys2, item) {
    for (let i = 0; i < keys2.length; i++) {
        const key = keys2[i];
        if (i === keys2.length - 1) {
            map.set(key, item);
        }
        else {
            if (!map.has(key)) {
                map.set(key, /* @__PURE__ */ new Map());
            }
            map = map.get(key);
        }
    }
}
function getIn(map, keys2) {
    let item = map;
    for (let i = 0; i < keys2.length; i++) {
        item = item.get(keys2[i]);
        if (item == null) {
            return item;
        }
    }
    return item;
}
function fastSetMerge(set1, set2) {
    const finalSet = new Set(set1);
    const iter = set2.values();
    let value = iter.next();
    while (!value.done) {
        finalSet.add(value.value);
        value = iter.next();
    }
    return finalSet;
}
let numberFormatConfig = {
    format: "comma-dot",
    hideFraction: false
};
function getNumberFormat({ format: format2 = numberFormatConfig.format, hideFraction = numberFormatConfig.hideFraction, decimalPlaces } = numberFormatConfig) {
    let locale, thousandsSeparator, decimalSeparator;
    const currentFormat = format2 || numberFormatConfig.format;
    const currentHideFraction = typeof hideFraction === "boolean" ? hideFraction : numberFormatConfig.hideFraction;
    switch (format2) {
        case "space-comma":
            locale = "en-SE";
            thousandsSeparator = "";
            decimalSeparator = ",";
            break;
        case "dot-comma":
            locale = "de-DE";
            thousandsSeparator = ".";
            decimalSeparator = ",";
            break;
        case "apostrophe-dot":
            locale = "de-CH";
            thousandsSeparator = "";
            decimalSeparator = ".";
            break;
        case "comma-dot-in":
            locale = "en-IN";
            thousandsSeparator = ",";
            decimalSeparator = ".";
            break;
        case "comma-dot":
        default:
            locale = "en-US";
            thousandsSeparator = ",";
            decimalSeparator = ".";
    }
    const fractionDigitsOptions = typeof decimalPlaces === "number" ? {
        minimumFractionDigits: decimalPlaces,
        maximumFractionDigits: decimalPlaces
    } : {
        minimumFractionDigits: currentHideFraction ? 0 : 2,
        maximumFractionDigits: currentHideFraction ? 0 : 2
    };
    return {
        value: currentFormat,
        thousandsSeparator,
        decimalSeparator,
        formatter: new Intl.NumberFormat(locale, fractionDigitsOptions)
    };
}
const MAX_SAFE_NUMBER = 2 ** 51 - 1;
const MIN_SAFE_NUMBER = -2251799813685247;
function safeNumber(value) {
    if (!Number.isInteger(value)) {
        throw new Error("safeNumber: number is not an integer: " + JSON.stringify(value));
    }
    if (value > MAX_SAFE_NUMBER || value < MIN_SAFE_NUMBER) {
        throw new Error("safeNumber: cant safely perform arithmetic with number: " + value);
    }
    return value;
}
function integerToCurrency(integerAmount, formatter = getNumberFormat().formatter, decimalPlaces = 2) {
    const divisor = Math.pow(10, decimalPlaces);
    const amount = safeNumber(integerAmount) / divisor;
    return formatter.format(amount);
}
function stringToInteger(str) {
    const amount = parseInt(str.replace(/[^-0-9.,]/g, ""));
    if (!isNaN(amount)) {
        return amount;
    }
    return null;
}
function amountToInteger$1(amount, decimalPlaces = 2) {
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.round(amount * multiplier);
}
function integerToAmount(integerAmount, decimalPlaces = 2) {
    const divisor = Math.pow(10, decimalPlaces);
    return integerAmount / divisor;
}
function looselyParseAmount(amount) {
    function safeNumber2(v) {
        if (isNaN(v)) {
            return null;
        }
        const value = v * 100;
        if (value > MAX_SAFE_NUMBER || value < MIN_SAFE_NUMBER) {
            return null;
        }
        return v;
    }
    function extractNumbers(v) {
        return v.replace(/[^0-9-]/g, "");
    }
    if (amount.startsWith("(") && amount.endsWith(")")) {
        amount = amount.replace("(", "-").replace(")", "");
    }
    const m = amount.match(/[.,]([^.,]{4,9}|[^.,]{1,2})$/);
    if (!m || m.index === void 0) {
        return safeNumber2(parseFloat(extractNumbers(amount)));
    }
    const left = extractNumbers(amount.slice(0, m.index));
    const right = extractNumbers(amount.slice(m.index + 1));
    return safeNumber2(parseFloat(left + "." + right));
}
function sortByKey(arr, key) {
    return [...arr].sort((item1, item2) => {
        if (item1[key] < item2[key]) {
            return -1;
        }
        else if (item1[key] > item2[key]) {
            return 1;
        }
        return 0;
    });
}
function mitt(n) {
    return { all: n = n || /* @__PURE__ */ new Map(), on: function (t2, e) {
            var i = n.get(t2);
            i ? i.push(e) : n.set(t2, [e]);
        }, off: function (t2, e) {
            var i = n.get(t2);
            i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t2, []));
        }, emit: function (t2, e) {
            var i = n.get(t2);
            i && i.slice().map(function (n2) {
                n2(e);
            }), (i = n.get("*")) && i.slice().map(function (n2) {
                n2(t2, e);
            });
        } };
}
class App {
    constructor() {
        this.handlers = {};
        this.services = [];
        this.events = mitt();
        this.unlistenServices = [];
    }
    method(name, func) {
        if (this.handlers[name] != null) {
            throw new Error("Conflicting method name, names must be globally unique: " + name);
        }
        this.handlers[name] = func;
    }
    service(func) {
        this.services.push(func);
    }
    combine(...apps) {
        for (const app2 of apps) {
            Object.keys(app2.handlers).forEach((name) => {
                this.method(name, app2.handlers[name]);
            });
            app2.services.forEach((service) => {
                this.service(service);
            });
            for (const [name, listeners] of app2.events.all.entries()) {
                for (const listener of listeners) {
                    this.events.on(name, listener);
                }
            }
        }
    }
    startServices() {
        if (this.unlistenServices.length > 0) {
            captureException(new Error("App: startServices called while services are already running"));
        }
        this.unlistenServices = this.services.map((service) => service());
    }
    stopServices() {
        this.unlistenServices.forEach((unlisten2) => {
            if (unlisten2) {
                unlisten2();
            }
        });
        this.unlistenServices = [];
    }
}
function createApp() {
    return new App();
}
var jspb = require("google-protobuf");
var goog = jspb;
var global$1 = globalThis;
goog.exportSymbol("proto.EncryptedData", null, global$1);
goog.exportSymbol("proto.Message", null, global$1);
goog.exportSymbol("proto.MessageEnvelope", null, global$1);
goog.exportSymbol("proto.SyncRequest", null, global$1);
goog.exportSymbol("proto.SyncResponse", null, global$1);
proto.EncryptedData = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EncryptedData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    proto.EncryptedData.displayName = "proto.EncryptedData";
}
proto.Message = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Message, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    proto.Message.displayName = "proto.Message";
}
proto.MessageEnvelope = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.MessageEnvelope, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    proto.MessageEnvelope.displayName = "proto.MessageEnvelope";
}
proto.SyncRequest = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, proto.SyncRequest.repeatedFields_, null);
};
goog.inherits(proto.SyncRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    proto.SyncRequest.displayName = "proto.SyncRequest";
}
proto.SyncResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, proto.SyncResponse.repeatedFields_, null);
};
goog.inherits(proto.SyncResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    proto.SyncResponse.displayName = "proto.SyncResponse";
}
if (jspb.Message.GENERATE_TO_OBJECT) {
    proto.EncryptedData.prototype.toObject = function (opt_includeInstance) {
        return proto.EncryptedData.toObject(opt_includeInstance, this);
    };
    proto.EncryptedData.toObject = function (includeInstance, msg) {
        var obj = {
            iv: msg.getIv_asB64(),
            authtag: msg.getAuthtag_asB64(),
            data: msg.getData_asB64()
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
proto.EncryptedData.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.EncryptedData();
    return proto.EncryptedData.deserializeBinaryFromReader(msg, reader);
};
proto.EncryptedData.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = (
                /** @type {!Uint8Array} */
                reader.readBytes());
                msg.setIv(value);
                break;
            case 2:
                var value = (
                /** @type {!Uint8Array} */
                reader.readBytes());
                msg.setAuthtag(value);
                break;
            case 3:
                var value = (
                /** @type {!Uint8Array} */
                reader.readBytes());
                msg.setData(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
proto.EncryptedData.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.EncryptedData.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
proto.EncryptedData.serializeBinaryToWriter = function (message2, writer) {
    var f2 = void 0;
    f2 = message2.getIv_asU8();
    if (f2.length > 0) {
        writer.writeBytes(1, f2);
    }
    f2 = message2.getAuthtag_asU8();
    if (f2.length > 0) {
        writer.writeBytes(2, f2);
    }
    f2 = message2.getData_asU8();
    if (f2.length > 0) {
        writer.writeBytes(3, f2);
    }
};
proto.EncryptedData.prototype.getIv = function () {
    return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 1, ""));
};
proto.EncryptedData.prototype.getIv_asB64 = function () {
    return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getIv()));
};
proto.EncryptedData.prototype.getIv_asU8 = function () {
    return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getIv()));
};
proto.EncryptedData.prototype.setIv = function (value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
};
proto.EncryptedData.prototype.getAuthtag = function () {
    return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 2, ""));
};
proto.EncryptedData.prototype.getAuthtag_asB64 = function () {
    return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getAuthtag()));
};
proto.EncryptedData.prototype.getAuthtag_asU8 = function () {
    return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getAuthtag()));
};
proto.EncryptedData.prototype.setAuthtag = function (value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
};
proto.EncryptedData.prototype.getData = function () {
    return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 3, ""));
};
proto.EncryptedData.prototype.getData_asB64 = function () {
    return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getData()));
};
proto.EncryptedData.prototype.getData_asU8 = function () {
    return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getData()));
};
proto.EncryptedData.prototype.setData = function (value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    proto.Message.prototype.toObject = function (opt_includeInstance) {
        return proto.Message.toObject(opt_includeInstance, this);
    };
    proto.Message.toObject = function (includeInstance, msg) {
        var obj = {
            dataset: jspb.Message.getFieldWithDefault(msg, 1, ""),
            row: jspb.Message.getFieldWithDefault(msg, 2, ""),
            column: jspb.Message.getFieldWithDefault(msg, 3, ""),
            value: jspb.Message.getFieldWithDefault(msg, 4, "")
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
proto.Message.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.Message();
    return proto.Message.deserializeBinaryFromReader(msg, reader);
};
proto.Message.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setDataset(value);
                break;
            case 2:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setRow(value);
                break;
            case 3:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setColumn(value);
                break;
            case 4:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setValue(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
proto.Message.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.Message.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
proto.Message.serializeBinaryToWriter = function (message2, writer) {
    var f2 = void 0;
    f2 = message2.getDataset();
    if (f2.length > 0) {
        writer.writeString(1, f2);
    }
    f2 = message2.getRow();
    if (f2.length > 0) {
        writer.writeString(2, f2);
    }
    f2 = message2.getColumn();
    if (f2.length > 0) {
        writer.writeString(3, f2);
    }
    f2 = message2.getValue();
    if (f2.length > 0) {
        writer.writeString(4, f2);
    }
};
proto.Message.prototype.getDataset = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, ""));
};
proto.Message.prototype.setDataset = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
proto.Message.prototype.getRow = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, ""));
};
proto.Message.prototype.setRow = function (value) {
    return jspb.Message.setProto3StringField(this, 2, value);
};
proto.Message.prototype.getColumn = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 3, ""));
};
proto.Message.prototype.setColumn = function (value) {
    return jspb.Message.setProto3StringField(this, 3, value);
};
proto.Message.prototype.getValue = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 4, ""));
};
proto.Message.prototype.setValue = function (value) {
    return jspb.Message.setProto3StringField(this, 4, value);
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    proto.MessageEnvelope.prototype.toObject = function (opt_includeInstance) {
        return proto.MessageEnvelope.toObject(opt_includeInstance, this);
    };
    proto.MessageEnvelope.toObject = function (includeInstance, msg) {
        var obj = {
            timestamp: jspb.Message.getFieldWithDefault(msg, 1, ""),
            isencrypted: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
            content: msg.getContent_asB64()
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
proto.MessageEnvelope.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.MessageEnvelope();
    return proto.MessageEnvelope.deserializeBinaryFromReader(msg, reader);
};
proto.MessageEnvelope.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setTimestamp(value);
                break;
            case 2:
                var value = (
                /** @type {boolean} */
                reader.readBool());
                msg.setIsencrypted(value);
                break;
            case 3:
                var value = (
                /** @type {!Uint8Array} */
                reader.readBytes());
                msg.setContent(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
proto.MessageEnvelope.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.MessageEnvelope.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
proto.MessageEnvelope.serializeBinaryToWriter = function (message2, writer) {
    var f2 = void 0;
    f2 = message2.getTimestamp();
    if (f2.length > 0) {
        writer.writeString(1, f2);
    }
    f2 = message2.getIsencrypted();
    if (f2) {
        writer.writeBool(2, f2);
    }
    f2 = message2.getContent_asU8();
    if (f2.length > 0) {
        writer.writeBytes(3, f2);
    }
};
proto.MessageEnvelope.prototype.getTimestamp = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, ""));
};
proto.MessageEnvelope.prototype.setTimestamp = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
proto.MessageEnvelope.prototype.getIsencrypted = function () {
    return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};
proto.MessageEnvelope.prototype.setIsencrypted = function (value) {
    return jspb.Message.setProto3BooleanField(this, 2, value);
};
proto.MessageEnvelope.prototype.getContent = function () {
    return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 3, ""));
};
proto.MessageEnvelope.prototype.getContent_asB64 = function () {
    return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getContent()));
};
proto.MessageEnvelope.prototype.getContent_asU8 = function () {
    return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getContent()));
};
proto.MessageEnvelope.prototype.setContent = function (value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
};
proto.SyncRequest.repeatedFields_ = [1];
if (jspb.Message.GENERATE_TO_OBJECT) {
    proto.SyncRequest.prototype.toObject = function (opt_includeInstance) {
        return proto.SyncRequest.toObject(opt_includeInstance, this);
    };
    proto.SyncRequest.toObject = function (includeInstance, msg) {
        var obj = {
            messagesList: jspb.Message.toObjectList(msg.getMessagesList(), proto.MessageEnvelope.toObject, includeInstance),
            fileid: jspb.Message.getFieldWithDefault(msg, 2, ""),
            groupid: jspb.Message.getFieldWithDefault(msg, 3, ""),
            keyid: jspb.Message.getFieldWithDefault(msg, 5, ""),
            since: jspb.Message.getFieldWithDefault(msg, 6, "")
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
proto.SyncRequest.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.SyncRequest();
    return proto.SyncRequest.deserializeBinaryFromReader(msg, reader);
};
proto.SyncRequest.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = new proto.MessageEnvelope();
                reader.readMessage(value, proto.MessageEnvelope.deserializeBinaryFromReader);
                msg.addMessages(value);
                break;
            case 2:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setFileid(value);
                break;
            case 3:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setGroupid(value);
                break;
            case 5:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setKeyid(value);
                break;
            case 6:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setSince(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
proto.SyncRequest.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.SyncRequest.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
proto.SyncRequest.serializeBinaryToWriter = function (message2, writer) {
    var f2 = void 0;
    f2 = message2.getMessagesList();
    if (f2.length > 0) {
        writer.writeRepeatedMessage(1, f2, proto.MessageEnvelope.serializeBinaryToWriter);
    }
    f2 = message2.getFileid();
    if (f2.length > 0) {
        writer.writeString(2, f2);
    }
    f2 = message2.getGroupid();
    if (f2.length > 0) {
        writer.writeString(3, f2);
    }
    f2 = message2.getKeyid();
    if (f2.length > 0) {
        writer.writeString(5, f2);
    }
    f2 = message2.getSince();
    if (f2.length > 0) {
        writer.writeString(6, f2);
    }
};
proto.SyncRequest.prototype.getMessagesList = function () {
    return (
    /** @type{!Array<!proto.MessageEnvelope>} */
    jspb.Message.getRepeatedWrapperField(this, proto.MessageEnvelope, 1));
};
proto.SyncRequest.prototype.setMessagesList = function (value) {
    return jspb.Message.setRepeatedWrapperField(this, 1, value);
};
proto.SyncRequest.prototype.addMessages = function (opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.MessageEnvelope, opt_index);
};
proto.SyncRequest.prototype.clearMessagesList = function () {
    return this.setMessagesList([]);
};
proto.SyncRequest.prototype.getFileid = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, ""));
};
proto.SyncRequest.prototype.setFileid = function (value) {
    return jspb.Message.setProto3StringField(this, 2, value);
};
proto.SyncRequest.prototype.getGroupid = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 3, ""));
};
proto.SyncRequest.prototype.setGroupid = function (value) {
    return jspb.Message.setProto3StringField(this, 3, value);
};
proto.SyncRequest.prototype.getKeyid = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 5, ""));
};
proto.SyncRequest.prototype.setKeyid = function (value) {
    return jspb.Message.setProto3StringField(this, 5, value);
};
proto.SyncRequest.prototype.getSince = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 6, ""));
};
proto.SyncRequest.prototype.setSince = function (value) {
    return jspb.Message.setProto3StringField(this, 6, value);
};
proto.SyncResponse.repeatedFields_ = [1];
if (jspb.Message.GENERATE_TO_OBJECT) {
    proto.SyncResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.SyncResponse.toObject(opt_includeInstance, this);
    };
    proto.SyncResponse.toObject = function (includeInstance, msg) {
        var obj = {
            messagesList: jspb.Message.toObjectList(msg.getMessagesList(), proto.MessageEnvelope.toObject, includeInstance),
            merkle: jspb.Message.getFieldWithDefault(msg, 2, "")
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
proto.SyncResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.SyncResponse();
    return proto.SyncResponse.deserializeBinaryFromReader(msg, reader);
};
proto.SyncResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = new proto.MessageEnvelope();
                reader.readMessage(value, proto.MessageEnvelope.deserializeBinaryFromReader);
                msg.addMessages(value);
                break;
            case 2:
                var value = (
                /** @type {string} */
                reader.readString());
                msg.setMerkle(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
proto.SyncResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.SyncResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
proto.SyncResponse.serializeBinaryToWriter = function (message2, writer) {
    var f2 = void 0;
    f2 = message2.getMessagesList();
    if (f2.length > 0) {
        writer.writeRepeatedMessage(1, f2, proto.MessageEnvelope.serializeBinaryToWriter);
    }
    f2 = message2.getMerkle();
    if (f2.length > 0) {
        writer.writeString(2, f2);
    }
};
proto.SyncResponse.prototype.getMessagesList = function () {
    return (
    /** @type{!Array<!proto.MessageEnvelope>} */
    jspb.Message.getRepeatedWrapperField(this, proto.MessageEnvelope, 1));
};
proto.SyncResponse.prototype.setMessagesList = function (value) {
    return jspb.Message.setRepeatedWrapperField(this, 1, value);
};
proto.SyncResponse.prototype.addMessages = function (opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.MessageEnvelope, opt_index);
};
proto.SyncResponse.prototype.clearMessagesList = function () {
    return this.setMessagesList([]);
};
proto.SyncResponse.prototype.getMerkle = function () {
    return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, ""));
};
proto.SyncResponse.prototype.setMerkle = function (value) {
    return jspb.Message.setProto3StringField(this, 2, value);
};
goog.object.extend(exports, proto);
function emptyTrie() {
    return { hash: 0 };
}
function isNumberTrieNodeKey(input) {
    return ["0", "1", "2"].includes(input);
}
function getKeys(trie) {
    return Object.keys(trie).filter(isNumberTrieNodeKey);
}
function keyToTimestamp(key) {
    const fullkey = key + "0".repeat(16 - key.length);
    return parseInt(fullkey, 3) * 1e3 * 60;
}
function insert$1(trie, timestamp) {
    const hash = timestamp.hash();
    const key = Number(Math.floor(timestamp.millis() / 1e3 / 60)).toString(3);
    trie = Object.assign({}, trie, { hash: (trie.hash || 0) ^ hash });
    return insertKey(trie, key, hash);
}
function insertKey(trie, key, hash) {
    if (key.length === 0) {
        return trie;
    }
    const c = key[0];
    const t2 = isNumberTrieNodeKey(c) ? trie[c] : void 0;
    const n = t2 || {};
    return Object.assign({}, trie, {
        [c]: Object.assign({}, n, insertKey(n, key.slice(1), hash), {
            hash: (n.hash || 0) ^ hash
        })
    });
}
function diff(trie1, trie2) {
    if (trie1.hash === trie2.hash) {
        return null;
    }
    let node1 = trie1;
    let node2 = trie2;
    let k = "";
    while (1) {
        const keyset = /* @__PURE__ */ new Set([...getKeys(node1), ...getKeys(node2)]);
        const keys2 = [...keyset.values()];
        keys2.sort();
        let diffkey = null;
        for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const next1 = node1[key];
            const next2 = node2[key];
            if (!next1 || !next2) {
                break;
            }
            if (next1.hash !== next2.hash) {
                diffkey = key;
                break;
            }
        }
        if (!diffkey) {
            return keyToTimestamp(k);
        }
        k += diffkey;
        node1 = node1[diffkey] || emptyTrie();
        node2 = node2[diffkey] || emptyTrie();
    }
    return null;
}
function prune(trie, n = 2) {
    if (!trie.hash) {
        return trie;
    }
    const keys2 = getKeys(trie);
    keys2.sort();
    const next = { hash: trie.hash };
    for (const k of keys2.slice(-n)) {
        const node2 = trie[k];
        if (!node2) {
            throw new Error(`TrieNode for key ${k} could not be found`);
        }
        next[k] = prune(node2, n);
    }
    return next;
}
var murmurhash$1 = { exports: {} };
var hasRequiredMurmurhash;
function requireMurmurhash() {
    if (hasRequiredMurmurhash)
        return murmurhash$1.exports;
    hasRequiredMurmurhash = 1;
    (function (module2) {
        (function () {
            const createBuffer = (val2) => new TextEncoder().encode(val2);
            function MurmurHashV2(str, seed) {
                if (typeof str === "string")
                    str = createBuffer(str);
                let l = str.length, h = seed ^ l, i = 0, k;
                while (l >= 4) {
                    k = str[i] & 255 | (str[++i] & 255) << 8 | (str[++i] & 255) << 16 | (str[++i] & 255) << 24;
                    k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
                    k ^= k >>> 24;
                    k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
                    h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16) ^ k;
                    l -= 4;
                    ++i;
                }
                switch (l) {
                    case 3:
                        h ^= (str[i + 2] & 255) << 16;
                    case 2:
                        h ^= (str[i + 1] & 255) << 8;
                    case 1:
                        h ^= str[i] & 255;
                        h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
                }
                h ^= h >>> 13;
                h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
                h ^= h >>> 15;
                return h >>> 0;
            }
            function MurmurHashV3(key, seed) {
                if (typeof key === "string")
                    key = createBuffer(key);
                let remainder, bytes, h1, h1b, c1, c2, k1, i;
                remainder = key.length & 3;
                bytes = key.length - remainder;
                h1 = seed;
                c1 = 3432918353;
                c2 = 461845907;
                i = 0;
                while (i < bytes) {
                    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;
                    ++i;
                    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
                    k1 = k1 << 15 | k1 >>> 17;
                    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
                    h1 ^= k1;
                    h1 = h1 << 13 | h1 >>> 19;
                    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
                    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
                }
                k1 = 0;
                switch (remainder) {
                    case 3:
                        k1 ^= (key[i + 2] & 255) << 16;
                    case 2:
                        k1 ^= (key[i + 1] & 255) << 8;
                    case 1:
                        k1 ^= key[i] & 255;
                        k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
                        h1 ^= k1;
                }
                h1 ^= key.length;
                h1 ^= h1 >>> 16;
                h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
                h1 ^= h1 >>> 13;
                h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
                h1 ^= h1 >>> 16;
                return h1 >>> 0;
            }
            const murmur = MurmurHashV3;
            murmur.v2 = MurmurHashV2;
            murmur.v3 = MurmurHashV3;
            {
                module2.exports = murmur;
            }
        })();
    })(murmurhash$1);
    return murmurhash$1.exports;
}
var murmurhashExports = requireMurmurhash();
const murmurhash = /* @__PURE__ */ getDefaultExportFromCjs(murmurhashExports);
let clock;
function setClock(clock_) {
    clock = clock_;
}
function getClock() {
    return clock;
}
function makeClock(timestamp, merkle = {}) {
    return { timestamp: MutableTimestamp.from(timestamp), merkle };
}
function serializeClock(clock2) {
    return JSON.stringify({
        timestamp: clock2.timestamp.toString(),
        merkle: clock2.merkle
    });
}
function deserializeClock(clock2) {
    let data;
    try {
        data = JSON.parse(clock2);
    }
    catch (e) {
        data = {
            timestamp: "1970-01-01T00:00:00.000Z-0000-" + makeClientId(),
            merkle: {}
        };
    }
    const ts = Timestamp.parse(data.timestamp);
    if (!ts) {
        throw new Timestamp.InvalidError(data.timestamp);
    }
    return {
        timestamp: MutableTimestamp.from(ts),
        merkle: data.merkle
    };
}
function makeClientId() {
    return v4().replace(/-/g, "").slice(-16);
}
const config$1 = {
    // Allow 5 minutes of clock drift
    maxDrift: 5 * 60 * 1e3
};
const MAX_COUNTER = parseInt("0xFFFF");
const MAX_NODE_LENGTH = 16;
class Timestamp {
    constructor(millis, counter, node2) {
        this._state = {
            millis,
            counter,
            node: node2
        };
    }
    valueOf() {
        return this.toString();
    }
    toString() {
        return [
            new Date(this.millis()).toISOString(),
            ("0000" + this.counter().toString(16).toUpperCase()).slice(-4),
            ("0000000000000000" + this.node()).slice(-16)
        ].join("-");
    }
    millis() {
        return this._state.millis;
    }
    counter() {
        return this._state.counter;
    }
    node() {
        return this._state.node;
    }
    hash() {
        return murmurhash.v3(this.toString());
    }
    // Timestamp generator initialization
    // * sets the node ID to an arbitrary value
    // * useful for mocking/unit testing
    static init(options2 = {}) {
        if (options2.maxDrift) {
            config$1.maxDrift = options2.maxDrift;
        }
        setClock(makeClock(new Timestamp(0, 0, options2.node ? ("0000000000000000" + options2.node).toString().slice(-16) : "")));
    }
    /**
     * timestamp parsing
     * converts a fixed-length string timestamp to the structured value
     */
    static parse(timestamp) {
        if (timestamp instanceof Timestamp) {
            return timestamp;
        }
        if (typeof timestamp === "string") {
            const parts = timestamp.split("-");
            if (parts && parts.length === 5) {
                const millis = Date.parse(parts.slice(0, 3).join("-")).valueOf();
                const counter = parseInt(parts[3], 16);
                const node2 = parts[4];
                if (!isNaN(millis) && millis >= 0 && !isNaN(counter) && counter <= MAX_COUNTER && typeof node2 === "string" && node2.length <= MAX_NODE_LENGTH) {
                    return new Timestamp(millis, counter, node2);
                }
            }
        }
        return null;
    }
    /**
     * Timestamp send. Generates a unique, monotonic timestamp suitable
     * for transmission to another system in string format
     */
    static send() {
        if (!clock) {
            return null;
        }
        const phys = Date.now();
        const lOld = clock.timestamp.millis();
        const cOld = clock.timestamp.counter();
        const lNew = Math.max(lOld, phys);
        const cNew = lOld === lNew ? cOld + 1 : 0;
        if (lNew - phys > config$1.maxDrift) {
            throw new Timestamp.ClockDriftError(lNew, phys, config$1.maxDrift);
        }
        if (cNew > MAX_COUNTER) {
            throw new Timestamp.OverflowError();
        }
        clock.timestamp.setMillis(lNew);
        clock.timestamp.setCounter(cNew);
        return new Timestamp(clock.timestamp.millis(), clock.timestamp.counter(), clock.timestamp.node());
    }
    // Timestamp receive. Parses and merges a timestamp from a remote
    // system with the local timeglobal uniqueness and monotonicity are
    // preserved
    static recv(msg) {
        if (!clock) {
            return null;
        }
        const phys = Date.now();
        const lMsg = msg.millis();
        const cMsg = msg.counter();
        if (lMsg - phys > config$1.maxDrift) {
            throw new Timestamp.ClockDriftError();
        }
        const lOld = clock.timestamp.millis();
        const cOld = clock.timestamp.counter();
        const lNew = Math.max(Math.max(lOld, phys), lMsg);
        const cNew = lNew === lOld && lNew === lMsg ? Math.max(cOld, cMsg) + 1 : lNew === lOld ? cOld + 1 : lNew === lMsg ? cMsg + 1 : 0;
        if (lNew - phys > config$1.maxDrift) {
            throw new Timestamp.ClockDriftError();
        }
        if (cNew > MAX_COUNTER) {
            throw new Timestamp.OverflowError();
        }
        clock.timestamp.setMillis(lNew);
        clock.timestamp.setCounter(cNew);
        return new Timestamp(clock.timestamp.millis(), clock.timestamp.counter(), clock.timestamp.node());
    }
}
/**
 * maximum timestamp
 */
Timestamp.max = Timestamp.parse("9999-12-31T23:59:59.999Z-FFFF-FFFFFFFFFFFFFFFF");
/**
 * zero/minimum timestamp
 */
Timestamp.zero = Timestamp.parse("1970-01-01T00:00:00.000Z-0000-0000000000000000");
Timestamp.since = (isoString) => isoString + "-0000-0000000000000000";
/**
 * error classes
 */
Timestamp.DuplicateNodeError = class DuplicateNodeError extends Error {
    constructor(node2) {
        super("duplicate node identifier " + node2);
        this.name = "DuplicateNodeError";
    }
};
Timestamp.ClockDriftError = class ClockDriftError extends Error {
    constructor(...args) {
        super(["maximum clock drift exceeded"].concat(args).join(" "));
        this.name = "ClockDriftError";
    }
};
Timestamp.OverflowError = class OverflowError extends Error {
    constructor() {
        super("timestamp counter overflow");
        this.name = "OverflowError";
    }
};
Timestamp.InvalidError = class InvalidError extends Error {
    constructor(...args) {
        super(["timestamp is not valid"].concat(args.map(String)).join(" "));
        this.name = "InvalidError";
    }
};
class MutableTimestamp extends Timestamp {
    static from(timestamp) {
        return new MutableTimestamp(timestamp.millis(), timestamp.counter(), timestamp.node());
    }
    setMillis(n) {
        this._state.millis = n;
    }
    setCounter(n) {
        this._state.counter = n;
    }
    setNode(n) {
        this._state.node = n;
    }
}
globalThis.proto.SyncRequest;
globalThis.proto.SyncResponse;
globalThis.proto.Message;
globalThis.proto.MessageEnvelope;
globalThis.proto.EncryptedData;
const SyncProtoBuf = globalThis.proto;
let _uid = 0;
function resetUid() {
    _uid = 0;
}
function uid(tableName) {
    _uid++;
    return tableName + _uid;
}
class CompileError extends Error {
}
function nativeDateToInt(date) {
    const pad = (x) => (x < 10 ? "0" : "") + x;
    return date.getFullYear() + pad(date.getMonth() + 1) + pad(date.getDate());
}
function dateToInt(date) {
    return parseInt(date.replace(/-/g, ""));
}
function addTombstone(schema2, tableName, tableId, whereStr) {
    const hasTombstone = schema2[tableName].tombstone != null;
    return hasTombstone ? `${whereStr} AND ${tableId}.tombstone = 0` : whereStr;
}
function popPath(path2) {
    const parts = path2.split(".");
    return { path: parts.slice(0, -1).join("."), field: parts[parts.length - 1] };
}
function isKeyword(str) {
    return str === "group";
}
function quoteAlias(alias) {
    return alias.indexOf(".") === -1 && !isKeyword(alias) ? alias : `"${alias}"`;
}
function typed(value, type2, { literal = false } = {}) {
    return { value, type: type2, literal };
}
function getFieldDescription(schema2, tableName, field) {
    if (schema2[tableName] == null) {
        throw new CompileError(`Table ${tableName} does not exist in the schema`);
    }
    const fieldDesc = schema2[tableName][field];
    if (fieldDesc == null) {
        throw new CompileError(`Field ${field} does not exist in table ${tableName}`);
    }
    return fieldDesc;
}
function makePath(state, path2) {
    const { schema: schema2, paths } = state;
    const parts = path2.split(".");
    if (parts.length < 2) {
        throw new CompileError("Invalid path: " + path2);
    }
    const initialTable = parts[0];
    const tableName = parts.slice(1).reduce((tableName2, field) => {
        const table = schema2[tableName2];
        if (table == null) {
            throw new CompileError(`Path error: ${tableName2} table does not exist`);
        }
        if (!table[field] || table[field].ref == null) {
            throw new CompileError(`Field not joinable on table ${tableName2}: ${field}`);
        }
        return table[field].ref;
    }, initialTable);
    let joinTable;
    const parentParts = parts.slice(0, -1);
    if (parentParts.length === 1) {
        joinTable = parentParts[0];
    }
    else {
        const parentPath = parentParts.join(".");
        const parentDesc = paths.get(parentPath);
        if (!parentDesc) {
            throw new CompileError("Path does not exist: " + parentPath);
        }
        joinTable = parentDesc.tableId;
    }
    return {
        tableName,
        tableId: uid(tableName),
        joinField: parts[parts.length - 1],
        joinTable
    };
}
function resolvePath(state, path2) {
    let paths = path2.split(".");
    paths = paths.reduce((acc, name) => {
        const fullName = acc.context + "." + name;
        return {
            context: fullName,
            path: [...acc.path, fullName]
        };
    }, { context: state.implicitTableName, path: [] }).path;
    paths.forEach((path22) => {
        if (!state.paths.get(path22)) {
            state.paths.set(path22, makePath(state, path22));
        }
    });
    const pathInfo = state.paths.get(paths[paths.length - 1]);
    return pathInfo;
}
function transformField(state, name) {
    if (typeof name !== "string") {
        throw new CompileError("Invalid field name, must be a string");
    }
    const { path: path2, field: originalField } = popPath(name);
    let field = originalField;
    let pathInfo;
    if (path2 === "") {
        pathInfo = {
            tableName: state.implicitTableName,
            tableId: state.implicitTableId
        };
    }
    else {
        pathInfo = resolvePath(state, path2);
    }
    const fieldDesc = getFieldDescription(state.schema, pathInfo.tableName, field);
    if (state.validateRefs && fieldDesc.ref && fieldDesc.type === "id" && field !== "id") {
        const refPath = state.implicitTableName + "." + name;
        let refPathInfo = state.paths.get(refPath);
        if (!refPathInfo) {
            refPathInfo = makePath(state, refPath);
            refPathInfo.noMapping = true;
            state.paths.set(refPath, refPathInfo);
        }
        field = "id";
        pathInfo = refPathInfo;
    }
    const fieldStr = pathInfo.tableId + "." + field;
    return typed(fieldStr, fieldDesc.type);
}
function parseDate(str) {
    const m = str.match(/^(\d{4}-\d{2}-\d{2})$/);
    if (m) {
        return typed(dateToInt(m[1]), "date", { literal: true });
    }
    return null;
}
function parseMonth(str) {
    const m = str.match(/^(\d{4}-\d{2})$/);
    if (m) {
        return typed(dateToInt(m[1]), "date", { literal: true });
    }
    return null;
}
function parseYear(str) {
    const m = str.match(/^(\d{4})$/);
    if (m) {
        return typed(dateToInt(m[1]), "date", { literal: true });
    }
    return null;
}
function badDateFormat(str, type2) {
    throw new CompileError(`Bad ${type2} format: ${str}`);
}
function inferParam(param, type2) {
    const existingType = param.paramType;
    if (existingType) {
        const casts = {
            date: ["string"],
            "date-month": ["date"],
            "date-year": ["date", "date-month"],
            id: ["string"],
            float: ["integer"]
        };
        if (existingType !== type2 && (!casts[type2] || !casts[type2].includes(existingType))) {
            throw new Error(`Parameter ${param.paramName} cant convert to ${type2} (already inferred as ${existingType})`);
        }
    }
    else {
        param.paramType = type2;
    }
}
function castInput(state, expr, type2) {
    if (expr.type === type2) {
        return expr;
    }
    else if (expr.type === "param") {
        inferParam(expr, type2);
        return typed(expr.value, type2);
    }
    else if (expr.type === "null") {
        if (!expr.literal) {
            throw new CompileError("A non-literal null doesnt make sense");
        }
        if (type2 === "boolean") {
            return typed(0, "boolean", { literal: true });
        }
        return expr;
    }
    if (type2 === "date") {
        if (expr.type === "string") {
            if (expr.literal) {
                return parseDate(expr.value) || badDateFormat(expr.value, "date");
            }
            else {
                throw new CompileError("Casting string fields to dates is not supported");
            }
        }
        throw new CompileError(`Cant cast ${expr.type} to date`);
    }
    else if (type2 === "date-month") {
        let expr2;
        if (expr.type === "date") {
            expr2 = expr;
        }
        else if (expr.type === "string" || expr.type === "any") {
            expr2 = parseMonth(expr.value) || parseDate(expr.value) || badDateFormat(expr.value, "date-month");
        }
        else {
            throw new CompileError(`Cant cast ${expr.type} to date-month`);
        }
        if (expr2.literal) {
            return typed(dateToInt(expr2.value.toString().slice(0, 6)), "date-month", { literal: true });
        }
        else {
            return typed(`CAST(SUBSTR(${expr2.value}, 1, 6) AS integer)`, "date-month");
        }
    }
    else if (type2 === "date-year") {
        let expr2;
        if (expr.type === "date" || expr.type === "date-month") {
            expr2 = expr;
        }
        else if (expr.type === "string") {
            expr2 = parseYear(expr.value) || parseMonth(expr.value) || parseDate(expr.value) || badDateFormat(expr.value, "date-year");
        }
        else {
            throw new CompileError(`Cant cast ${expr.type} to date-year`);
        }
        if (expr2.literal) {
            return typed(dateToInt(expr2.value.toString().slice(0, 4)), "date-year", {
                literal: true
            });
        }
        else {
            return typed(`CAST(SUBSTR(${expr2.value}, 1, 4) AS integer)`, "date-year");
        }
    }
    else if (type2 === "id") {
        if (expr.type === "string") {
            return typed(expr.value, "id", { literal: expr.literal });
        }
    }
    else if (type2 === "float") {
        if (expr.type === "integer") {
            return typed(expr.value, "float", { literal: expr.literal });
        }
    }
    if (expr.type === "any") {
        return typed(expr.value, type2, { literal: expr.literal });
    }
    throw new CompileError(`Cant convert ${expr.type} to ${type2}`);
}
function val(state, expr, type2) {
    let castedExpr = expr;
    if (type2) {
        castedExpr = castInput(state, expr, type2);
    }
    if (castedExpr.literal) {
        if (castedExpr.type === "id") {
            return `'${castedExpr.value}'`;
        }
        else if (castedExpr.type === "string") {
            const value = castedExpr.value.replace(/'/g, "''");
            return `'${value}'`;
        }
    }
    return castedExpr.value;
}
function valArray(state, arr, types) {
    return arr.map((value, idx) => val(state, value, types ? types[idx] : null));
}
function validateArgLength(arr, min2, max2) {
    if (max2 == null) {
        max2 = min2;
    }
    if (min2 != null && arr.length < min2) {
        throw new CompileError("Too few arguments");
    }
    if (max2 != null && arr.length > max2) {
        throw new CompileError("Too many arguments");
    }
}
function saveStack(type2, func) {
    return (state, ...args) => {
        if (state == null || state.compileStack == null) {
            throw new CompileError("This function cannot track error data. It needs to accept the compiler state as the first argument.");
        }
        state.compileStack.push({ type: type2, args });
        const ret = func(state, ...args);
        state.compileStack.pop();
        return ret;
    };
}
function prettyValue(value) {
    if (typeof value === "string") {
        return value;
    }
    else if (value === void 0) {
        return "undefined";
    }
    const str = JSON.stringify(value);
    if (str.length > 70) {
        const expanded = JSON.stringify(value, null, 2);
        return expanded.split("\n").join("\n  ");
    }
    return str;
}
function getCompileError(error, stack) {
    if (stack.length === 0) {
        return error;
    }
    let stackStr = stack.slice(1).reverse().map((entry) => {
        switch (entry.type) {
            case "expr":
            case "function":
                return prettyValue(entry.args[0]);
            case "op": {
                const [fieldRef, opData] = entry.args;
                return prettyValue({ [fieldRef]: opData });
            }
            case "value":
                return prettyValue(entry.value);
            default:
                return "";
        }
    }).map((str) => "\n  " + str).join("");
    const rootMethod = stack[0].type;
    const methodArgs = stack[0].args[0];
    stackStr += `
  ${rootMethod}(${prettyValue(methodArgs.length === 1 ? methodArgs[0] : methodArgs)})`;
    if (process.env.NODE_ENV === "production") {
        const err = new CompileError();
        err.message = `${error.message}

Expression stack:` + stackStr;
        err.stack = null;
        return err;
    }
    error.message = `${error.message}

Expression stack:` + stackStr;
    return error;
}
function compileLiteral(value) {
    if (value === void 0) {
        throw new CompileError("`undefined` is not a valid query value");
    }
    else if (value === null) {
        return typed("NULL", "null", { literal: true });
    }
    else if (value instanceof Date) {
        return typed(nativeDateToInt(value), "date", { literal: true });
    }
    else if (typeof value === "string") {
        value = value.replace(/\\\$/g, "$");
        return typed(value, "string", { literal: true });
    }
    else if (typeof value === "boolean") {
        return typed(value ? 1 : 0, "boolean", { literal: true });
    }
    else if (typeof value === "number") {
        return typed(value, Number.isInteger(value) ? "integer" : "float", {
            literal: true
        });
    }
    else if (Array.isArray(value)) {
        return typed(value, "array", { literal: true });
    }
    else {
        throw new CompileError("Unsupported type of expression: " + JSON.stringify(value));
    }
}
const compileExpr = saveStack("expr", (state, expr) => {
    if (typeof expr === "string") {
        if (expr[0] === "$") {
            const fieldRef = expr === "$" ? state.implicitField : expr.slice(1);
            if (fieldRef == null || fieldRef === "") {
                throw new CompileError("Invalid field reference: " + expr);
            }
            return transformField(state, fieldRef);
        }
        if (expr[0] === ":") {
            const param = { value: "?", type: "param", paramName: expr.slice(1) };
            state.namedParameters.push(param);
            return param;
        }
    }
    if (expr !== null) {
        if (Array.isArray(expr)) {
            return compileLiteral(expr);
        }
        else if (typeof expr === "object" && Object.keys(expr).find((k) => k[0] === "$")) {
            return compileFunction(state, expr);
        }
    }
    return compileLiteral(expr);
});
const compileFunction = saveStack("function", (state, func) => {
    const [name] = Object.keys(func);
    let argExprs = func[name];
    if (!Array.isArray(argExprs)) {
        argExprs = [argExprs];
    }
    if (name[0] !== "$") {
        throw new CompileError(`Unknown property ${name}. Did you mean to call a function? Try prefixing it with $`);
    }
    let args = argExprs;
    if (name !== "$condition") {
        args = argExprs.map((arg) => compileExpr(state, arg));
    }
    switch (name) {
        // aggregate functions
        case "$sum": {
            validateArgLength(args, 1);
            const [arg12] = valArray(state, args, ["float"]);
            return typed(`SUM(${arg12})`, args[0].type);
        }
        case "$sumOver": {
            const [arg12] = valArray(state, args, ["float"]);
            const order = state.orders ? "ORDER BY " + compileOrderBy(state, state.orders) : "";
            return typed(`(SUM(${arg12}) OVER (${order} ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING))`, args[0].type);
        }
        case "$count": {
            validateArgLength(args, 1);
            const [arg12] = valArray(state, args);
            return typed(`COUNT(${arg12})`, "integer");
        }
        // string functions
        case "$substr": {
            validateArgLength(args, 2, 3);
            const [arg12, arg2, arg3] = valArray(state, args, [
                "string",
                "integer",
                "integer"
            ]);
            return typed(`SUBSTR(${arg12}, ${arg2}, ${arg3})`, "string");
        }
        case "$lower": {
            validateArgLength(args, 1);
            const [arg12] = valArray(state, args, ["string"]);
            return typed(`UNICODE_LOWER(${arg12})`, "string");
        }
        // integer/float functions
        case "$neg": {
            validateArgLength(args, 1);
            valArray(state, args, ["float"]);
            return typed(`(-${val(state, args[0])})`, args[0].type);
        }
        case "$abs": {
            validateArgLength(args, 1);
            valArray(state, args, ["float"]);
            return typed(`ABS(${val(state, args[0])})`, args[0].type);
        }
        case "$idiv": {
            validateArgLength(args, 2);
            valArray(state, args, ["integer", "integer"]);
            return typed(`(${val(state, args[0])} / ${val(state, args[1])})`, args[0].type);
        }
        // id functions
        case "$id": {
            validateArgLength(args, 1);
            return typed(val(state, args[0]), args[0].type);
        }
        // date functions
        case "$day": {
            validateArgLength(args, 1);
            return castInput(state, args[0], "date");
        }
        case "$month": {
            validateArgLength(args, 1);
            return castInput(state, args[0], "date-month");
        }
        case "$year": {
            validateArgLength(args, 1);
            return castInput(state, args[0], "date-year");
        }
        // various functions
        case "$condition":
            validateArgLength(args, 1);
            const conds = compileConditions(state, args[0]);
            return typed(conds.join(" AND "), "boolean");
        case "$nocase":
            validateArgLength(args, 1);
            const [arg1] = valArray(state, args, ["string"]);
            return typed(`${arg1} COLLATE NOCASE`, args[0].type);
        case "$literal": {
            validateArgLength(args, 1);
            if (!args[0].literal) {
                throw new CompileError("Literal not passed to $literal");
            }
            return args[0];
        }
        default:
            throw new CompileError(`Unknown function: ${name}`);
    }
});
const compileOp = saveStack("op", (state, fieldRef, opData) => {
    const { $transform, ...opExpr } = opData;
    const [op] = Object.keys(opExpr);
    const rhs = compileExpr(state, opData[op]);
    let lhs;
    if ($transform) {
        lhs = compileFunction({ ...state, implicitField: fieldRef }, typeof $transform === "string" ? { [$transform]: "$" } : $transform);
    }
    else {
        lhs = compileExpr(state, "$" + fieldRef);
    }
    switch (op) {
        case "$gte": {
            const [left, right] = valArray(state, [lhs, rhs], [null, lhs.type]);
            return `${left} >= ${right}`;
        }
        case "$lte": {
            const [left, right] = valArray(state, [lhs, rhs], [null, lhs.type]);
            return `${left} <= ${right}`;
        }
        case "$gt": {
            const [left, right] = valArray(state, [lhs, rhs], [null, lhs.type]);
            return `${left} > ${right}`;
        }
        case "$lt": {
            const [left, right] = valArray(state, [lhs, rhs], [null, lhs.type]);
            return `${left} < ${right}`;
        }
        case "$eq": {
            if (castInput(state, rhs, lhs.type).type === "null") {
                return `${val(state, lhs)} IS NULL`;
            }
            const [left, right] = valArray(state, [lhs, rhs], [null, lhs.type]);
            if (rhs.type === "param") {
                const orders = state.namedParameters.map((param) => {
                    return param === rhs || param === lhs ? [param, { ...param }] : param;
                });
                state.namedParameters = [].concat.apply([], orders);
                return `CASE
          WHEN ${left} IS NULL THEN ${right} IS NULL
          ELSE ${left} = ${right}
        END`;
            }
            return `${left} = ${right}`;
        }
        case "$ne": {
            if (castInput(state, rhs, lhs.type).type === "null") {
                return `${val(state, lhs)} IS NOT NULL`;
            }
            const [left, right] = valArray(state, [lhs, rhs], [null, lhs.type]);
            if (rhs.type === "param") {
                const orders = state.namedParameters.map((param) => {
                    return param === rhs || param === lhs ? [param, { ...param }] : param;
                });
                state.namedParameters = [].concat.apply([], orders);
                return `CASE
          WHEN ${left} IS NULL THEN ${right} IS NOT NULL
          ELSE ${left} IS NOT ${right}
        END`;
            }
            return `(${left} != ${right} OR ${left} IS NULL)`;
        }
        case "$oneof": {
            const [left, right] = valArray(state, [lhs, rhs], [null, "array"]);
            const ids = [...new Set(right)];
            return `${left} IN (` + ids.map((id2) => `'${id2}'`).join(",") + ")";
        }
        case "$like": {
            const [left, right] = valArray(state, [lhs, rhs], ["string", "string"]);
            return `UNICODE_LIKE(${getNormalisedString(right)}, NORMALISE(${left}))`;
        }
        case "$regexp": {
            const [left, right] = valArray(state, [lhs, rhs], ["string", "string"]);
            return `REGEXP(${right}, ${left})`;
        }
        case "$notlike": {
            const [left, right] = valArray(state, [lhs, rhs], ["string", "string"]);
            return `(NOT UNICODE_LIKE(${getNormalisedString(right)}, NORMALISE(${left}))
 OR ${left} IS NULL)`;
        }
        default:
            throw new CompileError(`Unknown operator: ${op}`);
    }
});
function compileConditions(state, conds) {
    if (!Array.isArray(conds)) {
        conds = Object.entries(conds).map((cond) => {
            return { [cond[0]]: cond[1] };
        });
    }
    return conds.filter(Boolean).reduce((res, condsObj) => {
        const compiled = Object.entries(condsObj).map(([field, cond]) => {
            if (field === "$and") {
                if (!cond) {
                    return null;
                }
                return compileAnd(state, cond);
            }
            else if (field === "$or") {
                if (!cond || Array.isArray(cond) && cond.length === 0) {
                    return null;
                }
                return compileOr(state, cond);
            }
            if (typeof cond === "string" || typeof cond === "number" || typeof cond === "boolean" || cond instanceof Date || cond == null) {
                return compileOp(state, field, { $eq: cond });
            }
            if (Array.isArray(cond)) {
                return cond.map((c) => compileOp(state, field, c)).join(" AND ");
            }
            return compileOp(state, field, cond);
        }).filter(Boolean);
        return [...res, ...compiled];
    }, []);
}
function compileOr(state, conds) {
    if (!conds) {
        return "0";
    }
    const res = compileConditions(state, conds);
    if (res.length === 0) {
        return "0";
    }
    return "(" + res.join("\n  OR ") + ")";
}
function compileAnd(state, conds) {
    if (!conds) {
        return "1";
    }
    const res = compileConditions(state, conds);
    if (res.length === 0) {
        return "1";
    }
    return "(" + res.join("\n  AND ") + ")";
}
const compileWhere = saveStack("filter", (state, conds) => {
    return compileAnd(state, conds);
});
function compileJoins(state, tableRef, internalTableFilters) {
    const joins = [];
    state.paths.forEach((desc, path2) => {
        const { tableName, tableId, joinField, joinTable, noMapping } = state.paths.get(path2);
        let on = `${tableId}.id = ${tableRef(joinTable)}.${quoteAlias(joinField)}`;
        const filters = internalTableFilters(tableName);
        if (filters.length > 0) {
            on += " AND " + compileAnd({ ...state, implicitTableName: tableName, implicitTableId: tableId }, filters);
        }
        joins.push(`LEFT JOIN ${noMapping ? tableName : tableRef(tableName, true)} ${tableId} ON ${addTombstone(state.schema, tableName, tableId, on)}`);
        if (state.dependencies.indexOf(tableName) === -1) {
            state.dependencies.push(tableName);
        }
    });
    return joins.join("\n");
}
function expandStar(state, expr) {
    let path2;
    let pathInfo;
    if (expr === "*") {
        pathInfo = {
            tableName: state.implicitTableName,
            tableId: state.implicitTableId
        };
    }
    else if (expr.match(/\.\*$/)) {
        const result = popPath(expr);
        path2 = result.path;
        pathInfo = resolvePath(state, result.path);
    }
    const table = state.schema[pathInfo.tableName];
    if (table == null) {
        throw new Error(`Table ${pathInfo.tableName} does not exist`);
    }
    return Object.keys(table).map((field) => path2 ? `${path2}.${field}` : field);
}
const compileSelect = saveStack("select", (state, exprs, isAggregate, orders) => {
    if (!isAggregate && !exprs.includes("id") && !exprs.includes("*")) {
        exprs = exprs.concat(["id"]);
    }
    const select2 = exprs.map((expr) => {
        if (typeof expr === "string") {
            if (expr.indexOf("*") !== -1) {
                const fields = expandStar(state, expr);
                return fields.map((field) => {
                    const compiled3 = compileExpr(state, "$" + field);
                    state.outputTypes.set(field, compiled3.type);
                    return compiled3.value + " AS " + quoteAlias(field);
                }).join(", ");
            }
            const compiled2 = compileExpr(state, "$" + expr);
            state.outputTypes.set(expr, compiled2.type);
            return compiled2.value + " AS " + quoteAlias(expr);
        }
        const [name, value] = Object.entries(expr)[0];
        if (name[0] === "$") {
            state.compileStack.push({ type: "value", value: expr });
            throw new CompileError(`Invalid field ${name}, are you trying to select a function? You need to name the expression`);
        }
        if (typeof value === "string") {
            const compiled2 = compileExpr(state, "$" + value);
            state.outputTypes.set(name, compiled2.type);
            return `${compiled2.value} AS ${quoteAlias(name)}`;
        }
        const compiled = compileFunction({ ...state, orders }, value);
        state.outputTypes.set(name, compiled.type);
        return compiled.value + ` AS ${quoteAlias(name)}`;
    });
    return select2.join(", ");
});
const compileGroupBy = saveStack("groupBy", (state, exprs) => {
    const groupBy2 = exprs.map((expr) => {
        if (typeof expr === "string") {
            return compileExpr(state, "$" + expr).value;
        }
        return compileFunction(state, expr).value;
    });
    return groupBy2.join(", ");
});
const compileOrderBy = saveStack("orderBy", (state, exprs) => {
    const orderBy = exprs.map((expr) => {
        let compiled;
        let dir = null;
        if (typeof expr === "string") {
            compiled = compileExpr(state, "$" + expr).value;
        }
        else {
            const entries = Object.entries(expr);
            const entry = entries[0];
            if (entries.length === 1 && entry[0][0] !== "$") {
                dir = entry[1];
                compiled = compileExpr(state, "$" + entry[0]).value;
            }
            else {
                const { $dir, ...func } = expr;
                dir = $dir;
                compiled = compileFunction(state, func).value;
            }
        }
        if (dir != null) {
            if (dir !== "desc" && dir !== "asc") {
                throw new CompileError("Invalid order direction: " + dir);
            }
            return `${compiled} ${dir}`;
        }
        return compiled;
    });
    return orderBy.join(", ");
});
const AGGREGATE_FUNCTIONS = ["$sum", "$count"];
function isAggregateFunction(expr) {
    if (typeof expr !== "object" || Array.isArray(expr)) {
        return false;
    }
    const [name, originalArgExprs] = Object.entries(expr)[0];
    let argExprs = originalArgExprs;
    if (!Array.isArray(argExprs)) {
        argExprs = [argExprs];
    }
    if (AGGREGATE_FUNCTIONS.indexOf(name) !== -1) {
        return true;
    }
    return !!argExprs.find((ex) => isAggregateFunction(ex));
}
function isAggregateQuery(queryState) {
    if (queryState.groupExpressions.length > 0) {
        return true;
    }
    return !!queryState.selectExpressions.find((expr) => {
        if (typeof expr !== "string") {
            const [_, value] = Object.entries(expr)[0];
            return isAggregateFunction(value);
        }
        return false;
    });
}
function compileQuery(queryState, schema2, schemaConfig2 = {}) {
    const { withDead, validateRefs = true, tableOptions, rawMode } = queryState;
    const { tableViews = {}, tableFilters = () => [], customizeQuery = (queryState2) => queryState2 } = schemaConfig2;
    const internalTableFilters = (name) => {
        const filters = tableFilters(name);
        for (const filter of filters) {
            if (Array.isArray(filter)) {
                throw new CompileError("Invalid internal table filter: only object filters are supported");
            }
            if (Object.keys(filter)[0].indexOf(".") !== -1) {
                throw new CompileError("Invalid internal table filter: field names cannot contain paths");
            }
        }
        return filters;
    };
    const tableRef = (name, isJoin) => {
        const view = typeof tableViews === "function" ? tableViews(name, { withDead, isJoin, tableOptions }) : tableViews[name];
        return view || name;
    };
    const tableName = queryState.table;
    const { filterExpressions, selectExpressions, groupExpressions, orderExpressions, limit, offset } = customizeQuery(queryState);
    let select2 = "";
    let where = "";
    let joins = "";
    let groupBy2 = "";
    let orderBy = "";
    const state = {
        schema: schema2,
        implicitTableName: tableName,
        implicitTableId: tableRef(tableName),
        paths: /* @__PURE__ */ new Map(),
        dependencies: [tableName],
        compileStack: [],
        outputTypes: /* @__PURE__ */ new Map(),
        validateRefs,
        namedParameters: []
    };
    resetUid();
    try {
        select2 = compileSelect(state, selectExpressions, isAggregateQuery(queryState), orderExpressions);
        if (filterExpressions.length > 0) {
            const result = compileWhere(state, filterExpressions);
            where = "WHERE " + result;
        }
        else {
            where = "WHERE 1";
        }
        if (!rawMode) {
            const filters = internalTableFilters(tableName);
            if (filters.length > 0) {
                where += " AND " + compileAnd(state, filters);
            }
        }
        if (groupExpressions.length > 0) {
            const result = compileGroupBy(state, groupExpressions);
            groupBy2 = "GROUP BY " + result;
        }
        if (orderExpressions.length > 0) {
            const result = compileOrderBy(state, orderExpressions);
            orderBy = "ORDER BY " + result;
        }
        if (state.paths.size > 0) {
            joins = compileJoins(state, tableRef, internalTableFilters);
        }
    }
    catch (e) {
        if (e instanceof CompileError) {
            throw getCompileError(e, state.compileStack);
        }
        throw e;
    }
    const sqlPieces = {
        select: select2,
        from: tableRef(tableName),
        joins,
        where,
        groupBy: groupBy2,
        orderBy,
        limit,
        offset
    };
    return {
        sqlPieces,
        state
    };
}
function defaultConstructQuery(queryState, compilerState, sqlPieces) {
    const s = sqlPieces;
    const where = queryState.withDead ? s.where : addTombstone(compilerState.schema, compilerState.implicitTableName, compilerState.implicitTableId, s.where);
    return `
    SELECT ${s.select} FROM ${s.from}
    ${s.joins}
    ${where}
    ${s.groupBy}
    ${s.orderBy}
    ${s.limit != null ? `LIMIT ${s.limit}` : ""}
    ${s.offset != null ? `OFFSET ${s.offset}` : ""}
  `;
}
class PostError extends Error {
    constructor(reason, meta) {
        super("PostError: " + reason);
        this.type = "PostError";
        this.reason = reason;
        this.meta = meta;
    }
}
let BankSyncError$1 = class BankSyncError extends Error {
    constructor(reason, category, code) {
        super("BankSyncError: " + reason);
        this.type = "BankSyncError";
        this.reason = reason;
        this.category = category;
        this.code = code;
    }
};
class HTTPError extends Error {
    constructor(code, body) {
        super(`HTTPError: unsuccessful status code (${code}): ${body}`);
        this.statusCode = code;
        this.responseBody = body;
    }
}
class SyncError extends Error {
    constructor(reason, meta) {
        super("SyncError: " + reason);
        this.reason = reason;
        this.meta = meta;
    }
}
class ValidationError extends Error {
}
class TransactionError extends Error {
}
class RuleError extends Error {
    constructor(name, message2) {
        super("RuleError: " + message2);
        this.type = name;
    }
}
function APIError(msg, meta) {
    return { type: "APIError", message: msg, meta };
}
function FileDownloadError(reason, meta) {
    return { type: "FileDownloadError", reason, meta };
}
function FileUploadError(reason, meta) {
    return { type: "FileUploadError", reason, meta };
}
function requiredFields(name, row, fields, update2) {
    fields.forEach((field) => {
        if (update2) {
            if (row.hasOwnProperty(field) && row[field] == null) {
                throw new ValidationError(`${name} is missing field ${String(field)}`);
            }
        }
        else {
            if (!row.hasOwnProperty(field) || row[field] == null) {
                throw new ValidationError(`${name} is missing field ${String(field)}`);
            }
        }
    });
}
function toDateRepr(str) {
    if (typeof str !== "string") {
        throw new Error("toDateRepr not passed a string: " + str);
    }
    return parseInt(str.replace(/-/g, ""));
}
function fromDateRepr(number2) {
    if (typeof number2 !== "number") {
        throw new Error("fromDateRepr not passed a number: " + number2);
    }
    const dateString = number2.toString();
    return dateString.slice(0, 4) + "-" + dateString.slice(4, 6) + "-" + dateString.slice(6);
}
const accountModel$1 = {
    validate(account, { update: update2 } = {}) {
        requiredFields("account", account, update2 ? ["name", "offbudget", "closed"] : ["name"], update2);
        return account;
    }
};
const categoryModel$1 = {
    validate(category, { update: update2 } = {}) {
        requiredFields("category", category, update2 ? ["name", "is_income", "cat_group"] : ["name", "cat_group"], update2);
        const { sort_order, ...rest } = category;
        return { ...rest };
    },
    toDb(category, { update: update2 } = {}) {
        return update2 ? convertForUpdate(schema, schemaConfig, "categories", category) : convertForInsert(schema, schemaConfig, "categories", category);
    },
    fromDb(category) {
        return convertFromSelect(schema, schemaConfig, "categories", category);
    }
};
const categoryGroupModel$1 = {
    validate(categoryGroup, { update: update2 } = {}) {
        requiredFields("categoryGroup", categoryGroup, update2 ? ["name", "is_income"] : ["name"], update2);
        const { sort_order, ...rest } = categoryGroup;
        return { ...rest };
    },
    toDb(categoryGroup, { update: update2 } = {}) {
        return update2 ? convertForUpdate(schema, schemaConfig, "category_groups", categoryGroup) : convertForInsert(schema, schemaConfig, "category_groups", categoryGroup);
    },
    fromDb(categoryGroup) {
        const { categories, ...rest } = categoryGroup;
        const categoryGroupEntity = convertFromSelect(schema, schemaConfig, "category_groups", rest);
        return {
            ...categoryGroupEntity,
            categories: categories.filter((category) => category.cat_group === categoryGroup.id).map(categoryModel$1.fromDb)
        };
    }
};
const payeeModel$1 = {
    validate(payee, { update: update2 } = {}) {
        requiredFields("payee", payee, update2 ? [] : ["name"], update2);
        return payee;
    },
    toDb(payee, { update: update2 } = {}) {
        return update2 ? convertForUpdate(schema, schemaConfig, "payees", payee) : convertForInsert(schema, schemaConfig, "payees", payee);
    },
    fromDb(payee) {
        return convertFromSelect(schema, schemaConfig, "payees", payee);
    }
};
function isRequired(name, fieldDesc) {
    return fieldDesc.required || name === "id";
}
function convertInputType(value, type2) {
    if (value === void 0) {
        throw new Error("Query value cannot be undefined");
    }
    else if (value === null) {
        if (type2 === "boolean") {
            return 0;
        }
        return null;
    }
    switch (type2) {
        case "date":
            if (value instanceof Date) {
                return toDateRepr(dayFromDate(value));
            }
            else if (value.match(/^\d{4}-\d{2}-\d{2}$/) == null || value.date < "2000-01-01") {
                throw new Error("Invalid date: " + value);
            }
            return toDateRepr(value);
        case "date-month":
            return toDateRepr(value.slice(0, 7));
        case "date-year":
            return toDateRepr(value.slice(0, 4));
        case "boolean":
            return value ? 1 : 0;
        case "id":
            if (typeof value !== "string" && value !== null) {
                throw new Error("Invalid id, must be string: " + value);
            }
            return value;
        case "integer":
            if (typeof value === "number" && Number.isInteger(value)) {
                return value;
            }
            else {
                throw new Error("Cant convert to integer: " + JSON.stringify(value));
            }
        case "json":
            return JSON.stringify(value);
    }
    return value;
}
function convertOutputType(value, type2) {
    if (value === null) {
        if (type2 === "boolean") {
            return false;
        }
        return null;
    }
    switch (type2) {
        case "date":
            return fromDateRepr(value);
        case "date-month":
            return fromDateRepr(value).slice(0, 7);
        case "date-year":
            return fromDateRepr(value).slice(0, 4);
        case "boolean":
            return value === 1;
        case "json":
        case "json/fallback":
            try {
                return JSON.parse(value);
            }
            catch (e) {
                return type2 === "json/fallback" ? value : null;
            }
    }
    return value;
}
function conform(schema2, schemaConfig2, table, obj, { skipNull = false } = {}) {
    const tableSchema = schema2[table];
    if (tableSchema == null) {
        throw new Error(`Table ${table} does not exist`);
    }
    const views = schemaConfig2.views || {};
    const fieldRef = (field) => {
        if (views[table] && views[table].fields) {
            return views[table].fields[field] || field;
        }
        return field;
    };
    return Object.fromEntries(Object.keys(obj).map((field) => {
        if (field[0] === "_") {
            return null;
        }
        const fieldDesc = tableSchema[field];
        if (fieldDesc == null) {
            throw new Error(`Field ${field} does not exist on table ${table}: ${JSON.stringify(obj)}`);
        }
        if (isRequired(field, fieldDesc) && obj[field] == null) {
            throw new Error(`${field} is required for table ${table}: ${JSON.stringify(obj)}`);
        }
        if (skipNull && obj[field] == null) {
            return null;
        }
        return [fieldRef(field), convertInputType(obj[field], fieldDesc.type)];
    }).filter(Boolean));
}
function convertForInsert(schema2, schemaConfig2, table, rawObj) {
    const obj = { ...rawObj };
    const tableSchema = schema2[table];
    if (tableSchema == null) {
        throw new Error(`Error inserting: table ${table} does not exist`);
    }
    Object.keys(tableSchema).forEach((field) => {
        const fieldDesc = tableSchema[field];
        if (obj[field] == null) {
            if (fieldDesc.default !== void 0) {
                obj[field] = typeof fieldDesc.default === "function" ? fieldDesc.default() : fieldDesc.default;
            }
            else if (isRequired(field, fieldDesc)) {
                throw new Error(`${field} is required for table ${table}: ${JSON.stringify(obj)}`);
            }
        }
    });
    return conform(schema2, schemaConfig2, table, obj, { skipNull: true });
}
function convertForUpdate(schema2, schemaConfig2, table, rawObj) {
    const obj = { ...rawObj };
    const tableSchema = schema2[table];
    if (tableSchema == null) {
        throw new Error(`Error updating: table ${table} does not exist`);
    }
    return conform(schema2, schemaConfig2, table, obj);
}
function convertFromSelect(schema2, schemaConfig2, table, obj) {
    const tableSchema = schema2[table];
    if (tableSchema == null) {
        throw new Error(`Table ${table} does not exist`);
    }
    const fields = Object.keys(tableSchema);
    const result = {};
    for (let i = 0; i < fields.length; i++) {
        const fieldName = fields[i];
        const fieldDesc = tableSchema[fieldName];
        result[fieldName] = convertOutputType(obj[fieldName], fieldDesc.type);
    }
    return result;
}
function applyTypes(data, outputTypes) {
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        Object.keys(item).forEach((name) => {
            item[name] = convertOutputType(item[name], outputTypes.get(name));
        });
    }
}
async function execQuery$1(queryState, compilerState, sqlPieces, params, outputTypes) {
    const sql = defaultConstructQuery(queryState, compilerState, sqlPieces);
    const data = await all(sql, params);
    applyTypes(data, outputTypes);
    return data;
}
async function runCompiledAqlQuery(queryState, sqlPieces, compilerState, { params = {}, executors = {} } = {}) {
    const paramArray = compilerState.namedParameters.map((param) => {
        const name = param.paramName;
        if (params[name] === void 0) {
            throw new Error(`Parameter ${name} not provided to query`);
        }
        return convertInputType(params[name], param.paramType);
    });
    let data = [];
    if (executors[compilerState.implicitTableName]) {
        data = await executors[compilerState.implicitTableName](compilerState, queryState, sqlPieces, paramArray, compilerState.outputTypes);
    }
    else {
        data = await execQuery$1(queryState, compilerState, sqlPieces, paramArray, compilerState.outputTypes);
    }
    if (queryState.calculation) {
        if (data.length > 0) {
            const row = data[0];
            const k = Object.keys(row)[0];
            return row[k] || 0;
        }
        else {
            return null;
        }
    }
    return data;
}
async function compileAndRunAqlQuery(schema2, schemaConfig2, queryState, options2) {
    const { sqlPieces, state } = compileQuery(queryState, schema2, schemaConfig2);
    const data = await runCompiledAqlQuery(queryState, sqlPieces, state, options2);
    return { data, dependencies: state.dependencies };
}
function f(type2, opts) {
    return { type: type2, ...opts };
}
const schema = {
    transactions: {
        id: f("id"),
        is_parent: f("boolean"),
        is_child: f("boolean"),
        parent_id: f("id"),
        account: f("id", { ref: "accounts", required: true }),
        category: f("id", { ref: "categories" }),
        amount: f("integer", { default: 0, required: true }),
        payee: f("id", { ref: "payees" }),
        notes: f("string"),
        date: f("date", { required: true }),
        imported_id: f("string"),
        error: f("json"),
        imported_payee: f("string"),
        starting_balance_flag: f("boolean"),
        transfer_id: f("id"),
        sort_order: f("float", { default: () => Date.now() }),
        cleared: f("boolean", { default: true }),
        reconciled: f("boolean", { default: false }),
        tombstone: f("boolean"),
        schedule: f("id", { ref: "schedules" }),
        raw_synced_data: f("string")
        // subtransactions is a special field added if the table has the
        // `splits: grouped` option
    },
    payees: {
        id: f("id"),
        name: f("string", { required: true }),
        transfer_acct: f("id", { ref: "accounts" }),
        tombstone: f("boolean"),
        favorite: f("boolean"),
        learn_categories: f("boolean")
    },
    accounts: {
        id: f("id"),
        name: f("string", { required: true }),
        offbudget: f("boolean"),
        closed: f("boolean"),
        sort_order: f("float"),
        tombstone: f("boolean"),
        account_id: f("string"),
        official_name: f("string"),
        account_sync_source: f("string"),
        last_reconciled: f("string"),
        last_sync: f("string")
    },
    categories: {
        id: f("id"),
        name: f("string"),
        is_income: f("boolean"),
        hidden: f("boolean"),
        group: f("id", { ref: "category_groups" }),
        goal_def: f("string"),
        template_settings: f("json", { default: { source: "notes" } }),
        sort_order: f("float"),
        tombstone: f("boolean")
    },
    category_groups: {
        id: f("id"),
        name: f("string"),
        is_income: f("boolean"),
        hidden: f("boolean"),
        sort_order: f("float"),
        tombstone: f("boolean")
    },
    schedules: {
        id: f("id"),
        name: f("string"),
        rule: f("id", { ref: "rules", required: true }),
        next_date: f("date"),
        completed: f("boolean"),
        posts_transaction: f("boolean"),
        tombstone: f("boolean"),
        // These are special fields that are actually pulled from the
        // underlying rule
        _payee: f("id", { ref: "payees" }),
        _account: f("id", { ref: "accounts" }),
        _amount: f("json/fallback"),
        _amountOp: f("string"),
        _date: f("json/fallback"),
        _conditions: f("json"),
        _actions: f("json")
    },
    rules: {
        id: f("id"),
        stage: f("string"),
        conditions_op: f("string"),
        conditions: f("json"),
        actions: f("json"),
        tombstone: f("boolean")
    },
    notes: {
        id: f("id"),
        note: f("string")
    },
    preferences: {
        id: f("id"),
        value: f("string")
    },
    transaction_filters: {
        id: f("id"),
        name: f("string"),
        conditions_op: f("string"),
        conditions: f("json"),
        tombstone: f("boolean")
    },
    custom_reports: {
        id: f("id"),
        name: f("string"),
        start_date: f("string", { default: "2023-06" }),
        end_date: f("string", { default: "2023-09" }),
        date_static: f("integer", { default: 0 }),
        date_range: f("string"),
        mode: f("string", { default: "total" }),
        group_by: f("string", { default: "Category" }),
        sort_by: f("string", { default: "desc" }),
        balance_type: f("string", { default: "Expense" }),
        show_empty: f("integer", { default: 0 }),
        show_offbudget: f("integer", { default: 0 }),
        show_hidden: f("integer", { default: 0 }),
        show_uncategorized: f("integer", { default: 0 }),
        include_current: f("integer", { default: 0 }),
        graph_type: f("string", { default: "BarGraph" }),
        conditions: f("json"),
        conditions_op: f("string"),
        metadata: f("json"),
        interval: f("string", { default: "Monthly" }),
        color_scheme: f("json"),
        tombstone: f("boolean")
    },
    reflect_budgets: {
        id: f("id"),
        month: f("integer"),
        category: f("string"),
        amount: f("integer"),
        carryover: f("integer"),
        goal: f("integer"),
        long_goal: f("integer")
    },
    zero_budgets: {
        id: f("id"),
        month: f("integer"),
        category: f("string", { ref: "categories" }),
        amount: f("integer"),
        carryover: f("integer"),
        goal: f("integer"),
        long_goal: f("integer")
    },
    dashboard: {
        id: f("id"),
        type: f("string", { required: true }),
        width: f("integer", { required: true }),
        height: f("integer", { required: true }),
        x: f("integer", { required: true }),
        y: f("integer", { required: true }),
        meta: f("json"),
        tombstone: f("boolean")
    }
};
const schemaConfig = {
    // Note: these views *must* represent the underlying table that we
    // are mapping here. The compiler makes optimizations with this
    // assumption
    tableViews(name, { isJoin, withDead, tableOptions = { splits: void 0 } }) {
        switch (name) {
            case "transactions": {
                if (isJoin) {
                    return "v_transactions_internal_alive";
                }
                const splitType = tableOptions.splits || "inline";
                if (!withDead && (splitType === "inline" || splitType === "none")) {
                    return "v_transactions_internal_alive";
                }
                return "v_transactions_internal";
            }
            case "schedules":
                return "v_schedules";
            case "categories":
                return "v_categories";
            case "payees":
                return "v_payees";
        }
        return name;
    },
    customizeQuery(queryState) {
        const { table: tableName } = queryState;
        function orderBy(orders) {
            if (orders.length > 0) {
                return orders.concat(["id"]);
            }
            switch (tableName) {
                case "transactions":
                    return [
                        { date: "desc" },
                        "starting_balance_flag",
                        { sort_order: "desc" },
                        "id"
                    ];
                case "category_groups":
                    return ["is_income", "sort_order", "id"];
                case "categories":
                    return ["sort_order", "id"];
                case "payees":
                    return [
                        { $condition: { transfer_acct: null }, $dir: "desc" },
                        { $nocase: "$name" }
                    ];
                case "accounts":
                    return ["sort_order", "name"];
                case "schedules":
                    return [{ $condition: { completed: true } }, "next_date"];
            }
            return [];
        }
        return {
            ...queryState,
            orderExpressions: orderBy(queryState.orderExpressions)
        };
    },
    views: {
        payees: {
            v_payees: (internalFields2) => {
                const fields = internalFields2({
                    name: "COALESCE(__accounts.name, _.name)"
                });
                return `
          SELECT ${fields} FROM payees _
          LEFT JOIN accounts __accounts ON (_.transfer_acct = __accounts.id AND __accounts.tombstone = 0)
          -- We never want to show transfer payees that are pointing to deleted accounts.
          -- Either this is not a transfer payee, if the account exists
          WHERE _.transfer_acct IS NULL OR __accounts.id IS NOT NULL
        `;
            }
        },
        categories: {
            fields: {
                group: "cat_group"
            },
            v_categories: (internalFields2) => {
                const fields = internalFields2({ group: "cat_group" });
                return `SELECT ${fields} FROM categories _`;
            }
        },
        schedules: {
            v_schedules: (internalFields2) => {
                const fields = internalFields2({
                    next_date: `
            CASE
              WHEN _nd.local_next_date_ts = _nd.base_next_date_ts THEN _nd.local_next_date
              ELSE _nd.base_next_date
            END
          `,
                    _payee: `pm.targetId`,
                    _account: `json_extract(_rules.conditions, _paths.account || '.value')`,
                    _amount: `json_extract(_rules.conditions, _paths.amount || '.value')`,
                    _amountOp: `json_extract(_rules.conditions, _paths.amount || '.op')`,
                    _date: `json_extract(_rules.conditions, _paths.date || '.value')`,
                    _conditions: "_rules.conditions",
                    _actions: "_rules.actions"
                });
                return `
        SELECT ${fields} FROM schedules _
        LEFT JOIN schedules_next_date _nd ON _nd.schedule_id = _.id
        LEFT JOIN schedules_json_paths _paths ON _paths.schedule_id = _.id
        LEFT JOIN rules _rules ON _rules.id = _.rule
        LEFT JOIN payee_mapping pm ON pm.id = json_extract(_rules.conditions, _paths.payee || '.value')
        `;
            }
        },
        transactions: {
            fields: {
                is_parent: "isParent",
                is_child: "isChild",
                account: "acct",
                imported_id: "financial_id",
                imported_payee: "imported_description",
                transfer_id: "transferred_id",
                payee: "description"
            },
            v_transactions_internal: (internalFields2) => {
                const fields = internalFields2({
                    payee: "pm.targetId",
                    category: `CASE WHEN _.isParent = 1 THEN NULL ELSE cm.transferId END`,
                    amount: `IFNULL(_.amount, 0)`,
                    parent_id: "CASE WHEN _.isChild = 0 THEN NULL ELSE _.parent_id END"
                });
                return `
          SELECT ${fields} FROM transactions _
          LEFT JOIN category_mapping cm ON cm.id = _.category
          LEFT JOIN payee_mapping pm ON pm.id = _.description
          WHERE
           _.date IS NOT NULL AND
           _.acct IS NOT NULL AND
           (_.isChild = 0 OR _.parent_id IS NOT NULL)
        `;
            },
            // We join on t2 to only include valid child transactions. We
            // want to only include ones with valid parents, which is when
            // an alive parent transaction exists
            v_transactions_internal_alive: `
        SELECT _.* FROM v_transactions_internal _
        LEFT JOIN transactions t2 ON (_.is_child = 1 AND t2.id = _.parent_id)
        WHERE IFNULL(_.tombstone, 0) = 0 AND (_.is_child = 0 OR t2.tombstone = 0)
      `,
            v_transactions: (_, publicFields2) => {
                const fields = publicFields2({
                    payee: "p.id",
                    category: "c.id",
                    account: "a.id"
                });
                return `
          SELECT ${fields} FROM v_transactions_internal_alive _
          LEFT JOIN payees p ON (p.id = _.payee AND p.tombstone = 0)
          LEFT JOIN categories c ON (c.id = _.category AND c.tombstone = 0)
          LEFT JOIN accounts a ON (a.id = _.account AND a.tombstone = 0)
          ORDER BY _.date desc, _.starting_balance_flag, _.sort_order desc, _.id;
        `;
            }
        }
    }
};
async function incrFetch(runQuery2, terms, compare, makeQuery, params = []) {
    const pageCount = 500;
    let results = [];
    let fetchedIds = /* @__PURE__ */ new Set();
    for (let i = 0; i < terms.length; i += pageCount) {
        const slice = terms.slice(i, i + pageCount).filter((id2) => !fetchedIds.has(id2));
        if (slice.length > 0) {
            const filter = slice.map((id2) => compare(id2)).join(" OR ");
            const query = makeQuery("(" + filter + ")");
            const rows = await runQuery2(query, params, true);
            fetchedIds = /* @__PURE__ */ new Set([...fetchedIds, ...slice]);
            results = results.concat(rows);
        }
    }
    return results;
}
function whereIn(ids, field) {
    const ids2 = [...new Set(ids)];
    const filter = `${field} IN (` + ids2.map((id2) => `'${id2}'`).join(",") + ")";
    return filter;
}
function toGroup(parents, children2, mapper = (x) => x) {
    return parents.reduce((list, parent) => {
        const childs = children2.get(parent.id) || [];
        list.push({
            ...mapper(parent),
            subtransactions: childs.map(mapper)
        });
        return list;
    }, []);
}
function execTransactions(compilerState, queryState, sqlPieces, params, outputTypes) {
    const tableOptions = queryState.tableOptions || {};
    const splitType = tableOptions.splits ? tableOptions.splits : "inline";
    if (!isValidSplitsOption(splitType)) {
        throw new Error(`Invalid splits option for transactions: ${splitType}`);
    }
    if (splitType === "all" || splitType === "inline" || splitType === "none") {
        return execTransactionsBasic(compilerState, queryState, sqlPieces, params, splitType, outputTypes);
    }
    else if (splitType === "grouped") {
        return execTransactionsGrouped(compilerState, queryState, sqlPieces, params, outputTypes);
    }
}
function _isUnhappy(filter) {
    for (const key of Object.keys(filter)) {
        if (key === "$or" || key === "$and") {
            if (filter[key] && _isUnhappy(filter[key])) {
                return true;
            }
        }
        else if (!(key.indexOf("account") === 0 || key === "date")) {
            return true;
        }
    }
    return false;
}
function isHappyPathQuery(queryState) {
    return queryState.filterExpressions.find(_isUnhappy) == null;
}
async function execTransactionsGrouped(compilerState, queryState, sqlPieces, params, outputTypes) {
    const { withDead } = queryState;
    const whereDead = withDead ? "" : `AND ${sqlPieces.from}.tombstone = 0`;
    if (isAggregateQuery(queryState)) {
        const s = { ...sqlPieces };
        s.where = `${s.where} AND ${s.from}.is_parent = 0`;
        if (!withDead) {
            s.from = "v_transactions_internal_alive v_transactions_internal";
        }
        return execQuery$1(queryState, compilerState, s, params, outputTypes);
    }
    let rows;
    let matched = null;
    if (isHappyPathQuery(queryState)) {
        const rowSql = `
      SELECT ${sqlPieces.from}.id as group_id
      FROM ${sqlPieces.from}
      ${sqlPieces.joins}
      ${sqlPieces.where} AND is_child = 0 ${whereDead}
      ${sqlPieces.orderBy}
      ${sqlPieces.limit != null ? `LIMIT ${sqlPieces.limit}` : ""}
      ${sqlPieces.offset != null ? `OFFSET ${sqlPieces.offset}` : ""}
    `;
        rows = await all(rowSql, params);
    }
    else {
        const rowSql = `
      SELECT group_id, matched FROM (
        SELECT
          group_id,
          GROUP_CONCAT(id) as matched
          FROM (
            SELECT ${sqlPieces.from}.id, IFNULL(${sqlPieces.from}.parent_id, ${sqlPieces.from}.id) as group_id
            FROM ${sqlPieces.from}
            LEFT JOIN transactions _t2 ON ${sqlPieces.from}.is_child = 1 AND _t2.id = ${sqlPieces.from}.parent_id
            ${sqlPieces.joins}
            ${sqlPieces.where} AND ${sqlPieces.from}.tombstone = 0 AND IFNULL(_t2.tombstone, 0) = 0
          )
        GROUP BY group_id
      )
      LEFT JOIN ${sqlPieces.from} ON ${sqlPieces.from}.id = group_id
      ${sqlPieces.joins}
      ${sqlPieces.orderBy}
      ${sqlPieces.limit != null ? `LIMIT ${sqlPieces.limit}` : ""}
      ${sqlPieces.offset != null ? `OFFSET ${sqlPieces.offset}` : ""}
    `;
        rows = await all(rowSql, params);
        matched = new Set([].concat.apply([], rows.map((row) => row.matched.split(","))));
    }
    const where = whereIn(rows.map((row) => row.group_id), `IFNULL(${sqlPieces.from}.parent_id, ${sqlPieces.from}.id)`);
    const finalSql = `
    SELECT ${sqlPieces.select}, parent_id AS _parent_id FROM ${sqlPieces.from}
    ${sqlPieces.joins}
    WHERE ${where} ${whereDead}
    ${sqlPieces.orderBy}
  `;
    const allRows = await all(finalSql);
    const { parents, children: children2 } = allRows.reduce((acc, trans) => {
        const pid = trans._parent_id;
        delete trans._parent_id;
        if (pid == null) {
            acc.parents.push(trans);
        }
        else {
            const arr = acc.children.get(pid) || [];
            arr.push(trans);
            acc.children.set(pid, arr);
        }
        return acc;
    }, { parents: [], children: /* @__PURE__ */ new Map() });
    const mapper = (trans) => {
        Object.keys(trans).forEach((name) => {
            trans[name] = convertOutputType(trans[name], outputTypes.get(name));
        });
        if (matched && !matched.has(trans.id)) {
            trans._unmatched = true;
        }
        return trans;
    };
    return toGroup(parents, children2, mapper);
}
async function execTransactionsBasic(compilerState, queryState, sqlPieces, params, splitType, outputTypes) {
    const s = { ...sqlPieces };
    if (splitType !== "all") {
        if (splitType === "none") {
            s.where = `${s.where} AND ${s.from}.parent_id IS NULL`;
        }
        else {
            s.where = `${s.where} AND ${s.from}.is_parent = 0`;
        }
    }
    return execQuery$1(queryState, compilerState, s, params, outputTypes);
}
function isValidSplitsOption(splits) {
    return ["all", "inline", "none", "grouped"].includes(splits);
}
async function execCategoryGroups(compilerState, queryState, sqlPieces, params, outputTypes) {
    const tableOptions = queryState.tableOptions || {};
    const categoriesOption = tableOptions.categories ? tableOptions.categories : "all";
    if (!isValidCategoriesOption(categoriesOption)) {
        throw new Error(`Invalid categories option for category_groups: ${categoriesOption}`);
    }
    if (categoriesOption !== "none") {
        return execCategoryGroupsWithCategories(compilerState, queryState, sqlPieces, params, categoriesOption, outputTypes);
    }
    return execCategoryGroupsBasic(compilerState, queryState, sqlPieces, params, outputTypes);
}
async function execCategoryGroupsWithCategories(compilerState, queryState, sqlPieces, params, categoriesOption, outputTypes) {
    const categoryGroups = await execCategoryGroupsBasic(compilerState, queryState, sqlPieces, params, outputTypes);
    if (categoriesOption === "none") {
        return categoryGroups;
    }
    const { data: categories } = await aqlQuery(q("categories").filter({
        group: { $oneof: categoryGroups.map((cg) => cg.id) }
    }).select("*"));
    return categoryGroups.map((group) => {
        const cats = categories.filter((cat) => cat.group === group.id);
        return {
            ...group,
            categories: cats
        };
    });
}
async function execCategoryGroupsBasic(compilerState, queryState, sqlPieces, params, outputTypes) {
    return execQuery$1(queryState, compilerState, sqlPieces, params, outputTypes);
}
function isValidCategoriesOption(categories) {
    return ["all", "none"].includes(categories);
}
const schemaExecutors = {
    transactions: execTransactions,
    category_groups: execCategoryGroups
};
function selectFields(fields) {
    return Object.keys(fields).map((as) => {
        let field = fields[as];
        const needsAs = field !== as;
        if (!field.match(/[ .]/)) {
            field = `_.${field}`;
        }
        return needsAs ? `${field} AS ${quoteAlias(as)}` : `${field}`;
    }).join(", ");
}
function makeViews(schema2, schemaConfig2) {
    const views = schemaConfig2.views;
    const viewStrs = [];
    Object.keys(views).forEach((table) => {
        const { fields: fieldMappings = {}, ...tableViews } = views[table];
        const publicFields2 = Object.fromEntries(Object.keys(schema2[table]).map((name) => [name, name]));
        const internalFields2 = { ...publicFields2, ...fieldMappings };
        Object.keys(tableViews).forEach((viewName) => {
            const publicMaker = (overrides) => {
                const fields = { ...publicFields2, ...overrides };
                return selectFields(fields);
            };
            const internalMaker = (overrides) => {
                const fields = { ...internalFields2, ...overrides };
                return selectFields(fields);
            };
            let sql;
            if (typeof tableViews[viewName] === "function") {
                sql = tableViews[viewName](internalMaker, publicMaker);
            }
            else {
                sql = tableViews[viewName];
            }
            sql = sql.trim().replace(/;$/, "");
            viewStrs.push(`
        DROP VIEW IF EXISTS ${viewName};
        CREATE VIEW ${viewName} AS ${sql};
      `);
        });
    });
    return viewStrs.join("\n");
}
function aqlCompiledQuery(queryState, sqlPieces, compilerState, params) {
    return runCompiledAqlQuery(queryState, sqlPieces, compilerState, {
        params,
        executors: schemaExecutors
    });
}
function aqlQuery(query, params) {
    if (query instanceof Query) {
        query = query.serialize();
    }
    return compileAndRunAqlQuery(schema, schemaConfig, query, {
        params,
        executors: schemaExecutors
    });
}
function sequential(fn) {
    const sequenceState = {
        running: null,
        queue: []
    };
    function pump() {
        const next = sequenceState.queue.shift();
        if (next !== void 0) {
            run2(next.args, next.resolve, next.reject);
        }
        else {
            sequenceState.running = null;
        }
    }
    function run2(args, resolve, reject) {
        sequenceState.running = fn.apply(null, args).then((val2) => {
            pump();
            resolve(val2);
        }, (err) => {
            pump();
            reject(err);
        });
    }
    return (...args) => {
        if (!sequenceState.running) {
            return new Promise((resolve, reject) => {
                return run2(args, resolve, reject);
            });
        }
        else {
            return new Promise((resolve, reject) => {
                sequenceState.queue.push({ resolve, reject, args });
            });
        }
    };
}
function once(fn) {
    let promise = null;
    return (...args) => {
        if (!promise) {
            promise = fn.apply(null, args).finally(() => {
                promise = null;
            });
            return promise;
        }
        return promise;
    };
}
function Graph() {
    const graph = {
        addNode,
        removeNode,
        adjacent,
        adjacentIncoming,
        addEdge,
        removeEdge,
        removeIncomingEdges,
        topologicalSort,
        generateDOT,
        getEdges
    };
    const edges = /* @__PURE__ */ new Map();
    const incomingEdges = /* @__PURE__ */ new Map();
    function getEdges() {
        return { edges, incomingEdges };
    }
    function addNode(node2) {
        edges.set(node2, adjacent(node2));
        incomingEdges.set(node2, adjacentIncoming(node2));
        return graph;
    }
    function removeIncomingEdges(node2) {
        const incoming = adjacentIncoming(node2);
        incomingEdges.set(node2, /* @__PURE__ */ new Set());
        const iter = incoming.values();
        let cur = iter.next();
        while (!cur.done) {
            removeEdge(cur.value, node2);
            cur = iter.next();
        }
    }
    function removeNode(node2) {
        removeIncomingEdges(node2);
        edges.delete(node2);
        incomingEdges.delete(node2);
        return graph;
    }
    function adjacent(node2) {
        return edges.get(node2) || /* @__PURE__ */ new Set();
    }
    function adjacentIncoming(node2) {
        return incomingEdges.get(node2) || /* @__PURE__ */ new Set();
    }
    function addEdge(node1, node2) {
        addNode(node1);
        addNode(node2);
        adjacent(node1).add(node2);
        adjacentIncoming(node2).add(node1);
        return graph;
    }
    function removeEdge(node1, node2) {
        if (edges.has(node1)) {
            adjacent(node1).delete(node2);
        }
        if (incomingEdges.has(node2)) {
            adjacentIncoming(node2).delete(node1);
        }
        return graph;
    }
    function topologicalSort(sourceNodes) {
        const visited = /* @__PURE__ */ new Set();
        const sorted = [];
        sourceNodes.forEach((name) => {
            if (!visited.has(name)) {
                topologicalSortIterable(name, visited, sorted);
            }
        });
        return sorted;
    }
    function topologicalSortIterable(name, visited, sorted) {
        const stackTrace = [];
        stackTrace.push({
            count: -1,
            value: name,
            parent: "",
            level: 0
        });
        while (stackTrace.length > 0) {
            const current = stackTrace.slice(-1)[0];
            const adjacents = adjacent(current.value);
            if (current.count === -1) {
                current.count = adjacents.size;
            }
            if (current.count > 0) {
                const iter = adjacents.values();
                let cur = iter.next();
                while (!cur.done) {
                    if (!visited.has(cur.value)) {
                        stackTrace.push({
                            count: -1,
                            parent: current.value,
                            value: cur.value,
                            level: current.level + 1
                        });
                    }
                    else {
                        current.count--;
                    }
                    cur = iter.next();
                }
            }
            else {
                if (!visited.has(current.value)) {
                    visited.add(current.value);
                    sorted.unshift(current.value);
                }
                const removed = stackTrace.pop();
                for (let i = 0; i < stackTrace.length; i++) {
                    if (stackTrace[i].value === removed.parent) {
                        stackTrace[i].count--;
                    }
                }
            }
        }
    }
    function generateDOT() {
        const edgeStrings = [];
        edges.forEach(function (adj, edge) {
            if (adj.length !== 0) {
                edgeStrings.push(`${edge} -> {${adj.join(",")}}`);
            }
        });
        return `
    digraph G {
      ${edgeStrings.join("\n").replace(/!/g, "_")}
    }
    `;
    }
    return graph;
}
function unresolveName(name) {
    const idx = name.indexOf("!");
    if (idx !== -1) {
        return {
            sheet: name.slice(0, idx),
            name: name.slice(idx + 1)
        };
    }
    return { sheet: null, name };
}
function resolveName(sheet, name) {
    return sheet + "!" + name;
}
class Spreadsheet {
    constructor(saveCache, setCacheStatus2) {
        this.graph = new Graph();
        this.nodes = /* @__PURE__ */ new Map();
        this.transactionDepth = 0;
        this.saveCache = saveCache;
        this.setCacheStatus = setCacheStatus2;
        this.dirtyCells = [];
        this.computeQueue = [];
        this.events = mitt();
        this._meta = {
            createdMonths: /* @__PURE__ */ new Set(),
            budgetType: "envelope"
        };
    }
    meta() {
        return this._meta;
    }
    setMeta(meta) {
        this._meta = meta;
    }
    // Spreadsheet interface
    _getNode(name) {
        const { sheet } = unresolveName(name);
        if (!this.nodes.has(name)) {
            this.nodes.set(name, {
                name,
                expr: null,
                value: null,
                sheet
            });
        }
        return this.nodes.get(name);
    }
    getNode(name) {
        return this._getNode(name);
    }
    hasCell(name) {
        return this.nodes.has(name);
    }
    add(name, expr) {
        this.set(name, expr);
    }
    getNodes() {
        return this.nodes;
    }
    serialize() {
        return {
            graph: this.graph.getEdges(),
            nodes: [...this.nodes.entries()]
        };
    }
    transaction(func) {
        this.startTransaction();
        try {
            func();
        }
        catch (e) {
            logger.log(e);
        }
        return this.endTransaction();
    }
    startTransaction() {
        this.transactionDepth++;
    }
    endTransaction() {
        this.transactionDepth--;
        if (this.transactionDepth === 0) {
            const cells = this.dirtyCells;
            this.dirtyCells = [];
            this.queueComputation(this.graph.topologicalSort(cells));
        }
        return [];
    }
    queueComputation(cellNames) {
        this.computeQueue = this.computeQueue.concat(cellNames);
        Promise.resolve().then(() => {
            if (!this.running) {
                this.runComputations();
            }
        });
    }
    runComputations(idx = 0) {
        this.running = true;
        while (idx < this.computeQueue.length) {
            const name = this.computeQueue[idx];
            let node2;
            let result;
            try {
                node2 = this.getNode(name);
                if (node2._run) {
                    const args = node2._dependencies.map((dep) => {
                        return this.getNode(dep).value;
                    });
                    result = node2._run(...args);
                    if (result instanceof Promise) {
                        logger.warn(`dynamic cell ${name} returned a promise! this is discouraged because errors are not handled properly`);
                    }
                }
                else if (node2.sql) {
                    result = aqlCompiledQuery(node2.query, node2.sql.sqlPieces, node2.sql.state);
                }
                else {
                    idx++;
                    continue;
                }
            }
            catch (e) {
                logger.log("Error while evaluating " + name + ":", e);
                this.running = false;
                this.computeQueue = [];
                return;
            }
            if (result instanceof Promise) {
                result.then((value) => {
                    node2.value = value;
                    this.runComputations(idx + 1);
                }, (err) => {
                    logger.warn(`Failed running ${node2.name}!`, err);
                    this.runComputations(idx + 1);
                });
                return;
            }
            else {
                node2.value = result;
            }
            idx++;
        }
        if (idx === this.computeQueue.length) {
            this.events.emit("change", { names: this.computeQueue });
            if (typeof this.saveCache === "function") {
                this.saveCache(this.computeQueue);
            }
            this.markCacheSafe();
            this.running = false;
            this.computeQueue = [];
        }
    }
    markCacheSafe() {
        if (!this.cacheBarrier) {
            if (this.setCacheStatus) {
                this.setCacheStatus({ clean: true });
            }
        }
    }
    markCacheDirty() {
        if (this.setCacheStatus) {
            this.setCacheStatus({ clean: false });
        }
    }
    startCacheBarrier() {
        this.cacheBarrier = true;
        this.markCacheDirty();
    }
    endCacheBarrier() {
        this.cacheBarrier = false;
        const pendingChange = this.running || this.computeQueue.length > 0;
        if (!pendingChange) {
            this.markCacheSafe();
        }
    }
    addEventListener(name, func) {
        this.events.on(name, func);
        return () => this.events.off(name, func);
    }
    onFinish(func) {
        if (this.transactionDepth !== 0) {
            throw new Error("onFinish called while inside a spreadsheet transaction. This is not allowed as it will lead to race conditions");
        }
        if (!this.running && this.computeQueue.length === 0) {
            func([]);
            return () => {
            };
        }
        const remove = this.addEventListener("change", (...args) => {
            remove();
            return func(...args);
        });
        return remove;
    }
    unload() {
        this.events.all.clear();
    }
    getValue(name) {
        return this.getNode(name).value;
    }
    getExpr(name) {
        return this.getNode(name).expr;
    }
    getCellValue(sheet, name) {
        return this.getNode(resolveName(sheet, name)).value;
    }
    getCellExpr(sheet, name) {
        return this.getNode(resolveName(sheet, name)).expr;
    }
    getCellValueLoose(sheetName, cellName) {
        const name = resolveName(sheetName, cellName);
        if (this.nodes.has(name)) {
            return this.getNode(name).value;
        }
        return null;
    }
    bootup(onReady) {
        this.onFinish(() => {
            onReady();
        });
    }
    load(name, value) {
        const node2 = this._getNode(name);
        node2.expr = value;
        node2.value = value;
    }
    create(name, value) {
        return this.transaction(() => {
            const node2 = this._getNode(name);
            node2.expr = value;
            node2.value = value;
            this._markDirty(name);
        });
    }
    set(name, value) {
        this.create(name, value);
    }
    recompute(name) {
        this.transaction(() => {
            this.dirtyCells.push(name);
        });
    }
    recomputeAll() {
        this.transaction(() => {
            this.dirtyCells = [...this.nodes.keys()];
        });
    }
    createQuery(sheetName, cellName, query) {
        const name = resolveName(sheetName, cellName);
        const node2 = this._getNode(name);
        if (node2.query !== query) {
            node2.query = query;
            const { sqlPieces, state } = compileQuery(node2.query, schema, schemaConfig);
            node2.sql = { sqlPieces, state };
            this.transaction(() => {
                this._markDirty(name);
            });
        }
    }
    createStatic(sheetName, cellName, initialValue) {
        const name = resolveName(sheetName, cellName);
        const exists2 = this.nodes.has(name);
        if (!exists2) {
            this.create(name, initialValue);
        }
    }
    createDynamic(sheetName, cellName, { dependencies = [], run: run2, initialValue, refresh = false }) {
        const name = resolveName(sheetName, cellName);
        const node2 = this._getNode(name);
        if (node2.dynamic) {
            return;
        }
        node2.dynamic = true;
        node2._run = run2;
        dependencies = dependencies.map((dep) => {
            let resolved;
            if (!unresolveName(dep).sheet) {
                resolved = resolveName(sheetName, dep);
            }
            else {
                resolved = dep;
            }
            return resolved;
        });
        node2._dependencies = dependencies;
        this.graph.removeIncomingEdges(name);
        dependencies.forEach((dep) => {
            this.graph.addEdge(dep, name);
        });
        if (node2.value == null || refresh) {
            this.transaction(() => {
                node2.value = initialValue;
                this._markDirty(name);
            });
        }
    }
    clearSheet(sheetName) {
        for (const [name, node2] of this.nodes.entries()) {
            if (node2.sheet === sheetName) {
                this.nodes.delete(name);
            }
        }
    }
    voidCell(sheetName, name, voidValue = null) {
        const node2 = this.getNode(resolveName(sheetName, name));
        node2._run = null;
        node2.dynamic = false;
        node2.value = voidValue;
    }
    deleteCell(sheetName, name) {
        this.voidCell(sheetName, name);
        this.nodes.delete(resolveName(sheetName, name));
    }
    addDependencies(sheetName, cellName, deps) {
        const name = resolveName(sheetName, cellName);
        deps = deps.map((dep) => {
            if (!unresolveName(dep).sheet) {
                return resolveName(sheetName, dep);
            }
            return dep;
        });
        const node2 = this.getNode(name);
        const newDeps = deps.filter((dep) => (node2._dependencies || []).indexOf(dep) === -1);
        if (newDeps.length > 0) {
            node2._dependencies = (node2._dependencies || []).concat(newDeps);
            newDeps.forEach((dep) => {
                this.graph.addEdge(dep, name);
            });
            this.recompute(name);
        }
    }
    removeDependencies(sheetName, cellName, deps) {
        const name = resolveName(sheetName, cellName);
        deps = deps.map((dep) => {
            if (!unresolveName(dep).sheet) {
                return resolveName(sheetName, dep);
            }
            return dep;
        });
        const node2 = this.getNode(name);
        node2._dependencies = (node2._dependencies || []).filter((dep) => deps.indexOf(dep) === -1);
        deps.forEach((dep) => {
            this.graph.removeEdge(dep, name);
        });
        this.recompute(name);
    }
    _markDirty(name) {
        this.dirtyCells.push(name);
    }
    triggerDatabaseChanges(oldValues, newValues) {
        const tables = /* @__PURE__ */ new Set([...oldValues.keys(), ...newValues.keys()]);
        this.startTransaction();
        this.nodes.forEach((node2) => {
            if (node2.sql && node2.sql.state.dependencies.some((dep) => tables.has(dep))) {
                this._markDirty(node2.name);
            }
        });
        this.endTransaction();
    }
}
let globalSheet;
let globalOnChange;
let globalCacheDb;
function get$3() {
    return globalSheet;
}
async function updateSpreadsheetCache(rawDb, names) {
    await transaction$1(rawDb, () => {
        names.forEach((name) => {
            const node2 = globalSheet._getNode(name);
            if (node2.sql == null) {
                runQuery$1(rawDb, "INSERT OR REPLACE INTO kvcache (key, value) VALUES (?, ?)", [name, JSON.stringify(node2.value)]);
            }
        });
    });
}
function setCacheStatus(mainDb, cacheDb, { clean }) {
    if (clean) {
        const num2 = Math.random() * 1e7;
        runQuery$1(cacheDb, "INSERT OR REPLACE INTO kvcache_key (id, key) VALUES (1, ?)", [num2]);
        if (mainDb) {
            runQuery$1(mainDb, "INSERT OR REPLACE INTO kvcache_key (id, key) VALUES (1, ?)", [num2]);
        }
    }
    else {
        runQuery$1(cacheDb, "DELETE FROM kvcache_key");
    }
}
function isCacheDirty(mainDb, cacheDb) {
    let rows = runQuery$1(cacheDb, "SELECT key FROM kvcache_key WHERE id = 1", [], true);
    const num2 = rows.length === 0 ? null : rows[0].key;
    if (num2 == null) {
        return true;
    }
    if (mainDb) {
        const rows2 = runQuery$1(mainDb, "SELECT key FROM kvcache_key WHERE id = 1", [], true);
        if (rows2.length === 0 || rows2[0].key !== num2) {
            return true;
        }
    }
    rows = runQuery$1(cacheDb, "SELECT * FROM kvcache LIMIT 1", [], true);
    return rows.length === 0;
}
async function loadSpreadsheet(db2, onSheetChange2) {
    const cacheEnabled = process.env.NODE_ENV !== "test";
    const mainDb = db2.getDatabase();
    let cacheDb;
    if (cacheEnabled) {
        const cachePath = db2.getDatabasePath().replace(/db\.sqlite$/, "cache.sqlite");
        globalCacheDb = cacheDb = openDatabase$1(cachePath);
        execQuery$2(cacheDb, `
        CREATE TABLE IF NOT EXISTS kvcache (key TEXT PRIMARY KEY, value TEXT);
        CREATE TABLE IF NOT EXISTS kvcache_key (id INTEGER PRIMARY KEY, key REAL)
      `);
    }
    else {
        cacheDb = mainDb;
    }
    let sheet;
    if (cacheEnabled) {
        sheet = new Spreadsheet(updateSpreadsheetCache.bind(null, cacheDb), setCacheStatus.bind(null, mainDb, cacheDb));
    }
    else {
        sheet = new Spreadsheet();
    }
    globalSheet = sheet;
    globalOnChange = onSheetChange2;
    if (onSheetChange2) {
        sheet.addEventListener("change", onSheetChange2);
    }
    if (cacheEnabled && !isCacheDirty(mainDb, cacheDb)) {
        const cachedRows = await runQuery$1(cacheDb, "SELECT * FROM kvcache", [], true);
        logger.log(`Loaded spreadsheet from cache (${cachedRows.length} items)`);
        for (const row of cachedRows) {
            const parsed = JSON.parse(row.value);
            sheet.load(row.key, parsed);
        }
    }
    else {
        logger.log("Loading fresh spreadsheet");
        await loadUserBudgets(db2);
    }
    return sheet;
}
function unloadSpreadsheet() {
    if (globalSheet) {
        globalSheet.unload();
        globalSheet = null;
    }
    if (globalCacheDb) {
        closeDatabase$1(globalCacheDb);
        globalCacheDb = null;
    }
}
async function reloadSpreadsheet(db2) {
    if (globalSheet) {
        unloadSpreadsheet();
        return loadSpreadsheet(db2, globalOnChange);
    }
}
async function loadUserBudgets(db2) {
    const sheet = globalSheet;
    const { value: budgetType = "envelope" } = await db2.first("SELECT value from preferences WHERE id = ?", ["budgetType"]) ?? {};
    const table = budgetType === "tracking" ? "reflect_budgets" : "zero_budgets";
    const budgets = await db2.all(`
      SELECT * FROM ${table} b
      LEFT JOIN categories c ON c.id = b.category
      WHERE c.tombstone = 0
    `);
    sheet.startTransaction();
    for (const budget of budgets) {
        if (budget.month && budget.category) {
            const sheetName = `budget${budget.month}`;
            sheet.set(`${sheetName}!budget-${budget.category}`, budget.amount);
            sheet.set(`${sheetName}!carryover-${budget.category}`, budget.carryover === 1 ? true : false);
            sheet.set(`${sheetName}!goal-${budget.category}`, budget.goal);
            sheet.set(`${sheetName}!long-goal-${budget.category}`, budget.long_goal);
        }
    }
    if (budgetType !== "tracking") {
        const budgetMonths = await db2.all("SELECT * FROM zero_budget_months");
        for (const budgetMonth of budgetMonths) {
            const sheetName = sheetForMonth(budgetMonth.id);
            sheet.set(`${sheetName}!buffered`, budgetMonth.buffered);
        }
    }
    sheet.endTransaction();
}
function getCell$1(sheet, name) {
    return globalSheet._getNode(resolveName(sheet, name));
}
function getCellValue(sheet, name) {
    return globalSheet.getValue(resolveName(sheet, name));
}
function startTransaction() {
    if (globalSheet) {
        globalSheet.startTransaction();
    }
}
function endTransaction() {
    if (globalSheet) {
        globalSheet.endTransaction();
    }
}
function waitOnSpreadsheet() {
    return new Promise((resolve) => {
        if (globalSheet) {
            globalSheet.onFinish(resolve);
        }
        else {
            resolve(void 0);
        }
    });
}
const formatDistanceLocale$1i = {
    lessThanXSeconds: {
        one: "minder as 'n sekonde",
        other: "minder as {{count}} sekondes"
    },
    xSeconds: {
        one: "1 sekonde",
        other: "{{count}} sekondes"
    },
    halfAMinute: "'n halwe minuut",
    lessThanXMinutes: {
        one: "minder as 'n minuut",
        other: "minder as {{count}} minute"
    },
    xMinutes: {
        one: "'n minuut",
        other: "{{count}} minute"
    },
    aboutXHours: {
        one: "ongeveer 1 uur",
        other: "ongeveer {{count}} ure"
    },
    xHours: {
        one: "1 uur",
        other: "{{count}} ure"
    },
    xDays: {
        one: "1 dag",
        other: "{{count}} dae"
    },
    aboutXWeeks: {
        one: "ongeveer 1 week",
        other: "ongeveer {{count}} weke"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weke"
    },
    aboutXMonths: {
        one: "ongeveer 1 maand",
        other: "ongeveer {{count}} maande"
    },
    xMonths: {
        one: "1 maand",
        other: "{{count}} maande"
    },
    aboutXYears: {
        one: "ongeveer 1 jaar",
        other: "ongeveer {{count}} jaar"
    },
    xYears: {
        one: "1 jaar",
        other: "{{count}} jaar"
    },
    overXYears: {
        one: "meer as 1 jaar",
        other: "meer as {{count}} jaar"
    },
    almostXYears: {
        one: "byna 1 jaar",
        other: "byna {{count}} jaar"
    }
};
const formatDistance$1j = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$1i[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "oor " + result;
        }
        else {
            return result + " gelede";
        }
    }
    return result;
};
const dateFormats$1r = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "yyyy/MM/dd"
};
const timeFormats$1r = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$1r = {
    full: "{{date}} 'om' {{time}}",
    long: "{{date}} 'om' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1r = {
    date: buildFormatLongFn({
        formats: dateFormats$1r,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1r,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1r,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1j = {
    lastWeek: "'verlede' eeee 'om' p",
    yesterday: "'gister om' p",
    today: "'vandag om' p",
    tomorrow: "'mre om' p",
    nextWeek: "eeee 'om' p",
    other: "P"
};
const formatRelative$1j = (token, _date, _baseDate, _options) => formatRelativeLocale$1j[token];
const eraValues$1j = {
    narrow: ["vC", "nC"],
    abbreviated: ["vC", "nC"],
    wide: ["voor Christus", "na Christus"]
};
const quarterValues$1j = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1ste kwartaal", "2de kwartaal", "3de kwartaal", "4de kwartaal"]
};
const monthValues$1j = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Feb",
        "Mrt",
        "Apr",
        "Mei",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Des"
    ],
    wide: [
        "Januarie",
        "Februarie",
        "Maart",
        "April",
        "Mei",
        "Junie",
        "Julie",
        "Augustus",
        "September",
        "Oktober",
        "November",
        "Desember"
    ]
};
const dayValues$1j = {
    narrow: ["S", "M", "D", "W", "D", "V", "S"],
    short: ["So", "Ma", "Di", "Wo", "Do", "Vr", "Sa"],
    abbreviated: ["Son", "Maa", "Din", "Woe", "Don", "Vry", "Sat"],
    wide: [
        "Sondag",
        "Maandag",
        "Dinsdag",
        "Woensdag",
        "Donderdag",
        "Vrydag",
        "Saterdag"
    ]
};
const dayPeriodValues$1j = {
    narrow: {
        am: "vm",
        pm: "nm",
        midnight: "middernag",
        noon: "middaguur",
        morning: "oggend",
        afternoon: "middag",
        evening: "laat middag",
        night: "aand"
    },
    abbreviated: {
        am: "vm",
        pm: "nm",
        midnight: "middernag",
        noon: "middaguur",
        morning: "oggend",
        afternoon: "middag",
        evening: "laat middag",
        night: "aand"
    },
    wide: {
        am: "vm",
        pm: "nm",
        midnight: "middernag",
        noon: "middaguur",
        morning: "oggend",
        afternoon: "middag",
        evening: "laat middag",
        night: "aand"
    }
};
const formattingDayPeriodValues$13 = {
    narrow: {
        am: "vm",
        pm: "nm",
        midnight: "middernag",
        noon: "uur die middag",
        morning: "uur die oggend",
        afternoon: "uur die middag",
        evening: "uur die aand",
        night: "uur die aand"
    },
    abbreviated: {
        am: "vm",
        pm: "nm",
        midnight: "middernag",
        noon: "uur die middag",
        morning: "uur die oggend",
        afternoon: "uur die middag",
        evening: "uur die aand",
        night: "uur die aand"
    },
    wide: {
        am: "vm",
        pm: "nm",
        midnight: "middernag",
        noon: "uur die middag",
        morning: "uur die oggend",
        afternoon: "uur die middag",
        evening: "uur die aand",
        night: "uur die aand"
    }
};
const ordinalNumber$1j = (dirtyNumber) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 < 20) {
        switch (rem100) {
            case 1:
            case 8:
                return number2 + "ste";
            default:
                return number2 + "de";
        }
    }
    return number2 + "ste";
};
const localize$1j = {
    ordinalNumber: ordinalNumber$1j,
    era: buildLocalizeFn({
        values: eraValues$1j,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1j,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1j,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1j,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1j,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$13,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1i = /^(\d+)(ste|de)?/i;
const parseOrdinalNumberPattern$1i = /\d+/i;
const matchEraPatterns$1i = {
    narrow: /^([vn]\.? ?C\.?)/,
    abbreviated: /^([vn]\. ?C\.?)/,
    wide: /^((voor|na) Christus)/
};
const parseEraPatterns$1i = {
    any: [/^v/, /^n/]
};
const matchQuarterPatterns$1i = {
    narrow: /^[1234]/i,
    abbreviated: /^K[1234]/i,
    wide: /^[1234](st|d)e kwartaal/i
};
const parseQuarterPatterns$1i = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1i = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(Jan|Feb|Mrt|Apr|Mei|Jun|Jul|Aug|Sep|Okt|Nov|Dec)\.?/i,
    wide: /^(Januarie|Februarie|Maart|April|Mei|Junie|Julie|Augustus|September|Oktober|November|Desember)/i
};
const parseMonthPatterns$1i = {
    narrow: [
        /^J/i,
        /^F/i,
        /^M/i,
        /^A/i,
        /^M/i,
        /^J/i,
        /^J/i,
        /^A/i,
        /^S/i,
        /^O/i,
        /^N/i,
        /^D/i
    ],
    any: [
        /^Jan/i,
        /^Feb/i,
        /^Mrt/i,
        /^Apr/i,
        /^Mei/i,
        /^Jun/i,
        /^Jul/i,
        /^Aug/i,
        /^Sep/i,
        /^Okt/i,
        /^Nov/i,
        /^Dec/i
    ]
};
const matchDayPatterns$1i = {
    narrow: /^[smdwv]/i,
    short: /^(So|Ma|Di|Wo|Do|Vr|Sa)/i,
    abbreviated: /^(Son|Maa|Din|Woe|Don|Vry|Sat)/i,
    wide: /^(Sondag|Maandag|Dinsdag|Woensdag|Donderdag|Vrydag|Saterdag)/i
};
const parseDayPatterns$1i = {
    narrow: [/^S/i, /^M/i, /^D/i, /^W/i, /^D/i, /^V/i, /^S/i],
    any: [/^So/i, /^Ma/i, /^Di/i, /^Wo/i, /^Do/i, /^Vr/i, /^Sa/i]
};
const matchDayPeriodPatterns$1i = {
    any: /^(vm|nm|middernag|(?:uur )?die (oggend|middag|aand))/i
};
const parseDayPeriodPatterns$1i = {
    any: {
        am: /^vm/i,
        pm: /^nm/i,
        midnight: /^middernag/i,
        noon: /^middaguur/i,
        morning: /oggend/i,
        afternoon: /middag/i,
        evening: /laat middag/i,
        night: /aand/i
    }
};
const match$1i = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1i,
        parsePattern: parseOrdinalNumberPattern$1i,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1i,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1i,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1i,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1i,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1i,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1i,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1i,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1i,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1i,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1i,
        defaultParseWidth: "any"
    })
};
const af = {
    code: "af",
    formatDistance: formatDistance$1j,
    formatLong: formatLong$1r,
    formatRelative: formatRelative$1j,
    localize: localize$1j,
    match: match$1i,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1h = {
    lessThanXSeconds: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xHours: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xWeeks: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xMonths: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xYears: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: "   ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    }
};
const formatDistance$1i = (token, count, options2) => {
    const usageGroup = formatDistanceLocale$1h[token];
    let result;
    if (typeof usageGroup === "string") {
        result = usageGroup;
    }
    else if (count === 1) {
        result = usageGroup.one;
    }
    else if (count === 2) {
        result = usageGroup.two;
    }
    else if (count <= 10) {
        result = usageGroup.threeToTen.replace("{{count}}", String(count));
    }
    else {
        result = usageGroup.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$1q = {
    full: "EEEE do MMMM y",
    long: "do MMMM y",
    medium: "d MMM y",
    short: "dd/MM/yyyy"
};
const timeFormats$1q = {
    full: "HH:mm:ss",
    long: "HH:mm:ss",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$1q = {
    full: "{{date}} ' ' {{time}}",
    long: "{{date}} ' ' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1q = {
    date: buildFormatLongFn({
        formats: dateFormats$1q,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1q,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1q,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1i = {
    lastWeek: "eeee '  ' p",
    yesterday: "'  ' p",
    today: "'  ' p",
    tomorrow: "'  ' p",
    nextWeek: "eeee '  ' p",
    other: "P"
};
const formatRelative$1i = (token) => formatRelativeLocale$1i[token];
const eraValues$1i = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", " "]
};
const quarterValues$1i = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$1i = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1i = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1i = {
    narrow: {
        am: "",
        pm: "",
        morning: "",
        noon: "",
        afternoon: " ",
        evening: "",
        night: "",
        midnight: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        morning: "",
        noon: "",
        afternoon: " ",
        evening: "",
        night: "",
        midnight: " "
    },
    wide: {
        am: "",
        pm: "",
        morning: "",
        noon: "",
        afternoon: " ",
        evening: "",
        night: "",
        midnight: " "
    }
};
const formattingDayPeriodValues$12 = {
    narrow: {
        am: "",
        pm: "",
        morning: " ",
        noon: "",
        afternoon: " ",
        evening: " ",
        night: " ",
        midnight: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        morning: " ",
        noon: "",
        afternoon: " ",
        evening: " ",
        night: " ",
        midnight: " "
    },
    wide: {
        am: "",
        pm: "",
        morning: " ",
        noon: "",
        afternoon: " ",
        evening: " ",
        night: " ",
        midnight: " "
    }
};
const ordinalNumber$1i = (num2) => String(num2);
const localize$1i = {
    ordinalNumber: ordinalNumber$1i,
    era: buildLocalizeFn({
        values: eraValues$1i,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1i,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1i,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1i,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1i,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$12,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1h = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1h = /\d+/i;
const matchEraPatterns$1h = {
    narrow: /[]/,
    abbreviated: /[]\.\./,
    wide: /(|) /
};
const parseEraPatterns$1h = {
    any: [//, //]
};
const matchQuarterPatterns$1h = {
    narrow: /^[1234]/i,
    abbreviated: /[1234]/,
    wide: / (|||)/
};
const parseQuarterPatterns$1h = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1h = {
    narrow: /^[]/,
    abbreviated: /^(|||||||||||)/,
    wide: /^(|||||||||||)/
};
const parseMonthPatterns$1h = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$1h = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$1h = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1h = {
    narrow: /^(|| || | | | )/,
    any: /^(|| || | | | )/
};
const parseDayPeriodPatterns$1h = {
    any: {
        am: /^/,
        pm: /^/,
        midnight: / /,
        noon: //,
        afternoon: / /,
        morning: / /,
        evening: / /,
        night: / /
    }
};
const match$1h = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1h,
        parsePattern: parseOrdinalNumberPattern$1h,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1h,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1h,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1h,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1h,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1h,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1h,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1h,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1h,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1h,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1h,
        defaultParseWidth: "any"
    })
};
const ar = {
    code: "ar",
    formatDistance: formatDistance$1i,
    formatLong: formatLong$1q,
    formatRelative: formatRelative$1i,
    localize: localize$1i,
    match: match$1h,
    options: {
        weekStartsOn: 6,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1g = {
    lessThanXSeconds: {
        one: "   ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xHours: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xWeeks: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xMonths: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xYears: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    }
};
const formatDistance$1h = (token, count, options2) => {
    options2 = options2 || {};
    const usageGroup = formatDistanceLocale$1g[token];
    let result;
    if (typeof usageGroup === "string") {
        result = usageGroup;
    }
    else if (count === 1) {
        result = usageGroup.one;
    }
    else if (count === 2) {
        result = usageGroup.two;
    }
    else if (count <= 10) {
        result = usageGroup.threeToTen.replace("{{count}}", String(count));
    }
    else {
        result = usageGroup.other.replace("{{count}}", String(count));
    }
    if (options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "  " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$1p = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$1p = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1p = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1p = {
    date: buildFormatLongFn({
        formats: dateFormats$1p,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1p,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1p,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1h = {
    lastWeek: "'' eeee '' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$1h = (token, _date, _baseDate, _options) => {
    return formatRelativeLocale$1h[token];
};
const eraValues$1h = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", " "]
};
const quarterValues$1h = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$1h = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1h = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1h = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$11 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: " ",
        night: " "
    }
};
const ordinalNumber$1h = (dirtyNumber) => {
    return String(dirtyNumber);
};
const localize$1h = {
    ordinalNumber: ordinalNumber$1h,
    era: buildLocalizeFn({
        values: eraValues$1h,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1h,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1h,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1h,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1h,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$11,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1g = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1g = /\d+/i;
const matchEraPatterns$1g = {
    narrow: /^(|)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
    wide: /^( | | | )/i
};
const parseEraPatterns$1g = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$1g = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^ [1234]/i
};
const parseQuarterPatterns$1g = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1g = {
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$1g = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$1g = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$1g = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1g = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1g = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
const match$1g = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1g,
        parsePattern: parseOrdinalNumberPattern$1g,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1g,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1g,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1g,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1g,
        defaultParseWidth: "any",
        valueCallback: (index) => Number(index) + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1g,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1g,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1g,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1g,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1g,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1g,
        defaultParseWidth: "any"
    })
};
const arDZ = {
    code: "ar-DZ",
    formatDistance: formatDistance$1h,
    formatLong: formatLong$1p,
    formatRelative: formatRelative$1h,
    localize: localize$1h,
    match: match$1g,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1f = {
    lessThanXSeconds: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " ",
        two: " ",
        threeToTen: " {{count}} ",
        other: " {{count}} "
    },
    xHours: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " ",
        two: " ",
        threeToTen: " {{count}} ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " ",
        two: " ",
        threeToTen: " {{count}} ",
        other: " {{count}} "
    },
    xMonths: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " ",
        two: " ",
        threeToTen: " {{count}} ",
        other: " {{count}} "
    },
    xYears: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: " ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    }
};
const formatDistance$1g = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$1f[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 2) {
        result = tokenValue.two;
    }
    else if (count <= 10) {
        result = tokenValue.threeToTen.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return `  ${result}`;
        }
        else {
            return ` ${result}`;
        }
    }
    return result;
};
const dateFormats$1o = {
    full: "EEEE do MMMM y",
    long: "do MMMM y",
    medium: "dd/MMM/y",
    short: "d/MM/y"
};
const timeFormats$1o = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1o = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1o = {
    date: buildFormatLongFn({
        formats: dateFormats$1o,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1o,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1o,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1g = {
    lastWeek: "eeee '  ' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$1g = (token, _date, _baseDate, _options) => formatRelativeLocale$1g[token];
const eraValues$1g = {
    narrow: ["", ""],
    abbreviated: [".", "."],
    wide: [" ", " "]
};
const quarterValues$1g = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$1g = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1g = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1g = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$10 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        morning: " ",
        noon: "",
        afternoon: " ",
        evening: " ",
        night: " "
    }
};
const ordinalNumber$1g = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$1g = {
    ordinalNumber: ordinalNumber$1g,
    era: buildLocalizeFn({
        values: eraValues$1g,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1g,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1g,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1g,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1g,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$10,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1f = /^(\d+)/;
const parseOrdinalNumberPattern$1f = /\d+/i;
const matchEraPatterns$1f = {
    narrow: /^(|)/g,
    abbreviated: /^(.|.)/g,
    wide: /^( | )/g
};
const parseEraPatterns$1f = {
    any: [/^/g, /^/g]
};
const matchQuarterPatterns$1f = {
    narrow: /^[1234]/,
    abbreviated: /^[1234]/,
    wide: /^ (|||)/
};
const parseQuarterPatterns$1f = {
    wide: [/ /, / /, / /, / /],
    any: [/1/, /2/, /3/, /4/]
};
const matchMonthPatterns$1f = {
    narrow: /^(||||||)/,
    abbreviated: /^(|||||||||||)/,
    wide: /^(|||||||||||)/
};
const parseMonthPatterns$1f = {
    narrow: [
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/
    ],
    any: [
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/,
        /^/
    ]
};
const matchDayPatterns$1f = {
    narrow: /^(||||||)/,
    short: /^(||||||)/,
    abbreviated: /^(||||||)/,
    wide: /^(||||||)/
};
const parseDayPatterns$1f = {
    narrow: [/^/, /^/, /^/, /^/, /^/, /^/, /^/],
    any: [//, //, //, //, //, //, //]
};
const matchDayPeriodPatterns$1f = {
    narrow: /^(|||| | | | )/,
    abbreviated: /^(|| || | | | )/,
    wide: /^(|| | || | | )/,
    any: /^(|||||)/
};
const parseDayPeriodPatterns$1f = {
    any: {
        am: /^/,
        pm: /^/,
        midnight: /^/,
        noon: /^/,
        morning: /^/,
        afternoon: /^/,
        evening: /^/,
        night: /^/
    }
};
const match$1f = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1f,
        parsePattern: parseOrdinalNumberPattern$1f,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1f,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1f,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1f,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1f,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1f,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1f,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1f,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1f,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1f,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1f,
        defaultParseWidth: "any"
    })
};
const arEG = {
    code: "ar-EG",
    formatDistance: formatDistance$1g,
    formatLong: formatLong$1o,
    formatRelative: formatRelative$1g,
    localize: localize$1g,
    match: match$1f,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1e = {
    lessThanXSeconds: {
        one: "   ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xHours: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xWeeks: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xMonths: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xYears: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    }
};
const formatDistance$1f = (token, count, options2) => {
    options2 = options2 || {};
    const usageGroup = formatDistanceLocale$1e[token];
    let result;
    if (typeof usageGroup === "string") {
        result = usageGroup;
    }
    else if (count === 1) {
        result = usageGroup.one;
    }
    else if (count === 2) {
        result = usageGroup.two;
    }
    else if (count <= 10) {
        result = usageGroup.threeToTen.replace("{{count}}", String(count));
    }
    else {
        result = usageGroup.other.replace("{{count}}", String(count));
    }
    if (options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "  " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$1n = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$1n = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1n = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1n = {
    date: buildFormatLongFn({
        formats: dateFormats$1n,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1n,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1n,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1f = {
    lastWeek: "'' eeee '' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$1f = (token, _date, _baseDate, _options) => {
    return formatRelativeLocale$1f[token];
};
const eraValues$1f = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", " "]
};
const quarterValues$1f = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$1f = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1f = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1f = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$$ = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: " ",
        night: " "
    }
};
const ordinalNumber$1f = (dirtyNumber) => {
    return String(dirtyNumber);
};
const localize$1f = {
    ordinalNumber: ordinalNumber$1f,
    era: buildLocalizeFn({
        values: eraValues$1f,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1f,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1f,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1f,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1f,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$$,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1e = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1e = /\d+/i;
const matchEraPatterns$1e = {
    narrow: /^(|)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
    wide: /^( | | | )/i
};
const parseEraPatterns$1e = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$1e = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^ [1234]/i
};
const parseQuarterPatterns$1e = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1e = {
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$1e = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$1e = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$1e = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1e = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1e = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
const match$1e = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1e,
        parsePattern: parseOrdinalNumberPattern$1e,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1e,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1e,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1e,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1e,
        defaultParseWidth: "any",
        valueCallback: (index) => Number(index) + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1e,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1e,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1e,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1e,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1e,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1e,
        defaultParseWidth: "any"
    })
};
const arMA = {
    code: "ar-MA",
    formatDistance: formatDistance$1f,
    formatLong: formatLong$1n,
    formatRelative: formatRelative$1f,
    localize: localize$1f,
    match: match$1e,
    options: {
        // Monday is 1
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1d = {
    lessThanXSeconds: {
        one: "   ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xHours: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xWeeks: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xMonths: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xYears: {
        one: " ",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: "  ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    }
};
const formatDistance$1e = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$1d[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 2) {
        result = tokenValue.two;
    }
    else if (count <= 10) {
        result = tokenValue.threeToTen.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "  " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$1m = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$1m = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1m = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1m = {
    date: buildFormatLongFn({
        formats: dateFormats$1m,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1m,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1m,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1e = {
    lastWeek: "'' eeee '' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$1e = (token, _date, _baseDate, _options) => formatRelativeLocale$1e[token];
const eraValues$1e = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", " "]
};
const quarterValues$1e = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$1e = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1e = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1e = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$_ = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: " ",
        afternoon: " ",
        evening: " ",
        night: " "
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: " ",
        night: " "
    }
};
const ordinalNumber$1e = (dirtyNumber) => {
    return String(dirtyNumber);
};
const localize$1e = {
    ordinalNumber: ordinalNumber$1e,
    era: buildLocalizeFn({
        values: eraValues$1e,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1e,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1e,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1e,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1e,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$_,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1d = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1d = /\d+/i;
const matchEraPatterns$1d = {
    narrow: /^(|)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
    wide: /^( | | | )/i
};
const parseEraPatterns$1d = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$1d = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^ [1234]/i
};
const parseQuarterPatterns$1d = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1d = {
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$1d = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$1d = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$1d = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1d = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1d = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
const match$1d = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1d,
        parsePattern: parseOrdinalNumberPattern$1d,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1d,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1d,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1d,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1d,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1d,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1d,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1d,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1d,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1d,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1d,
        defaultParseWidth: "any"
    })
};
const arSA = {
    code: "ar-SA",
    formatDistance: formatDistance$1e,
    formatLong: formatLong$1m,
    formatRelative: formatRelative$1e,
    localize: localize$1e,
    match: match$1d,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1c = {
    lessThanXSeconds: {
        one: "  ",
        two: "   ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: "",
        two: " ",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xHours: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xWeeks: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xMonths: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    },
    xYears: {
        one: "",
        two: "",
        threeToTen: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        two: "  ",
        threeToTen: "  {{count}} ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: " ",
        two: " ",
        threeToTen: "{{count}}  ",
        other: "{{count}}  "
    }
};
const formatDistance$1d = (token, count, options2) => {
    const usageGroup = formatDistanceLocale$1c[token];
    let result;
    if (typeof usageGroup === "string") {
        result = usageGroup;
    }
    else if (count === 1) {
        result = usageGroup.one;
    }
    else if (count === 2) {
        result = usageGroup.two;
    }
    else if (count <= 10) {
        result = usageGroup.threeToTen.replace("{{count}}", String(count));
    }
    else {
        result = usageGroup.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$1l = {
    full: "EEEE do MMMM y",
    long: "do MMMM y",
    medium: "d MMM y",
    short: "dd/MM/yyyy"
};
const timeFormats$1l = {
    full: "HH:mm:ss",
    long: "HH:mm:ss",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$1l = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1l = {
    date: buildFormatLongFn({
        formats: dateFormats$1l,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1l,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1l,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1d = {
    lastWeek: "eeee '  ' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '  ' p ''",
    other: "P"
};
const formatRelative$1d = (token) => formatRelativeLocale$1d[token];
const eraValues$1d = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", " "]
};
const quarterValues$1d = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$1d = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1d = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1d = {
    narrow: {
        am: "",
        pm: "",
        morning: "",
        noon: "",
        afternoon: " ",
        evening: "",
        night: "",
        midnight: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        morning: "",
        noon: "",
        afternoon: " ",
        evening: "",
        night: "",
        midnight: " "
    },
    wide: {
        am: "",
        pm: "",
        morning: "",
        noon: "",
        afternoon: " ",
        evening: "",
        night: "",
        midnight: " "
    }
};
const formattingDayPeriodValues$Z = {
    narrow: {
        am: "",
        pm: "",
        morning: " ",
        noon: " ",
        afternoon: " ",
        evening: " ",
        night: " ",
        midnight: " "
    },
    abbreviated: {
        am: "",
        pm: "",
        morning: " ",
        noon: " ",
        afternoon: " ",
        evening: " ",
        night: " ",
        midnight: " "
    },
    wide: {
        am: "",
        pm: "",
        morning: " ",
        noon: " ",
        afternoon: " ",
        evening: " ",
        night: " ",
        midnight: " "
    }
};
const ordinalNumber$1d = (num2) => String(num2);
const localize$1d = {
    ordinalNumber: ordinalNumber$1d,
    era: buildLocalizeFn({
        values: eraValues$1d,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1d,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1d,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1d,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1d,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$Z,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1c = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1c = /\d+/i;
const matchEraPatterns$1c = {
    narrow: /[]/,
    abbreviated: /[]\.\./,
    wide: /(|) /
};
const parseEraPatterns$1c = {
    any: [//, //]
};
const matchQuarterPatterns$1c = {
    narrow: /^[1234]/i,
    abbreviated: /[1234]/,
    wide: / (|||)/
};
const parseQuarterPatterns$1c = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1c = {
    narrow: /^[]/,
    abbreviated: /^(|||||||||||)/,
    wide: /^(|||||||||||)/
};
const parseMonthPatterns$1c = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$1c = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$1c = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1c = {
    narrow: /^(|| ||(|) (|||))/,
    any: /^([]| ||(|) (|||))/
};
const parseDayPeriodPatterns$1c = {
    any: {
        am: /^/,
        pm: /^/,
        midnight: / /,
        noon: //,
        afternoon: / /,
        morning: //,
        evening: //,
        night: //
    }
};
const match$1c = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1c,
        parsePattern: parseOrdinalNumberPattern$1c,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1c,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1c,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1c,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1c,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1c,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1c,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1c,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1c,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1c,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1c,
        defaultParseWidth: "any"
    })
};
const arTN = {
    code: "ar-TN",
    formatDistance: formatDistance$1d,
    formatLong: formatLong$1l,
    formatRelative: formatRelative$1d,
    localize: localize$1d,
    match: match$1c,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$1b = {
    lessThanXSeconds: {
        one: "bir saniydn az",
        other: "{{count}} bir saniydn az"
    },
    xSeconds: {
        one: "1 saniy",
        other: "{{count}} saniy"
    },
    halfAMinute: "yarm dqiq",
    lessThanXMinutes: {
        one: "bir dqiqdn az",
        other: "{{count}} bir dqiqdn az"
    },
    xMinutes: {
        one: "bir dqiq",
        other: "{{count}} dqiq"
    },
    aboutXHours: {
        one: "txminn 1 saat",
        other: "txminn {{count}} saat"
    },
    xHours: {
        one: "1 saat",
        other: "{{count}} saat"
    },
    xDays: {
        one: "1 gn",
        other: "{{count}} gn"
    },
    aboutXWeeks: {
        one: "txminn 1 hft",
        other: "txminn {{count}} hft"
    },
    xWeeks: {
        one: "1 hft",
        other: "{{count}} hft"
    },
    aboutXMonths: {
        one: "txminn 1 ay",
        other: "txminn {{count}} ay"
    },
    xMonths: {
        one: "1 ay",
        other: "{{count}} ay"
    },
    aboutXYears: {
        one: "txminn 1 il",
        other: "txminn {{count}} il"
    },
    xYears: {
        one: "1 il",
        other: "{{count}} il"
    },
    overXYears: {
        one: "1 ildn ox",
        other: "{{count}} ildn ox"
    },
    almostXYears: {
        one: "demk olar ki 1 il",
        other: "demk olar ki {{count}} il"
    }
};
const formatDistance$1c = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$1b[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " sonra";
        }
        else {
            return result + " vvl";
        }
    }
    return result;
};
const dateFormats$1k = {
    full: "EEEE, do MMMM y 'il'",
    long: "do MMMM y 'il'",
    medium: "d MMM y 'il'",
    short: "dd.MM.yyyy"
};
const timeFormats$1k = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$1k = {
    full: "{{date}} {{time}} - 'd'",
    long: "{{date}} {{time}} - 'd'",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1k = {
    date: buildFormatLongFn({
        formats: dateFormats$1k,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1k,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1k,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1c = {
    lastWeek: "'sonuncu' eeee p -'d'",
    yesterday: "'dnn' p -'d'",
    today: "'bugn' p -'d'",
    tomorrow: "'sabah' p -'d'",
    nextWeek: "eeee p -'d'",
    other: "P"
};
const formatRelative$1c = (token, _date, _baseDate, _options) => formatRelativeLocale$1c[token];
const eraValues$1c = {
    narrow: ["e.", "b.e"],
    abbreviated: ["e.", "b.e"],
    wide: ["eramzdan vvl", "bizim era"]
};
const quarterValues$1c = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1ci kvartal", "2ci kvartal", "3c kvartal", "4c kvartal"]
};
const monthValues$1c = {
    narrow: ["Y", "F", "M", "A", "M", "", "", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Yan",
        "Fev",
        "Mar",
        "Apr",
        "May",
        "yun",
        "yul",
        "Avq",
        "Sen",
        "Okt",
        "Noy",
        "Dek"
    ],
    wide: [
        "Yanvar",
        "Fevral",
        "Mart",
        "Aprel",
        "May",
        "yun",
        "yul",
        "Avqust",
        "Sentyabr",
        "Oktyabr",
        "Noyabr",
        "Dekabr"
    ]
};
const dayValues$1c = {
    narrow: ["B.", "B.e", ".a", ".", "C.a", "C.", "."],
    short: ["B.", "B.e", ".a", ".", "C.a", "C.", "."],
    abbreviated: ["Baz", "Baz.e", "r.a", "r", "Cm.a", "Cm", ""],
    wide: [
        "Bazar",
        "Bazar ertsi",
        "rnb axam",
        "rnb",
        "Cm axam",
        "Cm",
        "nb"
    ]
};
const dayPeriodValues$1c = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "gecyar",
        noon: "gn",
        morning: "shr",
        afternoon: "gndz",
        evening: "axam",
        night: "gec"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "gecyar",
        noon: "gn",
        morning: "shr",
        afternoon: "gndz",
        evening: "axam",
        night: "gec"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "gecyar",
        noon: "gn",
        morning: "shr",
        afternoon: "gndz",
        evening: "axam",
        night: "gec"
    }
};
const formattingDayPeriodValues$Y = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "gecyar",
        noon: "gn",
        morning: "shr",
        afternoon: "gndz",
        evening: "axam",
        night: "gec"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "gecyar",
        noon: "gn",
        morning: "shr",
        afternoon: "gndz",
        evening: "axam",
        night: "gec"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "gecyar",
        noon: "gn",
        morning: "shr",
        afternoon: "gndz",
        evening: "axam",
        night: "gec"
    }
};
const suffixes$1 = {
    1: "-inci",
    5: "-inci",
    8: "-inci",
    70: "-inci",
    80: "-inci",
    2: "-nci",
    7: "-nci",
    20: "-nci",
    50: "-nci",
    3: "-nc",
    4: "-nc",
    100: "-nc",
    6: "-nc",
    9: "-uncu",
    10: "-uncu",
    30: "-uncu",
    60: "-nc",
    90: "-nc"
};
const getSuffix = (number2) => {
    if (number2 === 0) {
        return number2 + "-nc";
    }
    const a = number2 % 10;
    const b = number2 % 100 - a;
    const c = number2 >= 100 ? 100 : null;
    if (suffixes$1[a]) {
        return suffixes$1[a];
    }
    else if (suffixes$1[b]) {
        return suffixes$1[b];
    }
    else if (c !== null) {
        return suffixes$1[c];
    }
    return "";
};
const ordinalNumber$1c = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const suffix = getSuffix(number2);
    return number2 + suffix;
};
const localize$1c = {
    ordinalNumber: ordinalNumber$1c,
    era: buildLocalizeFn({
        values: eraValues$1c,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1c,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1c,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1c,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1c,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$Y,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1b = /^(\d+)(-?(ci|inci|nci|uncu|nc|nc))?/i;
const parseOrdinalNumberPattern$1b = /\d+/i;
const matchEraPatterns$1b = {
    narrow: /^(b|a)$/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)$/i,
    wide: /^(bizim eradan vvl|bizim era)$/i
};
const parseEraPatterns$1b = {
    any: [/^b$/i, /^(a|c)$/i]
};
const matchQuarterPatterns$1b = {
    narrow: /^[1234]$/i,
    abbreviated: /^K[1234]$/i,
    wide: /^[1234](ci)? kvartal$/i
};
const parseQuarterPatterns$1b = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1b = {
    narrow: /^[(?-i)yfmaisond]$/i,
    abbreviated: /^(Yan|Fev|Mar|Apr|May|yun|yul|Avq|Sen|Okt|Noy|Dek)$/i,
    wide: /^(Yanvar|Fevral|Mart|Aprel|May|yun|yul|Avgust|Sentyabr|Oktyabr|Noyabr|Dekabr)$/i
};
const parseMonthPatterns$1b = {
    narrow: [
        /^[(?-i)y]$/i,
        /^[(?-i)f]$/i,
        /^[(?-i)m]$/i,
        /^[(?-i)a]$/i,
        /^[(?-i)m]$/i,
        /^[(?-i)i]$/i,
        /^[(?-i)i]$/i,
        /^[(?-i)a]$/i,
        /^[(?-i)s]$/i,
        /^[(?-i)o]$/i,
        /^[(?-i)n]$/i,
        /^[(?-i)d]$/i
    ],
    abbreviated: [
        /^Yan$/i,
        /^Fev$/i,
        /^Mar$/i,
        /^Apr$/i,
        /^May$/i,
        /^yun$/i,
        /^yul$/i,
        /^Avg$/i,
        /^Sen$/i,
        /^Okt$/i,
        /^Noy$/i,
        /^Dek$/i
    ],
    wide: [
        /^Yanvar$/i,
        /^Fevral$/i,
        /^Mart$/i,
        /^Aprel$/i,
        /^May$/i,
        /^yun$/i,
        /^yul$/i,
        /^Avgust$/i,
        /^Sentyabr$/i,
        /^Oktyabr$/i,
        /^Noyabr$/i,
        /^Dekabr$/i
    ]
};
const matchDayPatterns$1b = {
    narrow: /^(B\.|B\.e|\.a|\.|C\.a|C\.|\.)$/i,
    short: /^(B\.|B\.e|\.a|\.|C\.a|C\.|\.)$/i,
    abbreviated: /^(Baz\.e|r|r\.a|Cm|Cm\.a|)$/i,
    wide: /^(Bazar|Bazar ertsi|rnb axam|rnb|Cm axam|Cm|nb)$/i
};
const parseDayPatterns$1b = {
    narrow: [
        /^B\.$/i,
        /^B\.e$/i,
        /^\.a$/i,
        /^\.$/i,
        /^C\.a$/i,
        /^C\.$/i,
        /^\.$/i
    ],
    abbreviated: [
        /^Baz$/i,
        /^Baz\.e$/i,
        /^r\.a$/i,
        /^r$/i,
        /^Cm\.a$/i,
        /^Cm$/i,
        /^$/i
    ],
    wide: [
        /^Bazar$/i,
        /^Bazar ertsi$/i,
        /^rnb axam$/i,
        /^rnb$/i,
        /^Cm axam$/i,
        /^Cm$/i,
        /^nb$/i
    ],
    any: [
        /^B\.$/i,
        /^B\.e$/i,
        /^\.a$/i,
        /^\.$/i,
        /^C\.a$/i,
        /^C\.$/i,
        /^\.$/i
    ]
};
const matchDayPeriodPatterns$1b = {
    narrow: /^(a|p|gecyar|gn|shr|gndz|axam|gec)$/i,
    any: /^(am|pm|a\.m\.|p\.m\.|AM|PM|gecyar|gn|shr|gndz|axam|gec)$/i
};
const parseDayPeriodPatterns$1b = {
    any: {
        am: /^a$/i,
        pm: /^p$/i,
        midnight: /^gecyar$/i,
        noon: /^gn$/i,
        morning: /shr$/i,
        afternoon: /gndz$/i,
        evening: /axam$/i,
        night: /gec$/i
    }
};
const match$1b = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1b,
        parsePattern: parseOrdinalNumberPattern$1b,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1b,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1b,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1b,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1b,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1b,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1b,
        defaultParseWidth: "narrow"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1b,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1b,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1b,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1b,
        defaultParseWidth: "any"
    })
};
const az = {
    code: "az",
    formatDistance: formatDistance$1c,
    formatLong: formatLong$1k,
    formatRelative: formatRelative$1c,
    localize: localize$1c,
    match: match$1b,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
function declension$6(scheme, count) {
    if (scheme.one !== void 0 && count === 1) {
        return scheme.one;
    }
    const rem10 = count % 10;
    const rem100 = count % 100;
    if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
    }
    else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
    }
    else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
    }
}
function buildLocalizeTokenFn$4(scheme) {
    return (count, options2) => {
        if (options2 && options2.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                if (scheme.future) {
                    return declension$6(scheme.future, count);
                }
                else {
                    return " " + declension$6(scheme.regular, count);
                }
            }
            else {
                if (scheme.past) {
                    return declension$6(scheme.past, count);
                }
                else {
                    return declension$6(scheme.regular, count) + " ";
                }
            }
        }
        else {
            return declension$6(scheme.regular, count);
        }
    };
}
const halfAMinute$1 = (_, options2) => {
    if (options2 && options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " ";
        }
        else {
            return " ";
        }
    }
    return "";
};
const formatDistanceLocale$1a = {
    lessThanXSeconds: buildLocalizeTokenFn$4({
        regular: {
            one: "  ",
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xSeconds: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    halfAMinute: halfAMinute$1,
    lessThanXMinutes: buildLocalizeTokenFn$4({
        regular: {
            one: "  ",
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xMinutes: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    aboutXHours: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xHours: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    xDays: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXWeeks: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xWeeks: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXMonths: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xMonths: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXYears: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xYears: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    overXYears: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        },
        future: {
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    almostXYears: buildLocalizeTokenFn$4({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    })
};
const formatDistance$1b = (token, count, options2) => {
    options2 = options2 || {};
    return formatDistanceLocale$1a[token](count, options2);
};
const dateFormats$1j = {
    full: "EEEE, d MMMM y '.'",
    long: "d MMMM y '.'",
    medium: "d MMM y '.'",
    short: "dd.MM.y"
};
const timeFormats$1j = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$1j = {
    any: "{{date}}, {{time}}"
};
const formatLong$1j = {
    date: buildFormatLongFn({
        formats: dateFormats$1j,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1j,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1j,
        defaultWidth: "any"
    })
};
const accusativeWeekdays$7 = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek$8(day) {
    const weekday = accusativeWeekdays$7[day];
    switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
    }
}
function thisWeek$8(day) {
    const weekday = accusativeWeekdays$7[day];
    return "' " + weekday + " ' p";
}
function nextWeek$8(day) {
    const weekday = accusativeWeekdays$7[day];
    switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
    }
}
const lastWeekFormat$2 = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek$8(day);
    }
    else {
        return lastWeek$8(day);
    }
};
const nextWeekFormat$2 = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek$8(day);
    }
    else {
        return nextWeek$8(day);
    }
};
const formatRelativeLocale$1b = {
    lastWeek: lastWeekFormat$2,
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: nextWeekFormat$2,
    other: "P"
};
const formatRelative$1b = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$1b[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$1b = {
    narrow: [" ..", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
};
const quarterValues$1b = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$1b = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        "",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$i = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        "",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1b = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1b = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$X = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$1b = (dirtyNumber, options2) => {
    const unit = String(options2?.unit);
    const number2 = Number(dirtyNumber);
    let suffix;
    if (unit === "date") {
        suffix = "-";
    }
    else if (unit === "hour" || unit === "minute" || unit === "second") {
        suffix = "-";
    }
    else {
        suffix = (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? "-" : "-";
    }
    return number2 + suffix;
};
const localize$1b = {
    ordinalNumber: ordinalNumber$1b,
    era: buildLocalizeFn({
        values: eraValues$1b,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1b,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1b,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$i,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1b,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1b,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$X,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1a = /^(\d+)(-?(||||||||||||))?/i;
const parseOrdinalNumberPattern$1a = /\d+/i;
const matchEraPatterns$1a = {
    narrow: /^(( )?\.?\s?\.?)/i,
    abbreviated: /^(( )?\.?\s?\.?)/i,
    wide: /^(  | | )/i
};
const parseEraPatterns$1a = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$1a = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]?)? .?/i,
    wide: /^[1234](-?[]?)? /i
};
const parseQuarterPatterns$1a = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1a = {
    narrow: /^[]/i,
    abbreviated: /^(||||[]|||||||)\.?/i,
    wide: /^([]|(|)|?|?|[]|[]|[]|(|)|(|)|?|?|(|))/i
};
const parseMonthPatterns$1a = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$1a = {
    narrow: /^[]/i,
    short: /^(|||||||||||||)\.?/i,
    abbreviated: /^(?|||||||||||).?/i,
    wide: /^([]|(|)|(|)|[]|(|)|[]|[])/i
};
const parseDayPatterns$1a = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^[]/i, /^/i, /^[]/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns$1a = {
    narrow: /^([]|\.?|\.?|\.?|||\.?|?)/i,
    abbreviated: /^([]|\.?|\.?|\.?|||\.?|?)/i,
    wide: /^([]|||[]|||?|?)/i
};
const parseDayPeriodPatterns$1a = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^[]/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$1a = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1a,
        parsePattern: parseOrdinalNumberPattern$1a,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1a,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1a,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1a,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1a,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1a,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1a,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1a,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1a,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1a,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$1a,
        defaultParseWidth: "any"
    })
};
const be = {
    code: "be",
    formatDistance: formatDistance$1b,
    formatLong: formatLong$1j,
    formatRelative: formatRelative$1b,
    localize: localize$1b,
    match: match$1a,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
function declension$5(scheme, count) {
    if (scheme.one !== void 0 && count === 1) {
        return scheme.one;
    }
    const rem10 = count % 10;
    const rem100 = count % 100;
    if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
    }
    else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
    }
    else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
    }
}
function buildLocalizeTokenFn$3(scheme) {
    return (count, options2) => {
        if (options2 && options2.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                if (scheme.future) {
                    return declension$5(scheme.future, count);
                }
                else {
                    return " " + declension$5(scheme.regular, count);
                }
            }
            else {
                if (scheme.past) {
                    return declension$5(scheme.past, count);
                }
                else {
                    return declension$5(scheme.regular, count) + " ";
                }
            }
        }
        else {
            return declension$5(scheme.regular, count);
        }
    };
}
const halfAMinute = (_, options2) => {
    if (options2 && options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " ";
        }
        else {
            return " ";
        }
    }
    return "";
};
const formatDistanceLocale$19 = {
    lessThanXSeconds: buildLocalizeTokenFn$3({
        regular: {
            one: "  ",
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xSeconds: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    halfAMinute,
    lessThanXMinutes: buildLocalizeTokenFn$3({
        regular: {
            one: "  ",
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xMinutes: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    aboutXHours: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xHours: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    xDays: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXWeeks: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xWeeks: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXMonths: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xMonths: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXYears: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xYears: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    overXYears: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        },
        future: {
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    almostXYears: buildLocalizeTokenFn$3({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    })
};
const formatDistance$1a = (token, count, options2) => {
    options2 = options2 || {};
    return formatDistanceLocale$19[token](count, options2);
};
const dateFormats$1i = {
    full: "EEEE, d MMMM y '.'",
    long: "d MMMM y '.'",
    medium: "d MMM y '.'",
    short: "dd.MM.y"
};
const timeFormats$1i = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$1i = {
    any: "{{date}}, {{time}}"
};
const formatLong$1i = {
    date: buildFormatLongFn({
        formats: dateFormats$1i,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1i,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1i,
        defaultWidth: "any"
    })
};
const accusativeWeekdays$6 = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek$7(day) {
    const weekday = accusativeWeekdays$6[day];
    switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
    }
}
function thisWeek$7(day) {
    const weekday = accusativeWeekdays$6[day];
    return "' " + weekday + " ' p";
}
function nextWeek$7(day) {
    const weekday = accusativeWeekdays$6[day];
    switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
    }
}
const lastWeekFormat$1 = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek$7(day);
    }
    else {
        return lastWeek$7(day);
    }
};
const nextWeekFormat$1 = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek$7(day);
    }
    else {
        return nextWeek$7(day);
    }
};
const formatRelativeLocale$1a = {
    lastWeek: lastWeekFormat$1,
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: nextWeekFormat$1,
    other: "P"
};
const formatRelative$1a = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$1a[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$1a = {
    narrow: [" ..", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
};
const quarterValues$1a = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$1a = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$h = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1a = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$1a = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$W = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$1a = (dirtyNumber, options2) => {
    const unit = String(options2?.unit);
    const number2 = Number(dirtyNumber);
    let suffix;
    if (unit === "date") {
        suffix = "-";
    }
    else if (unit === "hour" || unit === "minute" || unit === "second") {
        suffix = "-";
    }
    else {
        suffix = (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? "-" : "-";
    }
    return number2 + suffix;
};
const localize$1a = {
    ordinalNumber: ordinalNumber$1a,
    era: buildLocalizeFn({
        values: eraValues$1a,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1a,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1a,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$h,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1a,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1a,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$W,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$19 = /^(\d+)(-?(||||||||||||))?/i;
const parseOrdinalNumberPattern$19 = /\d+/i;
const matchEraPatterns$19 = {
    narrow: /^(( )?\.?\s?\.?)/i,
    abbreviated: /^(( )?\.?\s?\.?)/i,
    wide: /^(  | | )/i
};
const parseEraPatterns$19 = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$19 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]?)? .?/i,
    wide: /^[1234](-?[]?)? /i
};
const parseQuarterPatterns$19 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$19 = {
    narrow: /^[]/i,
    abbreviated: /^(||||()?|||||||)\.?/i,
    wide: /^([]|(|)|?|?|(|)|[]|[]|(|)|(|)|?|?|(|))/i
};
const parseMonthPatterns$19 = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$19 = {
    narrow: /^[]/i,
    short: /^(|||||||||||||)\.?/i,
    abbreviated: /^(?|||||||||||).?/i,
    wide: /^([]|(|)|(|)|[]|(|)|[]|[])/i
};
const parseDayPatterns$19 = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^[]/i, /^/i, /^[]/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns$19 = {
    narrow: /^([]|\.?|\.?|\.?|||\.?|?)/i,
    abbreviated: /^([]|\.?|\.?|\.?|||\.?|?)/i,
    wide: /^([]|||[]|||?|?)/i
};
const parseDayPeriodPatterns$19 = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^[]/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$19 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$19,
        parsePattern: parseOrdinalNumberPattern$19,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$19,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$19,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$19,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$19,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$19,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$19,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$19,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$19,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$19,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$19,
        defaultParseWidth: "any"
    })
};
const beTarask = {
    code: "be-tarask",
    formatDistance: formatDistance$1a,
    formatLong: formatLong$1i,
    formatRelative: formatRelative$1a,
    localize: localize$1a,
    match: match$19,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$18 = {
    lessThanXSeconds: {
        one: "-  ",
        other: "-  {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "-  ",
        other: "-  {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: " ",
        other: " {{count}} "
    },
    almostXYears: {
        one: " ",
        other: " {{count}} "
    }
};
const formatDistance$19 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$18[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$1h = {
    full: "EEEE, dd MMMM yyyy",
    long: "dd MMMM yyyy",
    medium: "dd MMM yyyy",
    short: "dd.MM.yyyy"
};
const timeFormats$1h = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$1h = {
    any: "{{date}} {{time}}"
};
const formatLong$1h = {
    date: buildFormatLongFn({
        formats: dateFormats$1h,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1h,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1h,
        defaultWidth: "any"
    })
};
const weekdays$3 = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek$6(day) {
    const weekday = weekdays$3[day];
    switch (day) {
        case 0:
        case 3:
        case 6:
            return "' " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
        case 5:
            return "' " + weekday + " ' p";
    }
}
function thisWeek$6(day) {
    const weekday = weekdays$3[day];
    if (day === 2) {
        return "' " + weekday + " ' p";
    }
    else {
        return "' " + weekday + " ' p";
    }
}
function nextWeek$6(day) {
    const weekday = weekdays$3[day];
    switch (day) {
        case 0:
        case 3:
        case 6:
            return "' " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
        case 5:
            return "' " + weekday + " ' p";
    }
}
const lastWeekFormatToken = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek$6(day);
    }
    else {
        return lastWeek$6(day);
    }
};
const nextWeekFormatToken = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek$6(day);
    }
    else {
        return nextWeek$6(day);
    }
};
const formatRelativeLocale$19 = {
    lastWeek: lastWeekFormatToken,
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: nextWeekFormatToken,
    other: "P"
};
const formatRelative$19 = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$19[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$19 = {
    narrow: ["...", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
};
const quarterValues$19 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: [
        "1- ",
        "2- ",
        "3- ",
        "4- "
    ]
};
const monthValues$19 = {
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$19 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$19 = {
    wide: {
        am: " ",
        pm: " ",
        midnight: " ",
        noon: " ",
        morning: "",
        afternoon: "",
        evening: "",
        night: " "
    }
};
function isFeminine(unit) {
    return unit === "year" || unit === "week" || unit === "minute" || unit === "second";
}
function isNeuter(unit) {
    return unit === "quarter";
}
function numberWithSuffix(number2, unit, masculine, feminine, neuter) {
    const suffix = isNeuter(unit) ? neuter : isFeminine(unit) ? feminine : masculine;
    return number2 + "-" + suffix;
}
const ordinalNumber$19 = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = options2?.unit;
    if (number2 === 0) {
        return numberWithSuffix(0, unit, "", "", "");
    }
    else if (number2 % 1e3 === 0) {
        return numberWithSuffix(number2, unit, "", "", "");
    }
    else if (number2 % 100 === 0) {
        return numberWithSuffix(number2, unit, "", "", "");
    }
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return numberWithSuffix(number2, unit, "", "", "");
            case 2:
                return numberWithSuffix(number2, unit, "", "", "");
            case 7:
            case 8:
                return numberWithSuffix(number2, unit, "", "", "");
        }
    }
    return numberWithSuffix(number2, unit, "", "", "");
};
const localize$19 = {
    ordinalNumber: ordinalNumber$19,
    era: buildLocalizeFn({
        values: eraValues$19,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$19,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$19,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$19,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$19,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$18 = /^(\d+)(-?[][]|-??(|)|-?(|))?/i;
const parseOrdinalNumberPattern$18 = /\d+/i;
const matchEraPatterns$18 = {
    narrow: /^(()?\.?\s?\.?)/i,
    abbreviated: /^(()?\.?\s?\.?)/i,
    wide: /^(  | | )/i
};
const parseEraPatterns$18 = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$18 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]?o?)? .?/i,
    wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$18 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchDayPatterns$18 = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$18 = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^[]/i, /^[]/i, /^/i, /^/i, /^[]/i, /^[]/i, /^[]/i]
};
const matchMonthPatterns$18 = {
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$18 = {
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPeriodPatterns$18 = {
    any: /^( | | | ||||)/i
};
const parseDayPeriodPatterns$18 = {
    any: {
        am: /^ /i,
        pm: /^ /i,
        midnight: /^ /i,
        noon: /^ /i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^/i,
        night: /^ /i
    }
};
const match$18 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$18,
        parsePattern: parseOrdinalNumberPattern$18,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$18,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$18,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$18,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$18,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$18,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$18,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$18,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$18,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$18,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$18,
        defaultParseWidth: "any"
    })
};
const bg = {
    code: "bg",
    formatDistance: formatDistance$19,
    formatLong: formatLong$1h,
    formatRelative: formatRelative$19,
    localize: localize$19,
    match: match$18,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const numberValues$1 = {
    locale: {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }
};
const eraValues$18 = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: ["", ""]
};
const quarterValues$18 = {
    narrow: ["", "", "", ""],
    abbreviated: ["", "", "", ""],
    wide: [" ", " ", " ", " "]
};
const monthValues$18 = {
    narrow: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$18 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        " ",
        "",
        ""
    ]
};
const dayPeriodValues$18 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$V = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
function dateOrdinalNumber(number2, localeNumber) {
    if (number2 > 18 && number2 <= 31) {
        return localeNumber + "";
    }
    else {
        switch (number2) {
            case 1:
                return localeNumber + "";
            case 2:
            case 3:
                return localeNumber + "";
            case 4:
                return localeNumber + "";
            default:
                return localeNumber + "";
        }
    }
}
const ordinalNumber$18 = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const localeNumber = numberToLocale$1(number2);
    const unit = options2?.unit;
    if (unit === "date") {
        return dateOrdinalNumber(number2, localeNumber);
    }
    if (number2 > 10 || number2 === 0)
        return localeNumber + "";
    const rem10 = number2 % 10;
    switch (rem10) {
        case 2:
        case 3:
            return localeNumber + "";
        case 4:
            return localeNumber + "";
        case 6:
            return localeNumber + "";
        default:
            return localeNumber + "";
    }
};
function numberToLocale$1(enNumber) {
    return enNumber.toString().replace(/\d/g, function (match2) {
        return numberValues$1.locale[match2];
    });
}
const localize$18 = {
    ordinalNumber: ordinalNumber$18,
    era: buildLocalizeFn({
        values: eraValues$18,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$18,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$18,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$18,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$18,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$V,
        defaultFormattingWidth: "wide"
    })
};
const formatDistanceLocale$17 = {
    lessThanXSeconds: {
        one: "  ",
        other: " {{count}} "
    },
    xSeconds: {
        one: " ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        other: " {{count}} "
    },
    xMinutes: {
        one: " ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: "  ",
        other: " {{count}} "
    },
    xHours: {
        one: " ",
        other: "{{count}} "
    },
    xDays: {
        one: " ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "  ",
        other: " {{count}} "
    },
    xWeeks: {
        one: " ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "  ",
        other: " {{count}} "
    },
    xMonths: {
        one: " ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  ",
        other: " {{count}} "
    },
    xYears: {
        one: " ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        other: "{{count}}  "
    },
    almostXYears: {
        one: "  ",
        other: " {{count}} "
    }
};
const formatDistance$18 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$17[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", numberToLocale$1(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "  ";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$1g = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$1g = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1g = {
    full: "{{date}} {{time}} ''",
    long: "{{date}} {{time}} ''",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1g = {
    date: buildFormatLongFn({
        formats: dateFormats$1g,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1g,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1g,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$18 = {
    lastWeek: "'' eeee '' p",
    yesterday: "'' '' p",
    today: "'' '' p",
    tomorrow: "'' '' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$18 = (token, _date, _baseDate, _options) => formatRelativeLocale$18[token];
const matchOrdinalNumberPattern$17 = /^(\d+)(||||||)?/i;
const parseOrdinalNumberPattern$17 = /\d+/i;
const matchEraPatterns$17 = {
    narrow: /^(|)/i,
    abbreviated: /^(|)/i,
    wide: /^(|)/i
};
const parseEraPatterns$17 = {
    narrow: [/^/i, /^/i],
    abbreviated: [/^/i, /^/i],
    wide: [/^/i, /^/i]
};
const matchQuarterPatterns$17 = {
    narrow: /^[]/i,
    abbreviated: /^[]/i,
    wide: /^[](||)? /i
};
const parseQuarterPatterns$17 = {
    any: [//i, //i, //i, //i]
};
const matchMonthPatterns$17 = {
    narrow: /^(|||||||||||)/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$17 = {
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$17 = {
    narrow: /^(||||||)+/i,
    short: /^(||||||)+/i,
    abbreviated: /^(||||||)+/i,
    wide: /^(|||| ||)+/i
};
const parseDayPatterns$17 = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    short: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    abbreviated: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^ /i,
        /^/i,
        /^/i
    ]
};
const matchDayPeriodPatterns$17 = {
    narrow: /^(|||||||)/i,
    abbreviated: /^(|||||||)/i,
    wide: /^(|||||||)/i
};
const parseDayPeriodPatterns$17 = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$17 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$17,
        parsePattern: parseOrdinalNumberPattern$17,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$17,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$17,
        defaultParseWidth: "wide"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$17,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$17,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$17,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$17,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$17,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$17,
        defaultParseWidth: "wide"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$17,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$17,
        defaultParseWidth: "any"
    })
};
const bn = {
    code: "bn",
    formatDistance: formatDistance$18,
    formatLong: formatLong$1g,
    formatRelative: formatRelative$18,
    localize: localize$18,
    match: match$17,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$16 = {
    lessThanXSeconds: {
        one: {
            standalone: "manje od 1 sekunde",
            withPrepositionAgo: "manje od 1 sekunde",
            withPrepositionIn: "manje od 1 sekundu"
        },
        dual: "manje od {{count}} sekunde",
        other: "manje od {{count}} sekundi"
    },
    xSeconds: {
        one: {
            standalone: "1 sekunda",
            withPrepositionAgo: "1 sekunde",
            withPrepositionIn: "1 sekundu"
        },
        dual: "{{count}} sekunde",
        other: "{{count}} sekundi"
    },
    halfAMinute: "pola minute",
    lessThanXMinutes: {
        one: {
            standalone: "manje od 1 minute",
            withPrepositionAgo: "manje od 1 minute",
            withPrepositionIn: "manje od 1 minutu"
        },
        dual: "manje od {{count}} minute",
        other: "manje od {{count}} minuta"
    },
    xMinutes: {
        one: {
            standalone: "1 minuta",
            withPrepositionAgo: "1 minute",
            withPrepositionIn: "1 minutu"
        },
        dual: "{{count}} minute",
        other: "{{count}} minuta"
    },
    aboutXHours: {
        one: {
            standalone: "oko 1 sat",
            withPrepositionAgo: "oko 1 sat",
            withPrepositionIn: "oko 1 sat"
        },
        dual: "oko {{count}} sata",
        other: "oko {{count}} sati"
    },
    xHours: {
        one: {
            standalone: "1 sat",
            withPrepositionAgo: "1 sat",
            withPrepositionIn: "1 sat"
        },
        dual: "{{count}} sata",
        other: "{{count}} sati"
    },
    xDays: {
        one: {
            standalone: "1 dan",
            withPrepositionAgo: "1 dan",
            withPrepositionIn: "1 dan"
        },
        dual: "{{count}} dana",
        other: "{{count}} dana"
    },
    aboutXWeeks: {
        one: {
            standalone: "oko 1 sedmicu",
            withPrepositionAgo: "oko 1 sedmicu",
            withPrepositionIn: "oko 1 sedmicu"
        },
        dual: "oko {{count}} sedmice",
        other: "oko {{count}} sedmice"
    },
    xWeeks: {
        one: {
            standalone: "1 sedmicu",
            withPrepositionAgo: "1 sedmicu",
            withPrepositionIn: "1 sedmicu"
        },
        dual: "{{count}} sedmice",
        other: "{{count}} sedmice"
    },
    aboutXMonths: {
        one: {
            standalone: "oko 1 mjesec",
            withPrepositionAgo: "oko 1 mjesec",
            withPrepositionIn: "oko 1 mjesec"
        },
        dual: "oko {{count}} mjeseca",
        other: "oko {{count}} mjeseci"
    },
    xMonths: {
        one: {
            standalone: "1 mjesec",
            withPrepositionAgo: "1 mjesec",
            withPrepositionIn: "1 mjesec"
        },
        dual: "{{count}} mjeseca",
        other: "{{count}} mjeseci"
    },
    aboutXYears: {
        one: {
            standalone: "oko 1 godinu",
            withPrepositionAgo: "oko 1 godinu",
            withPrepositionIn: "oko 1 godinu"
        },
        dual: "oko {{count}} godine",
        other: "oko {{count}} godina"
    },
    xYears: {
        one: {
            standalone: "1 godina",
            withPrepositionAgo: "1 godine",
            withPrepositionIn: "1 godinu"
        },
        dual: "{{count}} godine",
        other: "{{count}} godina"
    },
    overXYears: {
        one: {
            standalone: "preko 1 godinu",
            withPrepositionAgo: "preko 1 godinu",
            withPrepositionIn: "preko 1 godinu"
        },
        dual: "preko {{count}} godine",
        other: "preko {{count}} godina"
    },
    almostXYears: {
        one: {
            standalone: "gotovo 1 godinu",
            withPrepositionAgo: "gotovo 1 godinu",
            withPrepositionIn: "gotovo 1 godinu"
        },
        dual: "gotovo {{count}} godine",
        other: "gotovo {{count}} godina"
    }
};
const formatDistance$17 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$16[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                result = tokenValue.one.withPrepositionIn;
            }
            else {
                result = tokenValue.one.withPrepositionAgo;
            }
        }
        else {
            result = tokenValue.one.standalone;
        }
    }
    else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
        String(count).substr(-2, 1) !== "1") {
        result = tokenValue.dual.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "za " + result;
        }
        else {
            return "prije " + result;
        }
    }
    return result;
};
const dateFormats$1f = {
    full: "EEEE, d. MMMM yyyy.",
    long: "d. MMMM yyyy.",
    medium: "d. MMM yy.",
    short: "dd. MM. yy."
};
const timeFormats$1f = {
    full: "HH:mm:ss (zzzz)",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$1f = {
    full: "{{date}} 'u' {{time}}",
    long: "{{date}} 'u' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$1f = {
    date: buildFormatLongFn({
        formats: dateFormats$1f,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1f,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1f,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$17 = {
    lastWeek: (date) => {
        switch (date.getDay()) {
            case 0:
                return "'prole nedjelje u' p";
            case 3:
                return "'prole srijede u' p";
            case 6:
                return "'prole subote u' p";
            default:
                return "'proli' EEEE 'u' p";
        }
    },
    yesterday: "'jue u' p",
    today: "'danas u' p",
    tomorrow: "'sutra u' p",
    nextWeek: (date) => {
        switch (date.getDay()) {
            case 0:
                return "'sljedee nedjelje u' p";
            case 3:
                return "'sljedeu srijedu u' p";
            case 6:
                return "'sljedeu subotu u' p";
            default:
                return "'sljedei' EEEE 'u' p";
        }
    },
    other: "P"
};
const formatRelative$17 = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$17[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$17 = {
    narrow: ["pr.n.e.", "AD"],
    abbreviated: ["pr. Hr.", "po. Hr."],
    wide: ["Prije Hrista", "Poslije Hrista"]
};
const quarterValues$17 = {
    narrow: ["1.", "2.", "3.", "4."],
    abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$17 = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "avg",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "januar",
        "februar",
        "mart",
        "april",
        "maj",
        "juni",
        "juli",
        "avgust",
        "septembar",
        "oktobar",
        "novembar",
        "decembar"
    ]
};
const formattingMonthValues$g = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "avg",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "januar",
        "februar",
        "mart",
        "april",
        "maj",
        "juni",
        "juli",
        "avgust",
        "septembar",
        "oktobar",
        "novembar",
        "decembar"
    ]
};
const dayValues$17 = {
    narrow: ["N", "P", "U", "S", "", "P", "S"],
    short: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
    abbreviated: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
    wide: [
        "nedjelja",
        "ponedjeljak",
        "utorak",
        "srijeda",
        "etvrtak",
        "petak",
        "subota"
    ]
};
const dayPeriodValues$17 = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "poslije podne",
        evening: "uvee",
        night: "nou"
    }
};
const formattingDayPeriodValues$U = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "poslije podne",
        evening: "uvee",
        night: "nou"
    }
};
const ordinalNumber$17 = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return String(number2) + ".";
};
const localize$17 = {
    ordinalNumber: ordinalNumber$17,
    era: buildLocalizeFn({
        values: eraValues$17,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$17,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$17,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$g,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$17,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$17,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$U,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$16 = /^(\d+)\./i;
const parseOrdinalNumberPattern$16 = /\d+/i;
const matchEraPatterns$16 = {
    narrow: /^(pr\.n\.e\.|AD)/i,
    abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
    wide: /^(Prije Hrista|prije nove ere|Poslije Hrista|nova era)/i
};
const parseEraPatterns$16 = {
    any: [/^pr/i, /^(po|nova)/i]
};
const matchQuarterPatterns$16 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]\.\s?kv\.?/i,
    wide: /^[1234]\. kvartal/i
};
const parseQuarterPatterns$16 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$16 = {
    narrow: /^(10|11|12|[123456789])\./i,
    abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
    wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(juni|juna)|(juli|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i
};
const parseMonthPatterns$16 = {
    narrow: [
        /^1/i,
        /^2/i,
        /^3/i,
        /^4/i,
        /^5/i,
        /^6/i,
        /^7/i,
        /^8/i,
        /^9/i,
        /^10/i,
        /^11/i,
        /^12/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^avg/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$16 = {
    narrow: /^[npusc]/i,
    short: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
    abbreviated: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
    wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(etvrtak|cetvrtak)|petak|subota)/i
};
const parseDayPatterns$16 = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$16 = {
    any: /^(am|pm|ponoc|pono|(po)?podne|uvece|uvee|nou|poslije podne|ujutru)/i
};
const parseDayPeriodPatterns$16 = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^pono/i,
        noon: /^pod/i,
        morning: /jutro/i,
        afternoon: /(poslije\s|po)+podne/i,
        evening: /(uvece|uvee)/i,
        night: /(nocu|nou)/i
    }
};
const match$16 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$16,
        parsePattern: parseOrdinalNumberPattern$16,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$16,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$16,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$16,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$16,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$16,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$16,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$16,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$16,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$16,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$16,
        defaultParseWidth: "any"
    })
};
const bs = {
    code: "bs",
    formatDistance: formatDistance$17,
    formatLong: formatLong$1f,
    formatRelative: formatRelative$17,
    localize: localize$17,
    match: match$16,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$15 = {
    lessThanXSeconds: {
        one: "menys d'un segon",
        eleven: "menys d'onze segons",
        other: "menys de {{count}} segons"
    },
    xSeconds: {
        one: "1 segon",
        other: "{{count}} segons"
    },
    halfAMinute: "mig minut",
    lessThanXMinutes: {
        one: "menys d'un minut",
        eleven: "menys d'onze minuts",
        other: "menys de {{count}} minuts"
    },
    xMinutes: {
        one: "1 minut",
        other: "{{count}} minuts"
    },
    aboutXHours: {
        one: "aproximadament una hora",
        other: "aproximadament {{count}} hores"
    },
    xHours: {
        one: "1 hora",
        other: "{{count}} hores"
    },
    xDays: {
        one: "1 dia",
        other: "{{count}} dies"
    },
    aboutXWeeks: {
        one: "aproximadament una setmana",
        other: "aproximadament {{count}} setmanes"
    },
    xWeeks: {
        one: "1 setmana",
        other: "{{count}} setmanes"
    },
    aboutXMonths: {
        one: "aproximadament un mes",
        other: "aproximadament {{count}} mesos"
    },
    xMonths: {
        one: "1 mes",
        other: "{{count}} mesos"
    },
    aboutXYears: {
        one: "aproximadament un any",
        other: "aproximadament {{count}} anys"
    },
    xYears: {
        one: "1 any",
        other: "{{count}} anys"
    },
    overXYears: {
        one: "ms d'un any",
        eleven: "ms d'onze anys",
        other: "ms de {{count}} anys"
    },
    almostXYears: {
        one: "gaireb un any",
        other: "gaireb {{count}} anys"
    }
};
const formatDistance$16 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$15[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 11 && tokenValue.eleven) {
        result = tokenValue.eleven;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "en " + result;
        }
        else {
            return "fa " + result;
        }
    }
    return result;
};
const dateFormats$1e = {
    full: "EEEE, d 'de' MMMM y",
    long: "d 'de' MMMM y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$1e = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$1e = {
    full: "{{date}} 'a les' {{time}}",
    long: "{{date}} 'a les' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1e = {
    date: buildFormatLongFn({
        formats: dateFormats$1e,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1e,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1e,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$16 = {
    lastWeek: "'el' eeee 'passat a la' LT",
    yesterday: "'ahir a la' p",
    today: "'avui a la' p",
    tomorrow: "'dem a la' p",
    nextWeek: "eeee 'a la' p",
    other: "P"
};
const formatRelativeLocalePlural$3 = {
    lastWeek: "'el' eeee 'passat a les' p",
    yesterday: "'ahir a les' p",
    today: "'avui a les' p",
    tomorrow: "'dem a les' p",
    nextWeek: "eeee 'a les' p",
    other: "P"
};
const formatRelative$16 = (token, date, _baseDate, _options) => {
    if (date.getHours() !== 1) {
        return formatRelativeLocalePlural$3[token];
    }
    return formatRelativeLocale$16[token];
};
const eraValues$16 = {
    narrow: ["aC", "dC"],
    abbreviated: ["a. de C.", "d. de C."],
    wide: ["abans de Crist", "desprs de Crist"]
};
const quarterValues$16 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1r trimestre", "2n trimestre", "3r trimestre", "4t trimestre"]
};
const monthValues$16 = {
    narrow: [
        "GN",
        "FB",
        "M",
        "AB",
        "MG",
        "JN",
        "JL",
        "AG",
        "ST",
        "OC",
        "NV",
        "DS"
    ],
    /**
     * Les abreviatures dels mesos de l'any es formen seguint una de les normes generals de formaci d'abreviatures.
     * S'escriu la primera sllaba i les consonants de la sllaba segent anteriors a la primera vocal.
     * Els mesos de mar, maig i juny no s'abreugen perqu sn paraules d'una sola sllaba.
     */
    abbreviated: [
        "gen.",
        "febr.",
        "mar",
        "abr.",
        "maig",
        "juny",
        "jul.",
        "ag.",
        "set.",
        "oct.",
        "nov.",
        "des."
    ],
    wide: [
        "gener",
        "febrer",
        "mar",
        "abril",
        "maig",
        "juny",
        "juliol",
        "agost",
        "setembre",
        "octubre",
        "novembre",
        "desembre"
    ]
};
const dayValues$16 = {
    narrow: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
    short: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
    abbreviated: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
    wide: [
        "diumenge",
        "dilluns",
        "dimarts",
        "dimecres",
        "dijous",
        "divendres",
        "dissabte"
    ]
};
const dayPeriodValues$16 = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "mitjanit",
        noon: "migdia",
        morning: "mat",
        afternoon: "tarda",
        evening: "vespre",
        night: "nit"
    },
    abbreviated: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "mitjanit",
        noon: "migdia",
        morning: "mat",
        afternoon: "tarda",
        evening: "vespre",
        night: "nit"
    },
    wide: {
        am: "ante meridiem",
        pm: "post meridiem",
        midnight: "mitjanit",
        noon: "migdia",
        morning: "mat",
        afternoon: "tarda",
        evening: "vespre",
        night: "nit"
    }
};
const formattingDayPeriodValues$T = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "de la mitjanit",
        noon: "del migdia",
        morning: "del mat",
        afternoon: "de la tarda",
        evening: "del vespre",
        night: "de la nit"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "de la mitjanit",
        noon: "del migdia",
        morning: "del mat",
        afternoon: "de la tarda",
        evening: "del vespre",
        night: "de la nit"
    },
    wide: {
        am: "ante meridiem",
        pm: "post meridiem",
        midnight: "de la mitjanit",
        noon: "del migdia",
        morning: "del mat",
        afternoon: "de la tarda",
        evening: "del vespre",
        night: "de la nit"
    }
};
const ordinalNumber$16 = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number2 + "r";
            case 2:
                return number2 + "n";
            case 3:
                return number2 + "r";
            case 4:
                return number2 + "t";
        }
    }
    return number2 + "";
};
const localize$16 = {
    ordinalNumber: ordinalNumber$16,
    era: buildLocalizeFn({
        values: eraValues$16,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$16,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$16,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$16,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$16,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$T,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$15 = /^(\d+)(|r|n|r|t)?/i;
const parseOrdinalNumberPattern$15 = /\d+/i;
const matchEraPatterns$15 = {
    narrow: /^(aC|dC)/i,
    abbreviated: /^(a. de C.|d. de C.)/i,
    wide: /^(abans de Crist|despr[e]s de Crist)/i
};
const parseEraPatterns$15 = {
    narrow: [/^aC/i, /^dC/i],
    abbreviated: [/^(a. de C.)/i, /^(d. de C.)/i],
    wide: [/^(abans de Crist)/i, /^(despr[e]s de Crist)/i]
};
const matchQuarterPatterns$15 = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^[1234](|r|n|r|t)? trimestre/i
};
const parseQuarterPatterns$15 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$15 = {
    narrow: /^(GN|FB|M|AB|MG|JN|JL|AG|ST|OC|NV|DS)/i,
    abbreviated: /^(gen.|febr.|mar|abr.|maig|juny|jul.|ag.|set.|oct.|nov.|des.)/i,
    wide: /^(gener|febrer|mar|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre)/i
};
const parseMonthPatterns$15 = {
    narrow: [
        /^GN/i,
        /^FB/i,
        /^M/i,
        /^AB/i,
        /^MG/i,
        /^JN/i,
        /^JL/i,
        /^AG/i,
        /^ST/i,
        /^OC/i,
        /^NV/i,
        /^DS/i
    ],
    abbreviated: [
        /^gen./i,
        /^febr./i,
        /^mar/i,
        /^abr./i,
        /^maig/i,
        /^juny/i,
        /^jul./i,
        /^ag./i,
        /^set./i,
        /^oct./i,
        /^nov./i,
        /^des./i
    ],
    wide: [
        /^gener/i,
        /^febrer/i,
        /^mar/i,
        /^abril/i,
        /^maig/i,
        /^juny/i,
        /^juliol/i,
        /^agost/i,
        /^setembre/i,
        /^octubre/i,
        /^novembre/i,
        /^desembre/i
    ]
};
const matchDayPatterns$15 = {
    narrow: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
    short: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
    abbreviated: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
    wide: /^(diumenge|dilluns|dimarts|dimecres|dijous|divendres|dissabte)/i
};
const parseDayPatterns$15 = {
    narrow: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],
    abbreviated: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],
    wide: [
        /^diumenge/i,
        /^dilluns/i,
        /^dimarts/i,
        /^dimecres/i,
        /^dijous/i,
        /^divendres/i,
        /^disssabte/i
    ]
};
const matchDayPeriodPatterns$15 = {
    narrow: /^(a|p|mn|md|(del|de la) (mat|tarda|vespre|nit))/i,
    abbreviated: /^([ap]\.?\s?m\.?|mitjanit|migdia|(del|de la) (mat|tarda|vespre|nit))/i,
    wide: /^(ante meridiem|post meridiem|mitjanit|migdia|(del|de la) (mat|tarda|vespre|nit))/i
};
const parseDayPeriodPatterns$15 = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mitjanit/i,
        noon: /^migdia/i,
        morning: /mat/i,
        afternoon: /tarda/i,
        evening: /vespre/i,
        night: /nit/i
    }
};
const match$15 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$15,
        parsePattern: parseOrdinalNumberPattern$15,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$15,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$15,
        defaultParseWidth: "wide"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$15,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$15,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$15,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$15,
        defaultParseWidth: "wide"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$15,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$15,
        defaultParseWidth: "wide"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$15,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$15,
        defaultParseWidth: "any"
    })
};
const ca = {
    code: "ca",
    formatDistance: formatDistance$16,
    formatLong: formatLong$1e,
    formatRelative: formatRelative$16,
    localize: localize$16,
    match: match$15,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$14 = {
    lessThanXSeconds: {
        one: "   ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "   ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: "   ",
        other: " {{count}} "
    }
};
const formatDistance$15 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$14[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "  " + result + "";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$1d = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$1d = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1d = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1d = {
    date: buildFormatLongFn({
        formats: dateFormats$1d,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1d,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1d,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$15 = {
    lastWeek: "' ' eeee '' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$15 = (token, _date, _baseDate, _options) => formatRelativeLocale$15[token];
const eraValues$15 = {
    narrow: ["", ""],
    abbreviated: ["-", "-"],
    wide: [" ", " "]
};
const quarterValues$15 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$15 = {
    narrow: [
        "-",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "-",
        "-",
        "-"
    ],
    abbreviated: [
        "-",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "-",
        "-",
        "-"
    ],
    wide: [
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        " ",
        " ",
        " "
    ]
};
const dayValues$15 = {
    narrow: ["-", "-", "-", "-", "-", "", ""],
    short: ["-", "-", "-", "-", "-", "", ""],
    abbreviated: [
        "-",
        "-",
        "-",
        "-",
        "-",
        "",
        ""
    ],
    wide: [
        " ",
        " ",
        " ",
        " ",
        " ",
        "",
        ""
    ]
};
const dayPeriodValues$15 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "-",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "-",
        pm: "-",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: " ",
        pm: " ",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$S = {
    narrow: {
        am: "",
        pm: "",
        midnight: "-",
        noon: "",
        morning: " ",
        afternoon: "  ",
        evening: " ",
        night: " "
    },
    abbreviated: {
        am: "-",
        pm: "-",
        midnight: " ",
        noon: "",
        morning: " ",
        afternoon: "  ",
        evening: " ",
        night: " "
    },
    wide: {
        am: " ",
        pm: " ",
        midnight: " ",
        noon: "",
        morning: " ",
        afternoon: "  ",
        evening: " ",
        night: " "
    }
};
const ordinalNumber$15 = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$15 = {
    ordinalNumber: ordinalNumber$15,
    era: buildLocalizeFn({
        values: eraValues$15,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$15,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$15,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$15,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$15,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$S,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$14 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$14 = /\d+/i;
const matchEraPatterns$14 = {
    narrow: /^(|)/i,
    abbreviated: /^(-|.)/i,
    wide: /^( |  )/i
};
const parseEraPatterns$14 = {
    any: [/^/g, /^/g]
};
const matchQuarterPatterns$14 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^(||| ) ()? quarter/i
};
const parseQuarterPatterns$14 = {
    wide: [/ /, / /, / /, / /],
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$14 = {
    narrow: /^(-||||||||-|-|-)/i,
    abbreviated: /^(-|||||||||-|-|-)/i,
    wide: /^( ||||||||| | | )/i
};
const parseMonthPatterns$14 = {
    narrow: [
        /^-/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^-/i,
        /^-/i,
        /^-/i
    ],
    any: [
        /^-/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^-/i,
        /^-/i,
        /^|-/i
    ]
};
const matchDayPatterns$14 = {
    narrow: /^(||||||)/i,
    short: /^(-|-|-|-|-||)/i,
    abbreviated: /^(-|-|-|-|-||)/i,
    wide: /^( | | | | ||)/i
};
const parseDayPatterns$14 = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$14 = {
    narrow: /^(||-|| (| ||))/i,
    abbreviated: /^(-|-| ||| ||)/,
    wide: /^( | || ||| | )/,
    any: /^(|||||)/
};
const parseDayPeriodPatterns$14 = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^-/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$14 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$14,
        parsePattern: parseOrdinalNumberPattern$14,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$14,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$14,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$14,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$14,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$14,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$14,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$14,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$14,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$14,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$14,
        defaultParseWidth: "any"
    })
};
const ckb = {
    code: "ckb",
    formatDistance: formatDistance$15,
    formatLong: formatLong$1d,
    formatRelative: formatRelative$15,
    localize: localize$15,
    match: match$14,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$13 = {
    lessThanXSeconds: {
        one: {
            regular: "mn ne 1 sekunda",
            past: "ped mn ne 1 sekundou",
            future: "za mn ne 1 sekundu"
        },
        few: {
            regular: "mn ne {{count}} sekundy",
            past: "ped mn ne {{count}} sekundami",
            future: "za mn ne {{count}} sekundy"
        },
        many: {
            regular: "mn ne {{count}} sekund",
            past: "ped mn ne {{count}} sekundami",
            future: "za mn ne {{count}} sekund"
        }
    },
    xSeconds: {
        one: {
            regular: "1 sekunda",
            past: "ped 1 sekundou",
            future: "za 1 sekundu"
        },
        few: {
            regular: "{{count}} sekundy",
            past: "ped {{count}} sekundami",
            future: "za {{count}} sekundy"
        },
        many: {
            regular: "{{count}} sekund",
            past: "ped {{count}} sekundami",
            future: "za {{count}} sekund"
        }
    },
    halfAMinute: {
        type: "other",
        other: {
            regular: "pl minuty",
            past: "ped pl minutou",
            future: "za pl minuty"
        }
    },
    lessThanXMinutes: {
        one: {
            regular: "mn ne 1 minuta",
            past: "ped mn ne 1 minutou",
            future: "za mn ne 1 minutu"
        },
        few: {
            regular: "mn ne {{count}} minuty",
            past: "ped mn ne {{count}} minutami",
            future: "za mn ne {{count}} minuty"
        },
        many: {
            regular: "mn ne {{count}} minut",
            past: "ped mn ne {{count}} minutami",
            future: "za mn ne {{count}} minut"
        }
    },
    xMinutes: {
        one: {
            regular: "1 minuta",
            past: "ped 1 minutou",
            future: "za 1 minutu"
        },
        few: {
            regular: "{{count}} minuty",
            past: "ped {{count}} minutami",
            future: "za {{count}} minuty"
        },
        many: {
            regular: "{{count}} minut",
            past: "ped {{count}} minutami",
            future: "za {{count}} minut"
        }
    },
    aboutXHours: {
        one: {
            regular: "piblin 1 hodina",
            past: "piblin ped 1 hodinou",
            future: "piblin za 1 hodinu"
        },
        few: {
            regular: "piblin {{count}} hodiny",
            past: "piblin ped {{count}} hodinami",
            future: "piblin za {{count}} hodiny"
        },
        many: {
            regular: "piblin {{count}} hodin",
            past: "piblin ped {{count}} hodinami",
            future: "piblin za {{count}} hodin"
        }
    },
    xHours: {
        one: {
            regular: "1 hodina",
            past: "ped 1 hodinou",
            future: "za 1 hodinu"
        },
        few: {
            regular: "{{count}} hodiny",
            past: "ped {{count}} hodinami",
            future: "za {{count}} hodiny"
        },
        many: {
            regular: "{{count}} hodin",
            past: "ped {{count}} hodinami",
            future: "za {{count}} hodin"
        }
    },
    xDays: {
        one: {
            regular: "1 den",
            past: "ped 1 dnem",
            future: "za 1 den"
        },
        few: {
            regular: "{{count}} dny",
            past: "ped {{count}} dny",
            future: "za {{count}} dny"
        },
        many: {
            regular: "{{count}} dn",
            past: "ped {{count}} dny",
            future: "za {{count}} dn"
        }
    },
    aboutXWeeks: {
        one: {
            regular: "piblin 1 tden",
            past: "piblin ped 1 tdnem",
            future: "piblin za 1 tden"
        },
        few: {
            regular: "piblin {{count}} tdny",
            past: "piblin ped {{count}} tdny",
            future: "piblin za {{count}} tdny"
        },
        many: {
            regular: "piblin {{count}} tdn",
            past: "piblin ped {{count}} tdny",
            future: "piblin za {{count}} tdn"
        }
    },
    xWeeks: {
        one: {
            regular: "1 tden",
            past: "ped 1 tdnem",
            future: "za 1 tden"
        },
        few: {
            regular: "{{count}} tdny",
            past: "ped {{count}} tdny",
            future: "za {{count}} tdny"
        },
        many: {
            regular: "{{count}} tdn",
            past: "ped {{count}} tdny",
            future: "za {{count}} tdn"
        }
    },
    aboutXMonths: {
        one: {
            regular: "piblin 1 msc",
            past: "piblin ped 1 mscem",
            future: "piblin za 1 msc"
        },
        few: {
            regular: "piblin {{count}} msce",
            past: "piblin ped {{count}} msci",
            future: "piblin za {{count}} msce"
        },
        many: {
            regular: "piblin {{count}} msc",
            past: "piblin ped {{count}} msci",
            future: "piblin za {{count}} msc"
        }
    },
    xMonths: {
        one: {
            regular: "1 msc",
            past: "ped 1 mscem",
            future: "za 1 msc"
        },
        few: {
            regular: "{{count}} msce",
            past: "ped {{count}} msci",
            future: "za {{count}} msce"
        },
        many: {
            regular: "{{count}} msc",
            past: "ped {{count}} msci",
            future: "za {{count}} msc"
        }
    },
    aboutXYears: {
        one: {
            regular: "piblin 1 rok",
            past: "piblin ped 1 rokem",
            future: "piblin za 1 rok"
        },
        few: {
            regular: "piblin {{count}} roky",
            past: "piblin ped {{count}} roky",
            future: "piblin za {{count}} roky"
        },
        many: {
            regular: "piblin {{count}} rok",
            past: "piblin ped {{count}} roky",
            future: "piblin za {{count}} rok"
        }
    },
    xYears: {
        one: {
            regular: "1 rok",
            past: "ped 1 rokem",
            future: "za 1 rok"
        },
        few: {
            regular: "{{count}} roky",
            past: "ped {{count}} roky",
            future: "za {{count}} roky"
        },
        many: {
            regular: "{{count}} rok",
            past: "ped {{count}} roky",
            future: "za {{count}} rok"
        }
    },
    overXYears: {
        one: {
            regular: "vce ne 1 rok",
            past: "ped vce ne 1 rokem",
            future: "za vce ne 1 rok"
        },
        few: {
            regular: "vce ne {{count}} roky",
            past: "ped vce ne {{count}} roky",
            future: "za vce ne {{count}} roky"
        },
        many: {
            regular: "vce ne {{count}} rok",
            past: "ped vce ne {{count}} roky",
            future: "za vce ne {{count}} rok"
        }
    },
    almostXYears: {
        one: {
            regular: "skoro 1 rok",
            past: "skoro ped 1 rokem",
            future: "skoro za 1 rok"
        },
        few: {
            regular: "skoro {{count}} roky",
            past: "skoro ped {{count}} roky",
            future: "skoro za {{count}} roky"
        },
        many: {
            regular: "skoro {{count}} rok",
            past: "skoro ped {{count}} roky",
            future: "skoro za {{count}} rok"
        }
    }
};
const formatDistance$14 = (token, count, options2) => {
    let pluralResult;
    const tokenValue = formatDistanceLocale$13[token];
    if (tokenValue.type === "other") {
        pluralResult = tokenValue.other;
    }
    else if (count === 1) {
        pluralResult = tokenValue.one;
    }
    else if (count > 1 && count < 5) {
        pluralResult = tokenValue.few;
    }
    else {
        pluralResult = tokenValue.many;
    }
    const suffixExist = options2?.addSuffix === true;
    const comparison = options2?.comparison;
    let timeResult;
    if (suffixExist && comparison === -1) {
        timeResult = pluralResult.past;
    }
    else if (suffixExist && comparison === 1) {
        timeResult = pluralResult.future;
    }
    else {
        timeResult = pluralResult.regular;
    }
    return timeResult.replace("{{count}}", String(count));
};
const dateFormats$1c = {
    full: "EEEE, d. MMMM yyyy",
    long: "d. MMMM yyyy",
    medium: "d. M. yyyy",
    short: "dd.MM.yyyy"
};
const timeFormats$1c = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$1c = {
    full: "{{date}} 'v' {{time}}",
    long: "{{date}} 'v' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1c = {
    date: buildFormatLongFn({
        formats: dateFormats$1c,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1c,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1c,
        defaultWidth: "full"
    })
};
const accusativeWeekdays$5 = [
    "nedli",
    "pondl",
    "ter",
    "stedu",
    "tvrtek",
    "ptek",
    "sobotu"
];
const formatRelativeLocale$14 = {
    lastWeek: "'posledn' eeee 've' p",
    yesterday: "'vera v' p",
    today: "'dnes v' p",
    tomorrow: "'ztra v' p",
    nextWeek: (date) => {
        const day = date.getDay();
        return "'v " + accusativeWeekdays$5[day] + " o' p";
    },
    other: "P"
};
const formatRelative$14 = (token, date) => {
    const format2 = formatRelativeLocale$14[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$14 = {
    narrow: ["p. n. l.", "n. l."],
    abbreviated: ["p. n. l.", "n. l."],
    wide: ["ped nam letopotem", "naeho letopotu"]
};
const quarterValues$14 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1. tvrtlet", "2. tvrtlet", "3. tvrtlet", "4. tvrtlet"],
    wide: ["1. tvrtlet", "2. tvrtlet", "3. tvrtlet", "4. tvrtlet"]
};
const monthValues$14 = {
    narrow: ["L", "", "B", "D", "K", "", "", "S", "Z", "", "L", "P"],
    abbreviated: [
        "led",
        "no",
        "be",
        "dub",
        "kv",
        "vn",
        "vc",
        "srp",
        "z",
        "j",
        "lis",
        "pro"
    ],
    wide: [
        "leden",
        "nor",
        "bezen",
        "duben",
        "kvten",
        "erven",
        "ervenec",
        "srpen",
        "z",
        "jen",
        "listopad",
        "prosinec"
    ]
};
const formattingMonthValues$f = {
    narrow: ["L", "", "B", "D", "K", "", "", "S", "Z", "", "L", "P"],
    abbreviated: [
        "led",
        "no",
        "be",
        "dub",
        "kv",
        "vn",
        "vc",
        "srp",
        "z",
        "j",
        "lis",
        "pro"
    ],
    wide: [
        "ledna",
        "nora",
        "bezna",
        "dubna",
        "kvtna",
        "ervna",
        "ervence",
        "srpna",
        "z",
        "jna",
        "listopadu",
        "prosince"
    ]
};
const dayValues$14 = {
    narrow: ["ne", "po", "t", "st", "t", "p", "so"],
    short: ["ne", "po", "t", "st", "t", "p", "so"],
    abbreviated: ["ned", "pon", "te", "st", "tv", "pt", "sob"],
    wide: ["nedle", "pondl", "ter", "steda", "tvrtek", "ptek", "sobota"]
};
const dayPeriodValues$14 = {
    narrow: {
        am: "dop.",
        pm: "odp.",
        midnight: "plnoc",
        noon: "poledne",
        morning: "rno",
        afternoon: "odpoledne",
        evening: "veer",
        night: "noc"
    },
    abbreviated: {
        am: "dop.",
        pm: "odp.",
        midnight: "plnoc",
        noon: "poledne",
        morning: "rno",
        afternoon: "odpoledne",
        evening: "veer",
        night: "noc"
    },
    wide: {
        am: "dopoledne",
        pm: "odpoledne",
        midnight: "plnoc",
        noon: "poledne",
        morning: "rno",
        afternoon: "odpoledne",
        evening: "veer",
        night: "noc"
    }
};
const formattingDayPeriodValues$R = {
    narrow: {
        am: "dop.",
        pm: "odp.",
        midnight: "plnoc",
        noon: "poledne",
        morning: "rno",
        afternoon: "odpoledne",
        evening: "veer",
        night: "noc"
    },
    abbreviated: {
        am: "dop.",
        pm: "odp.",
        midnight: "plnoc",
        noon: "poledne",
        morning: "rno",
        afternoon: "odpoledne",
        evening: "veer",
        night: "noc"
    },
    wide: {
        am: "dopoledne",
        pm: "odpoledne",
        midnight: "plnoc",
        noon: "poledne",
        morning: "rno",
        afternoon: "odpoledne",
        evening: "veer",
        night: "noc"
    }
};
const ordinalNumber$14 = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$14 = {
    ordinalNumber: ordinalNumber$14,
    era: buildLocalizeFn({
        values: eraValues$14,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$14,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$14,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$f,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$14,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$14,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$R,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$13 = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$13 = /\d+/i;
const matchEraPatterns$13 = {
    narrow: /^(p[r](\.|ed) Kr\.|p[r](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
    abbreviated: /^(p[r](\.|ed) Kr\.|p[r](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
    wide: /^(p[r](\.|ed) Kristem|p[r](\.|ed) na[s][i]m letopo[c]tem|po Kristu|na[s]eho letopo[c]tu)/i
};
const parseEraPatterns$13 = {
    any: [/^p[r]/i, /^(po|n)/i]
};
const matchQuarterPatterns$13 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]\. [c]tvrtlet[i]/i,
    wide: /^[1234]\. [c]tvrtlet[i]/i
};
const parseQuarterPatterns$13 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$13 = {
    narrow: /^[lubdkcszrlp]/i,
    abbreviated: /^(led|[u]no|b[r]e|dub|kv[e]|[c]vn|[c]vc|srp|z[a][r]|[r][i]j|lis|pro)/i,
    wide: /^(leden|ledna|[u]nora?|b[r]ezen|b[r]ezna|duben|dubna|kv[e]ten|kv[e]tna|[c]erven(ec|ce)?|[c]ervna|srpen|srpna|z[a][r][i]|[r][i]jen|[r][i]jna|listopad(a|u)?|prosinec|prosince)/i
};
const parseMonthPatterns$13 = {
    narrow: [
        /^l/i,
        /^[u]/i,
        /^b/i,
        /^d/i,
        /^k/i,
        /^[c]/i,
        /^[c]/i,
        /^s/i,
        /^z/i,
        /^[r]/i,
        /^l/i,
        /^p/i
    ],
    any: [
        /^led/i,
        /^[u]n/i,
        /^b[r]e/i,
        /^dub/i,
        /^kv[e]/i,
        /^[c]vn|[c]erven(?!\w)|[c]ervna/i,
        /^[c]vc|[c]erven(ec|ce)/i,
        /^srp/i,
        /^z[a][r]/i,
        /^[r][i]j/i,
        /^lis/i,
        /^pro/i
    ]
};
const matchDayPatterns$13 = {
    narrow: /^[npusps]/i,
    short: /^(ne|po|[u]t|st|[c]t|p[a]|so)/i,
    abbreviated: /^(ned|pon|[u]te|st[r]|[c]tv|p[a]t|sob)/i,
    wide: /^(ned[e]le|pond[e]l[i]|[u]ter[y]|st[r]eda|[c]tvrtek|p[a]tek|sobota)/i
};
const parseDayPatterns$13 = {
    narrow: [/^n/i, /^p/i, /^[u]/i, /^s/i, /^[c]/i, /^p/i, /^s/i],
    any: [/^ne/i, /^po/i, /^[u]t/i, /^st/i, /^[c]t/i, /^p[a]/i, /^so/i]
};
const matchDayPeriodPatterns$13 = {
    any: /^dopoledne|dop\.?|odpoledne|odp\.?|p[u]lnoc|poledne|r[a]no|odpoledne|ve[c]er|(v )?noci?/i
};
const parseDayPeriodPatterns$13 = {
    any: {
        am: /^dop/i,
        pm: /^odp/i,
        midnight: /^p[u]lnoc/i,
        noon: /^poledne/i,
        morning: /r[a]no/i,
        afternoon: /odpoledne/i,
        evening: /ve[c]er/i,
        night: /noc/i
    }
};
const match$13 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$13,
        parsePattern: parseOrdinalNumberPattern$13,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$13,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$13,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$13,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$13,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$13,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$13,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$13,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$13,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$13,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$13,
        defaultParseWidth: "any"
    })
};
const cs = {
    code: "cs",
    formatDistance: formatDistance$14,
    formatLong: formatLong$1c,
    formatRelative: formatRelative$14,
    localize: localize$14,
    match: match$13,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$12 = {
    lessThanXSeconds: {
        one: "llai na eiliad",
        other: "llai na {{count}} eiliad"
    },
    xSeconds: {
        one: "1 eiliad",
        other: "{{count}} eiliad"
    },
    halfAMinute: "hanner munud",
    lessThanXMinutes: {
        one: "llai na munud",
        two: "llai na 2 funud",
        other: "llai na {{count}} munud"
    },
    xMinutes: {
        one: "1 munud",
        two: "2 funud",
        other: "{{count}} munud"
    },
    aboutXHours: {
        one: "tua 1 awr",
        other: "tua {{count}} awr"
    },
    xHours: {
        one: "1 awr",
        other: "{{count}} awr"
    },
    xDays: {
        one: "1 diwrnod",
        two: "2 ddiwrnod",
        other: "{{count}} diwrnod"
    },
    aboutXWeeks: {
        one: "tua 1 wythnos",
        two: "tua pythefnos",
        other: "tua {{count}} wythnos"
    },
    xWeeks: {
        one: "1 wythnos",
        two: "pythefnos",
        other: "{{count}} wythnos"
    },
    aboutXMonths: {
        one: "tua 1 mis",
        two: "tua 2 fis",
        other: "tua {{count}} mis"
    },
    xMonths: {
        one: "1 mis",
        two: "2 fis",
        other: "{{count}} mis"
    },
    aboutXYears: {
        one: "tua 1 flwyddyn",
        two: "tua 2 flynedd",
        other: "tua {{count}} mlynedd"
    },
    xYears: {
        one: "1 flwyddyn",
        two: "2 flynedd",
        other: "{{count}} mlynedd"
    },
    overXYears: {
        one: "dros 1 flwyddyn",
        two: "dros 2 flynedd",
        other: "dros {{count}} mlynedd"
    },
    almostXYears: {
        one: "bron 1 flwyddyn",
        two: "bron 2 flynedd",
        other: "bron {{count}} mlynedd"
    }
};
const formatDistance$13 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$12[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 2 && !!tokenValue.two) {
        result = tokenValue.two;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "mewn " + result;
        }
        else {
            return result + " yn l";
        }
    }
    return result;
};
const dateFormats$1b = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$1b = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$1b = {
    full: "{{date}} 'am' {{time}}",
    long: "{{date}} 'am' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$1b = {
    date: buildFormatLongFn({
        formats: dateFormats$1b,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1b,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1b,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$13 = {
    lastWeek: "eeee 'diwethaf am' p",
    yesterday: "'ddoe am' p",
    today: "'heddiw am' p",
    tomorrow: "'yfory am' p",
    nextWeek: "eeee 'am' p",
    other: "P"
};
const formatRelative$13 = (token, _date, _baseDate, _options) => formatRelativeLocale$13[token];
const eraValues$13 = {
    narrow: ["C", "O"],
    abbreviated: ["CC", "OC"],
    wide: ["Cyn Crist", "Ar l Crist"]
};
const quarterValues$13 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Ch1", "Ch2", "Ch3", "Ch4"],
    wide: ["Chwarter 1af", "2ail chwarter", "3ydd chwarter", "4ydd chwarter"]
};
const monthValues$13 = {
    narrow: ["I", "Ch", "Ma", "E", "Mi", "Me", "G", "A", "Md", "H", "T", "Rh"],
    abbreviated: [
        "Ion",
        "Chwe",
        "Maw",
        "Ebr",
        "Mai",
        "Meh",
        "Gor",
        "Aws",
        "Med",
        "Hyd",
        "Tach",
        "Rhag"
    ],
    wide: [
        "Ionawr",
        "Chwefror",
        "Mawrth",
        "Ebrill",
        "Mai",
        "Mehefin",
        "Gorffennaf",
        "Awst",
        "Medi",
        "Hydref",
        "Tachwedd",
        "Rhagfyr"
    ]
};
const dayValues$13 = {
    narrow: ["S", "Ll", "M", "M", "I", "G", "S"],
    short: ["Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa"],
    abbreviated: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
    wide: [
        "dydd Sul",
        "dydd Llun",
        "dydd Mawrth",
        "dydd Mercher",
        "dydd Iau",
        "dydd Gwener",
        "dydd Sadwrn"
    ]
};
const dayPeriodValues$13 = {
    narrow: {
        am: "b",
        pm: "h",
        midnight: "hn",
        noon: "hd",
        morning: "bore",
        afternoon: "prynhawn",
        evening: "gyda'r nos",
        night: "nos"
    },
    abbreviated: {
        am: "yb",
        pm: "yh",
        midnight: "hanner nos",
        noon: "hanner dydd",
        morning: "bore",
        afternoon: "prynhawn",
        evening: "gyda'r nos",
        night: "nos"
    },
    wide: {
        am: "y.b.",
        pm: "y.h.",
        midnight: "hanner nos",
        noon: "hanner dydd",
        morning: "bore",
        afternoon: "prynhawn",
        evening: "gyda'r nos",
        night: "nos"
    }
};
const formattingDayPeriodValues$Q = {
    narrow: {
        am: "b",
        pm: "h",
        midnight: "hn",
        noon: "hd",
        morning: "yn y bore",
        afternoon: "yn y prynhawn",
        evening: "gyda'r nos",
        night: "yn y nos"
    },
    abbreviated: {
        am: "yb",
        pm: "yh",
        midnight: "hanner nos",
        noon: "hanner dydd",
        morning: "yn y bore",
        afternoon: "yn y prynhawn",
        evening: "gyda'r nos",
        night: "yn y nos"
    },
    wide: {
        am: "y.b.",
        pm: "y.h.",
        midnight: "hanner nos",
        noon: "hanner dydd",
        morning: "yn y bore",
        afternoon: "yn y prynhawn",
        evening: "gyda'r nos",
        night: "yn y nos"
    }
};
const ordinalNumber$13 = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    if (number2 < 20) {
        switch (number2) {
            case 0:
                return number2 + "fed";
            case 1:
                return number2 + "af";
            case 2:
                return number2 + "ail";
            case 3:
            case 4:
                return number2 + "ydd";
            case 5:
            case 6:
                return number2 + "ed";
            case 7:
            case 8:
            case 9:
            case 10:
            case 12:
            case 15:
            case 18:
                return number2 + "fed";
            case 11:
            case 13:
            case 14:
            case 16:
            case 17:
            case 19:
                return number2 + "eg";
        }
    }
    else if (number2 >= 50 && number2 <= 60 || number2 === 80 || number2 >= 100) {
        return number2 + "fed";
    }
    return number2 + "ain";
};
const localize$13 = {
    ordinalNumber: ordinalNumber$13,
    era: buildLocalizeFn({
        values: eraValues$13,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$13,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$13,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$13,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$13,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$Q,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$12 = /^(\d+)(af|ail|ydd|ed|fed|eg|ain)?/i;
const parseOrdinalNumberPattern$12 = /\d+/i;
const matchEraPatterns$12 = {
    narrow: /^(c|o)/i,
    abbreviated: /^(c\.?\s?c\.?|o\.?\s?c\.?)/i,
    wide: /^(cyn christ|ar l crist|ar ol crist)/i
};
const parseEraPatterns$12 = {
    wide: [/^c/i, /^(ar l crist|ar ol crist)/i],
    any: [/^c/i, /^o/i]
};
const matchQuarterPatterns$12 = {
    narrow: /^[1234]/i,
    abbreviated: /^ch[1234]/i,
    wide: /^(chwarter 1af)|([234](ail|ydd)? chwarter)/i
};
const parseQuarterPatterns$12 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$12 = {
    narrow: /^(i|ch|m|e|g|a|h|t|rh)/i,
    abbreviated: /^(ion|chwe|maw|ebr|mai|meh|gor|aws|med|hyd|tach|rhag)/i,
    wide: /^(ionawr|chwefror|mawrth|ebrill|mai|mehefin|gorffennaf|awst|medi|hydref|tachwedd|rhagfyr)/i
};
const parseMonthPatterns$12 = {
    narrow: [
        /^i/i,
        /^ch/i,
        /^m/i,
        /^e/i,
        /^m/i,
        /^m/i,
        /^g/i,
        /^a/i,
        /^m/i,
        /^h/i,
        /^t/i,
        /^rh/i
    ],
    any: [
        /^io/i,
        /^ch/i,
        /^maw/i,
        /^e/i,
        /^mai/i,
        /^meh/i,
        /^g/i,
        /^a/i,
        /^med/i,
        /^h/i,
        /^t/i,
        /^rh/i
    ]
};
const matchDayPatterns$12 = {
    narrow: /^(s|ll|m|i|g)/i,
    short: /^(su|ll|ma|me|ia|gw|sa)/i,
    abbreviated: /^(sul|llun|maw|mer|iau|gwe|sad)/i,
    wide: /^dydd (sul|llun|mawrth|mercher|iau|gwener|sadwrn)/i
};
const parseDayPatterns$12 = {
    narrow: [/^s/i, /^ll/i, /^m/i, /^m/i, /^i/i, /^g/i, /^s/i],
    wide: [
        /^dydd su/i,
        /^dydd ll/i,
        /^dydd ma/i,
        /^dydd me/i,
        /^dydd i/i,
        /^dydd g/i,
        /^dydd sa/i
    ],
    any: [/^su/i, /^ll/i, /^ma/i, /^me/i, /^i/i, /^g/i, /^sa/i]
};
const matchDayPeriodPatterns$12 = {
    narrow: /^(b|h|hn|hd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i,
    any: /^(y\.?\s?[bh]\.?|hanner nos|hanner dydd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i
};
const parseDayPeriodPatterns$12 = {
    any: {
        am: /^b|(y\.?\s?b\.?)/i,
        pm: /^h|(y\.?\s?h\.?)|(yr hwyr)/i,
        midnight: /^hn|hanner nos/i,
        noon: /^hd|hanner dydd/i,
        morning: /bore/i,
        afternoon: /prynhawn/i,
        evening: /^gyda'r nos$/i,
        night: /blah/i
    }
};
const match$12 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$12,
        parsePattern: parseOrdinalNumberPattern$12,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$12,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$12,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$12,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$12,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$12,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$12,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$12,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$12,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$12,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$12,
        defaultParseWidth: "any"
    })
};
const cy = {
    code: "cy",
    formatDistance: formatDistance$13,
    formatLong: formatLong$1b,
    formatRelative: formatRelative$13,
    localize: localize$13,
    match: match$12,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$11 = {
    lessThanXSeconds: {
        one: "mindre end t sekund",
        other: "mindre end {{count}} sekunder"
    },
    xSeconds: {
        one: "1 sekund",
        other: "{{count}} sekunder"
    },
    halfAMinute: "t halvt minut",
    lessThanXMinutes: {
        one: "mindre end t minut",
        other: "mindre end {{count}} minutter"
    },
    xMinutes: {
        one: "1 minut",
        other: "{{count}} minutter"
    },
    aboutXHours: {
        one: "cirka 1 time",
        other: "cirka {{count}} timer"
    },
    xHours: {
        one: "1 time",
        other: "{{count}} timer"
    },
    xDays: {
        one: "1 dag",
        other: "{{count}} dage"
    },
    aboutXWeeks: {
        one: "cirka 1 uge",
        other: "cirka {{count}} uger"
    },
    xWeeks: {
        one: "1 uge",
        other: "{{count}} uger"
    },
    aboutXMonths: {
        one: "cirka 1 mned",
        other: "cirka {{count}} mneder"
    },
    xMonths: {
        one: "1 mned",
        other: "{{count}} mneder"
    },
    aboutXYears: {
        one: "cirka 1 r",
        other: "cirka {{count}} r"
    },
    xYears: {
        one: "1 r",
        other: "{{count}} r"
    },
    overXYears: {
        one: "over 1 r",
        other: "over {{count}} r"
    },
    almostXYears: {
        one: "nsten 1 r",
        other: "nsten {{count}} r"
    }
};
const formatDistance$12 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$11[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "om " + result;
        }
        else {
            return result + " siden";
        }
    }
    return result;
};
const dateFormats$1a = {
    full: "EEEE 'den' d. MMMM y",
    long: "d. MMMM y",
    medium: "d. MMM y",
    short: "dd/MM/y"
};
const timeFormats$1a = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$1a = {
    full: "{{date}} 'kl'. {{time}}",
    long: "{{date}} 'kl'. {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$1a = {
    date: buildFormatLongFn({
        formats: dateFormats$1a,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1a,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1a,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$12 = {
    lastWeek: "'sidste' eeee 'kl.' p",
    yesterday: "'i gr kl.' p",
    today: "'i dag kl.' p",
    tomorrow: "'i morgen kl.' p",
    nextWeek: "'p' eeee 'kl.' p",
    other: "P"
};
const formatRelative$12 = (token, _date, _baseDate, _options) => formatRelativeLocale$12[token];
const eraValues$12 = {
    narrow: ["fvt", "vt"],
    abbreviated: ["f.v.t.", "v.t."],
    wide: ["fr vesterlandsk tidsregning", "vesterlandsk tidsregning"]
};
const quarterValues$12 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1. kvt.", "2. kvt.", "3. kvt.", "4. kvt."],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$12 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mar.",
        "apr.",
        "maj",
        "jun.",
        "jul.",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "januar",
        "februar",
        "marts",
        "april",
        "maj",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "december"
    ]
};
const dayValues$12 = {
    narrow: ["S", "M", "T", "O", "T", "F", "L"],
    short: ["s", "ma", "ti", "on", "to", "fr", "l"],
    abbreviated: ["sn.", "man.", "tir.", "ons.", "tor.", "fre.", "lr."],
    wide: [
        "sndag",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "lrdag"
    ]
};
const dayPeriodValues$12 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "midnat",
        noon: "middag",
        morning: "morgen",
        afternoon: "eftermiddag",
        evening: "aften",
        night: "nat"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnat",
        noon: "middag",
        morning: "morgen",
        afternoon: "eftermiddag",
        evening: "aften",
        night: "nat"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnat",
        noon: "middag",
        morning: "morgen",
        afternoon: "eftermiddag",
        evening: "aften",
        night: "nat"
    }
};
const formattingDayPeriodValues$P = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "midnat",
        noon: "middag",
        morning: "om morgenen",
        afternoon: "om eftermiddagen",
        evening: "om aftenen",
        night: "om natten"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnat",
        noon: "middag",
        morning: "om morgenen",
        afternoon: "om eftermiddagen",
        evening: "om aftenen",
        night: "om natten"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnat",
        noon: "middag",
        morning: "om morgenen",
        afternoon: "om eftermiddagen",
        evening: "om aftenen",
        night: "om natten"
    }
};
const ordinalNumber$12 = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$12 = {
    ordinalNumber: ordinalNumber$12,
    era: buildLocalizeFn({
        values: eraValues$12,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$12,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$12,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$12,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$12,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$P,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$11 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$11 = /\d+/i;
const matchEraPatterns$11 = {
    narrow: /^(fKr|fvt|eKr|vt)/i,
    abbreviated: /^(f\.Kr\.?|f\.v\.t\.?|e\.Kr\.?|v\.t\.)/i,
    wide: /^(f.Kr.|fr vesterlandsk tidsregning|e.Kr.|vesterlandsk tidsregning)/i
};
const parseEraPatterns$11 = {
    any: [/^f/i, /^(v|e)/i]
};
const matchQuarterPatterns$11 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]. kvt\./i,
    wide: /^[1234]\.? kvartal/i
};
const parseQuarterPatterns$11 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$11 = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan.|feb.|mar.|apr.|maj|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
    wide: /^(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i
};
const parseMonthPatterns$11 = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$11 = {
    narrow: /^[smtofl]/i,
    short: /^(sn.|man.|tir.|ons.|tor.|fre.|lr.)/i,
    abbreviated: /^(sn|man|tir|ons|tor|fre|lr)/i,
    wide: /^(sndag|mandag|tirsdag|onsdag|torsdag|fredag|lrdag)/i
};
const parseDayPatterns$11 = {
    narrow: [/^s/i, /^m/i, /^t/i, /^o/i, /^t/i, /^f/i, /^l/i],
    any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$11 = {
    narrow: /^(a|p|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
    any: /^([ap]\.?\s?m\.?|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i
};
const parseDayPeriodPatterns$11 = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /midnat/i,
        noon: /middag/i,
        morning: /morgen/i,
        afternoon: /eftermiddag/i,
        evening: /aften/i,
        night: /nat/i
    }
};
const match$11 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$11,
        parsePattern: parseOrdinalNumberPattern$11,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$11,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$11,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$11,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$11,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$11,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$11,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$11,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$11,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$11,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$11,
        defaultParseWidth: "any"
    })
};
const da = {
    code: "da",
    formatDistance: formatDistance$12,
    formatLong: formatLong$1a,
    formatRelative: formatRelative$12,
    localize: localize$12,
    match: match$11,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$10 = {
    lessThanXSeconds: {
        standalone: {
            one: "weniger als 1 Sekunde",
            other: "weniger als {{count}} Sekunden"
        },
        withPreposition: {
            one: "weniger als 1 Sekunde",
            other: "weniger als {{count}} Sekunden"
        }
    },
    xSeconds: {
        standalone: {
            one: "1 Sekunde",
            other: "{{count}} Sekunden"
        },
        withPreposition: {
            one: "1 Sekunde",
            other: "{{count}} Sekunden"
        }
    },
    halfAMinute: {
        standalone: "eine halbe Minute",
        withPreposition: "einer halben Minute"
    },
    lessThanXMinutes: {
        standalone: {
            one: "weniger als 1 Minute",
            other: "weniger als {{count}} Minuten"
        },
        withPreposition: {
            one: "weniger als 1 Minute",
            other: "weniger als {{count}} Minuten"
        }
    },
    xMinutes: {
        standalone: {
            one: "1 Minute",
            other: "{{count}} Minuten"
        },
        withPreposition: {
            one: "1 Minute",
            other: "{{count}} Minuten"
        }
    },
    aboutXHours: {
        standalone: {
            one: "etwa 1 Stunde",
            other: "etwa {{count}} Stunden"
        },
        withPreposition: {
            one: "etwa 1 Stunde",
            other: "etwa {{count}} Stunden"
        }
    },
    xHours: {
        standalone: {
            one: "1 Stunde",
            other: "{{count}} Stunden"
        },
        withPreposition: {
            one: "1 Stunde",
            other: "{{count}} Stunden"
        }
    },
    xDays: {
        standalone: {
            one: "1 Tag",
            other: "{{count}} Tage"
        },
        withPreposition: {
            one: "1 Tag",
            other: "{{count}} Tagen"
        }
    },
    aboutXWeeks: {
        standalone: {
            one: "etwa 1 Woche",
            other: "etwa {{count}} Wochen"
        },
        withPreposition: {
            one: "etwa 1 Woche",
            other: "etwa {{count}} Wochen"
        }
    },
    xWeeks: {
        standalone: {
            one: "1 Woche",
            other: "{{count}} Wochen"
        },
        withPreposition: {
            one: "1 Woche",
            other: "{{count}} Wochen"
        }
    },
    aboutXMonths: {
        standalone: {
            one: "etwa 1 Monat",
            other: "etwa {{count}} Monate"
        },
        withPreposition: {
            one: "etwa 1 Monat",
            other: "etwa {{count}} Monaten"
        }
    },
    xMonths: {
        standalone: {
            one: "1 Monat",
            other: "{{count}} Monate"
        },
        withPreposition: {
            one: "1 Monat",
            other: "{{count}} Monaten"
        }
    },
    aboutXYears: {
        standalone: {
            one: "etwa 1 Jahr",
            other: "etwa {{count}} Jahre"
        },
        withPreposition: {
            one: "etwa 1 Jahr",
            other: "etwa {{count}} Jahren"
        }
    },
    xYears: {
        standalone: {
            one: "1 Jahr",
            other: "{{count}} Jahre"
        },
        withPreposition: {
            one: "1 Jahr",
            other: "{{count}} Jahren"
        }
    },
    overXYears: {
        standalone: {
            one: "mehr als 1 Jahr",
            other: "mehr als {{count}} Jahre"
        },
        withPreposition: {
            one: "mehr als 1 Jahr",
            other: "mehr als {{count}} Jahren"
        }
    },
    almostXYears: {
        standalone: {
            one: "fast 1 Jahr",
            other: "fast {{count}} Jahre"
        },
        withPreposition: {
            one: "fast 1 Jahr",
            other: "fast {{count}} Jahren"
        }
    }
};
const formatDistance$11 = (token, count, options2) => {
    let result;
    const tokenValue = options2?.addSuffix ? formatDistanceLocale$10[token].withPreposition : formatDistanceLocale$10[token].standalone;
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "in " + result;
        }
        else {
            return "vor " + result;
        }
    }
    return result;
};
const dateFormats$19 = {
    full: "EEEE, do MMMM y",
    // Montag, 7. Januar 2018
    long: "do MMMM y",
    // 7. Januar 2018
    medium: "do MMM y",
    // 7. Jan. 2018
    short: "dd.MM.y"
    // 07.01.2018
};
const timeFormats$19 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$19 = {
    full: "{{date}} 'um' {{time}}",
    long: "{{date}} 'um' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$19 = {
    date: buildFormatLongFn({
        formats: dateFormats$19,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$19,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$19,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$11 = {
    lastWeek: "'letzten' eeee 'um' p",
    yesterday: "'gestern um' p",
    today: "'heute um' p",
    tomorrow: "'morgen um' p",
    nextWeek: "eeee 'um' p",
    other: "P"
};
const formatRelative$11 = (token, _date, _baseDate, _options) => formatRelativeLocale$11[token];
const eraValues$11 = {
    narrow: ["v.Chr.", "n.Chr."],
    abbreviated: ["v.Chr.", "n.Chr."],
    wide: ["vor Christus", "nach Christus"]
};
const quarterValues$11 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$11 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Feb",
        "Mr",
        "Apr",
        "Mai",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dez"
    ],
    wide: [
        "Januar",
        "Februar",
        "Mrz",
        "April",
        "Mai",
        "Juni",
        "Juli",
        "August",
        "September",
        "Oktober",
        "November",
        "Dezember"
    ]
};
const formattingMonthValues$e = {
    narrow: monthValues$11.narrow,
    abbreviated: [
        "Jan.",
        "Feb.",
        "Mrz",
        "Apr.",
        "Mai",
        "Juni",
        "Juli",
        "Aug.",
        "Sep.",
        "Okt.",
        "Nov.",
        "Dez."
    ],
    wide: monthValues$11.wide
};
const dayValues$11 = {
    narrow: ["S", "M", "D", "M", "D", "F", "S"],
    short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
    wide: [
        "Sonntag",
        "Montag",
        "Dienstag",
        "Mittwoch",
        "Donnerstag",
        "Freitag",
        "Samstag"
    ]
};
const dayPeriodValues$11 = {
    narrow: {
        am: "vm.",
        pm: "nm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "Morgen",
        afternoon: "Nachm.",
        evening: "Abend",
        night: "Nacht"
    },
    abbreviated: {
        am: "vorm.",
        pm: "nachm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "Morgen",
        afternoon: "Nachmittag",
        evening: "Abend",
        night: "Nacht"
    },
    wide: {
        am: "vormittags",
        pm: "nachmittags",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "Morgen",
        afternoon: "Nachmittag",
        evening: "Abend",
        night: "Nacht"
    }
};
const formattingDayPeriodValues$O = {
    narrow: {
        am: "vm.",
        pm: "nm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "morgens",
        afternoon: "nachm.",
        evening: "abends",
        night: "nachts"
    },
    abbreviated: {
        am: "vorm.",
        pm: "nachm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "morgens",
        afternoon: "nachmittags",
        evening: "abends",
        night: "nachts"
    },
    wide: {
        am: "vormittags",
        pm: "nachmittags",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "morgens",
        afternoon: "nachmittags",
        evening: "abends",
        night: "nachts"
    }
};
const ordinalNumber$11 = (dirtyNumber) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$11 = {
    ordinalNumber: ordinalNumber$11,
    era: buildLocalizeFn({
        values: eraValues$11,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$11,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$11,
        formattingValues: formattingMonthValues$e,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$11,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$11,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$O,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$10 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$10 = /\d+/i;
const matchEraPatterns$10 = {
    narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
    abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
    wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
const parseEraPatterns$10 = {
    any: [/^v/i, /^n/i]
};
const matchQuarterPatterns$10 = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](\.)? Quartal/i
};
const parseQuarterPatterns$10 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$10 = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(j[a]n|feb|mr[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
    wide: /^(januar|februar|mrz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
const parseMonthPatterns$10 = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^j[a]/i,
        /^f/i,
        /^mr/i,
        /^ap/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$10 = {
    narrow: /^[smdmf]/i,
    short: /^(so|mo|di|mi|do|fr|sa)/i,
    abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
    wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
const parseDayPatterns$10 = {
    any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$10 = {
    narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
    abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
    wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
const parseDayPeriodPatterns$10 = {
    any: {
        am: /^v/i,
        pm: /^n/i,
        midnight: /^Mitte/i,
        noon: /^Mitta/i,
        morning: /morgens/i,
        afternoon: /nachmittags/i,
        // will never be matched. Afternoon is matched by `pm`
        evening: /abends/i,
        night: /nachts/i
        // will never be matched. Night is matched by `pm`
    }
};
const match$10 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$10,
        parsePattern: parseOrdinalNumberPattern$10,
        valueCallback: (value) => parseInt(value)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$10,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$10,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$10,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$10,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$10,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$10,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$10,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$10,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$10,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$10,
        defaultParseWidth: "any"
    })
};
const de = {
    code: "de",
    formatDistance: formatDistance$11,
    formatLong: formatLong$19,
    formatRelative: formatRelative$11,
    localize: localize$11,
    match: match$10,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const eraValues$10 = {
    narrow: ["v.Chr.", "n.Chr."],
    abbreviated: ["v.Chr.", "n.Chr."],
    wide: ["vor Christus", "nach Christus"]
};
const quarterValues$10 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$10 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jn",
        "Feb",
        "Mr",
        "Apr",
        "Mai",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dez"
    ],
    wide: [
        "Jnner",
        "Februar",
        "Mrz",
        "April",
        "Mai",
        "Juni",
        "Juli",
        "August",
        "September",
        "Oktober",
        "November",
        "Dezember"
    ]
};
const formattingMonthValues$d = {
    narrow: monthValues$10.narrow,
    abbreviated: [
        "Jn.",
        "Feb.",
        "Mrz",
        "Apr.",
        "Mai",
        "Juni",
        "Juli",
        "Aug.",
        "Sep.",
        "Okt.",
        "Nov.",
        "Dez."
    ],
    wide: monthValues$10.wide
};
const dayValues$10 = {
    narrow: ["S", "M", "D", "M", "D", "F", "S"],
    short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
    wide: [
        "Sonntag",
        "Montag",
        "Dienstag",
        "Mittwoch",
        "Donnerstag",
        "Freitag",
        "Samstag"
    ]
};
const dayPeriodValues$10 = {
    narrow: {
        am: "vm.",
        pm: "nm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "Morgen",
        afternoon: "Nachm.",
        evening: "Abend",
        night: "Nacht"
    },
    abbreviated: {
        am: "vorm.",
        pm: "nachm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "Morgen",
        afternoon: "Nachmittag",
        evening: "Abend",
        night: "Nacht"
    },
    wide: {
        am: "vormittags",
        pm: "nachmittags",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "Morgen",
        afternoon: "Nachmittag",
        evening: "Abend",
        night: "Nacht"
    }
};
const formattingDayPeriodValues$N = {
    narrow: {
        am: "vm.",
        pm: "nm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "morgens",
        afternoon: "nachm.",
        evening: "abends",
        night: "nachts"
    },
    abbreviated: {
        am: "vorm.",
        pm: "nachm.",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "morgens",
        afternoon: "nachmittags",
        evening: "abends",
        night: "nachts"
    },
    wide: {
        am: "vormittags",
        pm: "nachmittags",
        midnight: "Mitternacht",
        noon: "Mittag",
        morning: "morgens",
        afternoon: "nachmittags",
        evening: "abends",
        night: "nachts"
    }
};
const ordinalNumber$10 = (dirtyNumber) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$10 = {
    ordinalNumber: ordinalNumber$10,
    era: buildLocalizeFn({
        values: eraValues$10,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$10,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$10,
        formattingValues: formattingMonthValues$d,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$10,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$10,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$N,
        defaultFormattingWidth: "wide"
    })
};
const deAT = {
    code: "de-AT",
    formatDistance: formatDistance$11,
    formatLong: formatLong$19,
    formatRelative: formatRelative$11,
    localize: localize$10,
    match: match$10,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$$ = {
    lessThanXSeconds: {
        one: "   ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "   ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  1 ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$10 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$$[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$18 = {
    full: "EEEE, d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "d/M/yy"
};
const timeFormats$18 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$18 = {
    full: "{{date}} - {{time}}",
    long: "{{date}} - {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$18 = {
    date: buildFormatLongFn({
        formats: dateFormats$18,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$18,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$18,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$10 = {
    lastWeek: (date) => {
        switch (date.getDay()) {
            case 6:
                return "' ' eeee '' p";
            default:
                return "' ' eeee '' p";
        }
    },
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$10 = (token, date) => {
    const format2 = formatRelativeLocale$10[token];
    if (typeof format2 === "function")
        return format2(date);
    return format2;
};
const eraValues$$ = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", " "]
};
const quarterValues$$ = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$$ = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$c = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$$ = {
    narrow: ["", "", "T", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$$ = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "..",
        pm: "..",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "..",
        pm: "..",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$$ = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = options2?.unit;
    let suffix;
    if (unit === "year" || unit === "month") {
        suffix = "";
    }
    else if (unit === "week" || unit === "dayOfYear" || unit === "day" || unit === "hour" || unit === "date") {
        suffix = "";
    }
    else {
        suffix = "";
    }
    return number2 + suffix;
};
const localize$$ = {
    ordinalNumber: ordinalNumber$$,
    era: buildLocalizeFn({
        values: eraValues$$,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$$,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$$,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$c,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$$,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$$,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$$ = /^(\d+)(||)?/i;
const parseOrdinalNumberPattern$$ = /\d+/i;
const matchEraPatterns$$ = {
    narrow: /^(|)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
    wide: /^( (|)| (|)  (|) (|)|(|) (|)|(|) (|))/i
};
const parseEraPatterns$$ = {
    any: [/^/i, /^(|)/i]
};
const matchQuarterPatterns$$ = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^[1234]? (|)/i
};
const parseQuarterPatterns$$ = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$$ = {
    narrow: /^[]/i,
    abbreviated: /^(||[]||[][]|[]|[]|[]|||[]|)/i,
    wide: /^([][]|[][])(|)|([]|[]|[]|[]|[]|[]|[]|[]|[]|[])(|)/i
};
const parseMonthPatterns$$ = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^[]/i,
        /^/i,
        /^[][]/i,
        /^[]/i,
        /^[]/i,
        /^[]/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$$ = {
    narrow: /^[]/i,
    short: /^(||||[]|[]|[])/i,
    abbreviated: /^(||||||)/i,
    wide: /^((|)|(|)|(|)|(|)|(|)|(|)|(|))/i
};
const parseDayPatterns$$ = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i, /^/i]
};
const matchDayPeriodPatterns$$ = {
    narrow: /^(||(|)|(|)|(|)|(|)|(|)|(|))/i,
    any: /^([]\.?\s?\.?|(|)|(|)|(|)|(|)|(|)|(|))/i
};
const parseDayPeriodPatterns$$ = {
    any: {
        am: /^|\.\s?\./i,
        pm: /^|\.\s?\./i,
        midnight: /^/i,
        noon: /^(|)/i,
        morning: /(|)/i,
        afternoon: /(|)/i,
        evening: /(|)/i,
        night: /(|)/i
    }
};
const match$$ = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$$,
        parsePattern: parseOrdinalNumberPattern$$,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$$,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$$,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$$,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$$,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$$,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$$,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$$,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$$,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$$,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$$,
        defaultParseWidth: "any"
    })
};
const el = {
    code: "el",
    formatDistance: formatDistance$10,
    formatLong: formatLong$18,
    formatRelative: formatRelative$10,
    localize: localize$$,
    match: match$$,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const dateFormats$17 = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$17 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$17 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$17 = {
    date: buildFormatLongFn({
        formats: dateFormats$17,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$17,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$17,
        defaultWidth: "full"
    })
};
const enAU = {
    code: "en-AU",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$17,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$_ = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "a second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "a minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about an hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "an hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "a day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about a week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "a week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about a month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "a month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about a year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "a year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over a year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost a year",
        other: "almost {{count}} years"
    }
};
const formatDistance$$ = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$_[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "in " + result;
        }
        else {
            return result + " ago";
        }
    }
    return result;
};
const dateFormats$16 = {
    full: "EEEE, MMMM do, yyyy",
    long: "MMMM do, yyyy",
    medium: "MMM d, yyyy",
    short: "yyyy-MM-dd"
};
const timeFormats$16 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$16 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$16 = {
    date: buildFormatLongFn({
        formats: dateFormats$16,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$16,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$16,
        defaultWidth: "full"
    })
};
const enCA = {
    code: "en-CA",
    formatDistance: formatDistance$$,
    formatLong: formatLong$16,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const dateFormats$15 = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$15 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$15 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$15 = {
    date: buildFormatLongFn({
        formats: dateFormats$15,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$15,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$15,
        defaultWidth: "full"
    })
};
const enGB = {
    code: "en-GB",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$15,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const enIE = {
    code: "en-IE",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$15,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const dateFormats$14 = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM, yyyy",
    medium: "d MMM, yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$14 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$14 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$14 = {
    date: buildFormatLongFn({
        formats: dateFormats$14,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$14,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$14,
        defaultWidth: "full"
    })
};
const enIN = {
    code: "en-IN",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$14,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 1,
        // Monday is the first day of the week.
        firstWeekContainsDate: 4
        // The week that contains Jan 4th is the first week of the year.
    }
};
const dateFormats$13 = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$13 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$13 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$13 = {
    date: buildFormatLongFn({
        formats: dateFormats$13,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$13,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$13,
        defaultWidth: "full"
    })
};
const enNZ = {
    code: "en-NZ",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$13,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const dateFormats$12 = {
    full: "EEEE, dd MMMM yyyy",
    long: "dd MMMM yyyy",
    medium: "dd MMM yyyy",
    short: "yyyy/MM/dd"
};
const timeFormats$12 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$12 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$12 = {
    date: buildFormatLongFn({
        formats: dateFormats$12,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$12,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$12,
        defaultWidth: "full"
    })
};
const enZA = {
    code: "en-ZA",
    formatDistance: formatDistance$1k,
    formatLong: formatLong$12,
    formatRelative: formatRelative$1k,
    localize: localize$1k,
    match: match$1j,
    options: {
        weekStartsOn: 0,
        // Sunday is the first day of the week.
        firstWeekContainsDate: 1
        // The week that contains Jan 1st is the first week of the year.
    }
};
const formatDistanceLocale$Z = {
    lessThanXSeconds: {
        one: "malpli ol sekundo",
        other: "malpli ol {{count}} sekundoj"
    },
    xSeconds: {
        one: "1 sekundo",
        other: "{{count}} sekundoj"
    },
    halfAMinute: "duonminuto",
    lessThanXMinutes: {
        one: "malpli ol minuto",
        other: "malpli ol {{count}} minutoj"
    },
    xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutoj"
    },
    aboutXHours: {
        one: "proksimume 1 horo",
        other: "proksimume {{count}} horoj"
    },
    xHours: {
        one: "1 horo",
        other: "{{count}} horoj"
    },
    xDays: {
        one: "1 tago",
        other: "{{count}} tagoj"
    },
    aboutXMonths: {
        one: "proksimume 1 monato",
        other: "proksimume {{count}} monatoj"
    },
    xWeeks: {
        one: "1 semajno",
        other: "{{count}} semajnoj"
    },
    aboutXWeeks: {
        one: "proksimume 1 semajno",
        other: "proksimume {{count}} semajnoj"
    },
    xMonths: {
        one: "1 monato",
        other: "{{count}} monatoj"
    },
    aboutXYears: {
        one: "proksimume 1 jaro",
        other: "proksimume {{count}} jaroj"
    },
    xYears: {
        one: "1 jaro",
        other: "{{count}} jaroj"
    },
    overXYears: {
        one: "pli ol 1 jaro",
        other: "pli ol {{count}} jaroj"
    },
    almostXYears: {
        one: "preska 1 jaro",
        other: "preska {{count}} jaroj"
    }
};
const formatDistance$_ = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$Z[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2?.comparison && options2.comparison > 0) {
            return "post " + result;
        }
        else {
            return "anta " + result;
        }
    }
    return result;
};
const dateFormats$11 = {
    full: "EEEE, do 'de' MMMM y",
    long: "y-MMMM-dd",
    medium: "y-MMM-dd",
    short: "yyyy-MM-dd"
};
const timeFormats$11 = {
    full: "Ho 'horo kaj' m:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$11 = {
    any: "{{date}} {{time}}"
};
const formatLong$11 = {
    date: buildFormatLongFn({
        formats: dateFormats$11,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$11,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$11,
        defaultWidth: "any"
    })
};
const formatRelativeLocale$$ = {
    lastWeek: "'pasinta' eeee 'je' p",
    yesterday: "'hiera je' p",
    today: "'hodia je' p",
    tomorrow: "'morga je' p",
    nextWeek: "eeee 'je' p",
    other: "P"
};
const formatRelative$$ = (token, _date, _baseDate, _options) => formatRelativeLocale$$[token];
const eraValues$_ = {
    narrow: ["aK", "pK"],
    abbreviated: ["a.K.E.", "p.K.E."],
    wide: ["anta Komuna Erao", "Komuna Erao"]
};
const quarterValues$_ = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: [
        "1-a kvaronjaro",
        "2-a kvaronjaro",
        "3-a kvaronjaro",
        "4-a kvaronjaro"
    ]
};
const monthValues$_ = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "ag",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "januaro",
        "februaro",
        "marto",
        "aprilo",
        "majo",
        "junio",
        "julio",
        "agusto",
        "septembro",
        "oktobro",
        "novembro",
        "decembro"
    ]
};
const dayValues$_ = {
    narrow: ["D", "L", "M", "M", "", "V", "S"],
    short: ["di", "lu", "ma", "me", "a", "ve", "sa"],
    abbreviated: ["dim", "lun", "mar", "mer", "a", "ven", "sab"],
    wide: [
        "dimano",
        "lundo",
        "mardo",
        "merkredo",
        "ado",
        "vendredo",
        "sabato"
    ]
};
const dayPeriodValues$_ = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "noktomezo",
        noon: "tagmezo",
        morning: "matene",
        afternoon: "posttagmeze",
        evening: "vespere",
        night: "nokte"
    },
    abbreviated: {
        am: "a.t.m.",
        pm: "p.t.m.",
        midnight: "noktomezo",
        noon: "tagmezo",
        morning: "matene",
        afternoon: "posttagmeze",
        evening: "vespere",
        night: "nokte"
    },
    wide: {
        am: "antatagmeze",
        pm: "posttagmeze",
        midnight: "noktomezo",
        noon: "tagmezo",
        morning: "matene",
        afternoon: "posttagmeze",
        evening: "vespere",
        night: "nokte"
    }
};
const ordinalNumber$_ = (dirtyNumber) => {
    const number2 = Number(dirtyNumber);
    return number2 + "-a";
};
const localize$_ = {
    ordinalNumber: ordinalNumber$_,
    era: buildLocalizeFn({
        values: eraValues$_,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$_,
        defaultWidth: "wide",
        argumentCallback: function (quarter) {
            return Number(quarter) - 1;
        }
    }),
    month: buildLocalizeFn({
        values: monthValues$_,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$_,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$_,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$_ = /^(\d+)(-?a)?/i;
const parseOrdinalNumberPattern$_ = /\d+/i;
const matchEraPatterns$_ = {
    narrow: /^([ap]k)/i,
    abbreviated: /^([ap]\.?\s?k\.?\s?e\.?)/i,
    wide: /^((anta |post )?komuna erao)/i
};
const parseEraPatterns$_ = {
    any: [/^a/i, /^[kp]/i]
};
const matchQuarterPatterns$_ = {
    narrow: /^[1234]/i,
    abbreviated: /^k[1234]/i,
    wide: /^[1234](-?a)? kvaronjaro/i
};
const parseQuarterPatterns$_ = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$_ = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|a(|ux|uh|u)g|sep|okt|nov|dec)/i,
    wide: /^(januaro|februaro|marto|aprilo|majo|junio|julio|a(|ux|uh|u)gusto|septembro|oktobro|novembro|decembro)/i
};
const parseMonthPatterns$_ = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^a(u|)/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$_ = {
    narrow: /^[dlmjvs]/i,
    short: /^(di|lu|ma|me|(|jx|jh|j)a|ve|sa)/i,
    abbreviated: /^(dim|lun|mar|mer|(|jx|jh|j)a(|ux|uh|u)|ven|sab)/i,
    wide: /^(diman(|cx|ch|c)o|lundo|mardo|merkredo|(|jx|jh|j)a(|ux|uh|u)do|vendredo|sabato)/i
};
const parseDayPatterns$_ = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^(j|)/i, /^v/i, /^s/i],
    any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^(j|)/i, /^v/i, /^s/i]
};
const matchDayPeriodPatterns$_ = {
    narrow: /^([ap]|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
    abbreviated: /^([ap][.\s]?t[.\s]?m[.\s]?|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
    wide: /^(anta(|ux)tagmez|posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo]/i
};
const parseDayPeriodPatterns$_ = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^noktom/i,
        noon: /^t/i,
        morning: /^m/i,
        afternoon: /^posttagmeze/i,
        evening: /^v/i,
        night: /^n/i
    }
};
const match$_ = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$_,
        parsePattern: parseOrdinalNumberPattern$_,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$_,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$_,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$_,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$_,
        defaultParseWidth: "any",
        valueCallback: function (index) {
            return index + 1;
        }
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$_,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$_,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$_,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$_,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$_,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$_,
        defaultParseWidth: "any"
    })
};
const eo = {
    code: "eo",
    formatDistance: formatDistance$_,
    formatLong: formatLong$11,
    formatRelative: formatRelative$$,
    localize: localize$_,
    match: match$_,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$Y = {
    lessThanXSeconds: {
        one: "menos de un segundo",
        other: "menos de {{count}} segundos"
    },
    xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
    },
    halfAMinute: "medio minuto",
    lessThanXMinutes: {
        one: "menos de un minuto",
        other: "menos de {{count}} minutos"
    },
    xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
    },
    aboutXHours: {
        one: "alrededor de 1 hora",
        other: "alrededor de {{count}} horas"
    },
    xHours: {
        one: "1 hora",
        other: "{{count}} horas"
    },
    xDays: {
        one: "1 da",
        other: "{{count}} das"
    },
    aboutXWeeks: {
        one: "alrededor de 1 semana",
        other: "alrededor de {{count}} semanas"
    },
    xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
    },
    aboutXMonths: {
        one: "alrededor de 1 mes",
        other: "alrededor de {{count}} meses"
    },
    xMonths: {
        one: "1 mes",
        other: "{{count}} meses"
    },
    aboutXYears: {
        one: "alrededor de 1 ao",
        other: "alrededor de {{count}} aos"
    },
    xYears: {
        one: "1 ao",
        other: "{{count}} aos"
    },
    overXYears: {
        one: "ms de 1 ao",
        other: "ms de {{count}} aos"
    },
    almostXYears: {
        one: "casi 1 ao",
        other: "casi {{count}} aos"
    }
};
const formatDistance$Z = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$Y[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "en " + result;
        }
        else {
            return "hace " + result;
        }
    }
    return result;
};
const dateFormats$10 = {
    full: "EEEE, d 'de' MMMM 'de' y",
    long: "d 'de' MMMM 'de' y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$10 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$10 = {
    full: "{{date}} 'a las' {{time}}",
    long: "{{date}} 'a las' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$10 = {
    date: buildFormatLongFn({
        formats: dateFormats$10,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$10,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$10,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$_ = {
    lastWeek: "'el' eeee 'pasado a la' p",
    yesterday: "'ayer a la' p",
    today: "'hoy a la' p",
    tomorrow: "'maana a la' p",
    nextWeek: "eeee 'a la' p",
    other: "P"
};
const formatRelativeLocalePlural$2 = {
    lastWeek: "'el' eeee 'pasado a las' p",
    yesterday: "'ayer a las' p",
    today: "'hoy a las' p",
    tomorrow: "'maana a las' p",
    nextWeek: "eeee 'a las' p",
    other: "P"
};
const formatRelative$_ = (token, date, _baseDate, _options) => {
    if (date.getHours() !== 1) {
        return formatRelativeLocalePlural$2[token];
    }
    else {
        return formatRelativeLocale$_[token];
    }
};
const eraValues$Z = {
    narrow: ["AC", "DC"],
    abbreviated: ["AC", "DC"],
    wide: ["antes de cristo", "despus de cristo"]
};
const quarterValues$Z = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$Z = {
    narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "ene",
        "feb",
        "mar",
        "abr",
        "may",
        "jun",
        "jul",
        "ago",
        "sep",
        "oct",
        "nov",
        "dic"
    ],
    wide: [
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre"
    ]
};
const dayValues$Z = {
    narrow: ["d", "l", "m", "m", "j", "v", "s"],
    short: ["do", "lu", "ma", "mi", "ju", "vi", "s"],
    abbreviated: ["dom", "lun", "mar", "mi", "jue", "vie", "sb"],
    wide: [
        "domingo",
        "lunes",
        "martes",
        "mircoles",
        "jueves",
        "viernes",
        "sbado"
    ]
};
const dayPeriodValues$Z = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "maana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "maana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "maana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
    }
};
const formattingDayPeriodValues$M = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "de la maana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "de la maana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "de la maana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
    }
};
const ordinalNumber$Z = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "";
};
const localize$Z = {
    ordinalNumber: ordinalNumber$Z,
    era: buildLocalizeFn({
        values: eraValues$Z,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$Z,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$Z,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$Z,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$Z,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$M,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$Z = /^(\d+)()?/i;
const parseOrdinalNumberPattern$Z = /\d+/i;
const matchEraPatterns$Z = {
    narrow: /^(ac|dc|a|d)/i,
    abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
    wide: /^(antes de cristo|antes de la era com[u]n|despu[e]s de cristo|era com[u]n)/i
};
const parseEraPatterns$Z = {
    any: [/^ac/i, /^dc/i],
    wide: [
        /^(antes de cristo|antes de la era com[u]n)/i,
        /^(despu[e]s de cristo|era com[u]n)/i
    ]
};
const matchQuarterPatterns$Z = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$Z = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$Z = {
    narrow: /^[efmajsond]/i,
    abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
    wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
};
const parseMonthPatterns$Z = {
    narrow: [
        /^e/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^en/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
    ]
};
const matchDayPatterns$Z = {
    narrow: /^[dlmjvs]/i,
    short: /^(do|lu|ma|mi|ju|vi|s[a])/i,
    abbreviated: /^(dom|lun|mar|mi[e]|jue|vie|s[a]b)/i,
    wide: /^(domingo|lunes|martes|mi[e]rcoles|jueves|viernes|s[a]bado)/i
};
const parseDayPatterns$Z = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
    any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
};
const matchDayPeriodPatterns$Z = {
    narrow: /^(a|p|mn|md|(de la|a las) (maana|tarde|noche))/i,
    any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (maana|tarde|noche))/i
};
const parseDayPeriodPatterns$Z = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn/i,
        noon: /^md/i,
        morning: /maana/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noche/i
    }
};
const match$Z = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$Z,
        parsePattern: parseOrdinalNumberPattern$Z,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$Z,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$Z,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$Z,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$Z,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$Z,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$Z,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$Z,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$Z,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$Z,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$Z,
        defaultParseWidth: "any"
    })
};
const es = {
    code: "es",
    formatDistance: formatDistance$Z,
    formatLong: formatLong$10,
    formatRelative: formatRelative$_,
    localize: localize$Z,
    match: match$Z,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$X = {
    lessThanXSeconds: {
        standalone: {
            one: "vhem kui ks sekund",
            other: "vhem kui {{count}} sekundit"
        },
        withPreposition: {
            one: "vhem kui he sekundi",
            other: "vhem kui {{count}} sekundi"
        }
    },
    xSeconds: {
        standalone: {
            one: "ks sekund",
            other: "{{count}} sekundit"
        },
        withPreposition: {
            one: "he sekundi",
            other: "{{count}} sekundi"
        }
    },
    halfAMinute: {
        standalone: "pool minutit",
        withPreposition: "poole minuti"
    },
    lessThanXMinutes: {
        standalone: {
            one: "vhem kui ks minut",
            other: "vhem kui {{count}} minutit"
        },
        withPreposition: {
            one: "vhem kui he minuti",
            other: "vhem kui {{count}} minuti"
        }
    },
    xMinutes: {
        standalone: {
            one: "ks minut",
            other: "{{count}} minutit"
        },
        withPreposition: {
            one: "he minuti",
            other: "{{count}} minuti"
        }
    },
    aboutXHours: {
        standalone: {
            one: "umbes ks tund",
            other: "umbes {{count}} tundi"
        },
        withPreposition: {
            one: "umbes he tunni",
            other: "umbes {{count}} tunni"
        }
    },
    xHours: {
        standalone: {
            one: "ks tund",
            other: "{{count}} tundi"
        },
        withPreposition: {
            one: "he tunni",
            other: "{{count}} tunni"
        }
    },
    xDays: {
        standalone: {
            one: "ks pev",
            other: "{{count}} peva"
        },
        withPreposition: {
            one: "he peva",
            other: "{{count}} peva"
        }
    },
    aboutXWeeks: {
        standalone: {
            one: "umbes ks ndal",
            other: "umbes {{count}} ndalat"
        },
        withPreposition: {
            one: "umbes he ndala",
            other: "umbes {{count}} ndala"
        }
    },
    xWeeks: {
        standalone: {
            one: "ks ndal",
            other: "{{count}} ndalat"
        },
        withPreposition: {
            one: "he ndala",
            other: "{{count}} ndala"
        }
    },
    aboutXMonths: {
        standalone: {
            one: "umbes ks kuu",
            other: "umbes {{count}} kuud"
        },
        withPreposition: {
            one: "umbes he kuu",
            other: "umbes {{count}} kuu"
        }
    },
    xMonths: {
        standalone: {
            one: "ks kuu",
            other: "{{count}} kuud"
        },
        withPreposition: {
            one: "he kuu",
            other: "{{count}} kuu"
        }
    },
    aboutXYears: {
        standalone: {
            one: "umbes ks aasta",
            other: "umbes {{count}} aastat"
        },
        withPreposition: {
            one: "umbes he aasta",
            other: "umbes {{count}} aasta"
        }
    },
    xYears: {
        standalone: {
            one: "ks aasta",
            other: "{{count}} aastat"
        },
        withPreposition: {
            one: "he aasta",
            other: "{{count}} aasta"
        }
    },
    overXYears: {
        standalone: {
            one: "rohkem kui ks aasta",
            other: "rohkem kui {{count}} aastat"
        },
        withPreposition: {
            one: "rohkem kui he aasta",
            other: "rohkem kui {{count}} aasta"
        }
    },
    almostXYears: {
        standalone: {
            one: "peaaegu ks aasta",
            other: "peaaegu {{count}} aastat"
        },
        withPreposition: {
            one: "peaaegu he aasta",
            other: "peaaegu {{count}} aasta"
        }
    }
};
const formatDistance$Y = (token, count, options2) => {
    const usageGroup = options2?.addSuffix ? formatDistanceLocale$X[token].withPreposition : formatDistanceLocale$X[token].standalone;
    let result;
    if (typeof usageGroup === "string") {
        result = usageGroup;
    }
    else if (count === 1) {
        result = usageGroup.one;
    }
    else {
        result = usageGroup.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " prast";
        }
        else {
            return result + " eest";
        }
    }
    return result;
};
const dateFormats$$ = {
    full: "EEEE, d. MMMM y",
    long: "d. MMMM y",
    medium: "d. MMM y",
    short: "dd.MM.y"
};
const timeFormats$$ = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$$ = {
    full: "{{date}} 'kell' {{time}}",
    long: "{{date}} 'kell' {{time}}",
    medium: "{{date}}. {{time}}",
    short: "{{date}}. {{time}}"
};
const formatLong$$ = {
    date: buildFormatLongFn({
        formats: dateFormats$$,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$$,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$$,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$Z = {
    lastWeek: "'eelmine' eeee 'kell' p",
    yesterday: "'eile kell' p",
    today: "'tna kell' p",
    tomorrow: "'homme kell' p",
    nextWeek: "'jrgmine' eeee 'kell' p",
    other: "P"
};
const formatRelative$Z = (token, _date, _baseDate, _options) => formatRelativeLocale$Z[token];
const eraValues$Y = {
    narrow: ["e.m.a", "m.a.j"],
    abbreviated: ["e.m.a", "m.a.j"],
    wide: ["enne meie ajaarvamist", "meie ajaarvamise jrgi"]
};
const quarterValues$Y = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$Y = {
    narrow: ["J", "V", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jaan",
        "veebr",
        "mrts",
        "apr",
        "mai",
        "juuni",
        "juuli",
        "aug",
        "sept",
        "okt",
        "nov",
        "dets"
    ],
    wide: [
        "jaanuar",
        "veebruar",
        "mrts",
        "aprill",
        "mai",
        "juuni",
        "juuli",
        "august",
        "september",
        "oktoober",
        "november",
        "detsember"
    ]
};
const dayValues$Y = {
    narrow: ["P", "E", "T", "K", "N", "R", "L"],
    short: ["P", "E", "T", "K", "N", "R", "L"],
    abbreviated: [
        "phap.",
        "esmasp.",
        "teisip.",
        "kolmap.",
        "neljap.",
        "reede.",
        "laup."
    ],
    wide: [
        "phapev",
        "esmaspev",
        "teisipev",
        "kolmapev",
        "neljapev",
        "reede",
        "laupev"
    ]
};
const dayPeriodValues$Y = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "kesk",
        noon: "keskpev",
        morning: "hommik",
        afternoon: "prastluna",
        evening: "htu",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "kesk",
        noon: "keskpev",
        morning: "hommik",
        afternoon: "prastluna",
        evening: "htu",
        night: ""
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "kesk",
        noon: "keskpev",
        morning: "hommik",
        afternoon: "prastluna",
        evening: "htu",
        night: ""
    }
};
const formattingDayPeriodValues$L = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "keskl",
        noon: "keskpeval",
        morning: "hommikul",
        afternoon: "prastlunal",
        evening: "htul",
        night: "sel"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "keskl",
        noon: "keskpeval",
        morning: "hommikul",
        afternoon: "prastlunal",
        evening: "htul",
        night: "sel"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "keskl",
        noon: "keskpeval",
        morning: "hommikul",
        afternoon: "prastlunal",
        evening: "htul",
        night: "sel"
    }
};
const ordinalNumber$Y = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$Y = {
    ordinalNumber: ordinalNumber$Y,
    era: buildLocalizeFn({
        values: eraValues$Y,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$Y,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$Y,
        defaultWidth: "wide",
        formattingValues: monthValues$Y,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$Y,
        defaultWidth: "wide",
        formattingValues: dayValues$Y,
        defaultFormattingWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$Y,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$L,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$Y = /^\d+\./i;
const parseOrdinalNumberPattern$Y = /\d+/i;
const matchEraPatterns$Y = {
    narrow: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
    abbreviated: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
    wide: /^(enne meie ajaarvamist|meie ajaarvamise jrgi|enne Kristust|prast Kristust)/i
};
const parseEraPatterns$Y = {
    any: [/^e/i, /^(m|p)/i]
};
const matchQuarterPatterns$Y = {
    narrow: /^[1234]/i,
    abbreviated: /^K[1234]/i,
    wide: /^[1234](\.)? kvartal/i
};
const parseQuarterPatterns$Y = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$Y = {
    narrow: /^[jvmasond]/i,
    abbreviated: /^(jaan|veebr|mrts|apr|mai|juuni|juuli|aug|sept|okt|nov|dets)/i,
    wide: /^(jaanuar|veebruar|mrts|aprill|mai|juuni|juuli|august|september|oktoober|november|detsember)/i
};
const parseMonthPatterns$Y = {
    narrow: [
        /^j/i,
        /^v/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^v/i,
        /^mr/i,
        /^ap/i,
        /^mai/i,
        /^juun/i,
        /^juul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$Y = {
    narrow: /^[petknrl]/i,
    short: /^[petknrl]/i,
    abbreviated: /^(ph?|esm?|tei?|kolm?|nel?|ree?|laup?)\.?/i,
    wide: /^(phapev|esmaspev|teisipev|kolmapev|neljapev|reede|laupev)/i
};
const parseDayPatterns$Y = {
    any: [/^p/i, /^e/i, /^t/i, /^k/i, /^n/i, /^r/i, /^l/i]
};
const matchDayPeriodPatterns$Y = {
    any: /^(am|pm|keskl?|keskpev(al)?|hommik(ul)?|prastlunal?|htul?|(sel)?)/i
};
const parseDayPeriodPatterns$Y = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^kesk/i,
        noon: /^keskp/i,
        morning: /hommik/i,
        afternoon: /prastluna/i,
        evening: /htu/i,
        night: //i
    }
};
const match$Y = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$Y,
        parsePattern: parseOrdinalNumberPattern$Y,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$Y,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$Y,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$Y,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$Y,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$Y,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$Y,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$Y,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$Y,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$Y,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$Y,
        defaultParseWidth: "any"
    })
};
const et = {
    code: "et",
    formatDistance: formatDistance$Y,
    formatLong: formatLong$$,
    formatRelative: formatRelative$Z,
    localize: localize$Y,
    match: match$Y,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$W = {
    lessThanXSeconds: {
        one: "segundo bat baino gutxiago",
        other: "{{count}} segundo baino gutxiago"
    },
    xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundo"
    },
    halfAMinute: "minutu erdi",
    lessThanXMinutes: {
        one: "minutu bat baino gutxiago",
        other: "{{count}} minutu baino gutxiago"
    },
    xMinutes: {
        one: "1 minutu",
        other: "{{count}} minutu"
    },
    aboutXHours: {
        one: "1 ordu gutxi gorabehera",
        other: "{{count}} ordu gutxi gorabehera"
    },
    xHours: {
        one: "1 ordu",
        other: "{{count}} ordu"
    },
    xDays: {
        one: "1 egun",
        other: "{{count}} egun"
    },
    aboutXWeeks: {
        one: "aste 1 inguru",
        other: "{{count}} aste inguru"
    },
    xWeeks: {
        one: "1 aste",
        other: "{{count}} astean"
    },
    aboutXMonths: {
        one: "1 hilabete gutxi gorabehera",
        other: "{{count}} hilabete gutxi gorabehera"
    },
    xMonths: {
        one: "1 hilabete",
        other: "{{count}} hilabete"
    },
    aboutXYears: {
        one: "1 urte gutxi gorabehera",
        other: "{{count}} urte gutxi gorabehera"
    },
    xYears: {
        one: "1 urte",
        other: "{{count}} urte"
    },
    overXYears: {
        one: "1 urte baino gehiago",
        other: "{{count}} urte baino gehiago"
    },
    almostXYears: {
        one: "ia 1 urte",
        other: "ia {{count}} urte"
    }
};
const formatDistance$X = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$W[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "en " + result;
        }
        else {
            return "duela " + result;
        }
    }
    return result;
};
const dateFormats$_ = {
    full: "EEEE, y'ko' MMMM'ren' d'a' y'ren'",
    long: "y'ko' MMMM'ren' d'a'",
    medium: "y MMM d",
    short: "yy/MM/dd"
};
const timeFormats$_ = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$_ = {
    full: "{{date}} 'tan' {{time}}",
    long: "{{date}} 'tan' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$_ = {
    date: buildFormatLongFn({
        formats: dateFormats$_,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$_,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$_,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$Y = {
    lastWeek: "'joan den' eeee, LT",
    yesterday: "'atzo,' p",
    today: "'gaur,' p",
    tomorrow: "'bihar,' p",
    nextWeek: "eeee, p",
    other: "P"
};
const formatRelativeLocalePlural$1 = {
    lastWeek: "'joan den' eeee, p",
    yesterday: "'atzo,' p",
    today: "'gaur,' p",
    tomorrow: "'bihar,' p",
    nextWeek: "eeee, p",
    other: "P"
};
const formatRelative$Y = (token, date) => {
    if (date.getHours() !== 1) {
        return formatRelativeLocalePlural$1[token];
    }
    return formatRelativeLocale$Y[token];
};
const eraValues$X = {
    narrow: ["k.a.", "k.o."],
    abbreviated: ["k.a.", "k.o."],
    wide: ["kristo aurretik", "kristo ondoren"]
};
const quarterValues$X = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1H", "2H", "3H", "4H"],
    wide: [
        "1. hiruhilekoa",
        "2. hiruhilekoa",
        "3. hiruhilekoa",
        "4. hiruhilekoa"
    ]
};
const monthValues$X = {
    narrow: ["u", "o", "m", "a", "m", "e", "u", "a", "i", "u", "a", "a"],
    abbreviated: [
        "urt",
        "ots",
        "mar",
        "api",
        "mai",
        "eka",
        "uzt",
        "abu",
        "ira",
        "urr",
        "aza",
        "abe"
    ],
    wide: [
        "urtarrila",
        "otsaila",
        "martxoa",
        "apirila",
        "maiatza",
        "ekaina",
        "uztaila",
        "abuztua",
        "iraila",
        "urria",
        "azaroa",
        "abendua"
    ]
};
const dayValues$X = {
    narrow: ["i", "a", "a", "a", "o", "o", "l"],
    short: ["ig", "al", "as", "az", "og", "or", "lr"],
    abbreviated: ["iga", "ast", "ast", "ast", "ost", "ost", "lar"],
    wide: [
        "igandea",
        "astelehena",
        "asteartea",
        "asteazkena",
        "osteguna",
        "ostirala",
        "larunbata"
    ]
};
const dayPeriodValues$X = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "ge",
        noon: "eg",
        morning: "goiza",
        afternoon: "arratsaldea",
        evening: "arratsaldea",
        night: "gaua"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "gauerdia",
        noon: "eguerdia",
        morning: "goiza",
        afternoon: "arratsaldea",
        evening: "arratsaldea",
        night: "gaua"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "gauerdia",
        noon: "eguerdia",
        morning: "goiza",
        afternoon: "arratsaldea",
        evening: "arratsaldea",
        night: "gaua"
    }
};
const formattingDayPeriodValues$K = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "ge",
        noon: "eg",
        morning: "goizean",
        afternoon: "arratsaldean",
        evening: "arratsaldean",
        night: "gauean"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "gauerdia",
        noon: "eguerdia",
        morning: "goizean",
        afternoon: "arratsaldean",
        evening: "arratsaldean",
        night: "gauean"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "gauerdia",
        noon: "eguerdia",
        morning: "goizean",
        afternoon: "arratsaldean",
        evening: "arratsaldean",
        night: "gauean"
    }
};
const ordinalNumber$X = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$X = {
    ordinalNumber: ordinalNumber$X,
    era: buildLocalizeFn({
        values: eraValues$X,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$X,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$X,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$X,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$X,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$K,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$X = /^(\d+)(.)?/i;
const parseOrdinalNumberPattern$X = /\d+/i;
const matchEraPatterns$X = {
    narrow: /^(k.a.|k.o.)/i,
    abbreviated: /^(k.a.|k.o.)/i,
    wide: /^(kristo aurretik|kristo ondoren)/i
};
const parseEraPatterns$X = {
    narrow: [/^k.a./i, /^k.o./i],
    abbreviated: [/^(k.a.)/i, /^(k.o.)/i],
    wide: [/^(kristo aurretik)/i, /^(kristo ondoren)/i]
};
const matchQuarterPatterns$X = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]H/i,
    wide: /^[1234](.)? hiruhilekoa/i
};
const parseQuarterPatterns$X = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$X = {
    narrow: /^[uomaei]/i,
    abbreviated: /^(urt|ots|mar|api|mai|eka|uzt|abu|ira|urr|aza|abe)/i,
    wide: /^(urtarrila|otsaila|martxoa|apirila|maiatza|ekaina|uztaila|abuztua|iraila|urria|azaroa|abendua)/i
};
const parseMonthPatterns$X = {
    narrow: [
        /^u/i,
        /^o/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^e/i,
        /^u/i,
        /^a/i,
        /^i/i,
        /^u/i,
        /^a/i,
        /^a/i
    ],
    any: [
        /^urt/i,
        /^ots/i,
        /^mar/i,
        /^api/i,
        /^mai/i,
        /^eka/i,
        /^uzt/i,
        /^abu/i,
        /^ira/i,
        /^urr/i,
        /^aza/i,
        /^abe/i
    ]
};
const matchDayPatterns$X = {
    narrow: /^[iaol]/i,
    short: /^(ig|al|as|az|og|or|lr)/i,
    abbreviated: /^(iga|ast|ast|ast|ost|ost|lar)/i,
    wide: /^(igandea|astelehena|asteartea|asteazkena|osteguna|ostirala|larunbata)/i
};
const parseDayPatterns$X = {
    narrow: [/^i/i, /^a/i, /^a/i, /^a/i, /^o/i, /^o/i, /^l/i],
    short: [/^ig/i, /^al/i, /^as/i, /^az/i, /^og/i, /^or/i, /^lr/i],
    abbreviated: [/^iga/i, /^ast/i, /^ast/i, /^ast/i, /^ost/i, /^ost/i, /^lar/i],
    wide: [
        /^igandea/i,
        /^astelehena/i,
        /^asteartea/i,
        /^asteazkena/i,
        /^osteguna/i,
        /^ostirala/i,
        /^larunbata/i
    ]
};
const matchDayPeriodPatterns$X = {
    narrow: /^(a|p|ge|eg|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i,
    any: /^([ap]\.?\s?m\.?|gauerdia|eguerdia|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i
};
const parseDayPeriodPatterns$X = {
    narrow: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^ge/i,
        noon: /^eg/i,
        morning: /goiz/i,
        afternoon: /arratsaldea/i,
        evening: /arratsaldea/i,
        night: /gau/i
    },
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^gauerdia/i,
        noon: /^eguerdia/i,
        morning: /goiz/i,
        afternoon: /arratsaldea/i,
        evening: /arratsaldea/i,
        night: /gau/i
    }
};
const match$X = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$X,
        parsePattern: parseOrdinalNumberPattern$X,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$X,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$X,
        defaultParseWidth: "wide"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$X,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$X,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$X,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$X,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$X,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$X,
        defaultParseWidth: "wide"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$X,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$X,
        defaultParseWidth: "any"
    })
};
const eu = {
    code: "eu",
    formatDistance: formatDistance$X,
    formatLong: formatLong$_,
    formatRelative: formatRelative$Y,
    localize: localize$X,
    match: match$X,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$V = {
    lessThanXSeconds: {
        one: "   ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "   ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  1 ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$W = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$V[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$Z = {
    full: "EEEE do MMMM y",
    long: "do MMMM y",
    medium: "d MMM y",
    short: "yyyy/MM/dd"
};
const timeFormats$Z = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$Z = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$Z = {
    date: buildFormatLongFn({
        formats: dateFormats$Z,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$Z,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$Z,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$X = {
    lastWeek: "eeee ' ' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$X = (token, _date, _baseDate, _options) => formatRelativeLocale$X[token];
const eraValues$W = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: ["  ", "  "]
};
const quarterValues$W = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" 1", " 2", " 3", " 4"]
};
const monthValues$W = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$W = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["1", "2", "3", "4", "5", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$W = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "..",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "..",
        pm: "..",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$J = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "..",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "..",
        pm: "..",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$W = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$W = {
    ordinalNumber: ordinalNumber$W,
    era: buildLocalizeFn({
        values: eraValues$W,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$W,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$W,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$W,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$W,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$J,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$W = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$W = /\d+/i;
const matchEraPatterns$W = {
    narrow: /^(|)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?|\.?\s?\.?)/i,
    wide: /^(  |   || |  )/i
};
const parseEraPatterns$W = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$W = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^ [1234]/i
};
const parseQuarterPatterns$W = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$W = {
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||||||||||||||||)/i,
    wide: /^(|||||||||||||||||||||||||||)/i
};
const parseMonthPatterns$W = {
    narrow: [
        /^(|)/i,
        /^/i,
        /^/i,
        /^(|)/i,
        /^/i,
        /^(|)/i,
        /^(|)/i,
        /^(|)/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^(|)/i,
        /^(|)/i,
        /^(|)/i,
        /^(|)/i,
        /^/i,
        /^(|)/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$W = {
    narrow: /^[]/i,
    short: /^(||1|2|3|4|5)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$W = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [
        /^(|1|)/i,
        /^(|2|)/i,
        /^(|3|)/i,
        /^(|4|)/i,
        /^(|5|)/i,
        /^(|)/i,
        /^(|)/i
    ]
};
const matchDayPeriodPatterns$W = {
    narrow: /^(|||||..||)/i,
    abbreviated: /^(..|..||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPeriodPatterns$W = {
    any: {
        am: /^(|..|)/i,
        pm: /^(|..|)/i,
        midnight: /^(|)/i,
        noon: /^(|)/i,
        morning: /(|)/i,
        afternoon: /(|..|)/i,
        evening: /(|)/i,
        night: /(|)/i
    }
};
const match$W = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$W,
        parsePattern: parseOrdinalNumberPattern$W,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$W,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$W,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$W,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$W,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$W,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$W,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$W,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$W,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$W,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$W,
        defaultParseWidth: "any"
    })
};
const faIR = {
    code: "fa-IR",
    formatDistance: formatDistance$W,
    formatLong: formatLong$Z,
    formatRelative: formatRelative$X,
    localize: localize$W,
    match: match$W,
    options: {
        weekStartsOn: 6,
        firstWeekContainsDate: 1
    }
};
function futureSeconds(text) {
    return text.replace(/sekuntia?/, "sekunnin");
}
function futureMinutes(text) {
    return text.replace(/minuuttia?/, "minuutin");
}
function futureHours(text) {
    return text.replace(/tuntia?/, "tunnin");
}
function futureDays(text) {
    return text.replace(/piv?/, "pivn");
}
function futureWeeks(text) {
    return text.replace(/(viikko|viikkoa)/, "viikon");
}
function futureMonths(text) {
    return text.replace(/(kuukausi|kuukautta)/, "kuukauden");
}
function futureYears(text) {
    return text.replace(/(vuosi|vuotta)/, "vuoden");
}
const formatDistanceLocale$U = {
    lessThanXSeconds: {
        one: "alle sekunti",
        other: "alle {{count}} sekuntia",
        futureTense: futureSeconds
    },
    xSeconds: {
        one: "sekunti",
        other: "{{count}} sekuntia",
        futureTense: futureSeconds
    },
    halfAMinute: {
        one: "puoli minuuttia",
        other: "puoli minuuttia",
        futureTense: (_text) => "puolen minuutin"
    },
    lessThanXMinutes: {
        one: "alle minuutti",
        other: "alle {{count}} minuuttia",
        futureTense: futureMinutes
    },
    xMinutes: {
        one: "minuutti",
        other: "{{count}} minuuttia",
        futureTense: futureMinutes
    },
    aboutXHours: {
        one: "noin tunti",
        other: "noin {{count}} tuntia",
        futureTense: futureHours
    },
    xHours: {
        one: "tunti",
        other: "{{count}} tuntia",
        futureTense: futureHours
    },
    xDays: {
        one: "piv",
        other: "{{count}} piv",
        futureTense: futureDays
    },
    aboutXWeeks: {
        one: "noin viikko",
        other: "noin {{count}} viikkoa",
        futureTense: futureWeeks
    },
    xWeeks: {
        one: "viikko",
        other: "{{count}} viikkoa",
        futureTense: futureWeeks
    },
    aboutXMonths: {
        one: "noin kuukausi",
        other: "noin {{count}} kuukautta",
        futureTense: futureMonths
    },
    xMonths: {
        one: "kuukausi",
        other: "{{count}} kuukautta",
        futureTense: futureMonths
    },
    aboutXYears: {
        one: "noin vuosi",
        other: "noin {{count}} vuotta",
        futureTense: futureYears
    },
    xYears: {
        one: "vuosi",
        other: "{{count}} vuotta",
        futureTense: futureYears
    },
    overXYears: {
        one: "yli vuosi",
        other: "yli {{count}} vuotta",
        futureTense: futureYears
    },
    almostXYears: {
        one: "lhes vuosi",
        other: "lhes {{count}} vuotta",
        futureTense: futureYears
    }
};
const formatDistance$V = (token, count, options2) => {
    const tokenValue = formatDistanceLocale$U[token];
    const result = count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return tokenValue.futureTense(result) + " kuluttua";
        }
        else {
            return result + " sitten";
        }
    }
    return result;
};
const dateFormats$Y = {
    full: "eeee d. MMMM y",
    long: "d. MMMM y",
    medium: "d. MMM y",
    short: "d.M.y"
};
const timeFormats$Y = {
    full: "HH.mm.ss zzzz",
    long: "HH.mm.ss z",
    medium: "HH.mm.ss",
    short: "HH.mm"
};
const dateTimeFormats$Y = {
    full: "{{date}} 'klo' {{time}}",
    long: "{{date}} 'klo' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$Y = {
    date: buildFormatLongFn({
        formats: dateFormats$Y,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$Y,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$Y,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$W = {
    lastWeek: "'viime' eeee 'klo' p",
    yesterday: "'eilen klo' p",
    today: "'tnn klo' p",
    tomorrow: "'huomenna klo' p",
    nextWeek: "'ensi' eeee 'klo' p",
    other: "P"
};
const formatRelative$W = (token, _date, _baseDate, _options) => formatRelativeLocale$W[token];
const eraValues$V = {
    narrow: ["eaa.", "jaa."],
    abbreviated: ["eaa.", "jaa."],
    wide: ["ennen ajanlaskun alkua", "jlkeen ajanlaskun alun"]
};
const quarterValues$V = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. kvartaali", "2. kvartaali", "3. kvartaali", "4. kvartaali"]
};
const monthValues$V = {
    narrow: ["T", "H", "M", "H", "T", "K", "H", "E", "S", "L", "M", "J"],
    abbreviated: [
        "tammi",
        "helmi",
        "maalis",
        "huhti",
        "touko",
        "kes",
        "hein",
        "elo",
        "syys",
        "loka",
        "marras",
        "joulu"
    ],
    wide: [
        "tammikuu",
        "helmikuu",
        "maaliskuu",
        "huhtikuu",
        "toukokuu",
        "keskuu",
        "heinkuu",
        "elokuu",
        "syyskuu",
        "lokakuu",
        "marraskuu",
        "joulukuu"
    ]
};
const formattingMonthValues$b = {
    narrow: monthValues$V.narrow,
    abbreviated: monthValues$V.abbreviated,
    wide: [
        "tammikuuta",
        "helmikuuta",
        "maaliskuuta",
        "huhtikuuta",
        "toukokuuta",
        "keskuuta",
        "heinkuuta",
        "elokuuta",
        "syyskuuta",
        "lokakuuta",
        "marraskuuta",
        "joulukuuta"
    ]
};
const dayValues$V = {
    narrow: ["S", "M", "T", "K", "T", "P", "L"],
    short: ["su", "ma", "ti", "ke", "to", "pe", "la"],
    abbreviated: ["sunn.", "maan.", "tiis.", "kesk.", "torst.", "perj.", "la"],
    wide: [
        "sunnuntai",
        "maanantai",
        "tiistai",
        "keskiviikko",
        "torstai",
        "perjantai",
        "lauantai"
    ]
};
const formattingDayValues$3 = {
    narrow: dayValues$V.narrow,
    short: dayValues$V.short,
    abbreviated: dayValues$V.abbreviated,
    wide: [
        "sunnuntaina",
        "maanantaina",
        "tiistaina",
        "keskiviikkona",
        "torstaina",
        "perjantaina",
        "lauantaina"
    ]
};
const dayPeriodValues$V = {
    narrow: {
        am: "ap",
        pm: "ip",
        midnight: "keskiy",
        noon: "keskipiv",
        morning: "ap",
        afternoon: "ip",
        evening: "illalla",
        night: "yll"
    },
    abbreviated: {
        am: "ap",
        pm: "ip",
        midnight: "keskiy",
        noon: "keskipiv",
        morning: "ap",
        afternoon: "ip",
        evening: "illalla",
        night: "yll"
    },
    wide: {
        am: "ap",
        pm: "ip",
        midnight: "keskiyll",
        noon: "keskipivll",
        morning: "aamupivll",
        afternoon: "iltapivll",
        evening: "illalla",
        night: "yll"
    }
};
const ordinalNumber$V = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$V = {
    ordinalNumber: ordinalNumber$V,
    era: buildLocalizeFn({
        values: eraValues$V,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$V,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$V,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$b,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$V,
        defaultWidth: "wide",
        formattingValues: formattingDayValues$3,
        defaultFormattingWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$V,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$V = /^(\d+)(\.)/i;
const parseOrdinalNumberPattern$V = /\d+/i;
const matchEraPatterns$V = {
    narrow: /^(e|j)/i,
    abbreviated: /^(eaa.|jaa.)/i,
    wide: /^(ennen ajanlaskun alkua|jlkeen ajanlaskun alun)/i
};
const parseEraPatterns$V = {
    any: [/^e/i, /^j/i]
};
const matchQuarterPatterns$V = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234]\.? kvartaali/i
};
const parseQuarterPatterns$V = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$V = {
    narrow: /^[thmkeslj]/i,
    abbreviated: /^(tammi|helmi|maalis|huhti|touko|kes|hein|elo|syys|loka|marras|joulu)/i,
    wide: /^(tammikuu|helmikuu|maaliskuu|huhtikuu|toukokuu|keskuu|heinkuu|elokuu|syyskuu|lokakuu|marraskuu|joulukuu)(ta)?/i
};
const parseMonthPatterns$V = {
    narrow: [
        /^t/i,
        /^h/i,
        /^m/i,
        /^h/i,
        /^t/i,
        /^k/i,
        /^h/i,
        /^e/i,
        /^s/i,
        /^l/i,
        /^m/i,
        /^j/i
    ],
    any: [
        /^ta/i,
        /^hel/i,
        /^maa/i,
        /^hu/i,
        /^to/i,
        /^k/i,
        /^hei/i,
        /^e/i,
        /^s/i,
        /^l/i,
        /^mar/i,
        /^j/i
    ]
};
const matchDayPatterns$V = {
    narrow: /^[smtkpl]/i,
    short: /^(su|ma|ti|ke|to|pe|la)/i,
    abbreviated: /^(sunn.|maan.|tiis.|kesk.|torst.|perj.|la)/i,
    wide: /^(sunnuntai|maanantai|tiistai|keskiviikko|torstai|perjantai|lauantai)(na)?/i
};
const parseDayPatterns$V = {
    narrow: [/^s/i, /^m/i, /^t/i, /^k/i, /^t/i, /^p/i, /^l/i],
    any: [/^s/i, /^m/i, /^ti/i, /^k/i, /^to/i, /^p/i, /^l/i]
};
const matchDayPeriodPatterns$V = {
    narrow: /^(ap|ip|keskiy|keskipiv|aamupivll|iltapivll|illalla|yll)/i,
    any: /^(ap|ip|keskiyll|keskipivll|aamupivll|iltapivll|illalla|yll)/i
};
const parseDayPeriodPatterns$V = {
    any: {
        am: /^ap/i,
        pm: /^ip/i,
        midnight: /^keskiy/i,
        noon: /^keskipiv/i,
        morning: /aamupivll/i,
        afternoon: /iltapivll/i,
        evening: /illalla/i,
        night: /yll/i
    }
};
const match$V = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$V,
        parsePattern: parseOrdinalNumberPattern$V,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$V,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$V,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$V,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$V,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$V,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$V,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$V,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$V,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$V,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$V,
        defaultParseWidth: "any"
    })
};
const fi = {
    code: "fi",
    formatDistance: formatDistance$V,
    formatLong: formatLong$Y,
    formatRelative: formatRelative$W,
    localize: localize$V,
    match: match$V,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$T = {
    lessThanXSeconds: {
        one: "moins dune seconde",
        other: "moins de {{count}} secondes"
    },
    xSeconds: {
        one: "1 seconde",
        other: "{{count}} secondes"
    },
    halfAMinute: "30 secondes",
    lessThanXMinutes: {
        one: "moins dune minute",
        other: "moins de {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "environ 1 heure",
        other: "environ {{count}} heures"
    },
    xHours: {
        one: "1 heure",
        other: "{{count}} heures"
    },
    xDays: {
        one: "1 jour",
        other: "{{count}} jours"
    },
    aboutXWeeks: {
        one: "environ 1 semaine",
        other: "environ {{count}} semaines"
    },
    xWeeks: {
        one: "1 semaine",
        other: "{{count}} semaines"
    },
    aboutXMonths: {
        one: "environ 1 mois",
        other: "environ {{count}} mois"
    },
    xMonths: {
        one: "1 mois",
        other: "{{count}} mois"
    },
    aboutXYears: {
        one: "environ 1 an",
        other: "environ {{count}} ans"
    },
    xYears: {
        one: "1 an",
        other: "{{count}} ans"
    },
    overXYears: {
        one: "plus dun an",
        other: "plus de {{count}} ans"
    },
    almostXYears: {
        one: "presquun an",
        other: "presque {{count}} ans"
    }
};
const formatDistance$U = (token, count, options2) => {
    let result;
    const form = formatDistanceLocale$T[token];
    if (typeof form === "string") {
        result = form;
    }
    else if (count === 1) {
        result = form.one;
    }
    else {
        result = form.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "dans " + result;
        }
        else {
            return "il y a " + result;
        }
    }
    return result;
};
const dateFormats$X = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$X = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$X = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$X = {
    date: buildFormatLongFn({
        formats: dateFormats$X,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$X,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$X,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$V = {
    lastWeek: "eeee 'dernier ' p",
    yesterday: "'hier ' p",
    today: "'aujourdhui ' p",
    tomorrow: "'demain ' p'",
    nextWeek: "eeee 'prochain ' p",
    other: "P"
};
const formatRelative$V = (token, _date, _baseDate, _options) => formatRelativeLocale$V[token];
const eraValues$U = {
    narrow: ["av. J.-C", "ap. J.-C"],
    abbreviated: ["av. J.-C", "ap. J.-C"],
    wide: ["avant Jsus-Christ", "aprs Jsus-Christ"]
};
const quarterValues$U = {
    narrow: ["T1", "T2", "T3", "T4"],
    abbreviated: ["1er trim.", "2me trim.", "3me trim.", "4me trim."],
    wide: ["1er trimestre", "2me trimestre", "3me trimestre", "4me trimestre"]
};
const monthValues$U = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "janv.",
        "fvr.",
        "mars",
        "avr.",
        "mai",
        "juin",
        "juil.",
        "aot",
        "sept.",
        "oct.",
        "nov.",
        "dc."
    ],
    wide: [
        "janvier",
        "fvrier",
        "mars",
        "avril",
        "mai",
        "juin",
        "juillet",
        "aot",
        "septembre",
        "octobre",
        "novembre",
        "dcembre"
    ]
};
const dayValues$U = {
    narrow: ["D", "L", "M", "M", "J", "V", "S"],
    short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
    abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
    wide: [
        "dimanche",
        "lundi",
        "mardi",
        "mercredi",
        "jeudi",
        "vendredi",
        "samedi"
    ]
};
const dayPeriodValues$U = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "minuit",
        noon: "midi",
        morning: "mat.",
        afternoon: "ap.m.",
        evening: "soir",
        night: "mat."
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "minuit",
        noon: "midi",
        morning: "matin",
        afternoon: "aprs-midi",
        evening: "soir",
        night: "matin"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "minuit",
        noon: "midi",
        morning: "du matin",
        afternoon: "de laprs-midi",
        evening: "du soir",
        night: "du matin"
    }
};
const ordinalNumber$U = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = options2?.unit;
    if (number2 === 0)
        return "0";
    const feminineUnits = ["year", "week", "hour", "minute", "second"];
    let suffix;
    if (number2 === 1) {
        suffix = unit && feminineUnits.includes(unit) ? "re" : "er";
    }
    else {
        suffix = "me";
    }
    return number2 + suffix;
};
const LONG_MONTHS_TOKENS = ["MMM", "MMMM"];
const localize$U = {
    preprocessor: (date, parts) => {
        if (date.getDate() === 1)
            return parts;
        const hasLongMonthToken = parts.some((part) => part.isToken && LONG_MONTHS_TOKENS.includes(part.value));
        if (!hasLongMonthToken)
            return parts;
        return parts.map((part) => part.isToken && part.value === "do" ? { isToken: true, value: "d" } : part);
    },
    ordinalNumber: ordinalNumber$U,
    era: buildLocalizeFn({
        values: eraValues$U,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$U,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$U,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$U,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$U,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$U = /^(\d+)(ime|re|me|er|e)?/i;
const parseOrdinalNumberPattern$U = /\d+/i;
const matchEraPatterns$U = {
    narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
    abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
    wide: /^(avant Jsus-Christ|aprs Jsus-Christ)/i
};
const parseEraPatterns$U = {
    any: [/^av/i, /^ap/i]
};
const matchQuarterPatterns$U = {
    narrow: /^T?[1234]/i,
    abbreviated: /^[1234](er|me|e)? trim\.?/i,
    wide: /^[1234](er|me|e)? trimestre/i
};
const parseQuarterPatterns$U = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$U = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(janv|fvr|mars|avr|mai|juin|juill|juil|aot|sept|oct|nov|dc)\.?/i,
    wide: /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i
};
const parseMonthPatterns$U = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^av/i,
        /^ma/i,
        /^juin/i,
        /^juil/i,
        /^ao/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$U = {
    narrow: /^[lmjvsd]/i,
    short: /^(di|lu|ma|me|je|ve|sa)/i,
    abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
    wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
};
const parseDayPatterns$U = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
    any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
};
const matchDayPeriodPatterns$U = {
    narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
    any: /^([ap]\.?\s?m\.?|du matin|de l'aprs[-\s]midi|du soir|de la nuit)/i
};
const parseDayPeriodPatterns$U = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^min/i,
        noon: /^mid/i,
        morning: /mat/i,
        afternoon: /ap/i,
        evening: /soir/i,
        night: /nuit/i
    }
};
const match$U = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$U,
        parsePattern: parseOrdinalNumberPattern$U,
        valueCallback: (value) => parseInt(value)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$U,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$U,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$U,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$U,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$U,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$U,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$U,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$U,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$U,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$U,
        defaultParseWidth: "any"
    })
};
const fr = {
    code: "fr",
    formatDistance: formatDistance$U,
    formatLong: formatLong$X,
    formatRelative: formatRelative$V,
    localize: localize$U,
    match: match$U,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const dateFormats$W = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "yy-MM-dd"
};
const timeFormats$W = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$W = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$W = {
    date: buildFormatLongFn({
        formats: dateFormats$W,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$W,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$W,
        defaultWidth: "full"
    })
};
const frCA = {
    code: "fr-CA",
    formatDistance: formatDistance$U,
    formatLong: formatLong$W,
    formatRelative: formatRelative$V,
    localize: localize$U,
    match: match$U,
    // Unique for fr-CA
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const dateFormats$V = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd.MM.y"
};
const timeFormats$V = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$V = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$V = {
    date: buildFormatLongFn({
        formats: dateFormats$V,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$V,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$V,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$U = {
    lastWeek: "eeee 'la semaine dernire ' p",
    yesterday: "'hier ' p",
    today: "'aujourdhui ' p",
    tomorrow: "'demain ' p'",
    nextWeek: "eeee 'la semaine prochaine ' p",
    other: "P"
};
const formatRelative$U = (token, _date, _baseDate, _options) => formatRelativeLocale$U[token];
const frCH = {
    code: "fr-CH",
    formatDistance: formatDistance$U,
    formatLong: formatLong$V,
    formatRelative: formatRelative$U,
    localize: localize$U,
    match: match$U,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$S = {
    lessThanXSeconds: {
        one: "minder as 1 sekonde",
        other: "minder as {{count}} sekonden"
    },
    xSeconds: {
        one: "1 sekonde",
        other: "{{count}} sekonden"
    },
    halfAMinute: "oardel mint",
    lessThanXMinutes: {
        one: "minder as 1 mint",
        other: "minder as {{count}} minuten"
    },
    xMinutes: {
        one: "1 mint",
        other: "{{count}} minuten"
    },
    aboutXHours: {
        one: "sawat 1 oere",
        other: "sawat {{count}} oere"
    },
    xHours: {
        one: "1 oere",
        other: "{{count}} oere"
    },
    xDays: {
        one: "1 dei",
        other: "{{count}} dagen"
    },
    aboutXWeeks: {
        one: "sawat 1 wike",
        other: "sawat {{count}} wiken"
    },
    xWeeks: {
        one: "1 wike",
        other: "{{count}} wiken"
    },
    aboutXMonths: {
        one: "sawat 1 moanne",
        other: "sawat {{count}} moannen"
    },
    xMonths: {
        one: "1 moanne",
        other: "{{count}} moannen"
    },
    aboutXYears: {
        one: "sawat 1 jier",
        other: "sawat {{count}} jier"
    },
    xYears: {
        one: "1 jier",
        other: "{{count}} jier"
    },
    overXYears: {
        one: "mear as 1 jier",
        other: "mear as {{count}}s jier"
    },
    almostXYears: {
        one: "hast 1 jier",
        other: "hast {{count}} jier"
    }
};
const formatDistance$T = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$S[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "oer " + result;
        }
        else {
            return result + " lyn";
        }
    }
    return result;
};
const dateFormats$U = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd-MM-y"
};
const timeFormats$U = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$U = {
    full: "{{date}} 'om' {{time}}",
    long: "{{date}} 'om' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$U = {
    date: buildFormatLongFn({
        formats: dateFormats$U,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$U,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$U,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$T = {
    lastWeek: "'frne' eeee 'om' p",
    yesterday: "'juster om' p",
    today: "'hjoed om' p",
    tomorrow: "'moarn om' p",
    nextWeek: "eeee 'om' p",
    other: "P"
};
const formatRelative$T = (token, _date, _baseDate, _options) => formatRelativeLocale$T[token];
const eraValues$T = {
    narrow: ["f.K.", "n.K."],
    abbreviated: ["f.Kr.", "n.Kr."],
    wide: ["foar Kristus", "nei Kristus"]
};
const quarterValues$T = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1e fearnsjier", "2e fearnsjier", "3e fearnsjier", "4e fearnsjier"]
};
const monthValues$T = {
    narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "jan.",
        "feb.",
        "mrt.",
        "apr.",
        "mai.",
        "jun.",
        "jul.",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "des."
    ],
    wide: [
        "jannewaris",
        "febrewaris",
        "maart",
        "april",
        "maaie",
        "juny",
        "july",
        "augustus",
        "septimber",
        "oktober",
        "novimber",
        "desimber"
    ]
};
const dayValues$T = {
    narrow: ["s", "m", "t", "w", "t", "f", "s"],
    short: ["si", "mo", "ti", "wo", "to", "fr", "so"],
    abbreviated: ["snein", "moa", "tii", "woa", "ton", "fre", "sneon"],
    wide: [
        "snein",
        "moandei",
        "tiisdei",
        "woansdei",
        "tongersdei",
        "freed",
        "sneon"
    ]
};
const dayPeriodValues$T = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "middei",
        morning: "moarns",
        afternoon: "middeis",
        evening: "jns",
        night: "nachts"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "middei",
        morning: "moarns",
        afternoon: "middeis",
        evening: "jns",
        night: "nachts"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "middei",
        morning: "moarns",
        afternoon: "middeis",
        evening: "jns",
        night: "nachts"
    }
};
const ordinalNumber$T = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "e";
};
const localize$T = {
    ordinalNumber: ordinalNumber$T,
    era: buildLocalizeFn({
        values: eraValues$T,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$T,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$T,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$T,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$T,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$T = /^(\d+)e?/i;
const parseOrdinalNumberPattern$T = /\d+/i;
const matchEraPatterns$T = {
    narrow: /^([fn]\.? ?K\.?)/,
    abbreviated: /^([fn]\. ?Kr\.?)/,
    wide: /^((foar|nei) Kristus)/
};
const parseEraPatterns$T = {
    any: [/^f/, /^n/]
};
const matchQuarterPatterns$T = {
    narrow: /^[1234]/i,
    abbreviated: /^K[1234]/i,
    wide: /^[1234]e fearnsjier/i
};
const parseQuarterPatterns$T = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$T = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan.|feb.|mrt.|apr.|mai.|jun.|jul.|aug.|sep.|okt.|nov.|des.)/i,
    wide: /^(jannewaris|febrewaris|maart|april|maaie|juny|july|augustus|septimber|oktober|novimber|desimber)/i
};
const parseMonthPatterns$T = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^jan/i,
        /^feb/i,
        /^m(r|a)/i,
        /^apr/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^des/i
    ]
};
const matchDayPatterns$T = {
    narrow: /^[smtwf]/i,
    short: /^(si|mo|ti|wo|to|fr|so)/i,
    abbreviated: /^(snein|moa|tii|woa|ton|fre|sneon)/i,
    wide: /^(snein|moandei|tiisdei|woansdei|tongersdei|freed|sneon)/i
};
const parseDayPatterns$T = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^sn/i, /^mo/i, /^ti/i, /^wo/i, /^to/i, /^fr/i, /^sn/i]
};
const matchDayPeriodPatterns$T = {
    any: /^(am|pm|middernacht|middeis|moarns|middei|jns|nachts)/i
};
const parseDayPeriodPatterns$T = {
    any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /^middernacht/i,
        noon: /^middei/i,
        morning: /moarns/i,
        afternoon: /^middeis/i,
        evening: /jns/i,
        night: /nachts/i
    }
};
const match$T = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$T,
        parsePattern: parseOrdinalNumberPattern$T,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$T,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$T,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$T,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$T,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$T,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$T,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$T,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$T,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$T,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$T,
        defaultParseWidth: "any"
    })
};
const fy = {
    code: "fy",
    formatDistance: formatDistance$T,
    formatLong: formatLong$U,
    formatRelative: formatRelative$T,
    localize: localize$T,
    match: match$T,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$R = {
    lessThanXSeconds: {
        one: "nas lugha na diog",
        other: "nas lugha na {{count}} diogan"
    },
    xSeconds: {
        one: "1 diog",
        two: "2 dhiog",
        twenty: "20 diog",
        other: "{{count}} diogan"
    },
    halfAMinute: "leth mhionaid",
    lessThanXMinutes: {
        one: "nas lugha na mionaid",
        other: "nas lugha na {{count}} mionaidean"
    },
    xMinutes: {
        one: "1 mionaid",
        two: "2 mhionaid",
        twenty: "20 mionaid",
        other: "{{count}} mionaidean"
    },
    aboutXHours: {
        one: "mu uair de thde",
        other: "mu {{count}} uairean de thde"
    },
    xHours: {
        one: "1 uair de thde",
        two: "2 uair de thde",
        twenty: "20 uair de thde",
        other: "{{count}} uairean de thde"
    },
    xDays: {
        one: "1 l",
        other: "{{count}} l"
    },
    aboutXWeeks: {
        one: "mu 1 seachdain",
        other: "mu {{count}} seachdainean"
    },
    xWeeks: {
        one: "1 seachdain",
        other: "{{count}} seachdainean"
    },
    aboutXMonths: {
        one: "mu mhos",
        other: "mu {{count}} mosan"
    },
    xMonths: {
        one: "1 mos",
        other: "{{count}} mosan"
    },
    aboutXYears: {
        one: "mu bhliadhna",
        other: "mu {{count}} bliadhnaichean"
    },
    xYears: {
        one: "1 bhliadhna",
        other: "{{count}} bliadhna"
    },
    overXYears: {
        one: "crr is bliadhna",
        other: "crr is {{count}} bliadhnaichean"
    },
    almostXYears: {
        one: "cha mhr bliadhna",
        other: "cha mhr {{count}} bliadhnaichean"
    }
};
const formatDistance$S = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$R[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 2 && !!tokenValue.two) {
        result = tokenValue.two;
    }
    else if (count === 20 && !!tokenValue.twenty) {
        result = tokenValue.twenty;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "ann an " + result;
        }
        else {
            return "o chionn " + result;
        }
    }
    return result;
};
const dateFormats$T = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$T = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$T = {
    full: "{{date}} 'aig' {{time}}",
    long: "{{date}} 'aig' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$T = {
    date: buildFormatLongFn({
        formats: dateFormats$T,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$T,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$T,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$S = {
    lastWeek: "'mu dheireadh' eeee 'aig' p",
    //FIX
    yesterday: "'an-d aig' p",
    today: "'an-diugh aig' p",
    tomorrow: "'a-mireach aig' p",
    nextWeek: "eeee 'aig' p",
    other: "P"
};
const formatRelative$S = (token, _date, _baseDate, _options) => formatRelativeLocale$S[token];
const eraValues$S = {
    narrow: ["R", "A"],
    abbreviated: ["RC", "AD"],
    wide: ["ro Chrosta", "anno domini"]
};
const quarterValues$S = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["C1", "C2", "C3", "C4"],
    wide: [
        "a' chiad chairteal",
        "an drna cairteal",
        "an treas cairteal",
        "an ceathramh cairteal"
    ]
};
const monthValues$S = {
    narrow: ["F", "G", "M", "G", "C", "", "I", "L", "S", "D", "S", "D"],
    abbreviated: [
        "Faoi",
        "Gear",
        "Mrt",
        "Gibl",
        "Cit",
        "gmh",
        "Iuch",
        "Ln",
        "Sult",
        "Dmh",
        "Samh",
        "Dbh"
    ],
    wide: [
        "Am Faoilleach",
        "An Gearran",
        "Am Mrt",
        "An Giblean",
        "An Citean",
        "An t-gmhios",
        "An t-Iuchar",
        "An Lnastal",
        "An t-Sultain",
        "An Dmhair",
        "An t-Samhain",
        "An Dbhlachd"
    ]
};
const dayValues$S = {
    narrow: ["D", "L", "M", "C", "A", "H", "S"],
    short: ["D", "Lu", "M", "Ci", "Ar", "Ha", "Sa"],
    abbreviated: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
    wide: [
        "Didmhnaich",
        "Diluain",
        "Dimirt",
        "Diciadain",
        "Diardaoin",
        "Dihaoine",
        "Disathairne"
    ]
};
const dayPeriodValues$S = {
    narrow: {
        am: "m",
        pm: "f",
        midnight: "m.o.",
        noon: "m.l.",
        morning: "madainn",
        afternoon: "feasgar",
        evening: "feasgar",
        night: "oidhche"
    },
    abbreviated: {
        am: "M.",
        pm: "F.",
        midnight: "meadhan oidhche",
        noon: "meadhan l",
        morning: "madainn",
        afternoon: "feasgar",
        evening: "feasgar",
        night: "oidhche"
    },
    wide: {
        am: "m.",
        pm: "f.",
        midnight: "meadhan oidhche",
        noon: "meadhan l",
        morning: "madainn",
        afternoon: "feasgar",
        evening: "feasgar",
        night: "oidhche"
    }
};
const formattingDayPeriodValues$I = {
    narrow: {
        am: "m",
        pm: "f",
        midnight: "m.o.",
        noon: "m.l.",
        morning: "sa mhadainn",
        afternoon: "feasgar",
        evening: "feasgar",
        night: "air an oidhche"
    },
    abbreviated: {
        am: "M.",
        pm: "F.",
        midnight: "meadhan oidhche",
        noon: "meadhan l",
        morning: "sa mhadainn",
        afternoon: "feasgar",
        evening: "feasgar",
        night: "air an oidhche"
    },
    wide: {
        am: "m.",
        pm: "f.",
        midnight: "meadhan oidhche",
        noon: "meadhan l",
        morning: "sa mhadainn",
        afternoon: "feasgar",
        evening: "feasgar",
        night: "air an oidhche"
    }
};
const ordinalNumber$S = (dirtyNumber) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number2 + "d";
            case 2:
                return number2 + "na";
        }
    }
    if (rem100 === 12) {
        return number2 + "na";
    }
    return number2 + "mh";
};
const localize$S = {
    ordinalNumber: ordinalNumber$S,
    era: buildLocalizeFn({
        values: eraValues$S,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$S,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$S,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$S,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$S,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$I,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$S = /^(\d+)(d|na|tr|mh)?/i;
const parseOrdinalNumberPattern$S = /\d+/i;
const matchEraPatterns$S = {
    narrow: /^(r|a)/i,
    abbreviated: /^(r\.?\s?c\.?|r\.?\s?a\.?\s?c\.?|a\.?\s?d\.?|a\.?\s?c\.?)/i,
    wide: /^(ro Chrosta|ron aois choitchinn|anno domini|aois choitcheann)/i
};
const parseEraPatterns$S = {
    any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$S = {
    narrow: /^[1234]/i,
    abbreviated: /^c[1234]/i,
    wide: /^[1234](cd|na|tr|mh)? cairteal/i
};
const parseQuarterPatterns$S = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$S = {
    narrow: /^[fgmcilsd]/i,
    abbreviated: /^(faoi|gear|mrt|gibl|cit|gmh|iuch|ln|sult|dmh|samh|dbh)/i,
    wide: /^(am faoilleach|an gearran|am mrt|an giblean|an citean|an t-gmhios|an t-Iuchar|an lnastal|an t-Sultain|an dmhair|an t-Samhain|an dbhlachd)/i
};
const parseMonthPatterns$S = {
    narrow: [
        /^f/i,
        /^g/i,
        /^m/i,
        /^g/i,
        /^c/i,
        /^/i,
        /^i/i,
        /^l/i,
        /^s/i,
        /^d/i,
        /^s/i,
        /^d/i
    ],
    any: [
        /^fa/i,
        /^ge/i,
        /^m/i,
        /^gi/i,
        /^c/i,
        /^/i,
        /^i/i,
        /^l/i,
        /^su/i,
        /^d/i,
        /^sa/i,
        /^d/i
    ]
};
const matchDayPatterns$S = {
    narrow: /^[dlmcahs]/i,
    short: /^(d|lu|m|ci|ar|ha|sa)/i,
    abbreviated: /^(did|dil|dim|dic|dia|dih|dis)/i,
    wide: /^(didmhnaich|diluain|dimirt|diciadain|diardaoin|dihaoine|disathairne)/i
};
const parseDayPatterns$S = {
    narrow: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i],
    any: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i]
};
const matchDayPeriodPatterns$S = {
    narrow: /^(a|p|mi|n|(san|aig) (madainn|feasgar|feasgar|oidhche))/i,
    any: /^([ap]\.?\s?m\.?|meadhan oidhche|meadhan l|(san|aig) (madainn|feasgar|feasgar|oidhche))/i
};
const parseDayPeriodPatterns$S = {
    any: {
        am: /^m/i,
        pm: /^f/i,
        midnight: /^meadhan oidhche/i,
        noon: /^meadhan l/i,
        morning: /sa mhadainn/i,
        afternoon: /feasgar/i,
        evening: /feasgar/i,
        night: /air an oidhche/i
    }
};
const match$S = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$S,
        parsePattern: parseOrdinalNumberPattern$S,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$S,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$S,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$S,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$S,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$S,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$S,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$S,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$S,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$S,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$S,
        defaultParseWidth: "any"
    })
};
const gd = {
    code: "gd",
    formatDistance: formatDistance$S,
    formatLong: formatLong$T,
    formatRelative: formatRelative$S,
    localize: localize$S,
    match: match$S,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$Q = {
    lessThanXSeconds: {
        one: "menos dun segundo",
        other: "menos de {{count}} segundos"
    },
    xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
    },
    halfAMinute: "medio minuto",
    lessThanXMinutes: {
        one: "menos dun minuto",
        other: "menos de {{count}} minutos"
    },
    xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
    },
    aboutXHours: {
        one: "arredor dunha hora",
        other: "arredor de {{count}} horas"
    },
    xHours: {
        one: "1 hora",
        other: "{{count}} horas"
    },
    xDays: {
        one: "1 da",
        other: "{{count}} das"
    },
    aboutXWeeks: {
        one: "arredor dunha semana",
        other: "arredor de {{count}} semanas"
    },
    xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
    },
    aboutXMonths: {
        one: "arredor de 1 mes",
        other: "arredor de {{count}} meses"
    },
    xMonths: {
        one: "1 mes",
        other: "{{count}} meses"
    },
    aboutXYears: {
        one: "arredor dun ano",
        other: "arredor de {{count}} anos"
    },
    xYears: {
        one: "1 ano",
        other: "{{count}} anos"
    },
    overXYears: {
        one: "mis dun ano",
        other: "mis de {{count}} anos"
    },
    almostXYears: {
        one: "case un ano",
        other: "case {{count}} anos"
    }
};
const formatDistance$R = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$Q[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "en " + result;
        }
        else {
            return "hai " + result;
        }
    }
    return result;
};
const dateFormats$S = {
    full: "EEEE, d 'de' MMMM y",
    long: "d 'de' MMMM y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$S = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$S = {
    full: "{{date}} 's' {{time}}",
    long: "{{date}} 's' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$S = {
    date: buildFormatLongFn({
        formats: dateFormats$S,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$S,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$S,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$R = {
    lastWeek: "'o' eeee 'pasado ' LT",
    yesterday: "'onte ' p",
    today: "'hoxe ' p",
    tomorrow: "'ma ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelativeLocalePlural = {
    lastWeek: "'o' eeee 'pasado s' p",
    yesterday: "'onte s' p",
    today: "'hoxe s' p",
    tomorrow: "'ma s' p",
    nextWeek: "eeee 's' p",
    other: "P"
};
const formatRelative$R = (token, date, _baseDate, _options) => {
    if (date.getHours() !== 1) {
        return formatRelativeLocalePlural[token];
    }
    return formatRelativeLocale$R[token];
};
const eraValues$R = {
    narrow: ["AC", "DC"],
    abbreviated: ["AC", "DC"],
    wide: ["antes de cristo", "despois de cristo"]
};
const quarterValues$R = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$R = {
    narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "xan",
        "feb",
        "mar",
        "abr",
        "mai",
        "xun",
        "xul",
        "ago",
        "set",
        "out",
        "nov",
        "dec"
    ],
    wide: [
        "xaneiro",
        "febreiro",
        "marzo",
        "abril",
        "maio",
        "xuo",
        "xullo",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "decembro"
    ]
};
const dayValues$R = {
    narrow: ["d", "l", "m", "m", "j", "v", "s"],
    short: ["do", "lu", "ma", "me", "xo", "ve", "sa"],
    abbreviated: ["dom", "lun", "mar", "mer", "xov", "ven", "sab"],
    wide: ["domingo", "luns", "martes", "mrcores", "xoves", "venres", "sbado"]
};
const dayPeriodValues$R = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "ma",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoite",
        noon: "medioda",
        morning: "ma",
        afternoon: "tarde",
        evening: "tardia",
        night: "noite"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoite",
        noon: "medioda",
        morning: "ma",
        afternoon: "tarde",
        evening: "tardia",
        night: "noite"
    }
};
const formattingDayPeriodValues$H = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "da ma",
        afternoon: "da tarde",
        evening: "da tardia",
        night: "da noite"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoite",
        noon: "medioda",
        morning: "da ma",
        afternoon: "da tarde",
        evening: "da tardia",
        night: "da noite"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoite",
        noon: "medioda",
        morning: "da ma",
        afternoon: "da tarde",
        evening: "da tardia",
        night: "da noite"
    }
};
const ordinalNumber$R = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "";
};
const localize$R = {
    ordinalNumber: ordinalNumber$R,
    era: buildLocalizeFn({
        values: eraValues$R,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$R,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$R,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$R,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$R,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$H,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$R = /^(\d+)()?/i;
const parseOrdinalNumberPattern$R = /\d+/i;
const matchEraPatterns$R = {
    narrow: /^(ac|dc|a|d)/i,
    abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
    wide: /^(antes de cristo|antes da era com[u]n|despois de cristo|era com[u]n)/i
};
const parseEraPatterns$R = {
    any: [/^ac/i, /^dc/i],
    wide: [
        /^(antes de cristo|antes da era com[u]n)/i,
        /^(despois de cristo|era com[u]n)/i
    ]
};
const matchQuarterPatterns$R = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$R = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$R = {
    narrow: /^[xfmasond]/i,
    abbreviated: /^(xan|feb|mar|abr|mai|xun|xul|ago|set|out|nov|dec)/i,
    wide: /^(xaneiro|febreiro|marzo|abril|maio|xuo|xullo|agosto|setembro|outubro|novembro|decembro)/i
};
const parseMonthPatterns$R = {
    narrow: [
        /^x/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^x/i,
        /^x/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^xan/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^mai/i,
        /^xun/i,
        /^xul/i,
        /^ago/i,
        /^set/i,
        /^out/i,
        /^nov/i,
        /^dec/i
    ]
};
const matchDayPatterns$R = {
    narrow: /^[dlmxvs]/i,
    short: /^(do|lu|ma|me|xo|ve|sa)/i,
    abbreviated: /^(dom|lun|mar|mer|xov|ven|sab)/i,
    wide: /^(domingo|luns|martes|m[e]rcores|xoves|venres|s[a]bado)/i
};
const parseDayPatterns$R = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^x/i, /^v/i, /^s/i],
    any: [/^do/i, /^lu/i, /^ma/i, /^me/i, /^xo/i, /^ve/i, /^sa/i]
};
const matchDayPeriodPatterns$R = {
    narrow: /^(a|p|mn|md|(da|[a]s) (ma[a]|tarde|noite))/i,
    any: /^([ap]\.?\s?m\.?|medianoite|mediod[i]a|(da|[a]s) (ma[a]|tarde|noite))/i
};
const parseDayPeriodPatterns$R = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn/i,
        noon: /^md/i,
        morning: /ma[a]/i,
        afternoon: /tarde/i,
        evening: /tardia/i,
        night: /noite/i
    }
};
const match$R = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$R,
        parsePattern: parseOrdinalNumberPattern$R,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$R,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$R,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$R,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$R,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$R,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$R,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$R,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$R,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$R,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$R,
        defaultParseWidth: "any"
    })
};
const gl = {
    code: "gl",
    formatDistance: formatDistance$R,
    formatLong: formatLong$S,
    formatRelative: formatRelative$R,
    localize: localize$R,
    match: match$R,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$P = {
    lessThanXSeconds: {
        one: "",
        // CLDR #1461
        other: " {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: " ",
        // CLDR #1448
        other: " {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "1  ",
        other: "{{count}}  "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$Q = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$P[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$R = {
    full: "EEEE, d MMMM, y",
    // CLDR #1825
    long: "d MMMM, y",
    // CLDR #1826
    medium: "d MMM, y",
    // CLDR #1827
    short: "d/M/yy"
    // CLDR #1828
};
const timeFormats$R = {
    full: "hh:mm:ss a zzzz",
    // CLDR #1829
    long: "hh:mm:ss a z",
    // CLDR #1830
    medium: "hh:mm:ss a",
    // CLDR #1831
    short: "hh:mm a"
    // CLDR #1832
};
const dateTimeFormats$R = {
    full: "{{date}} {{time}}",
    // CLDR #1833
    long: "{{date}} {{time}}",
    // CLDR #1834
    medium: "{{date}} {{time}}",
    // CLDR #1835
    short: "{{date}} {{time}}"
    // CLDR #1836
};
const formatLong$R = {
    date: buildFormatLongFn({
        formats: dateFormats$R,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$R,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$R,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$Q = {
    lastWeek: "'' eeee p",
    // CLDR #1384
    yesterday: "'' p",
    // CLDR #1409
    today: "'' p",
    // CLDR #1410
    tomorrow: "'' p",
    // CLDR #1411
    nextWeek: "eeee p",
    // CLDR #1386
    other: "P"
};
const formatRelative$Q = (token, _date, _baseDate, _options) => formatRelativeLocale$Q[token];
const eraValues$Q = {
    narrow: ["", ""],
    abbreviated: ["..", ".."],
    wide: [" ", ""]
};
const quarterValues$Q = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$Q = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$Q = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$Q = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$G = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: ".",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$Q = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$Q = {
    ordinalNumber: ordinalNumber$Q,
    era: buildLocalizeFn({
        values: eraValues$Q,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$Q,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$Q,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$Q,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$Q,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$G,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$Q = /^(\d+)(||||)?/i;
const parseOrdinalNumberPattern$Q = /\d+/i;
const matchEraPatterns$Q = {
    narrow: /^(|)/i,
    abbreviated: /^(\.\.|\.\.)/i,
    wide: /^(\s|)/i
};
const parseEraPatterns$Q = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$Q = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](||)? /i
};
const parseQuarterPatterns$Q = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$Q = {
    // eslint-disable-next-line no-misleading-character-class
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$Q = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$Q = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$Q = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$Q = {
    narrow: /^(a|p|\.?||||)/i,
    any: /^(a|p|\.?||||)/i
};
const parseDayPeriodPatterns$Q = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^\.?/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$Q = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$Q,
        parsePattern: parseOrdinalNumberPattern$Q,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$Q,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$Q,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$Q,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$Q,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$Q,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$Q,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$Q,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$Q,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$Q,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$Q,
        defaultParseWidth: "any"
    })
};
const gu = {
    code: "gu",
    formatDistance: formatDistance$Q,
    formatLong: formatLong$R,
    formatRelative: formatRelative$Q,
    localize: localize$Q,
    match: match$Q,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$O = {
    lessThanXSeconds: {
        one: " ",
        two: "  ",
        other: " {{count}} "
    },
    xSeconds: {
        one: "",
        two: " ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: " ",
        two: "  ",
        other: " {{count}} "
    },
    xMinutes: {
        one: "",
        two: " ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    xHours: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    xDays: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    xWeeks: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    xMonths: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    xYears: {
        one: "",
        two: "",
        other: "{{count}} "
    },
    overXYears: {
        one: " ",
        two: " ",
        other: " {{count}} "
    },
    almostXYears: {
        one: " ",
        two: " ",
        other: " {{count}} "
    }
};
const formatDistance$P = (token, count, options2) => {
    if (token === "xDays" && options2?.addSuffix && count <= 2) {
        if (options2.comparison && options2.comparison > 0) {
            return count === 1 ? "" : "";
        }
        return count === 1 ? "" : "";
    }
    let result;
    const tokenValue = formatDistanceLocale$O[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 2) {
        result = tokenValue.two;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$Q = {
    full: "EEEE, d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "d.M.y"
};
const timeFormats$Q = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$Q = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$Q = {
    date: buildFormatLongFn({
        formats: dateFormats$Q,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$Q,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$Q,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$P = {
    lastWeek: "eeee ' ' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$P = (token, _date, _baseDate, _options) => formatRelativeLocale$P[token];
const eraValues$P = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: [" ", ""]
};
const quarterValues$P = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: [" 1", " 2", " 3", " 4"]
};
const monthValues$P = {
    narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$P = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        ""
    ],
    wide: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
    ]
};
const dayPeriodValues$P = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$F = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const ordinalNumber$P = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    if (number2 <= 0 || number2 > 10)
        return String(number2);
    const unit = String(options2?.unit);
    const isFemale = ["year", "hour", "minute", "second"].indexOf(unit) >= 0;
    const male = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ];
    const female = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ];
    const index = number2 - 1;
    return isFemale ? female[index] : male[index];
};
const localize$P = {
    ordinalNumber: ordinalNumber$P,
    era: buildLocalizeFn({
        values: eraValues$P,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$P,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$P,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$P,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$P,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$F,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$P = /^(\d+|(|||||||||||||||||||))/i;
const parseOrdinalNumberPattern$P = /^(\d+||||||||||)/i;
const matchEraPatterns$P = {
    narrow: /^(|)/i,
    abbreviated: /^(|)/i,
    wide: /^( )?/i
};
const parseEraPatterns$P = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$P = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^ [1234]/i
};
const parseQuarterPatterns$P = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$P = {
    narrow: /^\d+/i,
    abbreviated: /^(|||||||||||)?/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$P = {
    narrow: [
        /^1$/i,
        /^2/i,
        /^3/i,
        /^4/i,
        /^5/i,
        /^6/i,
        /^7/i,
        /^8/i,
        /^9/i,
        /^10/i,
        /^11/i,
        /^12/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$P = {
    narrow: /^[]/i,
    short: /^[]/i,
    abbreviated: /^(| (|||||))/i,
    wide: /^ (||||||)/i
};
const parseDayPatterns$P = {
    abbreviated: [/$/i, /$/i, /$/i, /$/i, /$/i, /$/i, /^/i],
    wide: [/$/i, /$/i, /$/i, /$/i, /$/i, /$/i, /$/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$P = {
    any: /^( |)?(||||||)/i
};
const parseDayPeriodPatterns$P = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: /|/i,
        evening: //i,
        night: //i
    }
};
const ordinalName = ["", "", "", "", "", "", "", "", "", ""];
const match$P = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$P,
        parsePattern: parseOrdinalNumberPattern$P,
        valueCallback: (value) => {
            const number2 = parseInt(value, 10);
            return isNaN(number2) ? ordinalName.indexOf(value) + 1 : number2;
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$P,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$P,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$P,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$P,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$P,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$P,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$P,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$P,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$P,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$P,
        defaultParseWidth: "any"
    })
};
const he = {
    code: "he",
    formatDistance: formatDistance$P,
    formatLong: formatLong$Q,
    formatRelative: formatRelative$P,
    localize: localize$P,
    match: match$P,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const numberValues = {
    locale: {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    },
    number: {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    }
};
const eraValues$O = {
    narrow: ["-", ""],
    abbreviated: ["-", ""],
    wide: ["-", " "]
};
const quarterValues$O = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$O = {
    narrow: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$O = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$O = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$E = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$O = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return numberToLocale(number2);
};
function localeToNumber(locale) {
    const enNumber = locale.toString().replace(/[]/g, function (match2) {
        return numberValues.number[match2];
    });
    return Number(enNumber);
}
function numberToLocale(enNumber) {
    return enNumber.toString().replace(/\d/g, function (match2) {
        return numberValues.locale[match2];
    });
}
const localize$O = {
    ordinalNumber: ordinalNumber$O,
    era: buildLocalizeFn({
        values: eraValues$O,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$O,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$O,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$O,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$O,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$E,
        defaultFormattingWidth: "wide"
    })
};
const formatDistanceLocale$N = {
    lessThanXSeconds: {
        one: "   ",
        // CLDR #1310
        other: "{{count}}   "
    },
    xSeconds: {
        one: " ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "   ",
        other: "{{count}}   "
    },
    xMinutes: {
        one: " ",
        // CLDR #1307
        other: "{{count}} "
    },
    aboutXHours: {
        one: "  ",
        other: " {{count}} "
    },
    xHours: {
        one: " ",
        // CLDR #1304
        other: "{{count}} "
        // CLDR #4467
    },
    xDays: {
        one: " ",
        // CLDR #1286
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: "  ",
        other: " {{count}} "
    },
    xWeeks: {
        one: " ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: "  ",
        other: " {{count}} "
    },
    xMonths: {
        one: " ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: "  ",
        other: " {{count}} "
        // CLDR #4823
    },
    xYears: {
        one: " ",
        other: "{{count}} "
    },
    overXYears: {
        one: "   ",
        other: "{{count}}   "
    },
    almostXYears: {
        one: "  ",
        other: " {{count}} "
    }
};
const formatDistance$O = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$N[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", numberToLocale(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " ";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$P = {
    full: "EEEE, do MMMM, y",
    // CLDR #1787
    long: "do MMMM, y",
    // CLDR #1788
    medium: "d MMM, y",
    // CLDR #1789
    short: "dd/MM/yyyy"
    // CLDR #1790
};
const timeFormats$P = {
    full: "h:mm:ss a zzzz",
    // CLDR #1791
    long: "h:mm:ss a z",
    // CLDR #1792
    medium: "h:mm:ss a",
    // CLDR #1793
    short: "h:mm a"
    // CLDR #1794
};
const dateTimeFormats$P = {
    full: "{{date}} '' {{time}}",
    // CLDR #1795
    long: "{{date}} '' {{time}}",
    // CLDR #1796
    medium: "{{date}}, {{time}}",
    // CLDR #1797
    short: "{{date}}, {{time}}"
    // CLDR #1798
};
const formatLong$P = {
    date: buildFormatLongFn({
        formats: dateFormats$P,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$P,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$P,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$O = {
    lastWeek: "'' eeee p",
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$O = (token, _date, _baseDate, _options) => formatRelativeLocale$O[token];
const matchOrdinalNumberPattern$O = /^[]+/i;
const parseOrdinalNumberPattern$O = /^[]+/i;
const matchEraPatterns$O = {
    narrow: /^(-|)/i,
    abbreviated: /^(\.?\s?\.?|\.?)/i,
    wide: /^(-| | |)/i
};
const parseEraPatterns$O = {
    any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$O = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^[1234](|||)? /i
};
const parseQuarterPatterns$O = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$O = {
    // eslint-disable-next-line no-misleading-character-class
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$O = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$O = {
    // eslint-disable-next-line no-misleading-character-class
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$O = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$O = {
    narrow: /^(|||.\?||||)/i,
    any: /^(|||.\?||||)/i
};
const parseDayPeriodPatterns$O = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$O = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$O,
        parsePattern: parseOrdinalNumberPattern$O,
        valueCallback: localeToNumber
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$O,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$O,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$O,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$O,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$O,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$O,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$O,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$O,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$O,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$O,
        defaultParseWidth: "any"
    })
};
const hi = {
    code: "hi",
    formatDistance: formatDistance$O,
    formatLong: formatLong$P,
    formatRelative: formatRelative$O,
    localize: localize$O,
    match: match$O,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$M = {
    lessThanXSeconds: {
        one: {
            standalone: "manje od 1 sekunde",
            withPrepositionAgo: "manje od 1 sekunde",
            withPrepositionIn: "manje od 1 sekundu"
        },
        dual: "manje od {{count}} sekunde",
        other: "manje od {{count}} sekundi"
    },
    xSeconds: {
        one: {
            standalone: "1 sekunda",
            withPrepositionAgo: "1 sekunde",
            withPrepositionIn: "1 sekundu"
        },
        dual: "{{count}} sekunde",
        other: "{{count}} sekundi"
    },
    halfAMinute: "pola minute",
    lessThanXMinutes: {
        one: {
            standalone: "manje od 1 minute",
            withPrepositionAgo: "manje od 1 minute",
            withPrepositionIn: "manje od 1 minutu"
        },
        dual: "manje od {{count}} minute",
        other: "manje od {{count}} minuta"
    },
    xMinutes: {
        one: {
            standalone: "1 minuta",
            withPrepositionAgo: "1 minute",
            withPrepositionIn: "1 minutu"
        },
        dual: "{{count}} minute",
        other: "{{count}} minuta"
    },
    aboutXHours: {
        one: {
            standalone: "oko 1 sat",
            withPrepositionAgo: "oko 1 sat",
            withPrepositionIn: "oko 1 sat"
        },
        dual: "oko {{count}} sata",
        other: "oko {{count}} sati"
    },
    xHours: {
        one: {
            standalone: "1 sat",
            withPrepositionAgo: "1 sat",
            withPrepositionIn: "1 sat"
        },
        dual: "{{count}} sata",
        other: "{{count}} sati"
    },
    xDays: {
        one: {
            standalone: "1 dan",
            withPrepositionAgo: "1 dan",
            withPrepositionIn: "1 dan"
        },
        dual: "{{count}} dana",
        other: "{{count}} dana"
    },
    aboutXWeeks: {
        one: {
            standalone: "oko 1 tjedan",
            withPrepositionAgo: "oko 1 tjedan",
            withPrepositionIn: "oko 1 tjedan"
        },
        dual: "oko {{count}} tjedna",
        other: "oko {{count}} tjedana"
    },
    xWeeks: {
        one: {
            standalone: "1 tjedan",
            withPrepositionAgo: "1 tjedan",
            withPrepositionIn: "1 tjedan"
        },
        dual: "{{count}} tjedna",
        other: "{{count}} tjedana"
    },
    aboutXMonths: {
        one: {
            standalone: "oko 1 mjesec",
            withPrepositionAgo: "oko 1 mjesec",
            withPrepositionIn: "oko 1 mjesec"
        },
        dual: "oko {{count}} mjeseca",
        other: "oko {{count}} mjeseci"
    },
    xMonths: {
        one: {
            standalone: "1 mjesec",
            withPrepositionAgo: "1 mjesec",
            withPrepositionIn: "1 mjesec"
        },
        dual: "{{count}} mjeseca",
        other: "{{count}} mjeseci"
    },
    aboutXYears: {
        one: {
            standalone: "oko 1 godinu",
            withPrepositionAgo: "oko 1 godinu",
            withPrepositionIn: "oko 1 godinu"
        },
        dual: "oko {{count}} godine",
        other: "oko {{count}} godina"
    },
    xYears: {
        one: {
            standalone: "1 godina",
            withPrepositionAgo: "1 godine",
            withPrepositionIn: "1 godinu"
        },
        dual: "{{count}} godine",
        other: "{{count}} godina"
    },
    overXYears: {
        one: {
            standalone: "preko 1 godinu",
            withPrepositionAgo: "preko 1 godinu",
            withPrepositionIn: "preko 1 godinu"
        },
        dual: "preko {{count}} godine",
        other: "preko {{count}} godina"
    },
    almostXYears: {
        one: {
            standalone: "gotovo 1 godinu",
            withPrepositionAgo: "gotovo 1 godinu",
            withPrepositionIn: "gotovo 1 godinu"
        },
        dual: "gotovo {{count}} godine",
        other: "gotovo {{count}} godina"
    }
};
const formatDistance$N = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$M[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                result = tokenValue.one.withPrepositionIn;
            }
            else {
                result = tokenValue.one.withPrepositionAgo;
            }
        }
        else {
            result = tokenValue.one.standalone;
        }
    }
    else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
        String(count).substr(-2, 1) !== "1") {
        result = tokenValue.dual.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "za " + result;
        }
        else {
            return "prije " + result;
        }
    }
    return result;
};
const dateFormats$O = {
    full: "EEEE, d. MMMM y.",
    long: "d. MMMM y.",
    medium: "d. MMM y.",
    short: "dd. MM. y."
};
const timeFormats$O = {
    full: "HH:mm:ss (zzzz)",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$O = {
    full: "{{date}} 'u' {{time}}",
    long: "{{date}} 'u' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$O = {
    date: buildFormatLongFn({
        formats: dateFormats$O,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$O,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$O,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$N = {
    lastWeek: (date) => {
        switch (date.getDay()) {
            case 0:
                return "'prolu nedjelju u' p";
            case 3:
                return "'prolu srijedu u' p";
            case 6:
                return "'prolu subotu u' p";
            default:
                return "'proli' EEEE 'u' p";
        }
    },
    yesterday: "'juer u' p",
    today: "'danas u' p",
    tomorrow: "'sutra u' p",
    nextWeek: (date) => {
        switch (date.getDay()) {
            case 0:
                return "'iduu nedjelju u' p";
            case 3:
                return "'iduu srijedu u' p";
            case 6:
                return "'iduu subotu u' p";
            default:
                return "'proli' EEEE 'u' p";
        }
    },
    other: "P"
};
const formatRelative$N = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$N[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$N = {
    narrow: ["pr.n.e.", "AD"],
    abbreviated: ["pr. Kr.", "po. Kr."],
    wide: ["Prije Krista", "Poslije Krista"]
};
const quarterValues$N = {
    narrow: ["1.", "2.", "3.", "4."],
    abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$N = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "sij",
        "velj",
        "ou",
        "tra",
        "svi",
        "lip",
        "srp",
        "kol",
        "ruj",
        "lis",
        "stu",
        "pro"
    ],
    wide: [
        "sijeanj",
        "veljaa",
        "oujak",
        "travanj",
        "svibanj",
        "lipanj",
        "srpanj",
        "kolovoz",
        "rujan",
        "listopad",
        "studeni",
        "prosinac"
    ]
};
const formattingMonthValues$a = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "sij",
        "velj",
        "ou",
        "tra",
        "svi",
        "lip",
        "srp",
        "kol",
        "ruj",
        "lis",
        "stu",
        "pro"
    ],
    wide: [
        "sijenja",
        "veljae",
        "oujka",
        "travnja",
        "svibnja",
        "lipnja",
        "srpnja",
        "kolovoza",
        "rujna",
        "listopada",
        "studenog",
        "prosinca"
    ]
};
const dayValues$N = {
    narrow: ["N", "P", "U", "S", "", "P", "S"],
    short: ["ned", "pon", "uto", "sri", "et", "pet", "sub"],
    abbreviated: ["ned", "pon", "uto", "sri", "et", "pet", "sub"],
    wide: [
        "nedjelja",
        "ponedjeljak",
        "utorak",
        "srijeda",
        "etvrtak",
        "petak",
        "subota"
    ]
};
const formattingDayPeriodValues$D = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutro",
        afternoon: "popodne",
        evening: "naveer",
        night: "nou"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutro",
        afternoon: "popodne",
        evening: "naveer",
        night: "nou"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutro",
        afternoon: "poslije podne",
        evening: "naveer",
        night: "nou"
    }
};
const dayPeriodValues$N = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutro",
        afternoon: "popodne",
        evening: "naveer",
        night: "nou"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutro",
        afternoon: "popodne",
        evening: "naveer",
        night: "nou"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutro",
        afternoon: "poslije podne",
        evening: "naveer",
        night: "nou"
    }
};
const ordinalNumber$N = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$N = {
    ordinalNumber: ordinalNumber$N,
    era: buildLocalizeFn({
        values: eraValues$N,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$N,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$N,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$a,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$N,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$N,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$D,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$N = /^(\d+)\./i;
const parseOrdinalNumberPattern$N = /\d+/i;
const matchEraPatterns$N = {
    narrow: /^(pr\.n\.e\.|AD)/i,
    abbreviated: /^(pr\.\s?Kr\.|po\.\s?Kr\.)/i,
    wide: /^(Prije Krista|prije nove ere|Poslije Krista|nova era)/i
};
const parseEraPatterns$N = {
    any: [/^pr/i, /^(po|nova)/i]
};
const matchQuarterPatterns$N = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]\.\s?kv\.?/i,
    wide: /^[1234]\. kvartal/i
};
const parseQuarterPatterns$N = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$N = {
    narrow: /^(10|11|12|[123456789])\./i,
    abbreviated: /^(sij|velj|(ou|ozu)|tra|svi|lip|srp|kol|ruj|lis|stu|pro)/i,
    wide: /^((sijeanj|sijenja|sijecanj|sijecnja)|(veljaa|veljae|veljaca|veljace)|(oujak|oujka|ozujak|ozujka)|(travanj|travnja)|(svibanj|svibnja)|(lipanj|lipnja)|(srpanj|srpnja)|(kolovoz|kolovoza)|(rujan|rujna)|(listopad|listopada)|(studeni|studenog)|(prosinac|prosinca))/i
};
const parseMonthPatterns$N = {
    narrow: [
        /1/i,
        /2/i,
        /3/i,
        /4/i,
        /5/i,
        /6/i,
        /7/i,
        /8/i,
        /9/i,
        /10/i,
        /11/i,
        /12/i
    ],
    abbreviated: [
        /^sij/i,
        /^velj/i,
        /^(ou|ozu)/i,
        /^tra/i,
        /^svi/i,
        /^lip/i,
        /^srp/i,
        /^kol/i,
        /^ruj/i,
        /^lis/i,
        /^stu/i,
        /^pro/i
    ],
    wide: [
        /^sij/i,
        /^velj/i,
        /^(ou|ozu)/i,
        /^tra/i,
        /^svi/i,
        /^lip/i,
        /^srp/i,
        /^kol/i,
        /^ruj/i,
        /^lis/i,
        /^stu/i,
        /^pro/i
    ]
};
const matchDayPatterns$N = {
    narrow: /^[npusc]/i,
    short: /^(ned|pon|uto|sri|(et|cet)|pet|sub)/i,
    abbreviated: /^(ned|pon|uto|sri|(et|cet)|pet|sub)/i,
    wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(etvrtak|cetvrtak)|petak|subota)/i
};
const parseDayPatterns$N = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$N = {
    any: /^(am|pm|ponoc|pono|(po)?podne|navecer|naveer|nou|poslije podne|ujutro)/i
};
const parseDayPeriodPatterns$N = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^pono/i,
        noon: /^pod/i,
        morning: /jutro/i,
        afternoon: /(poslije\s|po)+podne/i,
        evening: /(navece|navee)/i,
        night: /(nocu|nou)/i
    }
};
const match$N = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$N,
        parsePattern: parseOrdinalNumberPattern$N,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$N,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$N,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$N,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$N,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$N,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$N,
        defaultParseWidth: "wide"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$N,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$N,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$N,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$N,
        defaultParseWidth: "any"
    })
};
const hr = {
    code: "hr",
    formatDistance: formatDistance$N,
    formatLong: formatLong$O,
    formatRelative: formatRelative$N,
    localize: localize$N,
    match: match$N,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$L = {
    lessThanXSeconds: {
        one: "mwens pase yon segond",
        other: "mwens pase {{count}} segond"
    },
    xSeconds: {
        one: "1 segond",
        other: "{{count}} segond"
    },
    halfAMinute: "30 segond",
    lessThanXMinutes: {
        one: "mwens pase yon minit",
        other: "mwens pase {{count}} minit"
    },
    xMinutes: {
        one: "1 minit",
        other: "{{count}} minit"
    },
    aboutXHours: {
        one: "anviwon in",
        other: "anviwon {{count}} "
    },
    xHours: {
        one: "1 l",
        other: "{{count}} l"
    },
    xDays: {
        one: "1 jou",
        other: "{{count}} jou"
    },
    aboutXWeeks: {
        one: "anviwon 1 semn",
        other: "anviwon {{count}} semn"
    },
    xWeeks: {
        one: "1 semn",
        other: "{{count}} semn"
    },
    aboutXMonths: {
        one: "anviwon 1 mwa",
        other: "anviwon {{count}} mwa"
    },
    xMonths: {
        one: "1 mwa",
        other: "{{count}} mwa"
    },
    aboutXYears: {
        one: "anviwon 1 an",
        other: "anviwon {{count}} an"
    },
    xYears: {
        one: "1 an",
        other: "{{count}} an"
    },
    overXYears: {
        one: "plis pase 1 an",
        other: "plis pase {{count}} an"
    },
    almostXYears: {
        one: "prske 1 an",
        other: "prske {{count}} an"
    }
};
const formatDistance$M = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$L[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "nan " + result;
        }
        else {
            return "sa f " + result;
        }
    }
    return result;
};
const dateFormats$N = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$N = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$N = {
    full: "{{date}} 'nan l' {{time}}",
    long: "{{date}} 'nan l' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$N = {
    date: buildFormatLongFn({
        formats: dateFormats$N,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$N,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$N,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$M = {
    lastWeek: "eeee 'pase nan l' p",
    yesterday: "'y nan l' p",
    today: "'jodi a' p",
    tomorrow: "'demen nan l' p'",
    nextWeek: "eeee 'pwochen nan l' p",
    other: "P"
};
const formatRelative$M = (token, _date, _baseDate, _options) => formatRelativeLocale$M[token];
const eraValues$M = {
    narrow: ["av. J.-K", "ap. J.-K"],
    abbreviated: ["av. J.-K", "ap. J.-K"],
    wide: ["anvan Jezi Kris", "apre Jezi Kris"]
};
const quarterValues$M = {
    narrow: ["T1", "T2", "T3", "T4"],
    abbreviated: ["1ye trim.", "2ym trim.", "3ym trim.", "4ym trim."],
    wide: ["1ye trims", "2ym trims", "3ym trims", "4ym trims"]
};
const monthValues$M = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
    abbreviated: [
        "janv.",
        "fevr.",
        "mas",
        "avr.",
        "me",
        "jen",
        "jiy",
        "out",
        "sept.",
        "okt.",
        "nov.",
        "des."
    ],
    wide: [
        "janvye",
        "fevrye",
        "mas",
        "avril",
        "me",
        "jen",
        "jiy",
        "out",
        "septanm",
        "oktb",
        "novanm",
        "desanm"
    ]
};
const dayValues$M = {
    narrow: ["D", "L", "M", "M", "J", "V", "S"],
    short: ["di", "le", "ma", "m", "je", "va", "sa"],
    abbreviated: ["dim.", "len.", "mad.", "mk.", "jed.", "van.", "sam."],
    wide: ["dimanch", "lendi", "madi", "mkredi", "jedi", "vandredi", "samdi"]
};
const dayPeriodValues$M = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "minwit",
        noon: "midi",
        morning: "mat.",
        afternoon: "ap.m.",
        evening: "swa",
        night: "mat."
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "minwit",
        noon: "midi",
        morning: "maten",
        afternoon: "aprmidi",
        evening: "swa",
        night: "maten"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "minwit",
        noon: "midi",
        morning: "nan maten",
        afternoon: "nan aprmidi",
        evening: "nan asw",
        night: "nan maten"
    }
};
const ordinalNumber$M = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    if (number2 === 0)
        return String(number2);
    const suffix = number2 === 1 ? "ye" : "ym";
    return number2 + suffix;
};
const localize$M = {
    ordinalNumber: ordinalNumber$M,
    era: buildLocalizeFn({
        values: eraValues$M,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$M,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$M,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$M,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$M,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$M = /^(\d+)(ye|ym)?/i;
const parseOrdinalNumberPattern$M = /\d+/i;
const matchEraPatterns$M = {
    narrow: /^(av\.J\.K|ap\.J\.K|ap\.J\.-K)/i,
    abbreviated: /^(av\.J\.-K|av\.J-K|apr\.J\.-K|apr\.J-K|ap\.J-K)/i,
    wide: /^(avan Jezi Kris|apre Jezi Kris)/i
};
const parseEraPatterns$M = {
    any: [/^av/i, /^ap/i]
};
const matchQuarterPatterns$M = {
    narrow: /^[1234]/i,
    abbreviated: /^t[1234]/i,
    wide: /^[1234](ye|ym)? trims/i
};
const parseQuarterPatterns$M = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$M = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(janv|fevr|mas|avr|me|jen|jiy|out|sept|okt|nov|des)\.?/i,
    wide: /^(janvye|fevrye|mas|avril|me|jen|jiy|out|septanm|oktb|novanm|desanm)/i
};
const parseMonthPatterns$M = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^o/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^ma/i,
        /^av/i,
        /^me/i,
        /^je/i,
        /^ji/i,
        /^ou/i,
        /^s/i,
        /^ok/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$M = {
    narrow: /^[lmjvsd]/i,
    short: /^(di|le|ma|me|je|va|sa)/i,
    abbreviated: /^(dim|len|mad|mk|jed|van|sam)\.?/i,
    wide: /^(dimanch|lendi|madi|mkredi|jedi|vandredi|samdi)/i
};
const parseDayPatterns$M = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
    any: [/^di/i, /^le/i, /^ma/i, /^m/i, /^je/i, /^va/i, /^sa/i]
};
const matchDayPeriodPatterns$M = {
    narrow: /^(a|p|minwit|midi|mat\.?|ap\.?m\.?|swa)/i,
    any: /^([ap]\.?\s?m\.?|nan maten|nan aprmidi|nan asw)/i
};
const parseDayPeriodPatterns$M = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^min/i,
        noon: /^mid/i,
        morning: /mat/i,
        afternoon: /ap/i,
        evening: /sw/i,
        night: /nwit/i
    }
};
const match$M = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$M,
        parsePattern: parseOrdinalNumberPattern$M,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$M,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$M,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$M,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$M,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$M,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$M,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$M,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$M,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$M,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$M,
        defaultParseWidth: "any"
    })
};
const ht = {
    code: "ht",
    formatDistance: formatDistance$M,
    formatLong: formatLong$N,
    formatRelative: formatRelative$M,
    localize: localize$M,
    match: match$M,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const translations$1 = {
    about: "krlbell",
    over: "tbb mint",
    almost: "majdnem",
    lessthan: "kevesebb mint"
};
const withoutSuffixes = {
    xseconds: " msodperc",
    halfaminute: "fl perc",
    xminutes: " perc",
    xhours: " ra",
    xdays: " nap",
    xweeks: " ht",
    xmonths: " hnap",
    xyears: " v"
};
const withSuffixes = {
    xseconds: {
        "-1": " msodperccel ezeltt",
        1: " msodperc mlva",
        0: " msodperce"
    },
    halfaminute: {
        "-1": "fl perccel ezeltt",
        1: "fl perc mlva",
        0: "fl perce"
    },
    xminutes: {
        "-1": " perccel ezeltt",
        1: " perc mlva",
        0: " perce"
    },
    xhours: {
        "-1": " rval ezeltt",
        1: " ra mlva",
        0: " rja"
    },
    xdays: {
        "-1": " nappal ezeltt",
        1: " nap mlva",
        0: " napja"
    },
    xweeks: {
        "-1": " httel ezeltt",
        1: " ht mlva",
        0: " hete"
    },
    xmonths: {
        "-1": " hnappal ezeltt",
        1: " hnap mlva",
        0: " hnapja"
    },
    xyears: {
        "-1": " vvel ezeltt",
        1: " v mlva",
        0: " ve"
    }
};
const formatDistance$L = (token, count, options2) => {
    const adverb = token.match(/about|over|almost|lessthan/i);
    const unit = adverb ? token.replace(adverb[0], "") : token;
    const addSuffix = options2?.addSuffix === true;
    const key = unit.toLowerCase();
    const comparison = options2?.comparison || 0;
    const translated = addSuffix ? withSuffixes[key][comparison] : withoutSuffixes[key];
    let result = key === "halfaminute" ? translated : count + translated;
    if (adverb) {
        const adv = adverb[0].toLowerCase();
        result = translations$1[adv] + " " + result;
    }
    return result;
};
const dateFormats$M = {
    full: "y. MMMM d., EEEE",
    long: "y. MMMM d.",
    medium: "y. MMM d.",
    short: "y. MM. dd."
};
const timeFormats$M = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$M = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$M = {
    date: buildFormatLongFn({
        formats: dateFormats$M,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$M,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$M,
        defaultWidth: "full"
    })
};
const accusativeWeekdays$4 = [
    "vasrnap",
    "htfn",
    "kedden",
    "szerdn",
    "cstrtkn",
    "pnteken",
    "szombaton"
];
function week(isFuture) {
    return (date) => {
        const weekday = accusativeWeekdays$4[date.getDay()];
        const prefix = isFuture ? "" : "'mlt' ";
        return `${prefix}'${weekday}' p'-kor'`;
    };
}
const formatRelativeLocale$L = {
    lastWeek: week(false),
    yesterday: "'tegnap' p'-kor'",
    today: "'ma' p'-kor'",
    tomorrow: "'holnap' p'-kor'",
    nextWeek: week(true),
    other: "P"
};
const formatRelative$L = (token, date) => {
    const format2 = formatRelativeLocale$L[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$L = {
    narrow: ["ie.", "isz."],
    abbreviated: ["i. e.", "i. sz."],
    wide: ["Krisztus eltt", "idszmtsunk szerint"]
};
const quarterValues$L = {
    narrow: ["1.", "2.", "3.", "4."],
    abbreviated: ["1. n.v", "2. n.v", "3. n.v", "4. n.v"],
    wide: ["1. negyedv", "2. negyedv", "3. negyedv", "4. negyedv"]
};
const formattingQuarterValues$3 = {
    narrow: ["I.", "II.", "III.", "IV."],
    abbreviated: ["I. n.v", "II. n.v", "III. n.v", "IV. n.v"],
    wide: ["I. negyedv", "II. negyedv", "III. negyedv", "IV. negyedv"]
};
const monthValues$L = {
    narrow: ["J", "F", "M", "", "M", "J", "J", "A", "Sz", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "febr.",
        "mrc.",
        "pr.",
        "mj.",
        "jn.",
        "jl.",
        "aug.",
        "szept.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "janur",
        "februr",
        "mrcius",
        "prilis",
        "mjus",
        "jnius",
        "jlius",
        "augusztus",
        "szeptember",
        "oktber",
        "november",
        "december"
    ]
};
const dayValues$L = {
    narrow: ["V", "H", "K", "Sz", "Cs", "P", "Sz"],
    short: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
    abbreviated: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
    wide: [
        "vasrnap",
        "htf",
        "kedd",
        "szerda",
        "cstrtk",
        "pntek",
        "szombat"
    ]
};
const dayPeriodValues$L = {
    narrow: {
        am: "de.",
        pm: "du.",
        midnight: "jfl",
        noon: "dl",
        morning: "reggel",
        afternoon: "du.",
        evening: "este",
        night: "jjel"
    },
    abbreviated: {
        am: "de.",
        pm: "du.",
        midnight: "jfl",
        noon: "dl",
        morning: "reggel",
        afternoon: "du.",
        evening: "este",
        night: "jjel"
    },
    wide: {
        am: "de.",
        pm: "du.",
        midnight: "jfl",
        noon: "dl",
        morning: "reggel",
        afternoon: "dlutn",
        evening: "este",
        night: "jjel"
    }
};
const ordinalNumber$L = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$L = {
    ordinalNumber: ordinalNumber$L,
    era: buildLocalizeFn({
        values: eraValues$L,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$L,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1,
        formattingValues: formattingQuarterValues$3,
        defaultFormattingWidth: "wide"
    }),
    month: buildLocalizeFn({
        values: monthValues$L,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$L,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$L,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$L = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$L = /\d+/i;
const matchEraPatterns$L = {
    narrow: /^(ie\.|isz\.)/i,
    abbreviated: /^(i\.\s?e\.?|b?\s?c\s?e|i\.\s?sz\.?)/i,
    wide: /^(Krisztus eltt|idszmtsunk eltt|idszmtsunk szerint|i\. sz\.)/i
};
const parseEraPatterns$L = {
    narrow: [/ie/i, /isz/i],
    abbreviated: [/^(i\.?\s?e\.?|b\s?ce)/i, /^(i\.?\s?sz\.?|c\s?e)/i],
    any: [/eltt/i, /(szerint|i. sz.)/i]
};
const matchQuarterPatterns$L = {
    narrow: /^[1234]\.?/i,
    abbreviated: /^[1234]?\.?\s?n\.v/i,
    wide: /^([1234]|I|II|III|IV)?\.?\s?negyedv/i
};
const parseQuarterPatterns$L = {
    any: [/1|I$/i, /2|II$/i, /3|III/i, /4|IV/i]
};
const matchMonthPatterns$L = {
    narrow: /^[jfmasond]|sz/i,
    abbreviated: /^(jan\.?|febr\.?|mrc\.?|pr\.?|mj\.?|jn\.?|jl\.?|aug\.?|szept\.?|okt\.?|nov\.?|dec\.?)/i,
    wide: /^(janur|februr|mrcius|prilis|mjus|jnius|jlius|augusztus|szeptember|oktber|november|december)/i
};
const parseMonthPatterns$L = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a|/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s|sz/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mr/i,
        /^p/i,
        /^mj/i,
        /^jn/i,
        /^jl/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$L = {
    narrow: /^([vhkpc]|sz|cs|sz)/i,
    short: /^([vhkp]|sze|cs|szo)/i,
    abbreviated: /^([vhkp]|sze|cs|szo)/i,
    wide: /^(vasrnap|htf|kedd|szerda|cstrtk|pntek|szombat)/i
};
const parseDayPatterns$L = {
    narrow: [/^v/i, /^h/i, /^k/i, /^sz/i, /^c/i, /^p/i, /^sz/i],
    any: [/^v/i, /^h/i, /^k/i, /^sze/i, /^c/i, /^p/i, /^szo/i]
};
const matchDayPeriodPatterns$L = {
    any: /^((de|du)\.?|jfl|dlutn|dl|reggel|este|jjel)/i
};
const parseDayPeriodPatterns$L = {
    any: {
        am: /^de\.?/i,
        pm: /^du\.?/i,
        midnight: /^jf/i,
        noon: /^d/i,
        morning: /reg/i,
        afternoon: /^dlu\.?/i,
        evening: /es/i,
        night: /jj/i
    }
};
const match$L = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$L,
        parsePattern: parseOrdinalNumberPattern$L,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$L,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$L,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$L,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$L,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$L,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$L,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$L,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$L,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$L,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$L,
        defaultParseWidth: "any"
    })
};
const hu = {
    code: "hu",
    formatDistance: formatDistance$L,
    formatLong: formatLong$M,
    formatRelative: formatRelative$L,
    localize: localize$L,
    match: match$L,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$K = {
    lessThanXSeconds: {
        one: "   1 ",
        other: "   {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "   1 ",
        other: "   {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  1 ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$K = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$K[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " ";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$L = {
    full: "d MMMM, y, EEEE",
    long: "d MMMM, y",
    medium: "d MMM, y",
    short: "dd.MM.yyyy"
};
const timeFormats$L = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$L = {
    full: "{{date}} ''{{time}}",
    long: "{{date}} ''{{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$L = {
    date: buildFormatLongFn({
        formats: dateFormats$L,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$L,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$L,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$K = {
    lastWeek: "'' eeee p''",
    yesterday: "'' p''",
    today: "'' p''",
    tomorrow: "'' p''",
    nextWeek: "'' eeee p''",
    other: "P"
};
const formatRelative$K = (token, _date, _baseDate, _options) => formatRelativeLocale$K[token];
const eraValues$K = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: [" ", " "]
};
const quarterValues$K = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$K = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$K = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$K = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$C = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$K = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 < 10) {
        if (rem100 % 10 === 1) {
            return number2 + "";
        }
    }
    return number2 + "";
};
const localize$K = {
    ordinalNumber: ordinalNumber$K,
    era: buildLocalizeFn({
        values: eraValues$K,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$K,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$K,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$K,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$K,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$C,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$K = /^(\d+)((-|)?(|))?/i;
const parseOrdinalNumberPattern$K = /\d+/i;
const matchEraPatterns$K = {
    narrow: /^(|)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
    wide: /^( |  | | )/i
};
const parseEraPatterns$K = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$K = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^[1234]((-|)?(|)) /i
};
const parseQuarterPatterns$K = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$K = {
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$K = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$K = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$K = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i],
    short: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i],
    abbreviated: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i],
    wide: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i]
};
const matchDayPeriodPatterns$K = {
    narrow: /^([ap]|||(?|?|()?|?))/i,
    any: /^([ap]\.?\s?m\.?|()?|()?|(?|?|()?|?))/i
};
const parseDayPeriodPatterns$K = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: //i,
        noon: //i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$K = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$K,
        parsePattern: parseOrdinalNumberPattern$K,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$K,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$K,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$K,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$K,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$K,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$K,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$K,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$K,
        defaultParseWidth: "wide"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$K,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$K,
        defaultParseWidth: "any"
    })
};
const hy = {
    code: "hy",
    formatDistance: formatDistance$K,
    formatLong: formatLong$L,
    formatRelative: formatRelative$K,
    localize: localize$K,
    match: match$K,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$J = {
    lessThanXSeconds: {
        one: "kurang dari 1 detik",
        other: "kurang dari {{count}} detik"
    },
    xSeconds: {
        one: "1 detik",
        other: "{{count}} detik"
    },
    halfAMinute: "setengah menit",
    lessThanXMinutes: {
        one: "kurang dari 1 menit",
        other: "kurang dari {{count}} menit"
    },
    xMinutes: {
        one: "1 menit",
        other: "{{count}} menit"
    },
    aboutXHours: {
        one: "sekitar 1 jam",
        other: "sekitar {{count}} jam"
    },
    xHours: {
        one: "1 jam",
        other: "{{count}} jam"
    },
    xDays: {
        one: "1 hari",
        other: "{{count}} hari"
    },
    aboutXWeeks: {
        one: "sekitar 1 minggu",
        other: "sekitar {{count}} minggu"
    },
    xWeeks: {
        one: "1 minggu",
        other: "{{count}} minggu"
    },
    aboutXMonths: {
        one: "sekitar 1 bulan",
        other: "sekitar {{count}} bulan"
    },
    xMonths: {
        one: "1 bulan",
        other: "{{count}} bulan"
    },
    aboutXYears: {
        one: "sekitar 1 tahun",
        other: "sekitar {{count}} tahun"
    },
    xYears: {
        one: "1 tahun",
        other: "{{count}} tahun"
    },
    overXYears: {
        one: "lebih dari 1 tahun",
        other: "lebih dari {{count}} tahun"
    },
    almostXYears: {
        one: "hampir 1 tahun",
        other: "hampir {{count}} tahun"
    }
};
const formatDistance$J = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$J[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "dalam waktu " + result;
        }
        else {
            return result + " yang lalu";
        }
    }
    return result;
};
const dateFormats$K = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "d/M/yyyy"
};
const timeFormats$K = {
    full: "HH.mm.ss",
    long: "HH.mm.ss",
    medium: "HH.mm",
    short: "HH.mm"
};
const dateTimeFormats$K = {
    full: "{{date}} 'pukul' {{time}}",
    long: "{{date}} 'pukul' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$K = {
    date: buildFormatLongFn({
        formats: dateFormats$K,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$K,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$K,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$J = {
    lastWeek: "eeee 'lalu pukul' p",
    yesterday: "'Kemarin pukul' p",
    today: "'Hari ini pukul' p",
    tomorrow: "'Besok pukul' p",
    nextWeek: "eeee 'pukul' p",
    other: "P"
};
const formatRelative$J = (token, _date, _baseDate, _options) => formatRelativeLocale$J[token];
const eraValues$J = {
    narrow: ["SM", "M"],
    abbreviated: ["SM", "M"],
    wide: ["Sebelum Masehi", "Masehi"]
};
const quarterValues$J = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["Kuartal ke-1", "Kuartal ke-2", "Kuartal ke-3", "Kuartal ke-4"]
};
const monthValues$J = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "Mei",
        "Jun",
        "Jul",
        "Agt",
        "Sep",
        "Okt",
        "Nov",
        "Des"
    ],
    wide: [
        "Januari",
        "Februari",
        "Maret",
        "April",
        "Mei",
        "Juni",
        "Juli",
        "Agustus",
        "September",
        "Oktober",
        "November",
        "Desember"
    ]
};
const dayValues$J = {
    narrow: ["M", "S", "S", "R", "K", "J", "S"],
    short: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
    abbreviated: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
    wide: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
};
const dayPeriodValues$J = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "siang",
        evening: "sore",
        night: "malam"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "siang",
        evening: "sore",
        night: "malam"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "siang",
        evening: "sore",
        night: "malam"
    }
};
const formattingDayPeriodValues$B = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "siang",
        evening: "sore",
        night: "malam"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "siang",
        evening: "sore",
        night: "malam"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "siang",
        evening: "sore",
        night: "malam"
    }
};
const ordinalNumber$J = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return "ke-" + number2;
};
const localize$J = {
    ordinalNumber: ordinalNumber$J,
    era: buildLocalizeFn({
        values: eraValues$J,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$J,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$J,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$J,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$J,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$B,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$J = /^ke-(\d+)?/i;
const parseOrdinalNumberPattern$J = /\d+/i;
const matchEraPatterns$J = {
    narrow: /^(sm|m)/i,
    abbreviated: /^(s\.?\s?m\.?|s\.?\s?e\.?\s?u\.?|m\.?|e\.?\s?u\.?)/i,
    wide: /^(sebelum masehi|sebelum era umum|masehi|era umum)/i
};
const parseEraPatterns$J = {
    any: [/^s/i, /^(m|e)/i]
};
const matchQuarterPatterns$J = {
    narrow: /^[1234]/i,
    abbreviated: /^K-?\s[1234]/i,
    wide: /^Kuartal ke-?\s?[1234]/i
};
const parseQuarterPatterns$J = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$J = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|mei|jun|jul|agt|sep|okt|nov|des)/i,
    wide: /^(januari|februari|maret|april|mei|juni|juli|agustus|september|oktober|november|desember)/i
};
const parseMonthPatterns$J = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^ma/i,
        /^ap/i,
        /^me/i,
        /^jun/i,
        /^jul/i,
        /^ag/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$J = {
    narrow: /^[srkjm]/i,
    short: /^(min|sen|sel|rab|kam|jum|sab)/i,
    abbreviated: /^(min|sen|sel|rab|kam|jum|sab)/i,
    wide: /^(minggu|senin|selasa|rabu|kamis|jumat|sabtu)/i
};
const parseDayPatterns$J = {
    narrow: [/^m/i, /^s/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
    any: [/^m/i, /^sen/i, /^sel/i, /^r/i, /^k/i, /^j/i, /^sa/i]
};
const matchDayPeriodPatterns$J = {
    narrow: /^(a|p|tengah m|tengah h|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
    any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|(di(\swaktu)?) (pagi|siang|sore|malam))/i
};
const parseDayPeriodPatterns$J = {
    any: {
        am: /^a/i,
        pm: /^pm/i,
        midnight: /^tengah m/i,
        noon: /^tengah h/i,
        morning: /pagi/i,
        afternoon: /siang/i,
        evening: /sore/i,
        night: /malam/i
    }
};
const match$J = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$J,
        parsePattern: parseOrdinalNumberPattern$J,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$J,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$J,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$J,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$J,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$J,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$J,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$J,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$J,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$J,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$J,
        defaultParseWidth: "any"
    })
};
const id = {
    code: "id",
    formatDistance: formatDistance$J,
    formatLong: formatLong$K,
    formatRelative: formatRelative$J,
    localize: localize$J,
    match: match$J,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$I = {
    lessThanXSeconds: {
        one: "minna en 1 seknda",
        other: "minna en {{count}} sekndur"
    },
    xSeconds: {
        one: "1 seknda",
        other: "{{count}} sekndur"
    },
    halfAMinute: "hlf mnta",
    lessThanXMinutes: {
        one: "minna en 1 mnta",
        other: "minna en {{count}} mntur"
    },
    xMinutes: {
        one: "1 mnta",
        other: "{{count}} mntur"
    },
    aboutXHours: {
        one: "u..b. 1 klukkustund",
        other: "u..b. {{count}} klukkustundir"
    },
    xHours: {
        one: "1 klukkustund",
        other: "{{count}} klukkustundir"
    },
    xDays: {
        one: "1 dagur",
        other: "{{count}} dagar"
    },
    aboutXWeeks: {
        one: "um viku",
        other: "um {{count}} vikur"
    },
    xWeeks: {
        one: "1 viku",
        other: "{{count}} vikur"
    },
    aboutXMonths: {
        one: "u..b. 1 mnuur",
        other: "u..b. {{count}} mnuir"
    },
    xMonths: {
        one: "1 mnuur",
        other: "{{count}} mnuir"
    },
    aboutXYears: {
        one: "u..b. 1 r",
        other: "u..b. {{count}} r"
    },
    xYears: {
        one: "1 r",
        other: "{{count}} r"
    },
    overXYears: {
        one: "meira en 1 r",
        other: "meira en {{count}} r"
    },
    almostXYears: {
        one: "nstum 1 r",
        other: "nstum {{count}} r"
    }
};
const formatDistance$I = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$I[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return result + " san";
        }
    }
    return result;
};
const dateFormats$J = {
    full: "EEEE, do MMMM y",
    long: "do MMMM y",
    medium: "do MMM y",
    short: "d.MM.y"
};
const timeFormats$J = {
    full: "'kl'. HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$J = {
    full: "{{date}} 'kl.' {{time}}",
    long: "{{date}} 'kl.' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$J = {
    date: buildFormatLongFn({
        formats: dateFormats$J,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$J,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$J,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$I = {
    lastWeek: "'sasta' dddd 'kl.' p",
    yesterday: "' gr kl.' p",
    today: "' dag kl.' p",
    tomorrow: "' morgun kl.' p",
    nextWeek: "dddd 'kl.' p",
    other: "P"
};
const formatRelative$I = (token, _date, _baseDate, _options) => formatRelativeLocale$I[token];
const eraValues$I = {
    narrow: ["f.Kr.", "e.Kr."],
    abbreviated: ["f.Kr.", "e.Kr."],
    wide: ["fyrir Krist", "eftir Krist"]
};
const quarterValues$I = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1F", "2F", "3F", "4F"],
    wide: ["1. fjrungur", "2. fjrungur", "3. fjrungur", "4. fjrungur"]
};
const monthValues$I = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "", "S", "", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mars",
        "aprl",
        "ma",
        "jn",
        "jl",
        "gst",
        "sept.",
        "okt.",
        "nv.",
        "des."
    ],
    wide: [
        "janar",
        "febrar",
        "mars",
        "aprl",
        "ma",
        "jn",
        "jl",
        "gst",
        "september",
        "oktber",
        "nvember",
        "desember"
    ]
};
const dayValues$I = {
    narrow: ["S", "M", "", "M", "F", "F", "L"],
    short: ["Su", "M", "r", "Mi", "Fi", "F", "La"],
    abbreviated: ["sun.", "mn.", "ri.", "mi.", "fim.", "fs.", "lau."],
    wide: [
        "sunnudagur",
        "mnudagur",
        "rijudagur",
        "mivikudagur",
        "fimmtudagur",
        "fstudagur",
        "laugardagur"
    ]
};
const dayPeriodValues$I = {
    narrow: {
        am: "f",
        pm: "e",
        midnight: "mintti",
        noon: "hdegi",
        morning: "morgunn",
        afternoon: "sdegi",
        evening: "kvld",
        night: "ntt"
    },
    abbreviated: {
        am: "f.h.",
        pm: "e.h.",
        midnight: "mintti",
        noon: "hdegi",
        morning: "morgunn",
        afternoon: "sdegi",
        evening: "kvld",
        night: "ntt"
    },
    wide: {
        am: "fyrir hdegi",
        pm: "eftir hdegi",
        midnight: "mintti",
        noon: "hdegi",
        morning: "morgunn",
        afternoon: "sdegi",
        evening: "kvld",
        night: "ntt"
    }
};
const formattingDayPeriodValues$A = {
    narrow: {
        am: "f",
        pm: "e",
        midnight: " mintti",
        noon: " hdegi",
        morning: "a morgni",
        afternoon: "sdegis",
        evening: "um kvld",
        night: "um ntt"
    },
    abbreviated: {
        am: "f.h.",
        pm: "e.h.",
        midnight: " mintti",
        noon: " hdegi",
        morning: "a morgni",
        afternoon: "sdegis",
        evening: "um kvld",
        night: "um ntt"
    },
    wide: {
        am: "fyrir hdegi",
        pm: "eftir hdegi",
        midnight: " mintti",
        noon: " hdegi",
        morning: "a morgni",
        afternoon: "sdegis",
        evening: "um kvld",
        night: "um ntt"
    }
};
const ordinalNumber$I = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$I = {
    ordinalNumber: ordinalNumber$I,
    era: buildLocalizeFn({
        values: eraValues$I,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$I,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$I,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$I,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$I,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$A,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$I = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$I = /\d+(\.)?/i;
const matchEraPatterns$I = {
    narrow: /^(f\.Kr\.|e\.Kr\.)/i,
    abbreviated: /^(f\.Kr\.|e\.Kr\.)/i,
    wide: /^(fyrir Krist|eftir Krist)/i
};
const parseEraPatterns$I = {
    any: [/^(f\.Kr\.)/i, /^(e\.Kr\.)/i]
};
const matchQuarterPatterns$I = {
    narrow: /^[1234]\.?/i,
    abbreviated: /^q[1234]\.?/i,
    wide: /^[1234]\.? fjrungur/i
};
const parseQuarterPatterns$I = {
    any: [/1\.?/i, /2\.?/i, /3\.?/i, /4\.?/i]
};
const matchMonthPatterns$I = {
    narrow: /^[jfmsnd]/i,
    abbreviated: /^(jan\.|feb\.|mars\.|aprl\.|ma|jn|jl|gust|sep\.|oct\.|nov\.|dec\.)/i,
    wide: /^(januar|febrar|mars|aprl|ma|jn|jl|gust|september|oktber|nvember|desember)/i
};
const parseMonthPatterns$I = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^/i,
        /^s/i,
        /^/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^ma/i,
        /^jn/i,
        /^jl/i,
        /^u/i,
        /^s/i,
        /^/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$I = {
    narrow: /^[smtwf]/i,
    short: /^(su|m|r|mi|fi|f|la)/i,
    abbreviated: /^(sun|mn|ri|mi|fim|fs|lau)\.?/i,
    wide: /^(sunnudagur|mnudagur|rijudagur|mivikudagur|fimmtudagur|fstudagur|laugardagur)/i
};
const parseDayPatterns$I = {
    narrow: [/^s/i, /^m/i, /^/i, /^m/i, /^f/i, /^f/i, /^l/i],
    any: [/^su/i, /^m/i, /^r/i, /^mi/i, /^fi/i, /^f/i, /^la/i]
};
const matchDayPeriodPatterns$I = {
    narrow: /^(f|e|sdegis|(|a|um) (morgni|kvld|ntt|mintti))/i,
    any: /^(fyrir hdegi|eftir hdegi|[ef]\.?h\.?|sdegis|morgunn|(|a|um) (morgni|kvld|ntt|mintti))/i
};
const parseDayPeriodPatterns$I = {
    any: {
        am: /^f/i,
        pm: /^e/i,
        midnight: /^mi/i,
        noon: /^h/i,
        morning: /morgunn/i,
        afternoon: /sdegi/i,
        evening: /kvld/i,
        night: /ntt/i
    }
};
const match$I = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$I,
        parsePattern: parseOrdinalNumberPattern$I,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$I,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$I,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$I,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$I,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$I,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$I,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$I,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$I,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$I,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$I,
        defaultParseWidth: "any"
    })
};
const is = {
    code: "is",
    formatDistance: formatDistance$I,
    formatLong: formatLong$J,
    formatRelative: formatRelative$I,
    localize: localize$I,
    match: match$I,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$H = {
    lessThanXSeconds: {
        one: "meno di un secondo",
        other: "meno di {{count}} secondi"
    },
    xSeconds: {
        one: "un secondo",
        other: "{{count}} secondi"
    },
    halfAMinute: "alcuni secondi",
    lessThanXMinutes: {
        one: "meno di un minuto",
        other: "meno di {{count}} minuti"
    },
    xMinutes: {
        one: "un minuto",
        other: "{{count}} minuti"
    },
    aboutXHours: {
        one: "circa un'ora",
        other: "circa {{count}} ore"
    },
    xHours: {
        one: "un'ora",
        other: "{{count}} ore"
    },
    xDays: {
        one: "un giorno",
        other: "{{count}} giorni"
    },
    aboutXWeeks: {
        one: "circa una settimana",
        other: "circa {{count}} settimane"
    },
    xWeeks: {
        one: "una settimana",
        other: "{{count}} settimane"
    },
    aboutXMonths: {
        one: "circa un mese",
        other: "circa {{count}} mesi"
    },
    xMonths: {
        one: "un mese",
        other: "{{count}} mesi"
    },
    aboutXYears: {
        one: "circa un anno",
        other: "circa {{count}} anni"
    },
    xYears: {
        one: "un anno",
        other: "{{count}} anni"
    },
    overXYears: {
        one: "pi di un anno",
        other: "pi di {{count}} anni"
    },
    almostXYears: {
        one: "quasi un anno",
        other: "quasi {{count}} anni"
    }
};
const formatDistance$H = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$H[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "tra " + result;
        }
        else {
            return result + " fa";
        }
    }
    return result;
};
const dateFormats$I = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$I = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$I = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$I = {
    date: buildFormatLongFn({
        formats: dateFormats$I,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$I,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$I,
        defaultWidth: "full"
    })
};
const weekdays$2 = [
    "domenica",
    "luned",
    "marted",
    "mercoled",
    "gioved",
    "venerd",
    "sabato"
];
function lastWeek$5(day) {
    switch (day) {
        case 0:
            return "'domenica scorsa alle' p";
        default:
            return "'" + weekdays$2[day] + " scorso alle' p";
    }
}
function thisWeek$5(day) {
    return "'" + weekdays$2[day] + " alle' p";
}
function nextWeek$5(day) {
    switch (day) {
        case 0:
            return "'domenica prossima alle' p";
        default:
            return "'" + weekdays$2[day] + " prossimo alle' p";
    }
}
const formatRelativeLocale$H = {
    lastWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$5(day);
        }
        else {
            return lastWeek$5(day);
        }
    },
    yesterday: "'ieri alle' p",
    today: "'oggi alle' p",
    tomorrow: "'domani alle' p",
    nextWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$5(day);
        }
        else {
            return nextWeek$5(day);
        }
    },
    other: "P"
};
const formatRelative$H = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$H[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$H = {
    narrow: ["aC", "dC"],
    abbreviated: ["a.C.", "d.C."],
    wide: ["avanti Cristo", "dopo Cristo"]
};
const quarterValues$H = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$H = {
    narrow: ["G", "F", "M", "A", "M", "G", "L", "A", "S", "O", "N", "D"],
    abbreviated: [
        "gen",
        "feb",
        "mar",
        "apr",
        "mag",
        "giu",
        "lug",
        "ago",
        "set",
        "ott",
        "nov",
        "dic"
    ],
    wide: [
        "gennaio",
        "febbraio",
        "marzo",
        "aprile",
        "maggio",
        "giugno",
        "luglio",
        "agosto",
        "settembre",
        "ottobre",
        "novembre",
        "dicembre"
    ]
};
const dayValues$H = {
    narrow: ["D", "L", "M", "M", "G", "V", "S"],
    short: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
    abbreviated: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
    wide: [
        "domenica",
        "luned",
        "marted",
        "mercoled",
        "gioved",
        "venerd",
        "sabato"
    ]
};
const dayPeriodValues$H = {
    narrow: {
        am: "m.",
        pm: "p.",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "mattina",
        afternoon: "pomeriggio",
        evening: "sera",
        night: "notte"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "mattina",
        afternoon: "pomeriggio",
        evening: "sera",
        night: "notte"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "mattina",
        afternoon: "pomeriggio",
        evening: "sera",
        night: "notte"
    }
};
const formattingDayPeriodValues$z = {
    narrow: {
        am: "m.",
        pm: "p.",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "di mattina",
        afternoon: "del pomeriggio",
        evening: "di sera",
        night: "di notte"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "di mattina",
        afternoon: "del pomeriggio",
        evening: "di sera",
        night: "di notte"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "di mattina",
        afternoon: "del pomeriggio",
        evening: "di sera",
        night: "di notte"
    }
};
const ordinalNumber$H = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return String(number2);
};
const localize$H = {
    ordinalNumber: ordinalNumber$H,
    era: buildLocalizeFn({
        values: eraValues$H,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$H,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$H,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$H,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$H,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$z,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$H = /^(\d+)()?/i;
const parseOrdinalNumberPattern$H = /\d+/i;
const matchEraPatterns$H = {
    narrow: /^(aC|dC)/i,
    abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
    wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
};
const parseEraPatterns$H = {
    any: [/^a/i, /^(d|e)/i]
};
const matchQuarterPatterns$H = {
    narrow: /^[1234]/i,
    abbreviated: /^t[1234]/i,
    wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$H = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$H = {
    narrow: /^[gfmalsond]/i,
    abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
    wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
};
const parseMonthPatterns$H = {
    narrow: [
        /^g/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^g/i,
        /^l/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ge/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mag/i,
        /^gi/i,
        /^l/i,
        /^ag/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$H = {
    narrow: /^[dlmgvs]/i,
    short: /^(do|lu|ma|me|gi|ve|sa)/i,
    abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
    wide: /^(domenica|luned[i|]|marted[i|]|mercoled[i|]|gioved[i|]|venerd[i|]|sabato)/i
};
const parseDayPatterns$H = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
    any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
};
const matchDayPeriodPatterns$H = {
    narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
    any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
};
const parseDayPeriodPatterns$H = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mezza/i,
        noon: /^mezzo/i,
        morning: /mattina/i,
        afternoon: /pomeriggio/i,
        evening: /sera/i,
        night: /notte/i
    }
};
const match$H = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$H,
        parsePattern: parseOrdinalNumberPattern$H,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$H,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$H,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$H,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$H,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$H,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$H,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$H,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$H,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$H,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$H,
        defaultParseWidth: "any"
    })
};
const it = {
    code: "it",
    formatDistance: formatDistance$H,
    formatLong: formatLong$I,
    formatRelative: formatRelative$H,
    localize: localize$H,
    match: match$H,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const dateFormats$H = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd.MM.y"
};
const timeFormats$H = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$H = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$H = {
    date: buildFormatLongFn({
        formats: dateFormats$H,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$H,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$H,
        defaultWidth: "full"
    })
};
const itCH = {
    code: "it-CH",
    formatDistance: formatDistance$H,
    formatLong: formatLong$H,
    formatRelative: formatRelative$H,
    localize: localize$H,
    match: match$H,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$G = {
    lessThanXSeconds: {
        one: "1",
        other: "{{count}}",
        oneWithSuffix: "1",
        otherWithSuffix: "{{count}}"
    },
    xSeconds: {
        one: "1",
        other: "{{count}}"
    },
    halfAMinute: "30",
    lessThanXMinutes: {
        one: "1",
        other: "{{count}}",
        oneWithSuffix: "1",
        otherWithSuffix: "{{count}}"
    },
    xMinutes: {
        one: "1",
        other: "{{count}}"
    },
    aboutXHours: {
        one: "1",
        other: "{{count}}"
    },
    xHours: {
        one: "1",
        other: "{{count}}"
    },
    xDays: {
        one: "1",
        other: "{{count}}"
    },
    aboutXWeeks: {
        one: "1",
        other: "{{count}}"
    },
    xWeeks: {
        one: "1",
        other: "{{count}}"
    },
    aboutXMonths: {
        one: "1",
        other: "{{count}}"
    },
    xMonths: {
        one: "1",
        other: "{{count}}"
    },
    aboutXYears: {
        one: "1",
        other: "{{count}}"
    },
    xYears: {
        one: "1",
        other: "{{count}}"
    },
    overXYears: {
        one: "1",
        other: "{{count}}"
    },
    almostXYears: {
        one: "1",
        other: "{{count}}"
    }
};
const formatDistance$G = (token, count, options2) => {
    options2 = options2 || {};
    let result;
    const tokenValue = formatDistanceLocale$G[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        if (options2.addSuffix && tokenValue.oneWithSuffix) {
            result = tokenValue.oneWithSuffix;
        }
        else {
            result = tokenValue.one;
        }
    }
    else {
        if (options2.addSuffix && tokenValue.otherWithSuffix) {
            result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
        }
        else {
            result = tokenValue.other.replace("{{count}}", String(count));
        }
    }
    if (options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats$G = {
    full: "yMdEEEE",
    long: "yMd",
    medium: "y/MM/dd",
    short: "y/MM/dd"
};
const timeFormats$G = {
    full: "Hmmss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$G = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$G = {
    date: buildFormatLongFn({
        formats: dateFormats$G,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$G,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$G,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$G = {
    lastWeek: "eeeep",
    yesterday: "p",
    today: "p",
    tomorrow: "p",
    nextWeek: "eeeep",
    other: "P"
};
const formatRelative$G = (token, _date, _baseDate, _options) => {
    return formatRelativeLocale$G[token];
};
const eraValues$G = {
    narrow: ["BC", "AC"],
    abbreviated: ["", ""],
    wide: ["", ""]
};
const quarterValues$G = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1", "2", "3", "4"]
};
const monthValues$G = {
    narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    abbreviated: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ],
    wide: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ]
};
const dayValues$G = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$G = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$y = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$G = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = String(options2?.unit);
    switch (unit) {
        case "year":
            return `${number2}`;
        case "quarter":
            return `${number2}`;
        case "month":
            return `${number2}`;
        case "week":
            return `${number2}`;
        case "date":
            return `${number2}`;
        case "hour":
            return `${number2}`;
        case "minute":
            return `${number2}`;
        case "second":
            return `${number2}`;
        default:
            return `${number2}`;
    }
};
const localize$G = {
    ordinalNumber: ordinalNumber$G,
    era: buildLocalizeFn({
        values: eraValues$G,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$G,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$G,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$G,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$G,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$y,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$G = /^?\d+(|||||||)?/i;
const parseOrdinalNumberPattern$G = /\d+/i;
const matchEraPatterns$G = {
    narrow: /^(B\.?C\.?|A\.?D\.?)/i,
    abbreviated: /^([]|)/i,
    wide: /^([]|)/i
};
const parseEraPatterns$G = {
    narrow: [/^B/i, /^A/i],
    any: [/^()/i, /^(|)/i]
};
const matchQuarterPatterns$G = {
    narrow: /^[1234]/i,
    abbreviated: /^Q[1234]/i,
    wide: /^[1234]/i
};
const parseQuarterPatterns$G = {
    any: [/(1||)/i, /(2||)/i, /(3||)/i, /(4||)/i]
};
const matchMonthPatterns$G = {
    narrow: /^([123456789]|1[012])/,
    abbreviated: /^([123456789]|1[012])/i,
    wide: /^([123456789]|1[012])/i
};
const parseMonthPatterns$G = {
    any: [
        /^1\D/,
        /^2/,
        /^3/,
        /^4/,
        /^5/,
        /^6/,
        /^7/,
        /^8/,
        /^9/,
        /^10/,
        /^11/,
        /^12/
    ]
};
const matchDayPatterns$G = {
    narrow: /^[]/,
    short: /^[]/,
    abbreviated: /^[]/,
    wide: /^[]/
};
const parseDayPatterns$G = {
    any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
};
const matchDayPeriodPatterns$G = {
    any: /^(AM|PM|||||||)/i
};
const parseDayPeriodPatterns$G = {
    any: {
        am: /^(A|)/i,
        pm: /^(P|)/i,
        midnight: /^|/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$G = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$G,
        parsePattern: parseOrdinalNumberPattern$G,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$G,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$G,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$G,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$G,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$G,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$G,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$G,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$G,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$G,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$G,
        defaultParseWidth: "any"
    })
};
const ja = {
    code: "ja",
    formatDistance: formatDistance$G,
    formatLong: formatLong$G,
    formatRelative: formatRelative$G,
    localize: localize$G,
    match: match$G,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$F = {
    lessThanXSeconds: {
        one: "1",
        other: "{{count}}",
        oneWithSuffix: "1",
        otherWithSuffix: "{{count}}"
    },
    xSeconds: {
        one: "1",
        other: "{{count}}"
    },
    halfAMinute: "30",
    lessThanXMinutes: {
        one: "1",
        other: "{{count}}",
        oneWithSuffix: "1",
        otherWithSuffix: "{{count}}"
    },
    xMinutes: {
        one: "1",
        other: "{{count}}"
    },
    aboutXHours: {
        one: "1",
        other: "{{count}}"
    },
    xHours: {
        one: "1",
        other: "{{count}}"
    },
    xDays: {
        one: "1",
        other: "{{count}}"
    },
    aboutXWeeks: {
        one: "1",
        other: "{{count}}"
    },
    xWeeks: {
        one: "1",
        other: "{{count}}"
    },
    aboutXMonths: {
        one: "1",
        other: "{{count}}"
    },
    xMonths: {
        one: "1",
        other: "{{count}}"
    },
    aboutXYears: {
        one: "1",
        other: "{{count}}"
    },
    xYears: {
        one: "1",
        other: "{{count}}"
    },
    overXYears: {
        one: "1",
        other: "{{count}}"
    },
    almostXYears: {
        one: "1",
        other: "{{count}}"
    }
};
const formatDistance$F = (token, count, options2) => {
    options2 = options2 || {};
    let result;
    const tokenValue = formatDistanceLocale$F[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        if (options2.addSuffix && tokenValue.oneWithSuffix) {
            result = tokenValue.oneWithSuffix;
        }
        else {
            result = tokenValue.one;
        }
    }
    else {
        if (options2.addSuffix && tokenValue.otherWithSuffix) {
            result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
        }
        else {
            result = tokenValue.other.replace("{{count}}", String(count));
        }
    }
    if (options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats$F = {
    full: "yMdEEEE",
    long: "yMd",
    medium: "y/MM/dd",
    short: "y/MM/dd"
};
const timeFormats$F = {
    full: "Hmmss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$F = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$F = {
    date: buildFormatLongFn({
        formats: dateFormats$F,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$F,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$F,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$F = {
    lastWeek: "eeeep",
    yesterday: "p",
    today: "p",
    tomorrow: "p",
    nextWeek: "eeeep",
    other: "P"
};
const formatRelative$F = (token, _date, _baseDate, _options) => {
    return formatRelativeLocale$F[token];
};
const eraValues$F = {
    narrow: ["BC", "AC"],
    abbreviated: ["", ""],
    wide: ["", ""]
};
const quarterValues$F = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1", "2", "3", "4"]
};
const monthValues$F = {
    narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    abbreviated: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ],
    wide: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ]
};
const dayValues$F = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$F = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$x = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$F = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = String(options2?.unit);
    switch (unit) {
        case "year":
            return `${number2}`;
        case "quarter":
            return `${number2}`;
        case "month":
            return `${number2}`;
        case "week":
            return `${number2}`;
        case "date":
            return `${number2}`;
        case "hour":
            return `${number2}`;
        case "minute":
            return `${number2}`;
        case "second":
            return `${number2}`;
        default:
            return `${number2}`;
    }
};
const localize$F = {
    ordinalNumber: ordinalNumber$F,
    era: buildLocalizeFn({
        values: eraValues$F,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$F,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$F,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$F,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$F,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$x,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$F = /^??\d+(|||||||)?/i;
const parseOrdinalNumberPattern$F = /\d+/i;
const matchEraPatterns$F = {
    narrow: /^(B\.?C\.?|A\.?D\.?)/i,
    abbreviated: /^([]|)/i,
    wide: /^([]|)/i
};
const parseEraPatterns$F = {
    narrow: [/^B/i, /^A/i],
    any: [/^()/i, /^(|)/i]
};
const matchQuarterPatterns$F = {
    narrow: /^[1234]/i,
    abbreviated: /^Q[1234]/i,
    wide: /^[1234]/i
};
const parseQuarterPatterns$F = {
    any: [/(1||)/i, /(2||)/i, /(3||)/i, /(4||)/i]
};
const matchMonthPatterns$F = {
    narrow: /^([123456789]|1[012])/,
    abbreviated: /^([123456789]|1[012])/i,
    wide: /^([123456789]|1[012])/i
};
const parseMonthPatterns$F = {
    any: [
        /^1\D/,
        /^2/,
        /^3/,
        /^4/,
        /^5/,
        /^6/,
        /^7/,
        /^8/,
        /^9/,
        /^10/,
        /^11/,
        /^12/
    ]
};
const matchDayPatterns$F = {
    narrow: /^(||||||)/,
    short: /^(||||||)/,
    abbreviated: /^(||||||)/,
    wide: /^(||||||)/
};
const parseDayPatterns$F = {
    any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
};
const matchDayPeriodPatterns$F = {
    any: /^(AM|PM|||||||)/i
};
const parseDayPeriodPatterns$F = {
    any: {
        am: /^(A|)/i,
        pm: /^(P|)/i,
        midnight: /^|/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$F = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$F,
        parsePattern: parseOrdinalNumberPattern$F,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$F,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$F,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$F,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$F,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$F,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$F,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$F,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$F,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$F,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$F,
        defaultParseWidth: "any"
    })
};
const jaHira = {
    code: "ja-Hira",
    formatDistance: formatDistance$F,
    formatLong: formatLong$F,
    formatRelative: formatRelative$F,
    localize: localize$F,
    match: match$F,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$E = {
    lessThanXSeconds: {
        past: "{{count}}    ",
        present: "{{count}}  ",
        future: "{{count}}  "
    },
    xSeconds: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    halfAMinute: {
        past: "  ",
        present: " ",
        future: " "
    },
    lessThanXMinutes: {
        past: "{{count}}    ",
        present: "{{count}}  ",
        future: "{{count}}  "
    },
    xMinutes: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    aboutXHours: {
        past: " {{count}}  ",
        present: " {{count}} ",
        future: " {{count}} "
    },
    xHours: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    xDays: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    aboutXWeeks: {
        past: " {{count}}  ",
        present: " {{count}} ",
        future: " {{count}} "
    },
    xWeeks: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    aboutXMonths: {
        past: " {{count}}  ",
        present: " {{count}} ",
        future: " {{count}} "
    },
    xMonths: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    aboutXYears: {
        past: " {{count}}  ",
        present: " {{count}} ",
        future: " {{count}} "
    },
    xYears: {
        past: "{{count}}  ",
        present: "{{count}} ",
        future: "{{count}} "
    },
    overXYears: {
        past: "{{count}}    ",
        present: "{{count}}  ",
        future: "{{count}}    "
    },
    almostXYears: {
        past: " {{count}}  ",
        present: " {{count}} ",
        future: " {{count}} "
    }
};
const formatDistance$E = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$E[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (options2?.addSuffix && options2.comparison && options2.comparison > 0) {
        result = tokenValue.future.replace("{{count}}", String(count));
    }
    else if (options2?.addSuffix) {
        result = tokenValue.past.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.present.replace("{{count}}", String(count));
    }
    return result;
};
const dateFormats$E = {
    full: "EEEE, do MMMM, y",
    long: "do, MMMM, y",
    medium: "d, MMM, y",
    short: "dd/MM/yyyy"
};
const timeFormats$E = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$E = {
    full: "{{date}} {{time}}'-'",
    long: "{{date}} {{time}}'-'",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$E = {
    date: buildFormatLongFn({
        formats: dateFormats$E,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$E,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$E,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$E = {
    lastWeek: "'' eeee p'-'",
    yesterday: "'' p'-'",
    today: "'' p'-'",
    tomorrow: "'' p'-'",
    nextWeek: "'' eeee p'-'",
    other: "P"
};
const formatRelative$E = (token, _date, _baseDate, _options) => formatRelativeLocale$E[token];
const eraValues$E = {
    narrow: [".-", "."],
    abbreviated: [".-", "."],
    wide: [" ", " "]
};
const quarterValues$E = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- ", "2- ", "3- ", "4- "],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$E = {
    narrow: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$E = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$E = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$w = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$E = (dirtyNumber) => {
    const number2 = Number(dirtyNumber);
    if (number2 === 1) {
        return number2 + "-";
    }
    return number2 + "-";
};
const localize$E = {
    ordinalNumber: ordinalNumber$E,
    era: buildLocalizeFn({
        values: eraValues$E,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$E,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$E,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$E,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$E,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$w,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$E = /^(\d+)(-|-)?/i;
const parseOrdinalNumberPattern$E = /\d+/i;
const matchEraPatterns$E = {
    narrow: /^(?\.)/i,
    abbreviated: /^(?\.)/i,
    wide: /^( || |)/i
};
const parseEraPatterns$E = {
    any: [
        /^( |)/i,
        /^( |)/i
    ]
};
const matchQuarterPatterns$E = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]-(|)? /i,
    wide: /^[1234]-(|)? /i
};
const parseQuarterPatterns$E = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$E = {
    any: /^(|||||||||||)/i
};
const parseMonthPatterns$E = {
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^?/i,
        /^?/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$E = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$E = {
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$E = {
    any: /^([ap]\.?\s?m\.?||)/i
};
const parseDayPeriodPatterns$E = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$E = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$E,
        parsePattern: parseOrdinalNumberPattern$E,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$E,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$E,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$E,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$E,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$E,
        defaultMatchWidth: "any",
        parsePatterns: parseMonthPatterns$E,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$E,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$E,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$E,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$E,
        defaultParseWidth: "any"
    })
};
const ka = {
    code: "ka",
    formatDistance: formatDistance$E,
    formatLong: formatLong$E,
    formatRelative: formatRelative$E,
    localize: localize$E,
    match: match$E,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$D = {
    lessThanXSeconds: {
        regular: {
            one: "1  ",
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            one: "  ",
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    xSeconds: {
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    halfAMinute: (options2) => {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                return "  ";
            }
            else {
                return "  ";
            }
        }
        return " ";
    },
    lessThanXMinutes: {
        regular: {
            one: "1  ",
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            one: "  ",
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    xMinutes: {
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    aboutXHours: {
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: " {{count}}  ",
            singularGenitive: " {{count}}  ",
            pluralGenitive: " {{count}}  "
        }
    },
    xHours: {
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    },
    xDays: {
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        future: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    aboutXWeeks: {
        type: "weeks",
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        type: "weeks",
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: " {{count}}  ",
            singularGenitive: " {{count}}  ",
            pluralGenitive: " {{count}}  "
        }
    },
    xMonths: {
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    },
    aboutXYears: {
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: " {{count}}  ",
            singularGenitive: " {{count}}  ",
            pluralGenitive: " {{count}}  "
        }
    },
    xYears: {
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        future: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    overXYears: {
        regular: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    },
    almostXYears: {
        regular: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        }
    }
};
function declension$4(scheme, count) {
    if (scheme.one && count === 1)
        return scheme.one;
    const rem10 = count % 10;
    const rem100 = count % 100;
    if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
    }
    else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
    }
    else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
    }
}
const formatDistance$D = (token, count, options2) => {
    const tokenValue = formatDistanceLocale$D[token];
    if (typeof tokenValue === "function")
        return tokenValue(options2);
    if (tokenValue.type === "weeks") {
        return count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            if (tokenValue.future) {
                return declension$4(tokenValue.future, count);
            }
            else {
                return declension$4(tokenValue.regular, count) + " ";
            }
        }
        else {
            if (tokenValue.past) {
                return declension$4(tokenValue.past, count);
            }
            else {
                return declension$4(tokenValue.regular, count) + " ";
            }
        }
    }
    else {
        return declension$4(tokenValue.regular, count);
    }
};
const dateFormats$D = {
    full: "EEEE, do MMMM y '.'",
    long: "do MMMM y '.'",
    medium: "d MMM y '.'",
    short: "dd.MM.yyyy"
};
const timeFormats$D = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$D = {
    any: "{{date}}, {{time}}"
};
const formatLong$D = {
    date: buildFormatLongFn({
        formats: dateFormats$D,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$D,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$D,
        defaultWidth: "any"
    })
};
const accusativeWeekdays$3 = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek$4(day) {
    const weekday = accusativeWeekdays$3[day];
    return "' " + weekday + " ' p'-'";
}
function thisWeek$4(day) {
    const weekday = accusativeWeekdays$3[day];
    return "'" + weekday + " ' p'-'";
}
function nextWeek$4(day) {
    const weekday = accusativeWeekdays$3[day];
    return "' " + weekday + " ' p'-'";
}
const formatRelativeLocale$D = {
    lastWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$4(day);
        }
        else {
            return lastWeek$4(day);
        }
    },
    yesterday: "' ' p'-'",
    today: "' ' p'-'",
    tomorrow: "' ' p'-'",
    nextWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$4(day);
        }
        else {
            return nextWeek$4(day);
        }
    },
    other: "P"
};
const formatRelative$D = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$D[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$D = {
    narrow: ["...", ".."],
    abbreviated: ["...", ".."],
    wide: ["  ", " "]
};
const quarterValues$D = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$D = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$9 = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$D = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$D = {
    narrow: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$v = {
    narrow: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const suffixes = {
    0: "-",
    1: "-",
    2: "-",
    3: "-",
    4: "-",
    5: "-",
    6: "-",
    7: "-",
    8: "-",
    9: "-",
    10: "-",
    20: "-",
    30: "-",
    40: "-",
    50: "-",
    60: "-",
    70: "-",
    80: "-",
    90: "-",
    100: "-"
};
const ordinalNumber$D = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const mod10 = number2 % 10;
    const b = number2 >= 100 ? 100 : null;
    const suffix = suffixes[number2] || suffixes[mod10] || b && suffixes[b] || "";
    return number2 + suffix;
};
const localize$D = {
    ordinalNumber: ordinalNumber$D,
    era: buildLocalizeFn({
        values: eraValues$D,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$D,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$D,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$9,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$D,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$D,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$v,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$D = /^(\d+)(-?(|))?/i;
const parseOrdinalNumberPattern$D = /\d+/i;
const matchEraPatterns$D = {
    narrow: /^(( )?\.?\s?\.?)/i,
    abbreviated: /^(( )?\.?\s?\.?)/i,
    wide: /^(  | | )/i
};
const parseEraPatterns$D = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$D = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?)? .?/i,
    wide: /^[1234](-?)? /i
};
const parseQuarterPatterns$D = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$D = {
    narrow: /^(|||||||||||)/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$D = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    abbreviated: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$D = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$D = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    short: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [
        /^[]/i,
        /^[]/i,
        /^e[]/i,
        /^[]/i,
        /^[]/i,
        /^[]/i,
        /^[]/i
    ]
};
const matchDayPeriodPatterns$D = {
    narrow: /^\.?\s?[]\.?| |((|||||||||||)\.?)/i,
    wide: /^\.?\s?[]\.?| |((|||||||||||)\.?)/i,
    any: /^\.?\s?[]\.?| |((|||||||||||)\.?)/i
};
const parseDayPeriodPatterns$D = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^ /i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$D = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$D,
        parsePattern: parseOrdinalNumberPattern$D,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$D,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$D,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$D,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$D,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$D,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$D,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$D,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$D,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$D,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$D,
        defaultParseWidth: "any"
    })
};
const kk = {
    code: "kk",
    formatDistance: formatDistance$D,
    formatLong: formatLong$D,
    formatRelative: formatRelative$D,
    localize: localize$D,
    match: match$D,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$C = {
    lessThanXSeconds: " {{count}} ",
    xSeconds: "{{count}} ",
    halfAMinute: "",
    lessThanXMinutes: " {{count}} ",
    xMinutes: "{{count}} ",
    aboutXHours: " {{count}} ",
    xHours: "{{count}} ",
    xDays: "{{count}} ",
    aboutXWeeks: " {{count}} ",
    xWeeks: "{{count}} ",
    aboutXMonths: " {{count}} ",
    xMonths: "{{count}} ",
    aboutXYears: " {{count}} ",
    xYears: "{{count}} ",
    overXYears: " {{count}} ",
    almostXYears: " {{count}} "
};
const formatDistance$C = (token, count, options2) => {
    const tokenValue = formatDistanceLocale$C[token];
    let result = tokenValue;
    if (typeof count === "number") {
        result = result.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats$C = {
    full: "EEEE do MMMM y",
    long: "do MMMM y",
    medium: "d MMM y",
    short: "dd/MM/yyyy"
};
const timeFormats$C = {
    full: "h:mm:ss a",
    long: "h:mm:ss a",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$C = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$C = {
    date: buildFormatLongFn({
        formats: dateFormats$C,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$C,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$C,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$C = {
    lastWeek: "''eeee'' p",
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: "''eeee'' p",
    other: "P"
};
const formatRelative$C = (token, _date, _baseDate, _options) => formatRelativeLocale$C[token];
const eraValues$C = {
    narrow: [".", ""],
    abbreviated: [".", "."],
    wide: ["", ""]
};
const quarterValues$C = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: [" 1", " 2", " 3", " 4"]
};
const monthValues$C = {
    narrow: [
        ".",
        ".",
        "",
        ".",
        ".",
        ".",
        ".",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$C = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$C = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$u = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$C = (dirtyNumber, _) => {
    const number2 = Number(dirtyNumber);
    return number2.toString();
};
const localize$C = {
    ordinalNumber: ordinalNumber$C,
    era: buildLocalizeFn({
        values: eraValues$C,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$C,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$C,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$C,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$C,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$u,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$C = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$C = /\d+/i;
const matchEraPatterns$C = {
    narrow: /^(\.)?/i,
    abbreviated: /^()?\./i,
    wide: /^(|)/i
};
const parseEraPatterns$C = {
    any: [/^(|)\.?/i, /^()?\.?/i]
};
const matchQuarterPatterns$C = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^()()?\s?[1234]/i
};
const parseQuarterPatterns$C = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$C = {
    narrow: /^(\.|\.||\.|\.|\.|\.|||||)/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$C = {
    narrow: [
        /^\./i,
        /^\./i,
        /^/i,
        /^\./i,
        /^\./i,
        /^\./i,
        /^\./i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$C = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$C = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$C = {
    narrow: /^(|||||||)/i,
    any: /^(|||||||)/i
};
const parseDayPeriodPatterns$C = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$C = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$C,
        parsePattern: parseOrdinalNumberPattern$C,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$C,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$C,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$C,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$C,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$C,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$C,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$C,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$C,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$C,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$C,
        defaultParseWidth: "any"
    })
};
const km = {
    code: "km",
    formatDistance: formatDistance$C,
    formatLong: formatLong$C,
    formatRelative: formatRelative$C,
    localize: localize$C,
    match: match$C,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$B = {
    lessThanXSeconds: {
        one: {
            default: "1  ",
            future: "1  ",
            past: "1  "
        },
        other: {
            default: "{{count}}  ",
            future: "{{count}}  ",
            past: "{{count}}  "
        }
    },
    xSeconds: {
        one: {
            default: "1 ",
            future: "1 ",
            past: "1  "
        },
        other: {
            default: "{{count}} ",
            future: "{{count}} ",
            past: "{{count}}  "
        }
    },
    halfAMinute: {
        other: {
            default: " ",
            future: " ",
            past: "  "
        }
    },
    lessThanXMinutes: {
        one: {
            default: "1  ",
            future: "1  ",
            past: "1  "
        },
        other: {
            default: "{{count}}  ",
            future: "{{count}}  ",
            past: "{{count}}  "
        }
    },
    xMinutes: {
        one: {
            default: "1 ",
            future: "1 ",
            past: "1  "
        },
        other: {
            default: "{{count}} ",
            future: "{{count}} ",
            past: "{{count}}  "
        }
    },
    aboutXHours: {
        one: {
            default: " 1 ",
            future: " 1 ",
            past: " 1  "
        },
        other: {
            default: " {{count}} ",
            future: " {{count}} ",
            past: " {{count}}  "
        }
    },
    xHours: {
        one: {
            default: "1 ",
            future: "1 ",
            past: "1  "
        },
        other: {
            default: "{{count}} ",
            future: "{{count}} ",
            past: "{{count}}  "
        }
    },
    xDays: {
        one: {
            default: "1 ",
            future: "1 ",
            past: "1  "
        },
        other: {
            default: "{{count}} ",
            future: "{{count}} ",
            past: "{{count}}  "
        }
    },
    // TODO
    // aboutXWeeks: {},
    // TODO
    // xWeeks: {},
    aboutXMonths: {
        one: {
            default: " 1 ",
            future: " 1 ",
            past: " 1  "
        },
        other: {
            default: " {{count}} ",
            future: " {{count}} ",
            past: " {{count}}  "
        }
    },
    xMonths: {
        one: {
            default: "1 ",
            future: "1 ",
            past: "1  "
        },
        other: {
            default: "{{count}} ",
            future: "{{count}} ",
            past: "{{count}}  "
        }
    },
    aboutXYears: {
        one: {
            default: " 1 ",
            future: " 1 ",
            past: " 1  "
        },
        other: {
            default: " {{count}} ",
            future: " {{count}} ",
            past: " {{count}}  "
        }
    },
    xYears: {
        one: {
            default: "1 ",
            future: "1 ",
            past: "1  "
        },
        other: {
            default: "{{count}} ",
            future: "{{count}} ",
            past: "{{count}}  "
        }
    },
    overXYears: {
        one: {
            default: "1  ",
            future: "1  ",
            past: "1  "
        },
        other: {
            default: "{{count}}  ",
            future: "{{count}}  ",
            past: "{{count}}  "
        }
    },
    almostXYears: {
        one: {
            default: " 1 ",
            future: " 1 ",
            past: " 1 "
        },
        other: {
            default: " {{count}} ",
            future: " {{count}} ",
            past: " {{count}} "
        }
    }
};
function getResultByTense(parentToken, options2) {
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return parentToken.future;
        }
        else {
            return parentToken.past;
        }
    }
    return parentToken.default;
}
const formatDistance$B = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$B[token];
    if (tokenValue.one && count === 1) {
        result = getResultByTense(tokenValue.one, options2);
    }
    else {
        result = getResultByTense(tokenValue.other, options2);
    }
    return result.replace("{{count}}", String(count));
};
const dateFormats$B = {
    full: "EEEE, MMMM d, y",
    // CLDR 1816
    long: "MMMM d, y",
    // CLDR 1817
    medium: "MMM d, y",
    // CLDR 1818
    short: "d/M/yy"
    // CLDR 1819
};
const timeFormats$B = {
    full: "hh:mm:ss a zzzz",
    // CLDR 1820
    long: "hh:mm:ss a z",
    // CLDR 1821
    medium: "hh:mm:ss a",
    // CLDR 1822
    short: "hh:mm a"
    // CLDR 1823
};
const dateTimeFormats$B = {
    full: "{{date}} {{time}}",
    // CLDR 1824
    long: "{{date}} {{time}}",
    // CLDR 1825
    medium: "{{date}} {{time}}",
    // CLDR 1826
    short: "{{date}} {{time}}"
    // CLDR 1827
};
const formatLong$B = {
    date: buildFormatLongFn({
        formats: dateFormats$B,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$B,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$B,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$B = {
    lastWeek: "'' eeee p ''",
    yesterday: "'' p ''",
    today: "'' p ''",
    tomorrow: "'' p ''",
    nextWeek: "eeee p ''",
    other: "P"
};
const formatRelative$B = (token, _date, _baseDate, _options) => formatRelativeLocale$B[token];
const eraValues$B = {
    narrow: [".", "."],
    abbreviated: [".", "."],
    // CLDR #1618, #1620
    wide: [" ", " "]
    // CLDR #1614, #1616
};
const quarterValues$B = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: [" 1", " 2", " 3", " 4"],
    // CLDR #1630 - #1638
    wide: ["1 ", "2 ", "3 ", "4 "]
    // CLDR #1622 - #1629
};
const monthValues$B = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$B = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$B = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$t = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$B = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "";
};
const localize$B = {
    ordinalNumber: ordinalNumber$B,
    era: buildLocalizeFn({
        values: eraValues$B,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$B,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$B,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$B,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$B,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$t,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$B = /^(\d+)(|)?/i;
const parseOrdinalNumberPattern$B = /\d+/i;
const matchEraPatterns$B = {
    narrow: /^(.|.)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
    wide: /^( | | )/i
};
const parseEraPatterns$B = {
    any: [/^/i, /^(|)/i]
};
const matchQuarterPatterns$B = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]| [1234]| [1234]/i,
    wide: /^[1234]()? /i
};
const parseQuarterPatterns$B = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$B = {
    narrow: /^(|||||||||||)/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$B = {
    narrow: [
        /^$/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^$/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$B = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$B = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$B = {
    narrow: /^(||||||)/i,
    any: /^(||||||)/i
};
const parseDayPeriodPatterns$B = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: //i,
        noon: //i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$B = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$B,
        parsePattern: parseOrdinalNumberPattern$B,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$B,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$B,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$B,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$B,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$B,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$B,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$B,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$B,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$B,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$B,
        defaultParseWidth: "any"
    })
};
const kn = {
    code: "kn",
    formatDistance: formatDistance$B,
    formatLong: formatLong$B,
    formatRelative: formatRelative$B,
    localize: localize$B,
    match: match$B,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$A = {
    lessThanXSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    xSeconds: {
        one: "1",
        other: "{{count}}"
    },
    halfAMinute: "30",
    lessThanXMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    xMinutes: {
        one: "1",
        other: "{{count}}"
    },
    aboutXHours: {
        one: " 1",
        other: " {{count}}"
    },
    xHours: {
        one: "1",
        other: "{{count}}"
    },
    xDays: {
        one: "1",
        other: "{{count}}"
    },
    aboutXWeeks: {
        one: " 1",
        other: " {{count}}"
    },
    xWeeks: {
        one: "1",
        other: "{{count}}"
    },
    aboutXMonths: {
        one: " 1",
        other: " {{count}}"
    },
    xMonths: {
        one: "1",
        other: "{{count}}"
    },
    aboutXYears: {
        one: " 1",
        other: " {{count}}"
    },
    xYears: {
        one: "1",
        other: "{{count}}"
    },
    overXYears: {
        one: "1 ",
        other: "{{count}} "
    },
    almostXYears: {
        one: " 1",
        other: " {{count}}"
    }
};
const formatDistance$A = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$A[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " ";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$A = {
    full: "y M d EEEE",
    long: "y M d",
    medium: "y.MM.dd",
    short: "y.MM.dd"
};
const timeFormats$A = {
    full: "a H mm ss zzzz",
    long: "a H:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$A = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$A = {
    date: buildFormatLongFn({
        formats: dateFormats$A,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$A,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$A,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$A = {
    lastWeek: "'' eeee p",
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: "'' eeee p",
    other: "P"
};
const formatRelative$A = (token, _date, _baseDate, _options) => formatRelativeLocale$A[token];
const eraValues$A = {
    narrow: ["BC", "AD"],
    abbreviated: ["BC", "AD"],
    wide: ["", ""]
};
const quarterValues$A = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1", "2", "3", "4"]
};
const monthValues$A = {
    narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    abbreviated: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ],
    wide: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ]
};
const dayValues$A = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$A = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$s = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$A = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = String(options2?.unit);
    switch (unit) {
        case "minute":
        case "second":
            return String(number2);
        case "date":
            return number2 + "";
        default:
            return number2 + "";
    }
};
const localize$A = {
    ordinalNumber: ordinalNumber$A,
    era: buildLocalizeFn({
        values: eraValues$A,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$A,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$A,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$A,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$A,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$s,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$A = /^(\d+)(|)?/i;
const parseOrdinalNumberPattern$A = /\d+/i;
const matchEraPatterns$A = {
    narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(|)/i
};
const parseEraPatterns$A = {
    any: [/^(bc|)/i, /^(ad|)/i]
};
const matchQuarterPatterns$A = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234]?/i
};
const parseQuarterPatterns$A = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$A = {
    narrow: /^(1[012]|[123456789])/,
    abbreviated: /^(1[012]|[123456789])/i,
    wide: /^(1[012]|[123456789])/i
};
const parseMonthPatterns$A = {
    any: [
        /^1?$/,
        /^2/,
        /^3/,
        /^4/,
        /^5/,
        /^6/,
        /^7/,
        /^8/,
        /^9/,
        /^10/,
        /^11/,
        /^12/
    ]
};
const matchDayPatterns$A = {
    narrow: /^[]/,
    short: /^[]/,
    abbreviated: /^[]/,
    wide: /^[]/
};
const parseDayPatterns$A = {
    any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
};
const matchDayPeriodPatterns$A = {
    any: /^(am|pm|||||||)/i
};
const parseDayPeriodPatterns$A = {
    any: {
        am: /^(am|)/i,
        pm: /^(pm|)/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$A = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$A,
        parsePattern: parseOrdinalNumberPattern$A,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$A,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$A,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$A,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$A,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$A,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$A,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$A,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$A,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$A,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$A,
        defaultParseWidth: "any"
    })
};
const ko = {
    code: "ko",
    formatDistance: formatDistance$A,
    formatLong: formatLong$A,
    formatRelative: formatRelative$A,
    localize: localize$A,
    match: match$A,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$z = {
    lessThanXSeconds: {
        standalone: {
            one: "manner wi eng Sekonn",
            other: "manner wi {{count}} Sekonnen"
        },
        withPreposition: {
            one: "manner wi enger Sekonn",
            other: "manner wi {{count}} Sekonnen"
        }
    },
    xSeconds: {
        standalone: {
            one: "eng Sekonn",
            other: "{{count}} Sekonnen"
        },
        withPreposition: {
            one: "enger Sekonn",
            other: "{{count}} Sekonnen"
        }
    },
    halfAMinute: {
        standalone: "eng hallef Minutt",
        withPreposition: "enger hallwer Minutt"
    },
    lessThanXMinutes: {
        standalone: {
            one: "manner wi eng Minutt",
            other: "manner wi {{count}} Minutten"
        },
        withPreposition: {
            one: "manner wi enger Minutt",
            other: "manner wi {{count}} Minutten"
        }
    },
    xMinutes: {
        standalone: {
            one: "eng Minutt",
            other: "{{count}} Minutten"
        },
        withPreposition: {
            one: "enger Minutt",
            other: "{{count}} Minutten"
        }
    },
    aboutXHours: {
        standalone: {
            one: "ongefier eng Stonn",
            other: "ongefier {{count}} Stonnen"
        },
        withPreposition: {
            one: "ongefier enger Stonn",
            other: "ongefier {{count}} Stonnen"
        }
    },
    xHours: {
        standalone: {
            one: "eng Stonn",
            other: "{{count}} Stonnen"
        },
        withPreposition: {
            one: "enger Stonn",
            other: "{{count}} Stonnen"
        }
    },
    xDays: {
        standalone: {
            one: "een Dag",
            other: "{{count}} Deeg"
        },
        withPreposition: {
            one: "engem Dag",
            other: "{{count}} Deeg"
        }
    },
    aboutXWeeks: {
        standalone: {
            one: "ongefier eng Woch",
            other: "ongefier {{count}} Wochen"
        },
        withPreposition: {
            one: "ongefier enger Woche",
            other: "ongefier {{count}} Wochen"
        }
    },
    xWeeks: {
        standalone: {
            one: "eng Woch",
            other: "{{count}} Wochen"
        },
        withPreposition: {
            one: "enger Woch",
            other: "{{count}} Wochen"
        }
    },
    aboutXMonths: {
        standalone: {
            one: "ongefier ee Mount",
            other: "ongefier {{count}} Mint"
        },
        withPreposition: {
            one: "ongefier engem Mount",
            other: "ongefier {{count}} Mint"
        }
    },
    xMonths: {
        standalone: {
            one: "ee Mount",
            other: "{{count}} Mint"
        },
        withPreposition: {
            one: "engem Mount",
            other: "{{count}} Mint"
        }
    },
    aboutXYears: {
        standalone: {
            one: "ongefier ee Joer",
            other: "ongefier {{count}} Joer"
        },
        withPreposition: {
            one: "ongefier engem Joer",
            other: "ongefier {{count}} Joer"
        }
    },
    xYears: {
        standalone: {
            one: "ee Joer",
            other: "{{count}} Joer"
        },
        withPreposition: {
            one: "engem Joer",
            other: "{{count}} Joer"
        }
    },
    overXYears: {
        standalone: {
            one: "mi wi ee Joer",
            other: "mi wi {{count}} Joer"
        },
        withPreposition: {
            one: "mi wi engem Joer",
            other: "mi wi {{count}} Joer"
        }
    },
    almostXYears: {
        standalone: {
            one: "bal ee Joer",
            other: "bal {{count}} Joer"
        },
        withPreposition: {
            one: "bal engem Joer",
            other: "bal {{count}} Joer"
        }
    }
};
const EXCEPTION_CONSONANTS = ["d", "h", "n", "t", "z"];
const VOWELS = ["a,", "e", "i", "o", "u"];
const DIGITS_SPOKEN_N_NEEDED = [0, 1, 2, 3, 8, 9];
const FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED = [40, 50, 60, 70];
function isFinalNNeeded(nextWords) {
    const firstLetter = nextWords.charAt(0).toLowerCase();
    if (VOWELS.indexOf(firstLetter) != -1 || EXCEPTION_CONSONANTS.indexOf(firstLetter) != -1) {
        return true;
    }
    const firstWord = nextWords.split(" ")[0];
    const number2 = parseInt(firstWord);
    if (!isNaN(number2) && DIGITS_SPOKEN_N_NEEDED.indexOf(number2 % 10) != -1 && FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED.indexOf(parseInt(firstWord.substring(0, 2))) == -1) {
        return true;
    }
    return false;
}
const formatDistance$z = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$z[token];
    const usageGroup = options2?.addSuffix ? tokenValue.withPreposition : tokenValue.standalone;
    if (typeof usageGroup === "string") {
        result = usageGroup;
    }
    else if (count === 1) {
        result = usageGroup.one;
    }
    else {
        result = usageGroup.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "a" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
        }
        else {
            return "viru" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
        }
    }
    return result;
};
const dateFormats$z = {
    full: "EEEE, do MMMM y",
    // Mindeg, 7. Januar 2018
    long: "do MMMM y",
    // 7. Januar 2018
    medium: "do MMM y",
    // 7. Jan 2018
    short: "dd.MM.yy"
    // 07.01.18
};
const timeFormats$z = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$z = {
    full: "{{date}} 'um' {{time}}",
    long: "{{date}} 'um' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$z = {
    date: buildFormatLongFn({
        formats: dateFormats$z,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$z,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$z,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$z = {
    lastWeek: (date) => {
        const day = date.getDay();
        let result = "'lschte";
        if (day === 2 || day === 4) {
            result += "n";
        }
        result += "' eeee 'um' p";
        return result;
    },
    yesterday: "'gschter um' p",
    today: "'haut um' p",
    tomorrow: "'moien um' p",
    nextWeek: "eeee 'um' p",
    other: "P"
};
const formatRelative$z = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$z[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$z = {
    narrow: ["v.Chr.", "n.Chr."],
    abbreviated: ["v.Chr.", "n.Chr."],
    wide: ["viru Christus", "no Christus"]
};
const quarterValues$z = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$z = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Feb",
        "Me",
        "Abr",
        "Mee",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dez"
    ],
    wide: [
        "Januar",
        "Februar",
        "Merz",
        "Abrll",
        "Mee",
        "Juni",
        "Juli",
        "August",
        "September",
        "Oktober",
        "November",
        "Dezember"
    ]
};
const dayValues$z = {
    narrow: ["S", "M", "D", "M", "D", "F", "S"],
    short: ["So", "M", "D", "M", "Do", "Fr", "Sa"],
    abbreviated: ["So.", "M.", "D.", "M.", "Do.", "Fr.", "Sa."],
    wide: [
        "Sonndeg",
        "Mindeg",
        "Dnschdeg",
        "Mttwoch",
        "Donneschdeg",
        "Freideg",
        "Samschdeg"
    ]
};
const dayPeriodValues$z = {
    narrow: {
        am: "mo.",
        pm: "nom.",
        midnight: "Mtternuecht",
        noon: "Mtteg",
        morning: "Moien",
        afternoon: "Nomtteg",
        evening: "Owend",
        night: "Nuecht"
    },
    abbreviated: {
        am: "moies",
        pm: "nomttes",
        midnight: "Mtternuecht",
        noon: "Mtteg",
        morning: "Moien",
        afternoon: "Nomtteg",
        evening: "Owend",
        night: "Nuecht"
    },
    wide: {
        am: "moies",
        pm: "nomttes",
        midnight: "Mtternuecht",
        noon: "Mtteg",
        morning: "Moien",
        afternoon: "Nomtteg",
        evening: "Owend",
        night: "Nuecht"
    }
};
const formattingDayPeriodValues$r = {
    narrow: {
        am: "mo.",
        pm: "nom.",
        midnight: "Mtternuecht",
        noon: "mttes",
        morning: "moies",
        afternoon: "nomttes",
        evening: "owes",
        night: "nuets"
    },
    abbreviated: {
        am: "moies",
        pm: "nomttes",
        midnight: "Mtternuecht",
        noon: "mttes",
        morning: "moies",
        afternoon: "nomttes",
        evening: "owes",
        night: "nuets"
    },
    wide: {
        am: "moies",
        pm: "nomttes",
        midnight: "Mtternuecht",
        noon: "mttes",
        morning: "moies",
        afternoon: "nomttes",
        evening: "owes",
        night: "nuets"
    }
};
const ordinalNumber$z = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$z = {
    ordinalNumber: ordinalNumber$z,
    era: buildLocalizeFn({
        values: eraValues$z,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$z,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$z,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$z,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$z,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$r,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$z = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$z = /\d+/i;
const matchEraPatterns$z = {
    narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
    abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
    wide: /^(viru Christus|virun eiser Zitrechnung|no Christus|eiser Zitrechnung)/i
};
const parseEraPatterns$z = {
    any: [/^v/i, /^n/i]
};
const matchQuarterPatterns$z = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](\.)? Quartal/i
};
const parseQuarterPatterns$z = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$z = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|me|abr|mee|jun|jul|aug|sep|okt|nov|dez)/i,
    wide: /^(januar|februar|merz|abrll|mee|juni|juli|august|september|oktober|november|dezember)/i
};
const parseMonthPatterns$z = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^m/i,
        /^ab/i,
        /^me/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$z = {
    narrow: /^[smdf]/i,
    short: /^(so|m|d|m|do|fr|sa)/i,
    abbreviated: /^(son?|mi?|dn?|mt?|don?|fre?|sam?)\.?/i,
    wide: /^(sonndeg|mindeg|dnschdeg|mttwoch|donneschdeg|freideg|samschdeg)/i
};
const parseDayPatterns$z = {
    any: [/^so/i, /^m/i, /^d/i, /^m/i, /^do/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$z = {
    narrow: /^(mo\.?|nom\.?|Mtternuecht|mttes|moies|nomttes|owes|nuets)/i,
    abbreviated: /^(moi\.?|nomt\.?|Mtternuecht|mttes|moies|nomttes|owes|nuets)/i,
    wide: /^(moies|nomttes|Mtternuecht|mttes|moies|nomttes|owes|nuets)/i
};
const parseDayPeriodPatterns$z = {
    any: {
        am: /^m/i,
        pm: /^n/i,
        midnight: /^Mtter/i,
        noon: /^mttes/i,
        morning: /moies/i,
        afternoon: /nomttes/i,
        // will never be matched. Afternoon is matched by `pm`
        evening: /owes/i,
        night: /nuets/i
        // will never be matched. Night is matched by `pm`
    }
};
const match$z = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$z,
        parsePattern: parseOrdinalNumberPattern$z,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$z,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$z,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$z,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$z,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$z,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$z,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$z,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$z,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$z,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$z,
        defaultParseWidth: "any"
    })
};
const lb = {
    code: "lb",
    formatDistance: formatDistance$z,
    formatLong: formatLong$z,
    formatRelative: formatRelative$z,
    localize: localize$z,
    match: match$z,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const translations = {
    xseconds_other: "sekund_sekundi_sekundes",
    xminutes_one: "minut_minuts_minut",
    xminutes_other: "minuts_minui_minutes",
    xhours_one: "valanda_valandos_valand",
    xhours_other: "valandos_valand_valandas",
    xdays_one: "diena_dienos_dien",
    xdays_other: "dienos_dien_dienas",
    xweeks_one: "savait_savaits_savait",
    xweeks_other: "savaits_savaii_savaites",
    xmonths_one: "mnuo_mnesio_mnes",
    xmonths_other: "mnesiai_mnesi_mnesius",
    xyears_one: "metai_met_metus",
    xyears_other: "metai_met_metus",
    about: "apie",
    over: "daugiau nei",
    almost: "beveik",
    lessthan: "maiau nei"
};
const translateSeconds = (_number, addSuffix, _key, isFuture) => {
    if (!addSuffix) {
        return "kelios sekunds";
    }
    else {
        return isFuture ? "keli sekundi" : "kelias sekundes";
    }
};
const translateSingular = (_number, addSuffix, key, isFuture) => {
    return !addSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
};
const translate = (number2, addSuffix, key, isFuture) => {
    const result = number2 + " ";
    if (number2 === 1) {
        return result + translateSingular(number2, addSuffix, key, isFuture);
    }
    else if (!addSuffix) {
        return result + (special(number2) ? forms(key)[1] : forms(key)[0]);
    }
    else {
        if (isFuture) {
            return result + forms(key)[1];
        }
        else {
            return result + (special(number2) ? forms(key)[1] : forms(key)[2]);
        }
    }
};
function special(number2) {
    return number2 % 10 === 0 || number2 > 10 && number2 < 20;
}
function forms(key) {
    return translations[key].split("_");
}
const formatDistanceLocale$y = {
    lessThanXSeconds: {
        one: translateSeconds,
        other: translate
    },
    xSeconds: {
        one: translateSeconds,
        other: translate
    },
    halfAMinute: "pus minuts",
    lessThanXMinutes: {
        one: translateSingular,
        other: translate
    },
    xMinutes: {
        one: translateSingular,
        other: translate
    },
    aboutXHours: {
        one: translateSingular,
        other: translate
    },
    xHours: {
        one: translateSingular,
        other: translate
    },
    xDays: {
        one: translateSingular,
        other: translate
    },
    aboutXWeeks: {
        one: translateSingular,
        other: translate
    },
    xWeeks: {
        one: translateSingular,
        other: translate
    },
    aboutXMonths: {
        one: translateSingular,
        other: translate
    },
    xMonths: {
        one: translateSingular,
        other: translate
    },
    aboutXYears: {
        one: translateSingular,
        other: translate
    },
    xYears: {
        one: translateSingular,
        other: translate
    },
    overXYears: {
        one: translateSingular,
        other: translate
    },
    almostXYears: {
        one: translateSingular,
        other: translate
    }
};
const formatDistance$y = (token, count, options2) => {
    const adverb = token.match(/about|over|almost|lessthan/i);
    const unit = adverb ? token.replace(adverb[0], "") : token;
    const isFuture = options2?.comparison !== void 0 && options2.comparison > 0;
    let result;
    const tokenValue = formatDistanceLocale$y[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one(count, options2?.addSuffix === true, unit.toLowerCase() + "_one", isFuture);
    }
    else {
        result = tokenValue.other(count, options2?.addSuffix === true, unit.toLowerCase() + "_other", isFuture);
    }
    if (adverb) {
        const key = adverb[0].toLowerCase();
        result = translations[key] + " " + result;
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "po " + result;
        }
        else {
            return "prie " + result;
        }
    }
    return result;
};
const dateFormats$y = {
    full: "y 'm'. MMMM d 'd'., EEEE",
    long: "y 'm'. MMMM d 'd'.",
    medium: "y-MM-dd",
    short: "y-MM-dd"
};
const timeFormats$y = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$y = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$y = {
    date: buildFormatLongFn({
        formats: dateFormats$y,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$y,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$y,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$y = {
    lastWeek: "'Prajus' eeee p",
    yesterday: "'Vakar' p",
    today: "'iandien' p",
    tomorrow: "'Rytoj' p",
    nextWeek: "eeee p",
    other: "P"
};
const formatRelative$y = (token, _date, _baseDate, _options) => formatRelativeLocale$y[token];
const eraValues$y = {
    narrow: ["pr. Kr.", "po Kr."],
    abbreviated: ["pr. Kr.", "po Kr."],
    wide: ["prie Krist", "po Kristaus"]
};
const quarterValues$y = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["I ketv.", "II ketv.", "III ketv.", "IV ketv."],
    wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
};
const formattingQuarterValues$2 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["I k.", "II k.", "III k.", "IV k."],
    wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
};
const monthValues$y = {
    narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
    abbreviated: [
        "saus.",
        "vas.",
        "kov.",
        "bal.",
        "geg.",
        "bir.",
        "liep.",
        "rugp.",
        "rugs.",
        "spal.",
        "lapkr.",
        "gruod."
    ],
    wide: [
        "sausis",
        "vasaris",
        "kovas",
        "balandis",
        "gegu",
        "birelis",
        "liepa",
        "rugpjtis",
        "rugsjis",
        "spalis",
        "lapkritis",
        "gruodis"
    ]
};
const formattingMonthValues$8 = {
    narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
    abbreviated: [
        "saus.",
        "vas.",
        "kov.",
        "bal.",
        "geg.",
        "bir.",
        "liep.",
        "rugp.",
        "rugs.",
        "spal.",
        "lapkr.",
        "gruod."
    ],
    wide: [
        "sausio",
        "vasario",
        "kovo",
        "balandio",
        "gegus",
        "birelio",
        "liepos",
        "rugpjio",
        "rugsjo",
        "spalio",
        "lapkriio",
        "gruodio"
    ]
};
const dayValues$y = {
    narrow: ["S", "P", "A", "T", "K", "P", ""],
    short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "t"],
    abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "t"],
    wide: [
        "sekmadienis",
        "pirmadienis",
        "antradienis",
        "treiadienis",
        "ketvirtadienis",
        "penktadienis",
        "etadienis"
    ]
};
const formattingDayValues$2 = {
    narrow: ["S", "P", "A", "T", "K", "P", ""],
    short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "t"],
    abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "t"],
    wide: [
        "sekmadien",
        "pirmadien",
        "antradien",
        "treiadien",
        "ketvirtadien",
        "penktadien",
        "etadien"
    ]
};
const dayPeriodValues$y = {
    narrow: {
        am: "pr. p.",
        pm: "pop.",
        midnight: "vidurnaktis",
        noon: "vidurdienis",
        morning: "rytas",
        afternoon: "diena",
        evening: "vakaras",
        night: "naktis"
    },
    abbreviated: {
        am: "priepiet",
        pm: "popiet",
        midnight: "vidurnaktis",
        noon: "vidurdienis",
        morning: "rytas",
        afternoon: "diena",
        evening: "vakaras",
        night: "naktis"
    },
    wide: {
        am: "priepiet",
        pm: "popiet",
        midnight: "vidurnaktis",
        noon: "vidurdienis",
        morning: "rytas",
        afternoon: "diena",
        evening: "vakaras",
        night: "naktis"
    }
};
const formattingDayPeriodValues$q = {
    narrow: {
        am: "pr. p.",
        pm: "pop.",
        midnight: "vidurnaktis",
        noon: "perpiet",
        morning: "rytas",
        afternoon: "popiet",
        evening: "vakaras",
        night: "naktis"
    },
    abbreviated: {
        am: "priepiet",
        pm: "popiet",
        midnight: "vidurnaktis",
        noon: "perpiet",
        morning: "rytas",
        afternoon: "popiet",
        evening: "vakaras",
        night: "naktis"
    },
    wide: {
        am: "priepiet",
        pm: "popiet",
        midnight: "vidurnaktis",
        noon: "perpiet",
        morning: "rytas",
        afternoon: "popiet",
        evening: "vakaras",
        night: "naktis"
    }
};
const ordinalNumber$y = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "-oji";
};
const localize$y = {
    ordinalNumber: ordinalNumber$y,
    era: buildLocalizeFn({
        values: eraValues$y,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$y,
        defaultWidth: "wide",
        formattingValues: formattingQuarterValues$2,
        defaultFormattingWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$y,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$8,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$y,
        defaultWidth: "wide",
        formattingValues: formattingDayValues$2,
        defaultFormattingWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$y,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$q,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$y = /^(\d+)(-oji)?/i;
const parseOrdinalNumberPattern$y = /\d+/i;
const matchEraPatterns$y = {
    narrow: /^p(r|o)\.?\s?(kr\.?|me)/i,
    abbreviated: /^(pr\.\s?(kr\.|m\.\s?e\.)|po\s?kr\.|ms eroje)/i,
    wide: /^(prie Krist|prie ms er|po Kristaus|ms eroje)/i
};
const parseEraPatterns$y = {
    wide: [/prie/i, /(po|ms)/i],
    any: [/^pr/i, /^(po|m)/i]
};
const matchQuarterPatterns$y = {
    narrow: /^([1234])/i,
    abbreviated: /^(I|II|III|IV)\s?ketv?\.?/i,
    wide: /^(I|II|III|IV)\s?ketvirtis/i
};
const parseQuarterPatterns$y = {
    narrow: [/1/i, /2/i, /3/i, /4/i],
    any: [/I$/i, /II$/i, /III/i, /IV/i]
};
const matchMonthPatterns$y = {
    narrow: /^[svkbglr]/i,
    abbreviated: /^(saus\.|vas\.|kov\.|bal\.|geg\.|bir\.|liep\.|rugp\.|rugs\.|spal\.|lapkr\.|gruod\.)/i,
    wide: /^(sausi(s|o)|vasari(s|o)|kov(a|o)s|baland?i(s|o)|gegus?|bireli(s|o)|liep(a|os)|rugpj(t|)i(s|o)|rugsj(is|o)|spali(s|o)|lapkri(t|)i(s|o)|gruod?i(s|o))/i
};
const parseMonthPatterns$y = {
    narrow: [
        /^s/i,
        /^v/i,
        /^k/i,
        /^b/i,
        /^g/i,
        /^b/i,
        /^l/i,
        /^r/i,
        /^r/i,
        /^s/i,
        /^l/i,
        /^g/i
    ],
    any: [
        /^saus/i,
        /^vas/i,
        /^kov/i,
        /^bal/i,
        /^geg/i,
        /^bir/i,
        /^liep/i,
        /^rugp/i,
        /^rugs/i,
        /^spal/i,
        /^lapkr/i,
        /^gruod/i
    ]
};
const matchDayPatterns$y = {
    narrow: /^[spatk]/i,
    short: /^(sk|pr|an|tr|kt|pn|t)/i,
    abbreviated: /^(sk|pr|an|tr|kt|pn|t)/i,
    wide: /^(sekmadien(is|)|pirmadien(is|)|antradien(is|)|treiadien(is|)|ketvirtadien(is|)|penktadien(is|)|etadien(is|))/i
};
const parseDayPatterns$y = {
    narrow: [/^s/i, /^p/i, /^a/i, /^t/i, /^k/i, /^p/i, /^/i],
    wide: [/^se/i, /^pi/i, /^an/i, /^tr/i, /^ke/i, /^pe/i, /^e/i],
    any: [/^sk/i, /^pr/i, /^an/i, /^tr/i, /^kt/i, /^pn/i, /^t/i]
};
const matchDayPeriodPatterns$y = {
    narrow: /^(pr.\s?p.|pop.|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popiet)|vakaras|naktis)/i,
    any: /^(priepiet|popiet$|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popiet)|vakaras|naktis)/i
};
const parseDayPeriodPatterns$y = {
    narrow: {
        am: /^pr/i,
        pm: /^pop./i,
        midnight: /^vidurnaktis/i,
        noon: /^(vidurdienis|perp)/i,
        morning: /rytas/i,
        afternoon: /(die|popiet)/i,
        evening: /vakaras/i,
        night: /naktis/i
    },
    any: {
        am: /^pr/i,
        pm: /^popiet$/i,
        midnight: /^vidurnaktis/i,
        noon: /^(vidurdienis|perp)/i,
        morning: /rytas/i,
        afternoon: /(die|popiet)/i,
        evening: /vakaras/i,
        night: /naktis/i
    }
};
const match$y = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$y,
        parsePattern: parseOrdinalNumberPattern$y,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$y,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$y,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$y,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$y,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$y,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$y,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$y,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$y,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$y,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$y,
        defaultParseWidth: "any"
    })
};
const lt = {
    code: "lt",
    formatDistance: formatDistance$y,
    formatLong: formatLong$y,
    formatRelative: formatRelative$y,
    localize: localize$y,
    match: match$y,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
function buildLocalizeTokenFn$2(schema2) {
    return (count, options2) => {
        if (count === 1) {
            if (options2?.addSuffix) {
                return schema2.one[0].replace("{{time}}", schema2.one[2]);
            }
            else {
                return schema2.one[0].replace("{{time}}", schema2.one[1]);
            }
        }
        else {
            const rem = count % 10 === 1 && count % 100 !== 11;
            if (options2?.addSuffix) {
                return schema2.other[0].replace("{{time}}", rem ? schema2.other[3] : schema2.other[4]).replace("{{count}}", String(count));
            }
            else {
                return schema2.other[0].replace("{{time}}", rem ? schema2.other[1] : schema2.other[2]).replace("{{count}}", String(count));
            }
        }
    };
}
const formatDistanceLocale$x = {
    lessThanXSeconds: buildLocalizeTokenFn$2({
        one: ["mazk par {{time}}", "sekundi", "sekundi"],
        other: [
            "mazk nek {{count}} {{time}}",
            "sekunde",
            "sekundes",
            "sekundes",
            "sekundm"
        ]
    }),
    xSeconds: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "sekunde", "sekundes"],
        other: [
            "{{count}} {{time}}",
            "sekunde",
            "sekundes",
            "sekundes",
            "sekundm"
        ]
    }),
    halfAMinute: (_count, options2) => {
        if (options2?.addSuffix) {
            return "pusmintes";
        }
        else {
            return "pusminte";
        }
    },
    lessThanXMinutes: buildLocalizeTokenFn$2({
        one: ["mazk par {{time}}", "minti", "minti"],
        other: [
            "mazk nek {{count}} {{time}}",
            "minte",
            "mintes",
            "mintes",
            "mintm"
        ]
    }),
    xMinutes: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "minte", "mintes"],
        other: ["{{count}} {{time}}", "minte", "mintes", "mintes", "mintm"]
    }),
    aboutXHours: buildLocalizeTokenFn$2({
        one: ["apmram 1 {{time}}", "stunda", "stundas"],
        other: [
            "apmram {{count}} {{time}}",
            "stunda",
            "stundas",
            "stundas",
            "stundm"
        ]
    }),
    xHours: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "stunda", "stundas"],
        other: ["{{count}} {{time}}", "stunda", "stundas", "stundas", "stundm"]
    }),
    xDays: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "diena", "dienas"],
        other: ["{{count}} {{time}}", "diena", "dienas", "dienas", "dienm"]
    }),
    aboutXWeeks: buildLocalizeTokenFn$2({
        one: ["apmram 1 {{time}}", "neda", "nedas"],
        other: [
            "apmram {{count}} {{time}}",
            "neda",
            "nedu",
            "nedas",
            "nedm"
        ]
    }),
    xWeeks: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "neda", "nedas"],
        other: [
            "{{count}} {{time}}",
            // TODO
            "neda",
            "nedu",
            "nedas",
            "nedm"
        ]
    }),
    aboutXMonths: buildLocalizeTokenFn$2({
        one: ["apmram 1 {{time}}", "mnesis", "mnea"],
        other: [
            "apmram {{count}} {{time}}",
            "mnesis",
            "mnei",
            "mnea",
            "mneiem"
        ]
    }),
    xMonths: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "mnesis", "mnea"],
        other: ["{{count}} {{time}}", "mnesis", "mnei", "mnea", "mneiem"]
    }),
    aboutXYears: buildLocalizeTokenFn$2({
        one: ["apmram 1 {{time}}", "gads", "gada"],
        other: ["apmram {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
    }),
    xYears: buildLocalizeTokenFn$2({
        one: ["1 {{time}}", "gads", "gada"],
        other: ["{{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
    }),
    overXYears: buildLocalizeTokenFn$2({
        one: ["ilgk par 1 {{time}}", "gadu", "gadu"],
        other: ["vairk nek {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
    }),
    almostXYears: buildLocalizeTokenFn$2({
        one: ["gandrz 1 {{time}}", "gads", "gada"],
        other: ["vairk nek {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
    })
};
const formatDistance$x = (token, count, options2) => {
    const result = formatDistanceLocale$x[token](count, options2);
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "pc " + result;
        }
        else {
            return "pirms " + result;
        }
    }
    return result;
};
const dateFormats$x = {
    full: "EEEE, y. 'gada' d. MMMM",
    long: "y. 'gada' d. MMMM",
    medium: "dd.MM.y.",
    short: "dd.MM.y."
};
const timeFormats$x = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$x = {
    full: "{{date}} 'plkst.' {{time}}",
    long: "{{date}} 'plkst.' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$x = {
    date: buildFormatLongFn({
        formats: dateFormats$x,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$x,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$x,
        defaultWidth: "full"
    })
};
const weekdays$1 = [
    "svtdien",
    "pirmdien",
    "otrdien",
    "tredien",
    "ceturtdien",
    "piektdien",
    "sestdien"
];
const formatRelativeLocale$x = {
    lastWeek: (date, baseDate, options2) => {
        if (isSameWeek(date, baseDate, options2)) {
            return "eeee 'plkst.' p";
        }
        const weekday = weekdays$1[date.getDay()];
        return "'Pagju " + weekday + " plkst.' p";
    },
    yesterday: "'Vakar plkst.' p",
    today: "'odien plkst.' p",
    tomorrow: "'Rt plkst.' p",
    nextWeek: (date, baseDate, options2) => {
        if (isSameWeek(date, baseDate, options2)) {
            return "eeee 'plkst.' p";
        }
        const weekday = weekdays$1[date.getDay()];
        return "'Nkamaj " + weekday + " plkst.' p";
    },
    other: "P"
};
const formatRelative$x = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$x[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$x = {
    narrow: ["p.m.", "m."],
    abbreviated: ["p. m. .", "m. ."],
    wide: ["pirms msu ras", "msu r"]
};
const quarterValues$x = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
    wide: [
        "pirmais ceturksnis",
        "otrais ceturksnis",
        "treais ceturksnis",
        "ceturtais ceturksnis"
    ]
};
const formattingQuarterValues$1 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
    wide: [
        "pirmaj ceturksn",
        "otraj ceturksn",
        "treaj ceturksn",
        "ceturtaj ceturksn"
    ]
};
const monthValues$x = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "janv.",
        "febr.",
        "marts",
        "apr.",
        "maijs",
        "jn.",
        "jl.",
        "aug.",
        "sept.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "janvris",
        "februris",
        "marts",
        "aprlis",
        "maijs",
        "jnijs",
        "jlijs",
        "augusts",
        "septembris",
        "oktobris",
        "novembris",
        "decembris"
    ]
};
const formattingMonthValues$7 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "janv.",
        "febr.",
        "mart",
        "apr.",
        "maijs",
        "jn.",
        "jl.",
        "aug.",
        "sept.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "janvr",
        "februr",
        "mart",
        "aprl",
        "maij",
        "jnij",
        "jlij",
        "august",
        "septembr",
        "oktobr",
        "novembr",
        "decembr"
    ]
};
const dayValues$x = {
    narrow: ["S", "P", "O", "T", "C", "P", "S"],
    short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
    abbreviated: [
        "svtd.",
        "pirmd.",
        "otrd.",
        "tred.",
        "ceturtd.",
        "piektd.",
        "sestd."
    ],
    wide: [
        "svtdiena",
        "pirmdiena",
        "otrdiena",
        "trediena",
        "ceturtdiena",
        "piektdiena",
        "sestdiena"
    ]
};
const formattingDayValues$1 = {
    narrow: ["S", "P", "O", "T", "C", "P", "S"],
    short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
    abbreviated: [
        "svtd.",
        "pirmd.",
        "otrd.",
        "tred.",
        "ceturtd.",
        "piektd.",
        "sestd."
    ],
    wide: [
        "svtdien",
        "pirmdien",
        "otrdien",
        "tredien",
        "ceturtdien",
        "piektdien",
        "sestdien"
    ]
};
const dayPeriodValues$x = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "pusn.",
        noon: "pusd.",
        morning: "rts",
        afternoon: "diena",
        evening: "vakars",
        night: "nakts"
    },
    abbreviated: {
        am: "am",
        pm: "pm",
        midnight: "pusn.",
        noon: "pusd.",
        morning: "rts",
        afternoon: "pcpusd.",
        evening: "vakars",
        night: "nakts"
    },
    wide: {
        am: "am",
        pm: "pm",
        midnight: "pusnakts",
        noon: "pusdienlaiks",
        morning: "rts",
        afternoon: "pcpusdiena",
        evening: "vakars",
        night: "nakts"
    }
};
const formattingDayPeriodValues$p = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "pusn.",
        noon: "pusd.",
        morning: "rt",
        afternoon: "dien",
        evening: "vakar",
        night: "nakt"
    },
    abbreviated: {
        am: "am",
        pm: "pm",
        midnight: "pusn.",
        noon: "pusd.",
        morning: "rt",
        afternoon: "pcpusd.",
        evening: "vakar",
        night: "nakt"
    },
    wide: {
        am: "am",
        pm: "pm",
        midnight: "pusnakt",
        noon: "pusdienlaik",
        morning: "rt",
        afternoon: "pcpusdien",
        evening: "vakar",
        night: "nakt"
    }
};
const ordinalNumber$x = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$x = {
    ordinalNumber: ordinalNumber$x,
    era: buildLocalizeFn({
        values: eraValues$x,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$x,
        defaultWidth: "wide",
        formattingValues: formattingQuarterValues$1,
        defaultFormattingWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$x,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$7,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$x,
        defaultWidth: "wide",
        formattingValues: formattingDayValues$1,
        defaultFormattingWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$x,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$p,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$x = /^(\d+)\./i;
const parseOrdinalNumberPattern$x = /\d+/i;
const matchEraPatterns$x = {
    narrow: /^(p\.m\.|m\.)/i,
    abbreviated: /^(p\. m\. \.|m\. \.)/i,
    wide: /^(pirms msu ras|msu r)/i
};
const parseEraPatterns$x = {
    any: [/^p/i, /^m/i]
};
const matchQuarterPatterns$x = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](\. cet\.)/i,
    wide: /^(pirma(is|j)|otra(is|j)|trea(is|j)|ceturta(is|j)) ceturksn(is|)/i
};
const parseQuarterPatterns$x = {
    narrow: [/^1/i, /^2/i, /^3/i, /^4/i],
    abbreviated: [/^1/i, /^2/i, /^3/i, /^4/i],
    wide: [/^p/i, /^o/i, /^t/i, /^c/i]
};
const matchMonthPatterns$x = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(janv\.|febr\.|marts|apr\.|maijs|jn\.|jl\.|aug\.|sept\.|okt\.|nov\.|dec\.)/i,
    wide: /^(janvr(is|)|februr(is|)|mart[s]|aprl(is|)|maij[s]|jnij[s]|jlij[s]|august[s]|septembr(is|)|oktobr(is|)|novembr(is|)|decembr(is|))/i
};
const parseMonthPatterns$x = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mai/i,
        /^jn/i,
        /^jl/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$x = {
    narrow: /^[spotc]/i,
    short: /^(sv|pi|o|t|c|pk|s)/i,
    abbreviated: /^(svtd\.|pirmd\.|otrd.\|tred\.|ceturtd\.|piektd\.|sestd\.)/i,
    wide: /^(svtdien(a|)|pirmdien(a|)|otrdien(a|)|tredien(a|)|ceturtdien(a|)|piektdien(a|)|sestdien(a|))/i
};
const parseDayPatterns$x = {
    narrow: [/^s/i, /^p/i, /^o/i, /^t/i, /^c/i, /^p/i, /^s/i],
    any: [/^sv/i, /^pi/i, /^o/i, /^t/i, /^c/i, /^p/i, /^se/i]
};
const matchDayPeriodPatterns$x = {
    narrow: /^(am|pm|pusn\.|pusd\.|rt(s|)|dien(a|)|vakar(s|)|nakt(s|))/,
    abbreviated: /^(am|pm|pusn\.|pusd\.|rt(s|)|pcpusd\.|vakar(s|)|nakt(s|))/,
    wide: /^(am|pm|pusnakt(s|)|pusdienlaik(s|)|rt(s|)|pcpusdien(a|)|vakar(s|)|nakt(s|))/i
};
const parseDayPeriodPatterns$x = {
    any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /^pusn/i,
        noon: /^pusd/i,
        morning: /^r/i,
        afternoon: /^(d|pc)/i,
        evening: /^v/i,
        night: /^n/i
    }
};
const match$x = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$x,
        parsePattern: parseOrdinalNumberPattern$x,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$x,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$x,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$x,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$x,
        defaultParseWidth: "wide",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$x,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$x,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$x,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$x,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$x,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$x,
        defaultParseWidth: "any"
    })
};
const lv = {
    code: "lv",
    formatDistance: formatDistance$x,
    formatLong: formatLong$x,
    formatRelative: formatRelative$x,
    localize: localize$x,
    match: match$x,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$w = {
    lessThanXSeconds: {
        one: "  ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "  1 ",
        other: "  {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$w = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$w[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$w = {
    full: "EEEE, dd MMMM yyyy",
    long: "dd MMMM yyyy",
    medium: "dd MMM yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$w = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$w = {
    any: "{{date}} {{time}}"
};
const formatLong$w = {
    date: buildFormatLongFn({
        formats: dateFormats$w,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$w,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$w,
        defaultWidth: "any"
    })
};
const weekdays = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek$3(day) {
    const weekday = weekdays[day];
    switch (day) {
        case 0:
        case 3:
        case 6:
            return "' " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
        case 5:
            return "' " + weekday + " ' p";
    }
}
function thisWeek$3(day) {
    const weekday = weekdays[day];
    switch (day) {
        case 0:
        case 3:
        case 6:
            return "' " + weekday + " o' p";
        case 1:
        case 2:
        case 4:
        case 5:
            return "' " + weekday + " o' p";
    }
}
function nextWeek$3(day) {
    const weekday = weekdays[day];
    switch (day) {
        case 0:
        case 3:
        case 6:
            return "' " + weekday + " o' p";
        case 1:
        case 2:
        case 4:
        case 5:
            return "' " + weekday + " o' p";
    }
}
const formatRelativeLocale$w = {
    lastWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$3(day);
        }
        else {
            return lastWeek$3(day);
        }
    },
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$3(day);
        }
        else {
            return nextWeek$3(day);
        }
    },
    other: "P"
};
const formatRelative$w = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$w[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$w = {
    narrow: ["...", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
};
const quarterValues$w = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$w = {
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$w = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$w = {
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$w = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
                return number2 + "-";
            case 2:
                return number2 + "-";
            case 7:
            case 8:
                return number2 + "-";
        }
    }
    return number2 + "-";
};
const localize$w = {
    ordinalNumber: ordinalNumber$w,
    era: buildLocalizeFn({
        values: eraValues$w,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$w,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$w,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$w,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$w,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$w = /^(\d+)(-?[][])?/i;
const parseOrdinalNumberPattern$w = /\d+/i;
const matchEraPatterns$w = {
    narrow: /^(()?\.?\s?\.?)/i,
    abbreviated: /^(()?\.?\s?\.?)/i,
    wide: /^(  | )/i
};
const parseEraPatterns$w = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$w = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]??)? .?/i,
    wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$w = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchDayPatterns$w = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$w = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^[]/i, /^[]/i, /^/i, /^/i, /^[]/i, /^[]/i, /^[]/i]
};
const matchMonthPatterns$w = {
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$w = {
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPeriodPatterns$w = {
    any: /^(||||||)/i
};
const parseDayPeriodPatterns$w = {
    any: {
        am: //i,
        pm: //i,
        midnight: //i,
        noon: //i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$w = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$w,
        parsePattern: parseOrdinalNumberPattern$w,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$w,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$w,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$w,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$w,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$w,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$w,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$w,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$w,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$w,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$w,
        defaultParseWidth: "any"
    })
};
const mk = {
    code: "mk",
    formatDistance: formatDistance$w,
    formatLong: formatLong$w,
    formatRelative: formatRelative$w,
    localize: localize$w,
    match: match$w,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$v = {
    lessThanXSeconds: {
        one: " ",
        other: "{{count}}  "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: " ",
        other: "{{count}}  "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1  ",
        other: " {{count}}  "
    },
    xWeeks: {
        one: "1  ",
        other: "{{count}}  "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "1  ",
        other: "{{count}}  "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$v = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$v[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        const words = result.split(" ");
        const lastword = words.pop();
        result = words.join(" ");
        switch (lastword) {
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += " ";
                break;
            case "":
                result += "  ";
                break;
            default:
                result += lastword + "-";
        }
        if (options2.comparison && options2.comparison > 0) {
            return result + " ";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$v = {
    full: "y '' MMMM'' d, EEEE ''",
    long: "y '' MMMM'' d",
    medium: "y '' MMM'' d",
    short: "y.MM.dd"
};
const timeFormats$v = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$v = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$v = {
    date: buildFormatLongFn({
        formats: dateFormats$v,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$v,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$v,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$v = {
    lastWeek: "'' eeee '' p ''",
    yesterday: "'' p ''",
    today: "'' p ''",
    tomorrow: "'' p ''",
    nextWeek: "'' eeee '' p ''",
    other: "P"
};
const formatRelative$v = (token, _date, _baseDate, _options) => formatRelativeLocale$v[token];
const eraValues$v = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: ["  ", " "]
};
const quarterValues$v = {
    narrow: ["I", "II", "III", "IV"],
    abbreviated: ["I ", "II ", "III ", "IV "],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$v = {
    narrow: [
        "I",
        "II",
        "III",
        "IV",
        "V",
        "VI",
        "VII",
        "VIII",
        "IX",
        "X",
        "XI",
        "XII"
    ],
    abbreviated: [
        "1- ",
        "2- ",
        "3- ",
        "4- ",
        "5- ",
        "6- ",
        "7- ",
        "8- ",
        "9- ",
        "10- ",
        "11- ",
        "12- "
    ],
    wide: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        "  "
    ]
};
const formattingMonthValues$6 = {
    narrow: [
        "I",
        "II",
        "III",
        "IV",
        "V",
        "VI",
        "VII",
        "VIII",
        "IX",
        "X",
        "XI",
        "XII"
    ],
    abbreviated: [
        "1- ",
        "2- ",
        "3- ",
        "4- ",
        "5- ",
        "6- ",
        "7- ",
        "8- ",
        "9- ",
        "10- ",
        "11- ",
        "12- "
    ],
    wide: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        "  "
    ]
};
const dayValues$v = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const formattingDayValues = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$v = {
    narrow: {
        am: "..",
        pm: "..",
        midnight: " ",
        noon: " ",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "..",
        pm: "..",
        midnight: " ",
        noon: " ",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "..",
        pm: "..",
        midnight: " ",
        noon: " ",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$v = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$v = {
    ordinalNumber: ordinalNumber$v,
    era: buildLocalizeFn({
        values: eraValues$v,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$v,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$v,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$6,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$v,
        defaultWidth: "wide",
        formattingValues: formattingDayValues,
        defaultFormattingWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$v,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$v = /\d+/i;
const parseOrdinalNumberPattern$v = /\d+/i;
const matchEraPatterns$v = {
    narrow: /^(|)/i,
    abbreviated: /^(|)/i,
    wide: /^(  | )/i
};
const parseEraPatterns$v = {
    any: [/^(|  )/i, /^(| )/i]
};
const matchQuarterPatterns$v = {
    narrow: /^(iv|iii|ii|i)/i,
    abbreviated: /^(iv|iii|ii|i) /i,
    wide: /^[1-4]- /i
};
const parseQuarterPatterns$v = {
    any: [/^(i(\s|$)|1)/i, /^(ii(\s|$)|2)/i, /^(iii(\s|$)|3)/i, /^(iv(\s|$)|4)/i]
};
const matchMonthPatterns$v = {
    narrow: /^(xii|xi|x|ix|viii|vii|vi|v|iv|iii|ii|i)/i,
    abbreviated: /^(1- |2- |3- |4- |5- |6- |7- |8- |9- |10- |11- |12- )/i,
    wide: /^( | | | | | | | | | |  |  )/i
};
const parseMonthPatterns$v = {
    narrow: [
        /^i$/i,
        /^ii$/i,
        /^iii$/i,
        /^iv$/i,
        /^v$/i,
        /^vi$/i,
        /^vii$/i,
        /^viii$/i,
        /^ix$/i,
        /^x$/i,
        /^xi$/i,
        /^xii$/i
    ],
    any: [
        /^(1|)/i,
        /^(2|)/i,
        /^(3|)/i,
        /^(4|)/i,
        /^(5|)/i,
        /^(6|)/i,
        /^(7|)/i,
        /^(8|)/i,
        /^(9|)/i,
        /^(10|)/i,
        /^(11| )/i,
        /^(12| )/i
    ]
};
const matchDayPatterns$v = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$v = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$v = {
    narrow: /^(\.\.|\.\.| | ||||)/i,
    any: /^(\.\.|\.\.| | ||||)/i
};
const parseDayPeriodPatterns$v = {
    any: {
        am: /^\.\./i,
        pm: /^\.\./i,
        midnight: /^ /i,
        noon: /^ /i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$v = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$v,
        parsePattern: parseOrdinalNumberPattern$v,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$v,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$v,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$v,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$v,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$v,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$v,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$v,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$v,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$v,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$v,
        defaultParseWidth: "any"
    })
};
const mn = {
    code: "mn",
    formatDistance: formatDistance$v,
    formatLong: formatLong$v,
    formatRelative: formatRelative$v,
    localize: localize$v,
    match: match$v,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$u = {
    lessThanXSeconds: {
        one: "kurang dari 1 saat",
        other: "kurang dari {{count}} saat"
    },
    xSeconds: {
        one: "1 saat",
        other: "{{count}} saat"
    },
    halfAMinute: "setengah minit",
    lessThanXMinutes: {
        one: "kurang dari 1 minit",
        other: "kurang dari {{count}} minit"
    },
    xMinutes: {
        one: "1 minit",
        other: "{{count}} minit"
    },
    aboutXHours: {
        one: "sekitar 1 jam",
        other: "sekitar {{count}} jam"
    },
    xHours: {
        one: "1 jam",
        other: "{{count}} jam"
    },
    xDays: {
        one: "1 hari",
        other: "{{count}} hari"
    },
    aboutXWeeks: {
        one: "sekitar 1 minggu",
        other: "sekitar {{count}} minggu"
    },
    xWeeks: {
        one: "1 minggu",
        other: "{{count}} minggu"
    },
    aboutXMonths: {
        one: "sekitar 1 bulan",
        other: "sekitar {{count}} bulan"
    },
    xMonths: {
        one: "1 bulan",
        other: "{{count}} bulan"
    },
    aboutXYears: {
        one: "sekitar 1 tahun",
        other: "sekitar {{count}} tahun"
    },
    xYears: {
        one: "1 tahun",
        other: "{{count}} tahun"
    },
    overXYears: {
        one: "lebih dari 1 tahun",
        other: "lebih dari {{count}} tahun"
    },
    almostXYears: {
        one: "hampir 1 tahun",
        other: "hampir {{count}} tahun"
    }
};
const formatDistance$u = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$u[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "dalam masa " + result;
        }
        else {
            return result + " yang lalu";
        }
    }
    return result;
};
const dateFormats$u = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "d/M/yyyy"
};
const timeFormats$u = {
    full: "HH.mm.ss",
    long: "HH.mm.ss",
    medium: "HH.mm",
    short: "HH.mm"
};
const dateTimeFormats$u = {
    full: "{{date}} 'pukul' {{time}}",
    long: "{{date}} 'pukul' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$u = {
    date: buildFormatLongFn({
        formats: dateFormats$u,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$u,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$u,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$u = {
    lastWeek: "eeee 'lepas pada jam' p",
    yesterday: "'Semalam pada jam' p",
    today: "'Hari ini pada jam' p",
    tomorrow: "'Esok pada jam' p",
    nextWeek: "eeee 'pada jam' p",
    other: "P"
};
const formatRelative$u = (token, _date, _baseDate, _options) => formatRelativeLocale$u[token];
const eraValues$u = {
    narrow: ["SM", "M"],
    abbreviated: ["SM", "M"],
    wide: ["Sebelum Masihi", "Masihi"]
};
const quarterValues$u = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["S1", "S2", "S3", "S4"],
    wide: ["Suku pertama", "Suku kedua", "Suku ketiga", "Suku keempat"]
};
const monthValues$u = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Feb",
        "Mac",
        "Apr",
        "Mei",
        "Jun",
        "Jul",
        "Ogo",
        "Sep",
        "Okt",
        "Nov",
        "Dis"
    ],
    wide: [
        "Januari",
        "Februari",
        "Mac",
        "April",
        "Mei",
        "Jun",
        "Julai",
        "Ogos",
        "September",
        "Oktober",
        "November",
        "Disember"
    ]
};
const dayValues$u = {
    narrow: ["A", "I", "S", "R", "K", "J", "S"],
    short: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
    abbreviated: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
    wide: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
};
const dayPeriodValues$u = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "tgh malam",
        noon: "tgh hari",
        morning: "pagi",
        afternoon: "tengah hari",
        evening: "petang",
        night: "malam"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "tengah hari",
        evening: "petang",
        night: "malam"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "tengah hari",
        evening: "petang",
        night: "malam"
    }
};
const formattingDayPeriodValues$o = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "tengah hari",
        evening: "petang",
        night: "malam"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "tengah hari",
        evening: "petang",
        night: "malam"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "tengah malam",
        noon: "tengah hari",
        morning: "pagi",
        afternoon: "tengah hari",
        evening: "petang",
        night: "malam"
    }
};
const ordinalNumber$u = (dirtyNumber, _options) => {
    return "ke-" + Number(dirtyNumber);
};
const localize$u = {
    ordinalNumber: ordinalNumber$u,
    era: buildLocalizeFn({
        values: eraValues$u,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$u,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$u,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$u,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$u,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$o,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$u = /^ke-(\d+)?/i;
const parseOrdinalNumberPattern$u = /petama|\d+/i;
const matchEraPatterns$u = {
    narrow: /^(sm|m)/i,
    abbreviated: /^(s\.?\s?m\.?|m\.?)/i,
    wide: /^(sebelum masihi|masihi)/i
};
const parseEraPatterns$u = {
    any: [/^s/i, /^(m)/i]
};
const matchQuarterPatterns$u = {
    narrow: /^[1234]/i,
    abbreviated: /^S[1234]/i,
    wide: /Suku (pertama|kedua|ketiga|keempat)/i
};
const parseQuarterPatterns$u = {
    any: [/pertama|1/i, /kedua|2/i, /ketiga|3/i, /keempat|4/i]
};
const matchMonthPatterns$u = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mac|apr|mei|jun|jul|ogo|sep|okt|nov|dis)/i,
    wide: /^(januari|februari|mac|april|mei|jun|julai|ogos|september|oktober|november|disember)/i
};
const parseMonthPatterns$u = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^o/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^ma/i,
        /^ap/i,
        /^me/i,
        /^jun/i,
        /^jul/i,
        /^og/i,
        /^s/i,
        /^ok/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$u = {
    narrow: /^[aisrkj]/i,
    short: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
    abbreviated: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
    wide: /^(ahad|isnin|selasa|rabu|khamis|jumaat|sabtu)/i
};
const parseDayPatterns$u = {
    narrow: [/^a/i, /^i/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
    any: [/^a/i, /^i/i, /^se/i, /^r/i, /^k/i, /^j/i, /^sa/i]
};
const matchDayPeriodPatterns$u = {
    narrow: /^(am|pm|tengah malam|tengah hari|pagi|petang|malam)/i,
    any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|pagi|petang|malam)/i
};
const parseDayPeriodPatterns$u = {
    any: {
        am: /^a/i,
        pm: /^pm/i,
        midnight: /^tengah m/i,
        noon: /^tengah h/i,
        morning: /pa/i,
        afternoon: /tengah h/i,
        evening: /pe/i,
        night: /m/i
    }
};
const match$u = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$u,
        parsePattern: parseOrdinalNumberPattern$u,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$u,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$u,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$u,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$u,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$u,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$u,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$u,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$u,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$u,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$u,
        defaultParseWidth: "any"
    })
};
const ms = {
    code: "ms",
    formatDistance: formatDistance$u,
    formatLong: formatLong$u,
    formatRelative: formatRelative$u,
    localize: localize$u,
    match: match$u,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$t = {
    lessThanXSeconds: {
        one: "inqas minn sekonda",
        other: "inqas minn {{count}} sekondi"
    },
    xSeconds: {
        one: "sekonda",
        other: "{{count}} sekondi"
    },
    halfAMinute: "nofs minuta",
    lessThanXMinutes: {
        one: "inqas minn minuta",
        other: "inqas minn {{count}} minuti"
    },
    xMinutes: {
        one: "minuta",
        other: "{{count}} minuti"
    },
    aboutXHours: {
        one: "madwar siega",
        other: "madwar {{count}} siegat"
    },
    xHours: {
        one: "siega",
        other: "{{count}} siegat"
    },
    xDays: {
        one: "urnata",
        other: "{{count}} ranet"
    },
    aboutXWeeks: {
        one: "madwar imga",
        other: "madwar {{count}} imgat"
    },
    xWeeks: {
        one: "imga",
        other: "{{count}} imgat"
    },
    aboutXMonths: {
        one: "madwar xahar",
        other: "madwar {{count}} xhur"
    },
    xMonths: {
        one: "xahar",
        other: "{{count}} xhur"
    },
    aboutXYears: {
        one: "madwar sena",
        two: "madwar sentejn",
        other: "madwar {{count}} snin"
    },
    xYears: {
        one: "sena",
        two: "sentejn",
        other: "{{count}} snin"
    },
    overXYears: {
        one: "aktar minn sena",
        two: "aktar minn sentejn",
        other: "aktar minn {{count}} snin"
    },
    almostXYears: {
        one: "kwai sena",
        two: "kwai sentejn",
        other: "kwai {{count}} snin"
    }
};
const formatDistance$t = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$t[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else if (count === 2 && tokenValue.two) {
        result = tokenValue.two;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "f'" + result;
        }
        else {
            return result + " ilu";
        }
    }
    return result;
};
const dateFormats$t = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "dd/MM/yyyy"
};
const timeFormats$t = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$t = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$t = {
    date: buildFormatLongFn({
        formats: dateFormats$t,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$t,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$t,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$t = {
    lastWeek: "eeee 'li gadda' 'fil-'p",
    yesterday: "'Il-biera fil-'p",
    today: "'Illum fil-'p",
    tomorrow: "'Gada fil-'p",
    nextWeek: "eeee 'fil-'p",
    other: "P"
};
const formatRelative$t = (token, _date, _baseDate, _options) => formatRelativeLocale$t[token];
const eraValues$t = {
    narrow: ["Q", "W"],
    abbreviated: ["QK", "WK"],
    wide: ["qabel Kristu", "wara Kristu"]
};
const quarterValues$t = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1. kwart", "2. kwart", "3. kwart", "4. kwart"]
};
const monthValues$t = {
    narrow: ["J", "F", "M", "A", "M", "", "L", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Jan",
        "Fra",
        "Mar",
        "Apr",
        "Mej",
        "un",
        "Lul",
        "Aww",
        "Set",
        "Ott",
        "Nov",
        "Di"
    ],
    wide: [
        "Jannar",
        "Frar",
        "Marzu",
        "April",
        "Mejju",
        "unju",
        "Lulju",
        "Awwissu",
        "Settembru",
        "Ottubru",
        "Novembru",
        "Diembru"
    ]
};
const dayValues$t = {
    narrow: ["", "T", "T", "E", "", "", "S"],
    short: ["a", "Tn", "Tl", "Er", "a", "i", "Si"],
    abbreviated: ["ad", "Tne", "Tli", "Erb", "am", "im", "Sib"],
    wide: [
        "Il-add",
        "It-Tnejn",
        "It-Tlieta",
        "L-Erbga",
        "Il-amis",
        "Il-imga",
        "Is-Sibt"
    ]
};
const dayPeriodValues$t = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "nofsillejl",
        noon: "nofsinhar",
        morning: "godwa",
        afternoon: "wara nofsinhar",
        evening: "filgaxija",
        night: "lejl"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "nofsillejl",
        noon: "nofsinhar",
        morning: "godwa",
        afternoon: "wara nofsinhar",
        evening: "filgaxija",
        night: "lejl"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "nofsillejl",
        noon: "nofsinhar",
        morning: "godwa",
        afternoon: "wara nofsinhar",
        evening: "filgaxija",
        night: "lejl"
    }
};
const formattingDayPeriodValues$n = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "f'nofsillejl",
        noon: "f'nofsinhar",
        morning: "filgodu",
        afternoon: "wara nofsinhar",
        evening: "filgaxija",
        night: "billejl"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "f'nofsillejl",
        noon: "f'nofsinhar",
        morning: "filgodu",
        afternoon: "wara nofsinhar",
        evening: "filgaxija",
        night: "billejl"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "f'nofsillejl",
        noon: "f'nofsinhar",
        morning: "filgodu",
        afternoon: "wara nofsinhar",
        evening: "filgaxija",
        night: "billejl"
    }
};
const ordinalNumber$t = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "";
};
const localize$t = {
    ordinalNumber: ordinalNumber$t,
    era: buildLocalizeFn({
        values: eraValues$t,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$t,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$t,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$t,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$t,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$n,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$t = /^(\d+)()?/i;
const parseOrdinalNumberPattern$t = /\d+/i;
const matchEraPatterns$t = {
    narrow: /^(q|w)/i,
    abbreviated: /^(q\.?\s?k\.?|b\.?\s?c\.?\s?e\.?|w\.?\s?k\.?)/i,
    wide: /^(qabel kristu|before common era|wara kristu|common era)/i
};
const parseEraPatterns$t = {
    any: [/^(q|b)/i, /^(w|c)/i]
};
const matchQuarterPatterns$t = {
    narrow: /^[1234]/i,
    abbreviated: /^k[1234]/i,
    wide: /^[1234](\.)? kwart/i
};
const parseQuarterPatterns$t = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$t = {
    narrow: /^[jfmaglsond]/i,
    abbreviated: /^(jan|fra|mar|apr|mej|un|lul|aww|set|ott|nov|di)/i,
    wide: /^(jannar|frar|marzu|april|mejju|unju|lulju|awwissu|settembru|ottubru|novembru|diembru)/i
};
const parseMonthPatterns$t = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^/i,
        /^l/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mej/i,
        /^/i,
        /^l/i,
        /^aw/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$t = {
    narrow: /^[tes]/i,
    short: /^(a|tn|tl|er|a|i|si)/i,
    abbreviated: /^(ad|tne|tli|erb|am|im|sib)/i,
    wide: /^(il-add|it-tnejn|it-tlieta|l-erbga|il-amis|il-imga|is-sibt)/i
};
const parseDayPatterns$t = {
    narrow: [/^/i, /^t/i, /^t/i, /^e/i, /^/i, /^/i, /^s/i],
    any: [
        /^(il-)?ad/i,
        /^(it-)?tn/i,
        /^(it-)?tl/i,
        /^(l-)?er/i,
        /^(il-)?ham/i,
        /^(il-)?i/i,
        /^(is-)?si/i
    ]
};
const matchDayPeriodPatterns$t = {
    narrow: /^(a|p|f'nofsillejl|f'nofsinhar|(ta') (godwa|wara nofsinhar|filgaxija|lejl))/i,
    any: /^([ap]\.?\s?m\.?|f'nofsillejl|f'nofsinhar|(ta') (godwa|wara nofsinhar|filgaxija|lejl))/i
};
const parseDayPeriodPatterns$t = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^f'nofsillejl/i,
        noon: /^f'nofsinhar/i,
        morning: /godwa/i,
        afternoon: /wara(\s.*)nofsinhar/i,
        evening: /filgaxija/i,
        night: /lejl/i
    }
};
const match$t = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$t,
        parsePattern: parseOrdinalNumberPattern$t,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$t,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$t,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$t,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$t,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$t,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$t,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$t,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$t,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$t,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$t,
        defaultParseWidth: "any"
    })
};
const mt = {
    code: "mt",
    formatDistance: formatDistance$t,
    formatLong: formatLong$t,
    formatRelative: formatRelative$t,
    localize: localize$t,
    match: match$t,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$s = {
    lessThanXSeconds: {
        one: "mindre enn ett sekund",
        other: "mindre enn {{count}} sekunder"
    },
    xSeconds: {
        one: "ett sekund",
        other: "{{count}} sekunder"
    },
    halfAMinute: "et halvt minutt",
    lessThanXMinutes: {
        one: "mindre enn ett minutt",
        other: "mindre enn {{count}} minutter"
    },
    xMinutes: {
        one: "ett minutt",
        other: "{{count}} minutter"
    },
    aboutXHours: {
        one: "omtrent en time",
        other: "omtrent {{count}} timer"
    },
    xHours: {
        one: "en time",
        other: "{{count}} timer"
    },
    xDays: {
        one: "en dag",
        other: "{{count}} dager"
    },
    aboutXWeeks: {
        one: "omtrent en uke",
        other: "omtrent {{count}} uker"
    },
    xWeeks: {
        one: "en uke",
        other: "{{count}} uker"
    },
    aboutXMonths: {
        one: "omtrent en mned",
        other: "omtrent {{count}} mneder"
    },
    xMonths: {
        one: "en mned",
        other: "{{count}} mneder"
    },
    aboutXYears: {
        one: "omtrent ett r",
        other: "omtrent {{count}} r"
    },
    xYears: {
        one: "ett r",
        other: "{{count}} r"
    },
    overXYears: {
        one: "over ett r",
        other: "over {{count}} r"
    },
    almostXYears: {
        one: "nesten ett r",
        other: "nesten {{count}} r"
    }
};
const formatDistance$s = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$s[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "om " + result;
        }
        else {
            return result + " siden";
        }
    }
    return result;
};
const dateFormats$s = {
    full: "EEEE d. MMMM y",
    long: "d. MMMM y",
    medium: "d. MMM y",
    short: "dd.MM.y"
};
const timeFormats$s = {
    full: "'kl'. HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$s = {
    full: "{{date}} 'kl.' {{time}}",
    long: "{{date}} 'kl.' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$s = {
    date: buildFormatLongFn({
        formats: dateFormats$s,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$s,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$s,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$s = {
    lastWeek: "'forrige' eeee 'kl.' p",
    yesterday: "'i gr kl.' p",
    today: "'i dag kl.' p",
    tomorrow: "'i morgen kl.' p",
    nextWeek: "EEEE 'kl.' p",
    other: "P"
};
const formatRelative$s = (token, _date, _baseDate, _options) => formatRelativeLocale$s[token];
const eraValues$s = {
    narrow: ["f.Kr.", "e.Kr."],
    abbreviated: ["f.Kr.", "e.Kr."],
    wide: ["fr Kristus", "etter Kristus"]
};
const quarterValues$s = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$s = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mars",
        "apr.",
        "mai",
        "juni",
        "juli",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "des."
    ],
    wide: [
        "januar",
        "februar",
        "mars",
        "april",
        "mai",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "desember"
    ]
};
const dayValues$s = {
    narrow: ["S", "M", "T", "O", "T", "F", "L"],
    short: ["s", "ma", "ti", "on", "to", "fr", "l"],
    abbreviated: ["sn", "man", "tir", "ons", "tor", "fre", "lr"],
    wide: [
        "sndag",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "lrdag"
    ]
};
const dayPeriodValues$s = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morg.",
        afternoon: "p etterm.",
        evening: "p kvelden",
        night: "p natten"
    },
    abbreviated: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morg.",
        afternoon: "p etterm.",
        evening: "p kvelden",
        night: "p natten"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morgenen",
        afternoon: "p ettermiddagen",
        evening: "p kvelden",
        night: "p natten"
    }
};
const ordinalNumber$s = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$s = {
    ordinalNumber: ordinalNumber$s,
    era: buildLocalizeFn({
        values: eraValues$s,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$s,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$s,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$s,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$s,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$s = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$s = /\d+/i;
const matchEraPatterns$s = {
    narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
    abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
    wide: /^(fr Kristus|fr vr tid|etter Kristus|vr tid)/i
};
const parseEraPatterns$s = {
    any: [/^f/i, /^e/i]
};
const matchQuarterPatterns$s = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](\.)? kvartal/i
};
const parseQuarterPatterns$s = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$s = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
    wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
const parseMonthPatterns$s = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^aug/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$s = {
    narrow: /^[smtofl]/i,
    short: /^(s|ma|ti|on|to|fr|l)/i,
    abbreviated: /^(sn|man|tir|ons|tor|fre|lr)/i,
    wide: /^(sndag|mandag|tirsdag|onsdag|torsdag|fredag|lrdag)/i
};
const parseDayPatterns$s = {
    any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$s = {
    narrow: /^(midnatt|middag|(p) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
    any: /^([ap]\.?\s?m\.?|midnatt|middag|(p) (morgenen|ettermiddagen|kvelden|natten))/i
};
const parseDayPeriodPatterns$s = {
    any: {
        am: /^a(\.?\s?m\.?)?$/i,
        pm: /^p(\.?\s?m\.?)?$/i,
        midnight: /^midn/i,
        noon: /^midd/i,
        morning: /morgen/i,
        afternoon: /ettermiddag/i,
        evening: /kveld/i,
        night: /natt/i
    }
};
const match$s = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$s,
        parsePattern: parseOrdinalNumberPattern$s,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$s,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$s,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$s,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$s,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$s,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$s,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$s,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$s,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$s,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$s,
        defaultParseWidth: "any"
    })
};
const nb = {
    code: "nb",
    formatDistance: formatDistance$s,
    formatLong: formatLong$s,
    formatRelative: formatRelative$s,
    localize: localize$s,
    match: match$s,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$r = {
    lessThanXSeconds: {
        one: "minder dan een seconde",
        other: "minder dan {{count}} seconden"
    },
    xSeconds: {
        one: "1 seconde",
        other: "{{count}} seconden"
    },
    halfAMinute: "een halve minuut",
    lessThanXMinutes: {
        one: "minder dan een minuut",
        other: "minder dan {{count}} minuten"
    },
    xMinutes: {
        one: "een minuut",
        other: "{{count}} minuten"
    },
    aboutXHours: {
        one: "ongeveer 1 uur",
        other: "ongeveer {{count}} uur"
    },
    xHours: {
        one: "1 uur",
        other: "{{count}} uur"
    },
    xDays: {
        one: "1 dag",
        other: "{{count}} dagen"
    },
    aboutXWeeks: {
        one: "ongeveer 1 week",
        other: "ongeveer {{count}} weken"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weken"
    },
    aboutXMonths: {
        one: "ongeveer 1 maand",
        other: "ongeveer {{count}} maanden"
    },
    xMonths: {
        one: "1 maand",
        other: "{{count}} maanden"
    },
    aboutXYears: {
        one: "ongeveer 1 jaar",
        other: "ongeveer {{count}} jaar"
    },
    xYears: {
        one: "1 jaar",
        other: "{{count}} jaar"
    },
    overXYears: {
        one: "meer dan 1 jaar",
        other: "meer dan {{count}} jaar"
    },
    almostXYears: {
        one: "bijna 1 jaar",
        other: "bijna {{count}} jaar"
    }
};
const formatDistance$r = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$r[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "over " + result;
        }
        else {
            return result + " geleden";
        }
    }
    return result;
};
const dateFormats$r = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd-MM-y"
};
const timeFormats$r = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$r = {
    full: "{{date}} 'om' {{time}}",
    long: "{{date}} 'om' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$r = {
    date: buildFormatLongFn({
        formats: dateFormats$r,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$r,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$r,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$r = {
    lastWeek: "'afgelopen' eeee 'om' p",
    yesterday: "'gisteren om' p",
    today: "'vandaag om' p",
    tomorrow: "'morgen om' p",
    nextWeek: "eeee 'om' p",
    other: "P"
};
const formatRelative$r = (token, _date, _baseDate, _options) => formatRelativeLocale$r[token];
const eraValues$r = {
    narrow: ["v.C.", "n.C."],
    abbreviated: ["v.Chr.", "n.Chr."],
    wide: ["voor Christus", "na Christus"]
};
const quarterValues$r = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
};
const monthValues$r = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mrt.",
        "apr.",
        "mei",
        "jun.",
        "jul.",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "januari",
        "februari",
        "maart",
        "april",
        "mei",
        "juni",
        "juli",
        "augustus",
        "september",
        "oktober",
        "november",
        "december"
    ]
};
const dayValues$r = {
    narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
    short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
    abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
    wide: [
        "zondag",
        "maandag",
        "dinsdag",
        "woensdag",
        "donderdag",
        "vrijdag",
        "zaterdag"
    ]
};
const dayPeriodValues$r = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "het middaguur",
        morning: "'s ochtends",
        afternoon: "'s middags",
        evening: "'s avonds",
        night: "'s nachts"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "het middaguur",
        morning: "'s ochtends",
        afternoon: "'s middags",
        evening: "'s avonds",
        night: "'s nachts"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "het middaguur",
        morning: "'s ochtends",
        afternoon: "'s middags",
        evening: "'s avonds",
        night: "'s nachts"
    }
};
const ordinalNumber$r = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "e";
};
const localize$r = {
    ordinalNumber: ordinalNumber$r,
    era: buildLocalizeFn({
        values: eraValues$r,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$r,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$r,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$r,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$r,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$r = /^(\d+)e?/i;
const parseOrdinalNumberPattern$r = /\d+/i;
const matchEraPatterns$r = {
    narrow: /^([vn]\.? ?C\.?)/,
    abbreviated: /^([vn]\. ?Chr\.?)/,
    wide: /^((voor|na) Christus)/
};
const parseEraPatterns$r = {
    any: [/^v/, /^n/]
};
const matchQuarterPatterns$r = {
    narrow: /^[1234]/i,
    abbreviated: /^K[1234]/i,
    wide: /^[1234]e kwartaal/i
};
const parseQuarterPatterns$r = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$r = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
    wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
};
const parseMonthPatterns$r = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^jan/i,
        /^feb/i,
        /^m(r|a)/i,
        /^apr/i,
        /^mei/i,
        /^jun/i,
        /^jul/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i
    ]
};
const matchDayPatterns$r = {
    narrow: /^[zmdwv]/i,
    short: /^(zo|ma|di|wo|do|vr|za)/i,
    abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
    wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
};
const parseDayPatterns$r = {
    narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
    any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
};
const matchDayPeriodPatterns$r = {
    any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
};
const parseDayPeriodPatterns$r = {
    any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /^middernacht/i,
        noon: /^het middaguur/i,
        morning: /ochtend/i,
        afternoon: /middag/i,
        evening: /avond/i,
        night: /nacht/i
    }
};
const match$r = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$r,
        parsePattern: parseOrdinalNumberPattern$r,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$r,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$r,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$r,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$r,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$r,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$r,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$r,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$r,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$r,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$r,
        defaultParseWidth: "any"
    })
};
const nl$2 = {
    code: "nl",
    formatDistance: formatDistance$r,
    formatLong: formatLong$r,
    formatRelative: formatRelative$r,
    localize: localize$r,
    match: match$r,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$q = {
    lessThanXSeconds: {
        one: "minder dan een seconde",
        other: "minder dan {{count}} seconden"
    },
    xSeconds: {
        one: "1 seconde",
        other: "{{count}} seconden"
    },
    halfAMinute: "een halve minuut",
    lessThanXMinutes: {
        one: "minder dan een minuut",
        other: "minder dan {{count}} minuten"
    },
    xMinutes: {
        one: "een minuut",
        other: "{{count}} minuten"
    },
    aboutXHours: {
        one: "ongeveer 1 uur",
        other: "ongeveer {{count}} uur"
    },
    xHours: {
        one: "1 uur",
        other: "{{count}} uur"
    },
    xDays: {
        one: "1 dag",
        other: "{{count}} dagen"
    },
    aboutXWeeks: {
        one: "ongeveer 1 week",
        other: "ongeveer {{count}} weken"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weken"
    },
    aboutXMonths: {
        one: "ongeveer 1 maand",
        other: "ongeveer {{count}} maanden"
    },
    xMonths: {
        one: "1 maand",
        other: "{{count}} maanden"
    },
    aboutXYears: {
        one: "ongeveer 1 jaar",
        other: "ongeveer {{count}} jaar"
    },
    xYears: {
        one: "1 jaar",
        other: "{{count}} jaar"
    },
    overXYears: {
        one: "meer dan 1 jaar",
        other: "meer dan {{count}} jaar"
    },
    almostXYears: {
        one: "bijna 1 jaar",
        other: "bijna {{count}} jaar"
    }
};
const formatDistance$q = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$q[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "over " + result;
        }
        else {
            return result + " geleden";
        }
    }
    return result;
};
const dateFormats$q = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd.MM.y"
};
const timeFormats$q = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$q = {
    full: "{{date}} 'om' {{time}}",
    long: "{{date}} 'om' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$q = {
    date: buildFormatLongFn({
        formats: dateFormats$q,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$q,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$q,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$q = {
    lastWeek: "'vorige' eeee 'om' p",
    yesterday: "'gisteren om' p",
    today: "'vandaag om' p",
    tomorrow: "'morgen om' p",
    nextWeek: "eeee 'om' p",
    other: "P"
};
const formatRelative$q = (token, _date, _baseDate, _options) => formatRelativeLocale$q[token];
const eraValues$q = {
    narrow: ["v.C.", "n.C."],
    abbreviated: ["v.Chr.", "n.Chr."],
    wide: ["voor Christus", "na Christus"]
};
const quarterValues$q = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["K1", "K2", "K3", "K4"],
    wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
};
const monthValues$q = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mrt.",
        "apr.",
        "mei",
        "jun.",
        "jul.",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "januari",
        "februari",
        "maart",
        "april",
        "mei",
        "juni",
        "juli",
        "augustus",
        "september",
        "oktober",
        "november",
        "december"
    ]
};
const dayValues$q = {
    narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
    short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
    abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
    wide: [
        "zondag",
        "maandag",
        "dinsdag",
        "woensdag",
        "donderdag",
        "vrijdag",
        "zaterdag"
    ]
};
const dayPeriodValues$q = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "het middag",
        morning: "'s ochtends",
        afternoon: "'s namiddags",
        evening: "'s avonds",
        night: "'s nachts"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "het middag",
        morning: "'s ochtends",
        afternoon: "'s namiddags",
        evening: "'s avonds",
        night: "'s nachts"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "middernacht",
        noon: "het middag",
        morning: "'s ochtends",
        afternoon: "'s namiddags",
        evening: "'s avonds",
        night: "'s nachts"
    }
};
const ordinalNumber$q = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "e";
};
const localize$q = {
    ordinalNumber: ordinalNumber$q,
    era: buildLocalizeFn({
        values: eraValues$q,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$q,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$q,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$q,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$q,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$q = /^(\d+)e?/i;
const parseOrdinalNumberPattern$q = /\d+/i;
const matchEraPatterns$q = {
    narrow: /^([vn]\.? ?C\.?)/,
    abbreviated: /^([vn]\. ?Chr\.?)/,
    wide: /^((voor|na) Christus)/
};
const parseEraPatterns$q = {
    any: [/^v/, /^n/]
};
const matchQuarterPatterns$q = {
    narrow: /^[1234]/i,
    abbreviated: /^K[1234]/i,
    wide: /^[1234]e kwartaal/i
};
const parseQuarterPatterns$q = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$q = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
    wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
};
const parseMonthPatterns$q = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^jan/i,
        /^feb/i,
        /^m(r|a)/i,
        /^apr/i,
        /^mei/i,
        /^jun/i,
        /^jul/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i
    ]
};
const matchDayPatterns$q = {
    narrow: /^[zmdwv]/i,
    short: /^(zo|ma|di|wo|do|vr|za)/i,
    abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
    wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
};
const parseDayPatterns$q = {
    narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
    any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
};
const matchDayPeriodPatterns$q = {
    any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
};
const parseDayPeriodPatterns$q = {
    any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /^middernacht/i,
        noon: /^het middaguur/i,
        morning: /ochtend/i,
        afternoon: /middag/i,
        evening: /avond/i,
        night: /nacht/i
    }
};
const match$q = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$q,
        parsePattern: parseOrdinalNumberPattern$q,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$q,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$q,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$q,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$q,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$q,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$q,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$q,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$q,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$q,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$q,
        defaultParseWidth: "any"
    })
};
const nlBE = {
    code: "nl-BE",
    formatDistance: formatDistance$q,
    formatLong: formatLong$q,
    formatRelative: formatRelative$q,
    localize: localize$q,
    match: match$q,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$p = {
    lessThanXSeconds: {
        one: "mindre enn eitt sekund",
        other: "mindre enn {{count}} sekund"
    },
    xSeconds: {
        one: "eitt sekund",
        other: "{{count}} sekund"
    },
    halfAMinute: "eit halvt minutt",
    lessThanXMinutes: {
        one: "mindre enn eitt minutt",
        other: "mindre enn {{count}} minutt"
    },
    xMinutes: {
        one: "eitt minutt",
        other: "{{count}} minutt"
    },
    aboutXHours: {
        one: "omtrent ein time",
        other: "omtrent {{count}} timar"
    },
    xHours: {
        one: "ein time",
        other: "{{count}} timar"
    },
    xDays: {
        one: "ein dag",
        other: "{{count}} dagar"
    },
    aboutXWeeks: {
        one: "omtrent ei veke",
        other: "omtrent {{count}} veker"
    },
    xWeeks: {
        one: "ei veke",
        other: "{{count}} veker"
    },
    aboutXMonths: {
        one: "omtrent ein mnad",
        other: "omtrent {{count}} mnader"
    },
    xMonths: {
        one: "ein mnad",
        other: "{{count}} mnader"
    },
    aboutXYears: {
        one: "omtrent eitt r",
        other: "omtrent {{count}} r"
    },
    xYears: {
        one: "eitt r",
        other: "{{count}} r"
    },
    overXYears: {
        one: "over eitt r",
        other: "over {{count}} r"
    },
    almostXYears: {
        one: "nesten eitt r",
        other: "nesten {{count}} r"
    }
};
const wordMapping$1 = [
    "null",
    "ein",
    "to",
    "tre",
    "fire",
    "fem",
    "seks",
    "sju",
    "tte",
    "ni",
    "ti",
    "elleve",
    "tolv"
];
const formatDistance$p = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$p[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count < 13 ? wordMapping$1[count] : String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "om " + result;
        }
        else {
            return result + " sidan";
        }
    }
    return result;
};
const dateFormats$p = {
    full: "EEEE d. MMMM y",
    long: "d. MMMM y",
    medium: "d. MMM y",
    short: "dd.MM.y"
};
const timeFormats$p = {
    full: "'kl'. HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$p = {
    full: "{{date}} 'kl.' {{time}}",
    long: "{{date}} 'kl.' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$p = {
    date: buildFormatLongFn({
        formats: dateFormats$p,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$p,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$p,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$p = {
    lastWeek: "'frre' eeee 'kl.' p",
    yesterday: "'i gr kl.' p",
    today: "'i dag kl.' p",
    tomorrow: "'i morgon kl.' p",
    nextWeek: "EEEE 'kl.' p",
    other: "P"
};
const formatRelative$p = (token, _date, _baseDate, _options) => formatRelativeLocale$p[token];
const eraValues$p = {
    narrow: ["f.Kr.", "e.Kr."],
    abbreviated: ["f.Kr.", "e.Kr."],
    wide: ["fr Kristus", "etter Kristus"]
};
const quarterValues$p = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$p = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mars",
        "apr.",
        "mai",
        "juni",
        "juli",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "des."
    ],
    wide: [
        "januar",
        "februar",
        "mars",
        "april",
        "mai",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "desember"
    ]
};
const dayValues$p = {
    narrow: ["S", "M", "T", "O", "T", "F", "L"],
    short: ["su", "m", "ty", "on", "to", "fr", "lau"],
    abbreviated: ["sun", "mn", "tys", "ons", "tor", "fre", "laur"],
    wide: [
        "sundag",
        "mndag",
        "tysdag",
        "onsdag",
        "torsdag",
        "fredag",
        "laurdag"
    ]
};
const dayPeriodValues$p = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morg.",
        afternoon: "p etterm.",
        evening: "p kvelden",
        night: "p natta"
    },
    abbreviated: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morg.",
        afternoon: "p etterm.",
        evening: "p kvelden",
        night: "p natta"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morgonen",
        afternoon: "p ettermiddagen",
        evening: "p kvelden",
        night: "p natta"
    }
};
const ordinalNumber$p = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$p = {
    ordinalNumber: ordinalNumber$p,
    era: buildLocalizeFn({
        values: eraValues$p,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$p,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$p,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$p,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$p,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$p = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$p = /\d+/i;
const matchEraPatterns$p = {
    narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
    abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
    wide: /^(fr Kristus|fr vr tid|etter Kristus|vr tid)/i
};
const parseEraPatterns$p = {
    any: [/^f/i, /^e/i]
};
const matchQuarterPatterns$p = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](\.)? kvartal/i
};
const parseQuarterPatterns$p = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$p = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
    wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
const parseMonthPatterns$p = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^aug/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$p = {
    narrow: /^[smtofl]/i,
    short: /^(su|m|ty|on|to|fr|la)/i,
    abbreviated: /^(sun|mn|tys|ons|tor|fre|laur)/i,
    wide: /^(sundag|mndag|tysdag|onsdag|torsdag|fredag|laurdag)/i
};
const parseDayPatterns$p = {
    any: [/^s/i, /^m/i, /^ty/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$p = {
    narrow: /^(midnatt|middag|(p) (morgonen|ettermiddagen|kvelden|natta)|[ap])/i,
    any: /^([ap]\.?\s?m\.?|midnatt|middag|(p) (morgonen|ettermiddagen|kvelden|natta))/i
};
const parseDayPeriodPatterns$p = {
    any: {
        am: /^a(\.?\s?m\.?)?$/i,
        pm: /^p(\.?\s?m\.?)?$/i,
        midnight: /^midn/i,
        noon: /^midd/i,
        morning: /morgon/i,
        afternoon: /ettermiddag/i,
        evening: /kveld/i,
        night: /natt/i
    }
};
const match$p = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$p,
        parsePattern: parseOrdinalNumberPattern$p,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$p,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$p,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$p,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$p,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$p,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$p,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$p,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$p,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$p,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$p,
        defaultParseWidth: "any"
    })
};
const nn = {
    code: "nn",
    formatDistance: formatDistance$p,
    formatLong: formatLong$p,
    formatRelative: formatRelative$p,
    localize: localize$p,
    match: match$p,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$o = {
    lessThanXSeconds: {
        one: "mens duna segonda",
        other: "mens de {{count}} segondas"
    },
    xSeconds: {
        one: "1 segonda",
        other: "{{count}} segondas"
    },
    halfAMinute: "30 segondas",
    lessThanXMinutes: {
        one: "mens duna minuta",
        other: "mens de {{count}} minutas"
    },
    xMinutes: {
        one: "1 minuta",
        other: "{{count}} minutas"
    },
    aboutXHours: {
        one: "environ 1 ora",
        other: "environ {{count}} oras"
    },
    xHours: {
        one: "1 ora",
        other: "{{count}} oras"
    },
    xDays: {
        one: "1 jorn",
        other: "{{count}} jorns"
    },
    aboutXWeeks: {
        one: "environ 1 setmana",
        other: "environ {{count}} setmanas"
    },
    xWeeks: {
        one: "1 setmana",
        other: "{{count}} setmanas"
    },
    aboutXMonths: {
        one: "environ 1 mes",
        other: "environ {{count}} meses"
    },
    xMonths: {
        one: "1 mes",
        other: "{{count}} meses"
    },
    aboutXYears: {
        one: "environ 1 an",
        other: "environ {{count}} ans"
    },
    xYears: {
        one: "1 an",
        other: "{{count}} ans"
    },
    overXYears: {
        one: "mai dun an",
        other: "mai de {{count}} ans"
    },
    almostXYears: {
        one: "gaireben un an",
        other: "gaireben {{count}} ans"
    }
};
const formatDistance$o = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$o[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "daqu " + result;
        }
        else {
            return "fa " + result;
        }
    }
    return result;
};
const dateFormats$o = {
    full: "EEEE d 'de' MMMM y",
    long: "d 'de' MMMM y",
    medium: "d MMM y",
    short: "dd/MM/y"
};
const timeFormats$o = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$o = {
    full: "{{date}} 'a' {{time}}",
    long: "{{date}} 'a' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$o = {
    date: buildFormatLongFn({
        formats: dateFormats$o,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$o,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$o,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$o = {
    lastWeek: "eeee 'passat a' p",
    yesterday: "'ir a' p",
    today: "'ui a' p",
    tomorrow: "'deman a' p",
    nextWeek: "eeee 'a' p",
    other: "P"
};
const formatRelative$o = (token, _date, _baseDate, _options) => formatRelativeLocale$o[token];
const eraValues$o = {
    narrow: ["ab. J.C.", "apr. J.C."],
    abbreviated: ["ab. J.C.", "apr. J.C."],
    wide: ["abans Jsus-Crist", "aprs Jsus-Crist"]
};
const quarterValues$o = {
    narrow: ["T1", "T2", "T3", "T4"],
    abbreviated: ["1r trim.", "2nd trim.", "3en trim.", "4en trim."],
    wide: ["1r trimstre", "2nd trimstre", "3en trimstre", "4en trimstre"]
};
const monthValues$o = {
    narrow: [
        "GN",
        "FB",
        "M",
        "AB",
        "MA",
        "JN",
        "JL",
        "AG",
        "ST",
        "OC",
        "NV",
        "DC"
    ],
    abbreviated: [
        "gen.",
        "febr.",
        "mar",
        "abr.",
        "mai",
        "junh",
        "jul.",
        "ag.",
        "set.",
        "oct.",
        "nov.",
        "dec."
    ],
    wide: [
        "genir",
        "febrir",
        "mar",
        "abril",
        "mai",
        "junh",
        "julhet",
        "agost",
        "setembre",
        "octbre",
        "novembre",
        "decembre"
    ]
};
const dayValues$o = {
    narrow: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
    short: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
    abbreviated: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
    wide: [
        "dimenge",
        "diluns",
        "dimars",
        "dimcres",
        "dijus",
        "divendres",
        "dissabte"
    ]
};
const dayPeriodValues$o = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "mijanuch",
        noon: "migjorn",
        morning: "matin",
        afternoon: "aprp-migjorn",
        evening: "vspre",
        night: "nuch"
    },
    abbreviated: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "mijanuch",
        noon: "migjorn",
        morning: "matin",
        afternoon: "aprp-migjorn",
        evening: "vspre",
        night: "nuch"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "mijanuch",
        noon: "migjorn",
        morning: "matin",
        afternoon: "aprp-migjorn",
        evening: "vspre",
        night: "nuch"
    }
};
const formattingDayPeriodValues$m = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "mijanuch",
        noon: "migjorn",
        morning: "del matin",
        afternoon: "de laprp-migjorn",
        evening: "del ser",
        night: "de la nuch"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "mijanuch",
        noon: "migjorn",
        morning: "del matin",
        afternoon: "de laprp-migjorn",
        evening: "del ser",
        night: "de la nuch"
    },
    wide: {
        am: "ante meridiem",
        pm: "post meridiem",
        midnight: "mijanuch",
        noon: "migjorn",
        morning: "del matin",
        afternoon: "de laprp-migjorn",
        evening: "del ser",
        night: "de la nuch"
    }
};
const ordinalNumber$o = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = options2?.unit;
    let ordinal;
    switch (number2) {
        case 1:
            ordinal = "r";
            break;
        case 2:
            ordinal = "nd";
            break;
        default:
            ordinal = "en";
    }
    if (unit === "year" || unit === "week" || unit === "hour" || unit === "minute" || unit === "second") {
        ordinal += "a";
    }
    return number2 + ordinal;
};
const localize$o = {
    ordinalNumber: ordinalNumber$o,
    era: buildLocalizeFn({
        values: eraValues$o,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$o,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$o,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$o,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$o,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$m,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$o = /^(\d+)(r|nd|en)?[a]?/i;
const parseOrdinalNumberPattern$o = /\d+/i;
const matchEraPatterns$o = {
    narrow: /^(ab\.J\.C|apr\.J\.C|apr\.J\.-C)/i,
    abbreviated: /^(ab\.J\.-C|ab\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
    wide: /^(abans Jsus-Crist|aprs Jsus-Crist)/i
};
const parseEraPatterns$o = {
    any: [/^ab/i, /^ap/i]
};
const matchQuarterPatterns$o = {
    narrow: /^T[1234]/i,
    abbreviated: /^[1234](r|nd|en)? trim\.?/i,
    wide: /^[1234](r|nd|en)? trimstre/i
};
const parseQuarterPatterns$o = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$o = {
    narrow: /^(GN|FB|M|AB|MA|JN|JL|AG|ST|OC|NV|DC)/i,
    abbreviated: /^(gen|febr|mar|abr|mai|junh|jul|ag|set|oct|nov|dec)\.?/i,
    wide: /^(genir|febrir|mar|abril|mai|junh|julhet|agost|setembre|octbre|novembre|decembre)/i
};
const parseMonthPatterns$o = {
    any: [
        /^g/i,
        /^f/i,
        /^ma[r?]|M/i,
        /^ab/i,
        /^ma[i?]/i,
        /^ju[n?]|JN/i,
        /^ju[l?]|JL/i,
        /^ag/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$o = {
    narrow: /^d[glmcjvs]\.?/i,
    short: /^d[glmcjvs]\.?/i,
    abbreviated: /^d[glmcjvs]\.?/i,
    wide: /^(dimenge|diluns|dimars|dimcres|dijus|divendres|dissabte)/i
};
const parseDayPatterns$o = {
    narrow: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
    short: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
    abbreviated: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
    any: [
        /^dg|dime/i,
        /^dl|dil/i,
        /^dm|dima/i,
        /^dc|dim/i,
        /^dj|dij/i,
        /^dv|div/i,
        /^ds|dis/i
    ]
};
const matchDayPeriodPatterns$o = {
    any: /(^(a\.?m|p\.?m))|(ante meridiem|post meridiem)|((del |de la |de l)(matin|aprp-migjorn|vspre|ser|nuch))/i
};
const parseDayPeriodPatterns$o = {
    any: {
        am: /(^a)|ante meridiem/i,
        pm: /(^p)|post meridiem/i,
        midnight: /^mij/i,
        noon: /^mig/i,
        morning: /matin/i,
        afternoon: /aprp-migjorn/i,
        evening: /vspre|ser/i,
        night: /nuch/i
    }
};
const match$o = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$o,
        parsePattern: parseOrdinalNumberPattern$o,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$o,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$o,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$o,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$o,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$o,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$o,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$o,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$o,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$o,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$o,
        defaultParseWidth: "any"
    })
};
const oc = {
    code: "oc",
    formatDistance: formatDistance$o,
    formatLong: formatLong$o,
    formatRelative: formatRelative$o,
    localize: localize$o,
    match: match$o,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$n = {
    lessThanXSeconds: {
        one: {
            regular: "mniej ni sekunda",
            past: "mniej ni sekund",
            future: "mniej ni sekund"
        },
        twoFour: "mniej ni {{count}} sekundy",
        other: "mniej ni {{count}} sekund"
    },
    xSeconds: {
        one: {
            regular: "sekunda",
            past: "sekund",
            future: "sekund"
        },
        twoFour: "{{count}} sekundy",
        other: "{{count}} sekund"
    },
    halfAMinute: {
        one: "p minuty",
        twoFour: "p minuty",
        other: "p minuty"
    },
    lessThanXMinutes: {
        one: {
            regular: "mniej ni minuta",
            past: "mniej ni minut",
            future: "mniej ni minut"
        },
        twoFour: "mniej ni {{count}} minuty",
        other: "mniej ni {{count}} minut"
    },
    xMinutes: {
        one: {
            regular: "minuta",
            past: "minut",
            future: "minut"
        },
        twoFour: "{{count}} minuty",
        other: "{{count}} minut"
    },
    aboutXHours: {
        one: {
            regular: "okoo godziny",
            past: "okoo godziny",
            future: "okoo godzin"
        },
        twoFour: "okoo {{count}} godziny",
        other: "okoo {{count}} godzin"
    },
    xHours: {
        one: {
            regular: "godzina",
            past: "godzin",
            future: "godzin"
        },
        twoFour: "{{count}} godziny",
        other: "{{count}} godzin"
    },
    xDays: {
        one: {
            regular: "dzie",
            past: "dzie",
            future: "1 dzie"
        },
        twoFour: "{{count}} dni",
        other: "{{count}} dni"
    },
    aboutXWeeks: {
        one: "okoo tygodnia",
        twoFour: "okoo {{count}} tygodni",
        other: "okoo {{count}} tygodni"
    },
    xWeeks: {
        one: "tydzie",
        twoFour: "{{count}} tygodnie",
        other: "{{count}} tygodni"
    },
    aboutXMonths: {
        one: "okoo miesic",
        twoFour: "okoo {{count}} miesice",
        other: "okoo {{count}} miesicy"
    },
    xMonths: {
        one: "miesic",
        twoFour: "{{count}} miesice",
        other: "{{count}} miesicy"
    },
    aboutXYears: {
        one: "okoo rok",
        twoFour: "okoo {{count}} lata",
        other: "okoo {{count}} lat"
    },
    xYears: {
        one: "rok",
        twoFour: "{{count}} lata",
        other: "{{count}} lat"
    },
    overXYears: {
        one: "ponad rok",
        twoFour: "ponad {{count}} lata",
        other: "ponad {{count}} lat"
    },
    almostXYears: {
        one: "prawie rok",
        twoFour: "prawie {{count}} lata",
        other: "prawie {{count}} lat"
    }
};
function declensionGroup$1(scheme, count) {
    if (count === 1) {
        return scheme.one;
    }
    const rem100 = count % 100;
    if (rem100 <= 20 && rem100 > 10) {
        return scheme.other;
    }
    const rem10 = rem100 % 10;
    if (rem10 >= 2 && rem10 <= 4) {
        return scheme.twoFour;
    }
    return scheme.other;
}
function declension$3(scheme, count, time) {
    const group = declensionGroup$1(scheme, count);
    const finalText = typeof group === "string" ? group : group[time];
    return finalText.replace("{{count}}", String(count));
}
const formatDistance$n = (token, count, options2) => {
    const scheme = formatDistanceLocale$n[token];
    if (!options2?.addSuffix) {
        return declension$3(scheme, count, "regular");
    }
    if (options2.comparison && options2.comparison > 0) {
        return "za " + declension$3(scheme, count, "future");
    }
    else {
        return declension$3(scheme, count, "past") + " temu";
    }
};
const dateFormats$n = {
    full: "EEEE, do MMMM y",
    long: "do MMMM y",
    medium: "do MMM y",
    short: "dd.MM.y"
};
const timeFormats$n = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$n = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$n = {
    date: buildFormatLongFn({
        formats: dateFormats$n,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$n,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$n,
        defaultWidth: "full"
    })
};
const adjectivesLastWeek = {
    masculine: "ostatni",
    feminine: "ostatnia"
};
const adjectivesThisWeek = {
    masculine: "ten",
    feminine: "ta"
};
const adjectivesNextWeek = {
    masculine: "nastpny",
    feminine: "nastpna"
};
const dayGrammaticalGender = {
    0: "feminine",
    1: "masculine",
    2: "masculine",
    3: "feminine",
    4: "masculine",
    5: "masculine",
    6: "feminine"
};
function dayAndTimeWithAdjective(token, date, baseDate, options2) {
    let adjectives;
    if (isSameWeek(date, baseDate, options2)) {
        adjectives = adjectivesThisWeek;
    }
    else if (token === "lastWeek") {
        adjectives = adjectivesLastWeek;
    }
    else if (token === "nextWeek") {
        adjectives = adjectivesNextWeek;
    }
    else {
        throw new Error(`Cannot determine adjectives for token ${token}`);
    }
    const day = date.getDay();
    const grammaticalGender = dayGrammaticalGender[day];
    const adjective = adjectives[grammaticalGender];
    return `'${adjective}' eeee 'o' p`;
}
const formatRelativeLocale$n = {
    lastWeek: dayAndTimeWithAdjective,
    yesterday: "'wczoraj o' p",
    today: "'dzisiaj o' p",
    tomorrow: "'jutro o' p",
    nextWeek: dayAndTimeWithAdjective,
    other: "P"
};
const formatRelative$n = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$n[token];
    if (typeof format2 === "function") {
        return format2(token, date, baseDate, options2);
    }
    return format2;
};
const eraValues$n = {
    narrow: ["p.n.e.", "n.e."],
    abbreviated: ["p.n.e.", "n.e."],
    wide: ["przed nasz er", "naszej ery"]
};
const quarterValues$n = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["I kw.", "II kw.", "III kw.", "IV kw."],
    wide: ["I kwarta", "II kwarta", "III kwarta", "IV kwarta"]
};
const monthValues$n = {
    narrow: ["S", "L", "M", "K", "M", "C", "L", "S", "W", "P", "L", "G"],
    abbreviated: [
        "sty",
        "lut",
        "mar",
        "kwi",
        "maj",
        "cze",
        "lip",
        "sie",
        "wrz",
        "pa",
        "lis",
        "gru"
    ],
    wide: [
        "stycze",
        "luty",
        "marzec",
        "kwiecie",
        "maj",
        "czerwiec",
        "lipiec",
        "sierpie",
        "wrzesie",
        "padziernik",
        "listopad",
        "grudzie"
    ]
};
const monthFormattingValues = {
    narrow: ["s", "l", "m", "k", "m", "c", "l", "s", "w", "p", "l", "g"],
    abbreviated: [
        "sty",
        "lut",
        "mar",
        "kwi",
        "maj",
        "cze",
        "lip",
        "sie",
        "wrz",
        "pa",
        "lis",
        "gru"
    ],
    wide: [
        "stycznia",
        "lutego",
        "marca",
        "kwietnia",
        "maja",
        "czerwca",
        "lipca",
        "sierpnia",
        "wrzenia",
        "padziernika",
        "listopada",
        "grudnia"
    ]
};
const dayValues$n = {
    narrow: ["N", "P", "W", "", "C", "P", "S"],
    short: ["nie", "pon", "wto", "ro", "czw", "pi", "sob"],
    abbreviated: ["niedz.", "pon.", "wt.", "r.", "czw.", "pt.", "sob."],
    wide: [
        "niedziela",
        "poniedziaek",
        "wtorek",
        "roda",
        "czwartek",
        "pitek",
        "sobota"
    ]
};
const dayFormattingValues = {
    narrow: ["n", "p", "w", "", "c", "p", "s"],
    short: ["nie", "pon", "wto", "ro", "czw", "pi", "sob"],
    abbreviated: ["niedz.", "pon.", "wt.", "r.", "czw.", "pt.", "sob."],
    wide: [
        "niedziela",
        "poniedziaek",
        "wtorek",
        "roda",
        "czwartek",
        "pitek",
        "sobota"
    ]
};
const dayPeriodValues$n = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "pn.",
        noon: "po",
        morning: "rano",
        afternoon: "popo.",
        evening: "wiecz.",
        night: "noc"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pnoc",
        noon: "poudnie",
        morning: "rano",
        afternoon: "popoudnie",
        evening: "wieczr",
        night: "noc"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pnoc",
        noon: "poudnie",
        morning: "rano",
        afternoon: "popoudnie",
        evening: "wieczr",
        night: "noc"
    }
};
const dayPeriodFormattingValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "o pn.",
        noon: "w po.",
        morning: "rano",
        afternoon: "po po.",
        evening: "wiecz.",
        night: "w nocy"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "o pnocy",
        noon: "w poudnie",
        morning: "rano",
        afternoon: "po poudniu",
        evening: "wieczorem",
        night: "w nocy"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "o pnocy",
        noon: "w poudnie",
        morning: "rano",
        afternoon: "po poudniu",
        evening: "wieczorem",
        night: "w nocy"
    }
};
const ordinalNumber$n = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$n = {
    ordinalNumber: ordinalNumber$n,
    era: buildLocalizeFn({
        values: eraValues$n,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$n,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$n,
        defaultWidth: "wide",
        formattingValues: monthFormattingValues,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$n,
        defaultWidth: "wide",
        formattingValues: dayFormattingValues,
        defaultFormattingWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$n,
        defaultWidth: "wide",
        formattingValues: dayPeriodFormattingValues,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$n = /^(\d+)?/i;
const parseOrdinalNumberPattern$n = /\d+/i;
const matchEraPatterns$n = {
    narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
    abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
    wide: /^(przed\s*nasz(|a)\s*er(|a)|naszej\s*ery)/i
};
const parseEraPatterns$n = {
    any: [/^p/i, /^n/i]
};
const matchQuarterPatterns$n = {
    narrow: /^[1234]/i,
    abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
    wide: /^(I|II|III|IV)\s*kwarta(|l)/i
};
const parseQuarterPatterns$n = {
    narrow: [/1/i, /2/i, /3/i, /4/i],
    any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i]
};
const matchMonthPatterns$n = {
    narrow: /^[slmkcwpg]/i,
    abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(|z)|lis|gru)/i,
    wide: /^(stycznia|stycze(|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(|n)|wrze(|s)nia|wrzesie(|n)|pa(|z)dziernika|pa(|z)dziernik|listopada|listopad|grudnia|grudzie(|n))/i
};
const parseMonthPatterns$n = {
    narrow: [
        /^s/i,
        /^l/i,
        /^m/i,
        /^k/i,
        /^m/i,
        /^c/i,
        /^l/i,
        /^s/i,
        /^w/i,
        /^p/i,
        /^l/i,
        /^g/i
    ],
    any: [
        /^st/i,
        /^lu/i,
        /^mar/i,
        /^k/i,
        /^maj/i,
        /^c/i,
        /^lip/i,
        /^si/i,
        /^w/i,
        /^p/i,
        /^lis/i,
        /^g/i
    ]
};
const matchDayPatterns$n = {
    narrow: /^[npwcs]/i,
    short: /^(nie|pon|wto|(|s)ro|czw|pi(|a)|sob)/i,
    abbreviated: /^(niedz|pon|wt|(|s)r|czw|pt|sob)\.?/i,
    wide: /^(niedziela|poniedzia(|l)ek|wtorek|(|s)roda|czwartek|pi(|a)tek|sobota)/i
};
const parseDayPatterns$n = {
    narrow: [/^n/i, /^p/i, /^w/i, /^/i, /^c/i, /^p/i, /^s/i],
    abbreviated: [/^n/i, /^po/i, /^w/i, /^(|s)r/i, /^c/i, /^pt/i, /^so/i],
    any: [/^n/i, /^po/i, /^w/i, /^(|s)r/i, /^c/i, /^pi/i, /^so/i]
};
const matchDayPeriodPatterns$n = {
    narrow: /^(^a$|^p$|p(|l)n\.?|o\s*p(|l)n\.?|po(|l)\.?|w\s*po(|l)\.?|po\s*po(|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
    any: /^(am|pm|p(|l)noc|o\s*p(|l)nocy|po(|l)udnie|w\s*po(|l)udnie|popo(|l)udnie|po\s*po(|l)udniu|rano|wieczr|wieczorem|noc|w\s*nocy)/i
};
const parseDayPeriodPatterns$n = {
    narrow: {
        am: /^a$/i,
        pm: /^p$/i,
        midnight: /p(|l)n/i,
        noon: /po(|l)/i,
        morning: /rano/i,
        afternoon: /po\s*po(|l)/i,
        evening: /wiecz/i,
        night: /noc/i
    },
    any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /p(|l)n/i,
        noon: /po(|l)/i,
        morning: /rano/i,
        afternoon: /po\s*po(|l)/i,
        evening: /wiecz/i,
        night: /noc/i
    }
};
const match$n = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$n,
        parsePattern: parseOrdinalNumberPattern$n,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$n,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$n,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$n,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$n,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$n,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$n,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$n,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$n,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$n,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$n,
        defaultParseWidth: "any"
    })
};
const pl = {
    code: "pl",
    formatDistance: formatDistance$n,
    formatLong: formatLong$n,
    formatRelative: formatRelative$n,
    localize: localize$n,
    match: match$n,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$m = {
    lessThanXSeconds: {
        one: "menos de um segundo",
        other: "menos de {{count}} segundos"
    },
    xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
    },
    halfAMinute: "meio minuto",
    lessThanXMinutes: {
        one: "menos de um minuto",
        other: "menos de {{count}} minutos"
    },
    xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
    },
    aboutXHours: {
        one: "aproximadamente 1 hora",
        other: "aproximadamente {{count}} horas"
    },
    xHours: {
        one: "1 hora",
        other: "{{count}} horas"
    },
    xDays: {
        one: "1 dia",
        other: "{{count}} dias"
    },
    aboutXWeeks: {
        one: "aproximadamente 1 semana",
        other: "aproximadamente {{count}} semanas"
    },
    xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
    },
    aboutXMonths: {
        one: "aproximadamente 1 ms",
        other: "aproximadamente {{count}} meses"
    },
    xMonths: {
        one: "1 ms",
        other: "{{count}} meses"
    },
    aboutXYears: {
        one: "aproximadamente 1 ano",
        other: "aproximadamente {{count}} anos"
    },
    xYears: {
        one: "1 ano",
        other: "{{count}} anos"
    },
    overXYears: {
        one: "mais de 1 ano",
        other: "mais de {{count}} anos"
    },
    almostXYears: {
        one: "quase 1 ano",
        other: "quase {{count}} anos"
    }
};
const formatDistance$m = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$m[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "daqui a " + result;
        }
        else {
            return "h " + result;
        }
    }
    return result;
};
const dateFormats$m = {
    full: "EEEE, d 'de' MMMM 'de' y",
    long: "d 'de' MMMM 'de' y",
    medium: "d 'de' MMM 'de' y",
    short: "dd/MM/y"
};
const timeFormats$m = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$m = {
    full: "{{date}} 's' {{time}}",
    long: "{{date}} 's' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$m = {
    date: buildFormatLongFn({
        formats: dateFormats$m,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$m,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$m,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$m = {
    lastWeek: (date) => {
        const weekday = date.getDay();
        const last2 = weekday === 0 || weekday === 6 ? "ltimo" : "ltima";
        return "'" + last2 + "' eeee 's' p";
    },
    yesterday: "'ontem s' p",
    today: "'hoje s' p",
    tomorrow: "'amanh s' p",
    nextWeek: "eeee 's' p",
    other: "P"
};
const formatRelative$m = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$m[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$m = {
    narrow: ["aC", "dC"],
    abbreviated: ["a.C.", "d.C."],
    wide: ["antes de Cristo", "depois de Cristo"]
};
const quarterValues$m = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$m = {
    narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "jan",
        "fev",
        "mar",
        "abr",
        "mai",
        "jun",
        "jul",
        "ago",
        "set",
        "out",
        "nov",
        "dez"
    ],
    wide: [
        "janeiro",
        "fevereiro",
        "maro",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro"
    ]
};
const dayValues$m = {
    narrow: ["d", "s", "t", "q", "q", "s", "s"],
    short: ["dom", "seg", "ter", "qua", "qui", "sex", "sb"],
    abbreviated: ["dom", "seg", "ter", "qua", "qui", "sex", "sb"],
    wide: [
        "domingo",
        "segunda-feira",
        "tera-feira",
        "quarta-feira",
        "quinta-feira",
        "sexta-feira",
        "sbado"
    ]
};
const dayPeriodValues$m = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manh",
        afternoon: "tarde",
        evening: "noite",
        night: "madrugada"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manh",
        afternoon: "tarde",
        evening: "noite",
        night: "madrugada"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manh",
        afternoon: "tarde",
        evening: "noite",
        night: "madrugada"
    }
};
const formattingDayPeriodValues$l = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manh",
        afternoon: "da tarde",
        evening: "da noite",
        night: "da madrugada"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manh",
        afternoon: "da tarde",
        evening: "da noite",
        night: "da madrugada"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manh",
        afternoon: "da tarde",
        evening: "da noite",
        night: "da madrugada"
    }
};
const ordinalNumber$m = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "";
};
const localize$m = {
    ordinalNumber: ordinalNumber$m,
    era: buildLocalizeFn({
        values: eraValues$m,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$m,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$m,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$m,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$m,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$l,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$m = /^(\d+)(|)?/i;
const parseOrdinalNumberPattern$m = /\d+/i;
const matchEraPatterns$m = {
    narrow: /^(ac|dc|a|d)/i,
    abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
    wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i
};
const parseEraPatterns$m = {
    any: [/^ac/i, /^dc/i],
    wide: [
        /^(antes de cristo|antes da era comum)/i,
        /^(depois de cristo|era comum)/i
    ]
};
const matchQuarterPatterns$m = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^[1234](|)? trimestre/i
};
const parseQuarterPatterns$m = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$m = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
    wide: /^(janeiro|fevereiro|maro|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
};
const parseMonthPatterns$m = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ab/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^ag/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$m = {
    narrow: /^[dstq]/i,
    short: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
    abbreviated: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
    wide: /^(domingo|segunda-?\s?feira|tera-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[a]bado)/i
};
const parseDayPatterns$m = {
    narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
    any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[a]/i]
};
const matchDayPeriodPatterns$m = {
    narrow: /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[a]|tarde|noite|madrugada))/i,
    any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[a]|tarde|noite|madrugada))/i
};
const parseDayPeriodPatterns$m = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^meia/i,
        noon: /^meio/i,
        morning: /manh[a]/i,
        afternoon: /tarde/i,
        evening: /noite/i,
        night: /madrugada/i
    }
};
const match$m = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$m,
        parsePattern: parseOrdinalNumberPattern$m,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$m,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$m,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$m,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$m,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$m,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$m,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$m,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$m,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$m,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$m,
        defaultParseWidth: "any"
    })
};
const pt = {
    code: "pt",
    formatDistance: formatDistance$m,
    formatLong: formatLong$m,
    formatRelative: formatRelative$m,
    localize: localize$m,
    match: match$m,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$l = {
    lessThanXSeconds: {
        one: "menos de um segundo",
        other: "menos de {{count}} segundos"
    },
    xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
    },
    halfAMinute: "meio minuto",
    lessThanXMinutes: {
        one: "menos de um minuto",
        other: "menos de {{count}} minutos"
    },
    xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
    },
    aboutXHours: {
        one: "cerca de 1 hora",
        other: "cerca de {{count}} horas"
    },
    xHours: {
        one: "1 hora",
        other: "{{count}} horas"
    },
    xDays: {
        one: "1 dia",
        other: "{{count}} dias"
    },
    aboutXWeeks: {
        one: "cerca de 1 semana",
        other: "cerca de {{count}} semanas"
    },
    xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
    },
    aboutXMonths: {
        one: "cerca de 1 ms",
        other: "cerca de {{count}} meses"
    },
    xMonths: {
        one: "1 ms",
        other: "{{count}} meses"
    },
    aboutXYears: {
        one: "cerca de 1 ano",
        other: "cerca de {{count}} anos"
    },
    xYears: {
        one: "1 ano",
        other: "{{count}} anos"
    },
    overXYears: {
        one: "mais de 1 ano",
        other: "mais de {{count}} anos"
    },
    almostXYears: {
        one: "quase 1 ano",
        other: "quase {{count}} anos"
    }
};
const formatDistance$l = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$l[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "em " + result;
        }
        else {
            return "h " + result;
        }
    }
    return result;
};
const dateFormats$l = {
    full: "EEEE, d 'de' MMMM 'de' y",
    long: "d 'de' MMMM 'de' y",
    medium: "d MMM y",
    short: "dd/MM/yyyy"
};
const timeFormats$l = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$l = {
    full: "{{date}} 's' {{time}}",
    long: "{{date}} 's' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$l = {
    date: buildFormatLongFn({
        formats: dateFormats$l,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$l,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$l,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$l = {
    lastWeek: (date) => {
        const weekday = date.getDay();
        const last2 = weekday === 0 || weekday === 6 ? "ltimo" : "ltima";
        return "'" + last2 + "' eeee 's' p";
    },
    yesterday: "'ontem s' p",
    today: "'hoje s' p",
    tomorrow: "'amanh s' p",
    nextWeek: "eeee 's' p",
    other: "P"
};
const formatRelative$l = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$l[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$l = {
    narrow: ["AC", "DC"],
    abbreviated: ["AC", "DC"],
    wide: ["antes de cristo", "depois de cristo"]
};
const quarterValues$l = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$l = {
    narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "jan",
        "fev",
        "mar",
        "abr",
        "mai",
        "jun",
        "jul",
        "ago",
        "set",
        "out",
        "nov",
        "dez"
    ],
    wide: [
        "janeiro",
        "fevereiro",
        "maro",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro"
    ]
};
const dayValues$l = {
    narrow: ["D", "S", "T", "Q", "Q", "S", "S"],
    short: ["dom", "seg", "ter", "qua", "qui", "sex", "sab"],
    abbreviated: [
        "domingo",
        "segunda",
        "tera",
        "quarta",
        "quinta",
        "sexta",
        "sbado"
    ],
    wide: [
        "domingo",
        "segunda-feira",
        "tera-feira",
        "quarta-feira",
        "quinta-feira",
        "sexta-feira",
        "sbado"
    ]
};
const dayPeriodValues$l = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "manh",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manh",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manh",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
    }
};
const formattingDayPeriodValues$k = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "da manh",
        afternoon: "da tarde",
        evening: "da tarde",
        night: "da noite"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manh",
        afternoon: "da tarde",
        evening: "da tarde",
        night: "da noite"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manh",
        afternoon: "da tarde",
        evening: "da tarde",
        night: "da noite"
    }
};
const ordinalNumber$l = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    if (options2?.unit === "week") {
        return number2 + "";
    }
    return number2 + "";
};
const localize$l = {
    ordinalNumber: ordinalNumber$l,
    era: buildLocalizeFn({
        values: eraValues$l,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$l,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$l,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$l,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$l,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$k,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$l = /^(\d+)[o]?/i;
const parseOrdinalNumberPattern$l = /\d+/i;
const matchEraPatterns$l = {
    narrow: /^(ac|dc|a|d)/i,
    abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
    wide: /^(antes de cristo|depois de cristo)/i
};
const parseEraPatterns$l = {
    any: [/^ac/i, /^dc/i],
    wide: [/^antes de cristo/i, /^depois de cristo/i]
};
const matchQuarterPatterns$l = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$l = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$l = {
    narrow: /^[jfmajsond]/i,
    abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
    wide: /^(janeiro|fevereiro|maro|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
};
const parseMonthPatterns$l = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^fev/i,
        /^mar/i,
        /^abr/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^set/i,
        /^out/i,
        /^nov/i,
        /^dez/i
    ]
};
const matchDayPatterns$l = {
    narrow: /^(dom|[23456]?|s[a]b)/i,
    short: /^(dom|[23456]?|s[a]b)/i,
    abbreviated: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
    wide: /^(domingo|(segunda|ter[c]a|quarta|quinta|sexta)([- ]feira)?|s[a]bado)/i
};
const parseDayPatterns$l = {
    short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[a]/i],
    narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[a]/i],
    any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[a]b/i]
};
const matchDayPeriodPatterns$l = {
    narrow: /^(a|p|mn|md|(da) (manh|tarde|noite))/i,
    any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manh|tarde|noite))/i
};
const parseDayPeriodPatterns$l = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn|^meia[-\s]noite/i,
        noon: /^md|^meio[-\s]dia/i,
        morning: /manh/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noite/i
    }
};
const match$l = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$l,
        parsePattern: parseOrdinalNumberPattern$l,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$l,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$l,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$l,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$l,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$l,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$l,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$l,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$l,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$l,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$l,
        defaultParseWidth: "any"
    })
};
const ptBR = {
    code: "pt-BR",
    formatDistance: formatDistance$l,
    formatLong: formatLong$l,
    formatRelative: formatRelative$l,
    localize: localize$l,
    match: match$l,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$k = {
    lessThanXSeconds: {
        one: "mai puin de o secund",
        other: "mai puin de {{count}} secunde"
    },
    xSeconds: {
        one: "1 secund",
        other: "{{count}} secunde"
    },
    halfAMinute: "jumtate de minut",
    lessThanXMinutes: {
        one: "mai puin de un minut",
        other: "mai puin de {{count}} minute"
    },
    xMinutes: {
        one: "1 minut",
        other: "{{count}} minute"
    },
    aboutXHours: {
        one: "circa 1 or",
        other: "circa {{count}} ore"
    },
    xHours: {
        one: "1 or",
        other: "{{count}} ore"
    },
    xDays: {
        one: "1 zi",
        other: "{{count}} zile"
    },
    aboutXWeeks: {
        one: "circa o sptmn",
        other: "circa {{count}} sptmni"
    },
    xWeeks: {
        one: "1 sptmn",
        other: "{{count}} sptmni"
    },
    aboutXMonths: {
        one: "circa 1 lun",
        other: "circa {{count}} luni"
    },
    xMonths: {
        one: "1 lun",
        other: "{{count}} luni"
    },
    aboutXYears: {
        one: "circa 1 an",
        other: "circa {{count}} ani"
    },
    xYears: {
        one: "1 an",
        other: "{{count}} ani"
    },
    overXYears: {
        one: "peste 1 an",
        other: "peste {{count}} ani"
    },
    almostXYears: {
        one: "aproape 1 an",
        other: "aproape {{count}} ani"
    }
};
const formatDistance$k = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$k[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "n " + result;
        }
        else {
            return result + " n urm";
        }
    }
    return result;
};
const dateFormats$k = {
    full: "EEEE, d MMMM yyyy",
    long: "d MMMM yyyy",
    medium: "d MMM yyyy",
    short: "dd.MM.yyyy"
};
const timeFormats$k = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$k = {
    full: "{{date}} 'la' {{time}}",
    long: "{{date}} 'la' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$k = {
    date: buildFormatLongFn({
        formats: dateFormats$k,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$k,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$k,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$k = {
    lastWeek: "eeee 'trecut la' p",
    yesterday: "'ieri la' p",
    today: "'astzi la' p",
    tomorrow: "'mine la' p",
    nextWeek: "eeee 'viitoare la' p",
    other: "P"
};
const formatRelative$k = (token, _date, _baseDate, _options) => formatRelativeLocale$k[token];
const eraValues$k = {
    narrow: ["", "D"],
    abbreviated: [".d.C.", "D.C."],
    wide: ["nainte de Cristos", "Dup Cristos"]
};
const quarterValues$k = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: [
        "primul trimestru",
        "al doilea trimestru",
        "al treilea trimestru",
        "al patrulea trimestru"
    ]
};
const monthValues$k = {
    narrow: ["I", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
    abbreviated: [
        "ian",
        "feb",
        "mar",
        "apr",
        "mai",
        "iun",
        "iul",
        "aug",
        "sep",
        "oct",
        "noi",
        "dec"
    ],
    wide: [
        "ianuarie",
        "februarie",
        "martie",
        "aprilie",
        "mai",
        "iunie",
        "iulie",
        "august",
        "septembrie",
        "octombrie",
        "noiembrie",
        "decembrie"
    ]
};
const dayValues$k = {
    narrow: ["d", "l", "m", "m", "j", "v", "s"],
    short: ["du", "lu", "ma", "mi", "jo", "vi", "s"],
    abbreviated: ["dum", "lun", "mar", "mie", "joi", "vin", "sm"],
    wide: ["duminic", "luni", "mari", "miercuri", "joi", "vineri", "smbt"]
};
const dayPeriodValues$k = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "ami",
        morning: "dim",
        afternoon: "da",
        evening: "s",
        night: "n"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "miezul nopii",
        noon: "amiaz",
        morning: "diminea",
        afternoon: "dup-amiaz",
        evening: "sear",
        night: "noapte"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "miezul nopii",
        noon: "amiaz",
        morning: "diminea",
        afternoon: "dup-amiaz",
        evening: "sear",
        night: "noapte"
    }
};
const formattingDayPeriodValues$j = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "amiaz",
        morning: "diminea",
        afternoon: "dup-amiaz",
        evening: "sear",
        night: "noapte"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "miezul nopii",
        noon: "amiaz",
        morning: "diminea",
        afternoon: "dup-amiaz",
        evening: "sear",
        night: "noapte"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "miezul nopii",
        noon: "amiaz",
        morning: "diminea",
        afternoon: "dup-amiaz",
        evening: "sear",
        night: "noapte"
    }
};
const ordinalNumber$k = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$k = {
    ordinalNumber: ordinalNumber$k,
    era: buildLocalizeFn({
        values: eraValues$k,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$k,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$k,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$k,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$k,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$j,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$k = /^(\d+)?/i;
const parseOrdinalNumberPattern$k = /\d+/i;
const matchEraPatterns$k = {
    narrow: /^(|D)/i,
    abbreviated: /^(\.?\s?d\.?\s?C\.?|\.?\s?e\.?\s?n\.?|D\.?\s?C\.?|e\.?\s?n\.?)/i,
    wide: /^(nainte de Cristos|naintea erei noastre|Dup Cristos|Era noastr)/i
};
const parseEraPatterns$k = {
    any: [/^C/i, /^DC/i],
    wide: [
        /^(nainte de Cristos|naintea erei noastre)/i,
        /^(Dup Cristos|Era noastr)/i
    ]
};
const matchQuarterPatterns$k = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^trimestrul [1234]/i
};
const parseQuarterPatterns$k = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$k = {
    narrow: /^[ifmaasond]/i,
    abbreviated: /^(ian|feb|mar|apr|mai|iun|iul|aug|sep|oct|noi|dec)/i,
    wide: /^(ianuarie|februarie|martie|aprilie|mai|iunie|iulie|august|septembrie|octombrie|noiembrie|decembrie)/i
};
const parseMonthPatterns$k = {
    narrow: [
        /^i/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^i/i,
        /^i/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ia/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mai/i,
        /^iun/i,
        /^iul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$k = {
    narrow: /^[dlmjvs]/i,
    short: /^(d|l|ma|mi|j|v|s)/i,
    abbreviated: /^(dum|lun|mar|mie|jo|vi|s)/i,
    wide: /^(duminica|luni|mari|miercuri|joi|vineri|smbt)/i
};
const parseDayPatterns$k = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
    any: [/^d/i, /^l/i, /^ma/i, /^mi/i, /^j/i, /^v/i, /^s/i]
};
const matchDayPeriodPatterns$k = {
    narrow: /^(a|p|mn|a|(dimineaa|dup-amiaza|seara|noaptea))/i,
    any: /^([ap]\.?\s?m\.?|miezul nopii|amiaza|(dimineaa|dup-amiaza|seara|noaptea))/i
};
const parseDayPeriodPatterns$k = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn/i,
        noon: /amiaza/i,
        morning: /dimineaa/i,
        afternoon: /dup-amiaza/i,
        evening: /seara/i,
        night: /noaptea/i
    }
};
const match$k = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$k,
        parsePattern: parseOrdinalNumberPattern$k,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$k,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$k,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$k,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$k,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$k,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$k,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$k,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$k,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$k,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$k,
        defaultParseWidth: "any"
    })
};
const ro = {
    code: "ro",
    formatDistance: formatDistance$k,
    formatLong: formatLong$k,
    formatRelative: formatRelative$k,
    localize: localize$k,
    match: match$k,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
function declension$2(scheme, count) {
    if (scheme.one !== void 0 && count === 1) {
        return scheme.one;
    }
    const rem10 = count % 10;
    const rem100 = count % 100;
    if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
    }
    else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
    }
    else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
    }
}
function buildLocalizeTokenFn$1(scheme) {
    return (count, options2) => {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                if (scheme.future) {
                    return declension$2(scheme.future, count);
                }
                else {
                    return " " + declension$2(scheme.regular, count);
                }
            }
            else {
                if (scheme.past) {
                    return declension$2(scheme.past, count);
                }
                else {
                    return declension$2(scheme.regular, count) + " ";
                }
            }
        }
        else {
            return declension$2(scheme.regular, count);
        }
    };
}
const formatDistanceLocale$j = {
    lessThanXSeconds: buildLocalizeTokenFn$1({
        regular: {
            one: " ",
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xSeconds: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    halfAMinute: (_count, options2) => {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                return " ";
            }
            else {
                return " ";
            }
        }
        return "";
    },
    lessThanXMinutes: buildLocalizeTokenFn$1({
        regular: {
            one: " ",
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xMinutes: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    aboutXHours: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xHours: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    xDays: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXWeeks: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xWeeks: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXMonths: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xMonths: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXYears: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xYears: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    overXYears: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    almostXYears: buildLocalizeTokenFn$1({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    })
};
const formatDistance$j = (token, count, options2) => {
    return formatDistanceLocale$j[token](count, options2);
};
const dateFormats$j = {
    full: "EEEE, d MMMM y '.'",
    long: "d MMMM y '.'",
    medium: "d MMM y '.'",
    short: "dd.MM.y"
};
const timeFormats$j = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$j = {
    any: "{{date}}, {{time}}"
};
const formatLong$j = {
    date: buildFormatLongFn({
        formats: dateFormats$j,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$j,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$j,
        defaultWidth: "any"
    })
};
const accusativeWeekdays$2 = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek$2(day) {
    const weekday = accusativeWeekdays$2[day];
    switch (day) {
        case 0:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
    }
}
function thisWeek$2(day) {
    const weekday = accusativeWeekdays$2[day];
    if (day === 2) {
        return "' " + weekday + " ' p";
    }
    else {
        return "' " + weekday + " ' p";
    }
}
function nextWeek$2(day) {
    const weekday = accusativeWeekdays$2[day];
    switch (day) {
        case 0:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
    }
}
const formatRelativeLocale$j = {
    lastWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$2(day);
        }
        else {
            return lastWeek$2(day);
        }
    },
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$2(day);
        }
        else {
            return nextWeek$2(day);
        }
    },
    other: "P"
};
const formatRelative$j = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$j[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$j = {
    narrow: [" ..", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
};
const quarterValues$j = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$j = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        "",
        ".",
        "",
        "",
        "",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$5 = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        "",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$j = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$j = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$i = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$j = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = options2?.unit;
    let suffix;
    if (unit === "date") {
        suffix = "-";
    }
    else if (unit === "week" || unit === "minute" || unit === "second") {
        suffix = "-";
    }
    else {
        suffix = "-";
    }
    return number2 + suffix;
};
const localize$j = {
    ordinalNumber: ordinalNumber$j,
    era: buildLocalizeFn({
        values: eraValues$j,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$j,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$j,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$5,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$j,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$j,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$i,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$j = /^(\d+)(-?(||||||||||))?/i;
const parseOrdinalNumberPattern$j = /\d+/i;
const matchEraPatterns$j = {
    narrow: /^(( )?\.?\s?\.?)/i,
    abbreviated: /^(( )?\.?\s?\.?)/i,
    wide: /^(  | | )/i
};
const parseEraPatterns$j = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$j = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]??)? .?/i,
    wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$j = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$j = {
    narrow: /^[]/i,
    abbreviated: /^(||?||[]|[]?|[]?||?||?|)\.?/i,
    wide: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[]|[])/i
};
const parseMonthPatterns$j = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^[]/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$j = {
    narrow: /^[]/i,
    short: /^(|||||||||||)\.?/i,
    abbreviated: /^(||||||||||||).?/i,
    wide: /^([]|?|?|[]|?|[]|[])/i
};
const parseDayPatterns$j = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^[]/i, /^[]/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns$j = {
    narrow: /^([]|\.?|\.?|[]|||\.?|[])/i,
    abbreviated: /^([]|\.?|\.?|[]|||\.?|[])/i,
    wide: /^([]|||[]|||?|[])/i
};
const parseDayPeriodPatterns$j = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^[]/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$j = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$j,
        parsePattern: parseOrdinalNumberPattern$j,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$j,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$j,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$j,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$j,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$j,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$j,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$j,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$j,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$j,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$j,
        defaultParseWidth: "any"
    })
};
const ru = {
    code: "ru",
    formatDistance: formatDistance$j,
    formatLong: formatLong$j,
    formatRelative: formatRelative$j,
    localize: localize$j,
    match: match$j,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$i = {
    lessThanXSeconds: {
        one: "unnit go ovtta sekundda",
        other: "unnit go {{count}} sekundda"
    },
    xSeconds: {
        one: "sekundda",
        other: "{{count}} sekundda"
    },
    halfAMinute: "bealle minuhta",
    lessThanXMinutes: {
        one: "unnit go bealle minuhta",
        other: "unnit go {{count}} minuhta"
    },
    xMinutes: {
        one: "minuhta",
        other: "{{count}} minuhta"
    },
    aboutXHours: {
        one: "sullii ovtta diimmu",
        other: "sullii {{count}} diimmu"
    },
    xHours: {
        one: "diimmu",
        other: "{{count}} diimmu"
    },
    xDays: {
        one: "beaivvi",
        other: "{{count}} beaivvi"
    },
    aboutXWeeks: {
        one: "sullii ovtta vahku",
        other: "sullii {{count}} vahku"
    },
    xWeeks: {
        one: "vahku",
        other: "{{count}} vahku"
    },
    aboutXMonths: {
        one: "sullii ovtta mnu",
        other: "sullii {{count}} mnu"
    },
    xMonths: {
        one: "mnu",
        other: "{{count}} mnu"
    },
    aboutXYears: {
        one: "sullii ovtta jagi",
        other: "sullii {{count}} jagi"
    },
    xYears: {
        one: "jagi",
        other: "{{count}} jagi"
    },
    overXYears: {
        one: "guhkit go jagi",
        other: "guhkit go {{count}} jagi"
    },
    almostXYears: {
        one: "measta jagi",
        other: "measta {{count}} jagi"
    }
};
const formatDistance$i = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$i[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "geahen " + result;
        }
        else {
            return result + " igi";
        }
    }
    return result;
};
const dateFormats$i = {
    full: "EEEE MMMM d. 'b.' y",
    long: "MMMM d. 'b.' y",
    medium: "MMM d. 'b.' y",
    short: "dd.MM.y"
};
const timeFormats$i = {
    full: "'dii.' HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$i = {
    full: "{{date}} 'dii.' {{time}}",
    long: "{{date}} 'dii.' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$i = {
    date: buildFormatLongFn({
        formats: dateFormats$i,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$i,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$i,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$i = {
    lastWeek: "'ovddit' eeee 'dii.' p",
    yesterday: "'ikte dii.' p",
    today: "'odne dii.' p",
    tomorrow: "'ihtin dii.' p",
    nextWeek: "EEEE 'dii.' p",
    other: "P"
};
const formatRelative$i = (token, _date, _baseDate, _options) => formatRelativeLocale$i[token];
const eraValues$i = {
    narrow: ["o.Kr.", "m.Kr."],
    abbreviated: ["o.Kr.", "m.Kr."],
    wide: ["ovdal Kristusa", "mael Kristusa"]
};
const quarterValues$i = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. kvartla", "2. kvartla", "3. kvartla", "4. kvartla"]
};
const monthValues$i = {
    narrow: ["O", "G", "N", "C", "M", "G", "S", "B", "", "G", "S", "J"],
    abbreviated: [
        "oa",
        "guov",
        "njuk",
        "cuo",
        "mies",
        "geas",
        "suoi",
        "borg",
        "ak",
        "golg",
        "skb",
        "juov"
    ],
    wide: [
        "oajagemnnu",
        "guovvamnnu",
        "njukamnnu",
        "cuoomnnu",
        "miessemnnu",
        "geassemnnu",
        "suoidnemnnu",
        "borgemnnu",
        "akamnnu",
        "golggotmnnu",
        "skbmamnnu",
        "juovlamnnu"
    ]
};
const dayValues$i = {
    narrow: ["S", "V", "M", "G", "D", "B", "L"],
    short: ["sotn", "vuos", "ma", "gask", "duor", "bear", "lv"],
    abbreviated: ["sotn", "vuos", "ma", "gask", "duor", "bear", "lv"],
    wide: [
        "sotnabeaivi",
        "vuossrga",
        "maebrga",
        "gaskavahkku",
        "duorastat",
        "bearjadat",
        "lvvardat"
    ]
};
const dayPeriodValues$i = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "gaskaidja",
        noon: "gaskabeaivi",
        morning: "ies",
        afternoon: "mael gaska.",
        evening: "eahkes",
        night: "ihkku"
    },
    abbreviated: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "gaskaidja",
        noon: "gaskabeaivvi",
        morning: "ies",
        afternoon: "mael gaskabea.",
        evening: "eahkes",
        night: "ihkku"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "gaskaidja",
        noon: "gaskabeavvi",
        morning: "ies",
        afternoon: "mael gaskabeaivvi",
        evening: "eahkes",
        night: "ihkku"
    }
};
const ordinalNumber$i = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$i = {
    ordinalNumber: ordinalNumber$i,
    era: buildLocalizeFn({
        values: eraValues$i,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$i,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$i,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$i,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$i,
        defaultWidth: "wide"
    })
};
const matchOrdinalNumberPattern$i = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$i = /\d+/i;
const matchEraPatterns$i = {
    narrow: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
    abbreviated: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
    wide: /^(ovdal Kristusa|ovdal min iggi|mael Kristusa|min igi)/i
};
const parseEraPatterns$i = {
    any: [/^o/i, /^m/i]
};
const matchQuarterPatterns$i = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](\.)? kvartla/i
};
const parseQuarterPatterns$i = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$i = {
    narrow: /^[ogncmsbj]/i,
    abbreviated: /^(oa|guov|njuk|cuo|mies|geas|suoi|borg|ak|golg|skb|juov)\.?/i,
    wide: /^(oajagemnnu|guovvamnnu|njukamnnu|cuoomnnu|miessemnnu|geassemnnu|suoidnemnnu|borgemnnu|akamnnu|golggotmnnu|skbmamnnu|juovlamnnu)/i
};
const parseMonthPatterns$i = {
    narrow: [
        /^o/i,
        /^g/i,
        /^n/i,
        /^c/i,
        /^m/i,
        /^g/i,
        /^s/i,
        /^b/i,
        /^/i,
        /^g/i,
        /^s/i,
        /^j/i
    ],
    any: [
        /^o/i,
        /^gu/i,
        /^n/i,
        /^c/i,
        /^m/i,
        /^ge/i,
        /^su/i,
        /^b/i,
        /^/i,
        /^go/i,
        /^sk/i,
        /^j/i
    ]
};
const matchDayPatterns$i = {
    narrow: /^[svmgdbl]/i,
    short: /^(sotn|vuos|ma|gask|duor|bear|lv)/i,
    abbreviated: /^(sotn|vuos|ma|gask|duor|bear|lv)/i,
    wide: /^(sotnabeaivi|vuossrga|maebrga|gaskavahkku|duorastat|bearjadat|lvvardat)/i
};
const parseDayPatterns$i = {
    any: [/^s/i, /^v/i, /^m/i, /^g/i, /^d/i, /^b/i, /^l/i]
};
const matchDayPeriodPatterns$i = {
    narrow: /^(gaskaidja|gaskabeaivvi|(p) (ies|mael gaskabeaivvi|eahkes|ihkku)|[ap])/i,
    any: /^([ap]\.?\s?m\.?|gaskaidja|gaskabeaivvi|(p) (ies|mael gaskabeaivvi|eahkes|ihkku))/i
};
const parseDayPeriodPatterns$i = {
    any: {
        am: /^a(\.?\s?m\.?)?$/i,
        pm: /^p(\.?\s?m\.?)?$/i,
        midnight: /^gaskai/i,
        noon: /^gaskab/i,
        morning: /ies/i,
        afternoon: /mael gaskabeaivvi/i,
        evening: /eahkes/i,
        night: /ihkku/i
    }
};
const match$i = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$i,
        parsePattern: parseOrdinalNumberPattern$i,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$i,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$i,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$i,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$i,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$i,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$i,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$i,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$i,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$i,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$i,
        defaultParseWidth: "any"
    })
};
const se = {
    code: "se",
    formatDistance: formatDistance$i,
    formatLong: formatLong$i,
    formatRelative: formatRelative$i,
    localize: localize$i,
    match: match$i,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
function declensionGroup(scheme, count) {
    if (count === 1 && scheme.one) {
        return scheme.one;
    }
    if (count >= 2 && count <= 4 && scheme.twoFour) {
        return scheme.twoFour;
    }
    return scheme.other;
}
function declension$1(scheme, count, time) {
    const group = declensionGroup(scheme, count);
    const finalText = group[time];
    return finalText.replace("{{count}}", String(count));
}
function extractPreposition(token) {
    const result = ["lessThan", "about", "over", "almost"].filter(function (preposition) {
        return !!token.match(new RegExp("^" + preposition));
    });
    return result[0];
}
function prefixPreposition(preposition) {
    let translation = "";
    if (preposition === "almost") {
        translation = "takmer";
    }
    if (preposition === "about") {
        translation = "pribline";
    }
    return translation.length > 0 ? translation + " " : "";
}
function suffixPreposition(preposition) {
    let translation = "";
    if (preposition === "lessThan") {
        translation = "menej ne";
    }
    if (preposition === "over") {
        translation = "viac ne";
    }
    return translation.length > 0 ? translation + " " : "";
}
function lowercaseFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
}
const formatDistanceLocale$h = {
    xSeconds: {
        one: {
            present: "sekunda",
            past: "sekundou",
            future: "sekundu"
        },
        twoFour: {
            present: "{{count}} sekundy",
            past: "{{count}} sekundami",
            future: "{{count}} sekundy"
        },
        other: {
            present: "{{count}} seknd",
            past: "{{count}} sekundami",
            future: "{{count}} seknd"
        }
    },
    halfAMinute: {
        other: {
            present: "pol minty",
            past: "pol mintou",
            future: "pol minty"
        }
    },
    xMinutes: {
        one: {
            present: "minta",
            past: "mintou",
            future: "mintu"
        },
        twoFour: {
            present: "{{count}} minty",
            past: "{{count}} mintami",
            future: "{{count}} minty"
        },
        other: {
            present: "{{count}} mint",
            past: "{{count}} mintami",
            future: "{{count}} mint"
        }
    },
    xHours: {
        one: {
            present: "hodina",
            past: "hodinou",
            future: "hodinu"
        },
        twoFour: {
            present: "{{count}} hodiny",
            past: "{{count}} hodinami",
            future: "{{count}} hodiny"
        },
        other: {
            present: "{{count}} hodn",
            past: "{{count}} hodinami",
            future: "{{count}} hodn"
        }
    },
    xDays: {
        one: {
            present: "de",
            past: "dom",
            future: "de"
        },
        twoFour: {
            present: "{{count}} dni",
            past: "{{count}} dami",
            future: "{{count}} dni"
        },
        other: {
            present: "{{count}} dn",
            past: "{{count}} dami",
            future: "{{count}} dn"
        }
    },
    xWeeks: {
        one: {
            present: "tde",
            past: "tdom",
            future: "tde"
        },
        twoFour: {
            present: "{{count}} tdne",
            past: "{{count}} tdami",
            future: "{{count}} tdne"
        },
        other: {
            present: "{{count}} tdov",
            past: "{{count}} tdami",
            future: "{{count}} tdov"
        }
    },
    xMonths: {
        one: {
            present: "mesiac",
            past: "mesiacom",
            future: "mesiac"
        },
        twoFour: {
            present: "{{count}} mesiace",
            past: "{{count}} mesiacmi",
            future: "{{count}} mesiace"
        },
        other: {
            present: "{{count}} mesiacov",
            past: "{{count}} mesiacmi",
            future: "{{count}} mesiacov"
        }
    },
    xYears: {
        one: {
            present: "rok",
            past: "rokom",
            future: "rok"
        },
        twoFour: {
            present: "{{count}} roky",
            past: "{{count}} rokmi",
            future: "{{count}} roky"
        },
        other: {
            present: "{{count}} rokov",
            past: "{{count}} rokmi",
            future: "{{count}} rokov"
        }
    }
};
const formatDistance$h = (token, count, options2) => {
    const preposition = extractPreposition(token) || "";
    const key = lowercaseFirstLetter(token.substring(preposition.length));
    const scheme = formatDistanceLocale$h[key];
    if (!options2?.addSuffix) {
        return prefixPreposition(preposition) + suffixPreposition(preposition) + declension$1(scheme, count, "present");
    }
    if (options2.comparison && options2.comparison > 0) {
        return prefixPreposition(preposition) + "o " + suffixPreposition(preposition) + declension$1(scheme, count, "future");
    }
    else {
        return prefixPreposition(preposition) + "pred " + suffixPreposition(preposition) + declension$1(scheme, count, "past");
    }
};
const dateFormats$h = {
    full: "EEEE d. MMMM y",
    long: "d. MMMM y",
    medium: "d. M. y",
    short: "d. M. y"
};
const timeFormats$h = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$h = {
    full: "{{date}}, {{time}}",
    long: "{{date}}, {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$h = {
    date: buildFormatLongFn({
        formats: dateFormats$h,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$h,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$h,
        defaultWidth: "full"
    })
};
const accusativeWeekdays$1 = [
    "nedeu",
    "pondelok",
    "utorok",
    "stredu",
    "tvrtok",
    "piatok",
    "sobotu"
];
function lastWeek$1(day) {
    const weekday = accusativeWeekdays$1[day];
    switch (day) {
        case 0:
        /* Sun */
        case 3:
        /* Wed */
        case 6:
            return "'minul " + weekday + " o' p";
        default:
            return "'minul' eeee 'o' p";
    }
}
function thisWeek$1(day) {
    const weekday = accusativeWeekdays$1[day];
    if (day === 4) {
        return "'vo' eeee 'o' p";
    }
    else {
        return "'v " + weekday + " o' p";
    }
}
function nextWeek$1(day) {
    const weekday = accusativeWeekdays$1[day];
    switch (day) {
        case 0:
        /* Sun */
        case 4:
        /* Wed */
        case 6:
            return "'budcu " + weekday + " o' p";
        default:
            return "'budci' eeee 'o' p";
    }
}
const formatRelativeLocale$h = {
    lastWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$1(day);
        }
        else {
            return lastWeek$1(day);
        }
    },
    yesterday: "'vera o' p",
    today: "'dnes o' p",
    tomorrow: "'zajtra o' p",
    nextWeek: (date, baseDate, options2) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options2)) {
            return thisWeek$1(day);
        }
        else {
            return nextWeek$1(day);
        }
    },
    other: "P"
};
const formatRelative$h = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$h[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$h = {
    narrow: ["pred Kr.", "po Kr."],
    abbreviated: ["pred Kr.", "po Kr."],
    wide: ["pred Kristom", "po Kristovi"]
};
const quarterValues$h = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1. tvrrok", "2. tvrrok", "3. tvrrok", "4. tvrrok"]
};
const monthValues$h = {
    narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "mj",
        "jn",
        "jl",
        "aug",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "janur",
        "februr",
        "marec",
        "aprl",
        "mj",
        "jn",
        "jl",
        "august",
        "september",
        "oktber",
        "november",
        "december"
    ]
};
const formattingMonthValues$4 = {
    narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "mj",
        "jn",
        "jl",
        "aug",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "janura",
        "februra",
        "marca",
        "aprla",
        "mja",
        "jna",
        "jla",
        "augusta",
        "septembra",
        "oktbra",
        "novembra",
        "decembra"
    ]
};
const dayValues$h = {
    narrow: ["n", "p", "u", "s", "", "p", "s"],
    short: ["ne", "po", "ut", "st", "t", "pi", "so"],
    abbreviated: ["ne", "po", "ut", "st", "t", "pi", "so"],
    wide: [
        "nedea",
        "pondelok",
        "utorok",
        "streda",
        "tvrtok",
        "piatok",
        "sobota"
    ]
};
const dayPeriodValues$h = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "poln.",
        noon: "pol.",
        morning: "rno",
        afternoon: "pop.",
        evening: "ve.",
        night: "noc"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "poln.",
        noon: "pol.",
        morning: "rno",
        afternoon: "popol.",
        evening: "veer",
        night: "noc"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "polnoc",
        noon: "poludnie",
        morning: "rno",
        afternoon: "popoludnie",
        evening: "veer",
        night: "noc"
    }
};
const formattingDayPeriodValues$h = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "o poln.",
        noon: "nap.",
        morning: "rno",
        afternoon: "pop.",
        evening: "ve.",
        night: "v n."
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "o poln.",
        noon: "napol.",
        morning: "rno",
        afternoon: "popol.",
        evening: "veer",
        night: "v noci"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "o polnoci",
        noon: "napoludnie",
        morning: "rno",
        afternoon: "popoludn",
        evening: "veer",
        night: "v noci"
    }
};
const ordinalNumber$h = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$h = {
    ordinalNumber: ordinalNumber$h,
    era: buildLocalizeFn({
        values: eraValues$h,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$h,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$h,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$4,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$h,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$h,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$h,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$h = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$h = /\d+/i;
const matchEraPatterns$h = {
    narrow: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
    abbreviated: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
    wide: /^(pred Kristom|pred na[s][i]m letopo[c]tom|po Kristovi|n[a][s]ho letopo[c]tu)/i
};
const parseEraPatterns$h = {
    any: [/^pr/i, /^(po|n)/i]
};
const matchQuarterPatterns$h = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234]\. [s]tvr[t]rok/i
};
const parseQuarterPatterns$h = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$h = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|m[a]j|j[u]n|j[u]l|aug|sep|okt|nov|dec)/i,
    wide: /^(janu[a]ra?|febru[a]ra?|(marec|marca)|apr[i]la?|m[a]ja?|j[u]na?|j[u]la?|augusta?|(september|septembra)|(okt[o]ber|okt[o]bra)|(november|novembra)|(december|decembra))/i
};
const parseMonthPatterns$h = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^m[a]j/i,
        /^j[u]n/i,
        /^j[u]l/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$h = {
    narrow: /^[npusp]/i,
    short: /^(ne|po|ut|st|t|pi|so)/i,
    abbreviated: /^(ne|po|ut|st|t|pi|so)/i,
    wide: /^(nede[l]a|pondelok|utorok|streda|[s]tvrtok|piatok|sobota])/i
};
const parseDayPatterns$h = {
    narrow: [/^n/i, /^p/i, /^u/i, /^s/i, /^/i, /^p/i, /^s/i],
    any: [/^n/i, /^po/i, /^u/i, /^st/i, /^(t|stv)/i, /^pi/i, /^so/i]
};
const matchDayPeriodPatterns$h = {
    narrow: /^(am|pm|(o )?poln\.?|(nap\.?|pol\.?)|r[a]no|pop\.?|ve[c]\.?|(v n\.?|noc))/i,
    abbreviated: /^(am|pm|(o )?poln\.?|(napol\.?|pol\.?)|r[a]no|pop\.?|ve[c]er|(v )?noci?)/i,
    any: /^(am|pm|(o )?polnoci?|(na)?poludnie|r[a]no|popoludn(ie||i)|ve[c]er|(v )?noci?)/i
};
const parseDayPeriodPatterns$h = {
    any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /poln/i,
        noon: /^(nap|(na)?pol(\.|u))/i,
        morning: /^r[a]no/i,
        afternoon: /^pop/i,
        evening: /^ve[c]/i,
        night: /^(noc|v n\.)/i
    }
};
const match$h = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$h,
        parsePattern: parseOrdinalNumberPattern$h,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$h,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$h,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$h,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$h,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$h,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$h,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$h,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$h,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$h,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$h,
        defaultParseWidth: "any"
    })
};
const sk = {
    code: "sk",
    formatDistance: formatDistance$h,
    formatLong: formatLong$h,
    formatRelative: formatRelative$h,
    localize: localize$h,
    match: match$h,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
function isPluralType$1(val2) {
    return val2.one !== void 0;
}
const formatDistanceLocale$g = {
    lessThanXSeconds: {
        present: {
            one: "manj kot {{count}} sekunda",
            two: "manj kot {{count}} sekundi",
            few: "manj kot {{count}} sekunde",
            other: "manj kot {{count}} sekund"
        },
        past: {
            one: "manj kot {{count}} sekundo",
            two: "manj kot {{count}} sekundama",
            few: "manj kot {{count}} sekundami",
            other: "manj kot {{count}} sekundami"
        },
        future: {
            one: "manj kot {{count}} sekundo",
            two: "manj kot {{count}} sekundi",
            few: "manj kot {{count}} sekunde",
            other: "manj kot {{count}} sekund"
        }
    },
    xSeconds: {
        present: {
            one: "{{count}} sekunda",
            two: "{{count}} sekundi",
            few: "{{count}} sekunde",
            other: "{{count}} sekund"
        },
        past: {
            one: "{{count}} sekundo",
            two: "{{count}} sekundama",
            few: "{{count}} sekundami",
            other: "{{count}} sekundami"
        },
        future: {
            one: "{{count}} sekundo",
            two: "{{count}} sekundi",
            few: "{{count}} sekunde",
            other: "{{count}} sekund"
        }
    },
    halfAMinute: "pol minute",
    lessThanXMinutes: {
        present: {
            one: "manj kot {{count}} minuta",
            two: "manj kot {{count}} minuti",
            few: "manj kot {{count}} minute",
            other: "manj kot {{count}} minut"
        },
        past: {
            one: "manj kot {{count}} minuto",
            two: "manj kot {{count}} minutama",
            few: "manj kot {{count}} minutami",
            other: "manj kot {{count}} minutami"
        },
        future: {
            one: "manj kot {{count}} minuto",
            two: "manj kot {{count}} minuti",
            few: "manj kot {{count}} minute",
            other: "manj kot {{count}} minut"
        }
    },
    xMinutes: {
        present: {
            one: "{{count}} minuta",
            two: "{{count}} minuti",
            few: "{{count}} minute",
            other: "{{count}} minut"
        },
        past: {
            one: "{{count}} minuto",
            two: "{{count}} minutama",
            few: "{{count}} minutami",
            other: "{{count}} minutami"
        },
        future: {
            one: "{{count}} minuto",
            two: "{{count}} minuti",
            few: "{{count}} minute",
            other: "{{count}} minut"
        }
    },
    aboutXHours: {
        present: {
            one: "priblino {{count}} ura",
            two: "priblino {{count}} uri",
            few: "priblino {{count}} ure",
            other: "priblino {{count}} ur"
        },
        past: {
            one: "priblino {{count}} uro",
            two: "priblino {{count}} urama",
            few: "priblino {{count}} urami",
            other: "priblino {{count}} urami"
        },
        future: {
            one: "priblino {{count}} uro",
            two: "priblino {{count}} uri",
            few: "priblino {{count}} ure",
            other: "priblino {{count}} ur"
        }
    },
    xHours: {
        present: {
            one: "{{count}} ura",
            two: "{{count}} uri",
            few: "{{count}} ure",
            other: "{{count}} ur"
        },
        past: {
            one: "{{count}} uro",
            two: "{{count}} urama",
            few: "{{count}} urami",
            other: "{{count}} urami"
        },
        future: {
            one: "{{count}} uro",
            two: "{{count}} uri",
            few: "{{count}} ure",
            other: "{{count}} ur"
        }
    },
    xDays: {
        present: {
            one: "{{count}} dan",
            two: "{{count}} dni",
            few: "{{count}} dni",
            other: "{{count}} dni"
        },
        past: {
            one: "{{count}} dnem",
            two: "{{count}} dnevoma",
            few: "{{count}} dnevi",
            other: "{{count}} dnevi"
        },
        future: {
            one: "{{count}} dan",
            two: "{{count}} dni",
            few: "{{count}} dni",
            other: "{{count}} dni"
        }
    },
    // no tenses for weeks?
    aboutXWeeks: {
        one: "priblino {{count}} teden",
        two: "priblino {{count}} tedna",
        few: "priblino {{count}} tedne",
        other: "priblino {{count}} tednov"
    },
    // no tenses for weeks?
    xWeeks: {
        one: "{{count}} teden",
        two: "{{count}} tedna",
        few: "{{count}} tedne",
        other: "{{count}} tednov"
    },
    aboutXMonths: {
        present: {
            one: "priblino {{count}} mesec",
            two: "priblino {{count}} meseca",
            few: "priblino {{count}} mesece",
            other: "priblino {{count}} mesecev"
        },
        past: {
            one: "priblino {{count}} mesecem",
            two: "priblino {{count}} mesecema",
            few: "priblino {{count}} meseci",
            other: "priblino {{count}} meseci"
        },
        future: {
            one: "priblino {{count}} mesec",
            two: "priblino {{count}} meseca",
            few: "priblino {{count}} mesece",
            other: "priblino {{count}} mesecev"
        }
    },
    xMonths: {
        present: {
            one: "{{count}} mesec",
            two: "{{count}} meseca",
            few: "{{count}} meseci",
            other: "{{count}} mesecev"
        },
        past: {
            one: "{{count}} mesecem",
            two: "{{count}} mesecema",
            few: "{{count}} meseci",
            other: "{{count}} meseci"
        },
        future: {
            one: "{{count}} mesec",
            two: "{{count}} meseca",
            few: "{{count}} mesece",
            other: "{{count}} mesecev"
        }
    },
    aboutXYears: {
        present: {
            one: "priblino {{count}} leto",
            two: "priblino {{count}} leti",
            few: "priblino {{count}} leta",
            other: "priblino {{count}} let"
        },
        past: {
            one: "priblino {{count}} letom",
            two: "priblino {{count}} letoma",
            few: "priblino {{count}} leti",
            other: "priblino {{count}} leti"
        },
        future: {
            one: "priblino {{count}} leto",
            two: "priblino {{count}} leti",
            few: "priblino {{count}} leta",
            other: "priblino {{count}} let"
        }
    },
    xYears: {
        present: {
            one: "{{count}} leto",
            two: "{{count}} leti",
            few: "{{count}} leta",
            other: "{{count}} let"
        },
        past: {
            one: "{{count}} letom",
            two: "{{count}} letoma",
            few: "{{count}} leti",
            other: "{{count}} leti"
        },
        future: {
            one: "{{count}} leto",
            two: "{{count}} leti",
            few: "{{count}} leta",
            other: "{{count}} let"
        }
    },
    overXYears: {
        present: {
            one: "ve kot {{count}} leto",
            two: "ve kot {{count}} leti",
            few: "ve kot {{count}} leta",
            other: "ve kot {{count}} let"
        },
        past: {
            one: "ve kot {{count}} letom",
            two: "ve kot {{count}} letoma",
            few: "ve kot {{count}} leti",
            other: "ve kot {{count}} leti"
        },
        future: {
            one: "ve kot {{count}} leto",
            two: "ve kot {{count}} leti",
            few: "ve kot {{count}} leta",
            other: "ve kot {{count}} let"
        }
    },
    almostXYears: {
        present: {
            one: "skoraj {{count}} leto",
            two: "skoraj {{count}} leti",
            few: "skoraj {{count}} leta",
            other: "skoraj {{count}} let"
        },
        past: {
            one: "skoraj {{count}} letom",
            two: "skoraj {{count}} letoma",
            few: "skoraj {{count}} leti",
            other: "skoraj {{count}} leti"
        },
        future: {
            one: "skoraj {{count}} leto",
            two: "skoraj {{count}} leti",
            few: "skoraj {{count}} leta",
            other: "skoraj {{count}} let"
        }
    }
};
function getFormFromCount(count) {
    switch (count % 100) {
        case 1:
            return "one";
        case 2:
            return "two";
        case 3:
        case 4:
            return "few";
        default:
            return "other";
    }
}
const formatDistance$g = (token, count, options2) => {
    let result = "";
    let tense = "present";
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            tense = "future";
            result = "ez ";
        }
        else {
            tense = "past";
            result = "pred ";
        }
    }
    const tokenValue = formatDistanceLocale$g[token];
    if (typeof tokenValue === "string") {
        result += tokenValue;
    }
    else {
        const form = getFormFromCount(count);
        if (isPluralType$1(tokenValue)) {
            result += tokenValue[form].replace("{{count}}", String(count));
        }
        else {
            result += tokenValue[tense][form].replace("{{count}}", String(count));
        }
    }
    return result;
};
const dateFormats$g = {
    full: "EEEE, dd. MMMM y",
    long: "dd. MMMM y",
    medium: "d. MMM y",
    short: "d. MM. yy"
};
const timeFormats$g = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$g = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$g = {
    date: buildFormatLongFn({
        formats: dateFormats$g,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$g,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$g,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$g = {
    lastWeek: (date) => {
        const day = date.getDay();
        switch (day) {
            case 0:
                return "'prejnjo nedeljo ob' p";
            case 3:
                return "'prejnjo sredo ob' p";
            case 6:
                return "'prejnjo soboto ob' p";
            default:
                return "'prejnji' EEEE 'ob' p";
        }
    },
    yesterday: "'veraj ob' p",
    today: "'danes ob' p",
    tomorrow: "'jutri ob' p",
    nextWeek: (date) => {
        const day = date.getDay();
        switch (day) {
            case 0:
                return "'naslednjo nedeljo ob' p";
            case 3:
                return "'naslednjo sredo ob' p";
            case 6:
                return "'naslednjo soboto ob' p";
            default:
                return "'naslednji' EEEE 'ob' p";
        }
    },
    other: "P"
};
const formatRelative$g = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$g[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$g = {
    narrow: ["pr. n. t.", "po n. t."],
    abbreviated: ["pr. n. t.", "po n. t."],
    wide: ["pred naim tetjem", "po naem tetju"]
};
const quarterValues$g = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1. et.", "2. et.", "3. et.", "4. et."],
    wide: ["1. etrtletje", "2. etrtletje", "3. etrtletje", "4. etrtletje"]
};
const monthValues$g = {
    narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: [
        "jan.",
        "feb.",
        "mar.",
        "apr.",
        "maj",
        "jun.",
        "jul.",
        "avg.",
        "sep.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "januar",
        "februar",
        "marec",
        "april",
        "maj",
        "junij",
        "julij",
        "avgust",
        "september",
        "oktober",
        "november",
        "december"
    ]
};
const dayValues$g = {
    narrow: ["n", "p", "t", "s", "", "p", "s"],
    short: ["ned.", "pon.", "tor.", "sre.", "et.", "pet.", "sob."],
    abbreviated: ["ned.", "pon.", "tor.", "sre.", "et.", "pet.", "sob."],
    wide: [
        "nedelja",
        "ponedeljek",
        "torek",
        "sreda",
        "etrtek",
        "petek",
        "sobota"
    ]
};
const dayPeriodValues$g = {
    narrow: {
        am: "d",
        pm: "p",
        midnight: "24.00",
        noon: "12.00",
        morning: "j",
        afternoon: "p",
        evening: "v",
        night: "n"
    },
    abbreviated: {
        am: "dop.",
        pm: "pop.",
        midnight: "poln.",
        noon: "pold.",
        morning: "jut.",
        afternoon: "pop.",
        evening: "ve.",
        night: "no"
    },
    wide: {
        am: "dop.",
        pm: "pop.",
        midnight: "polno",
        noon: "poldne",
        morning: "jutro",
        afternoon: "popoldne",
        evening: "veer",
        night: "no"
    }
};
const formattingDayPeriodValues$g = {
    narrow: {
        am: "d",
        pm: "p",
        midnight: "24.00",
        noon: "12.00",
        morning: "zj",
        afternoon: "p",
        evening: "zv",
        night: "po"
    },
    abbreviated: {
        am: "dop.",
        pm: "pop.",
        midnight: "opoln.",
        noon: "opold.",
        morning: "zjut.",
        afternoon: "pop.",
        evening: "zve.",
        night: "ponoi"
    },
    wide: {
        am: "dop.",
        pm: "pop.",
        midnight: "opolnoi",
        noon: "opoldne",
        morning: "zjutraj",
        afternoon: "popoldan",
        evening: "zveer",
        night: "ponoi"
    }
};
const ordinalNumber$g = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$g = {
    ordinalNumber: ordinalNumber$g,
    era: buildLocalizeFn({
        values: eraValues$g,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$g,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$g,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$g,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$g,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$g,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$g = /^(\d+)\./i;
const parseOrdinalNumberPattern$g = /\d+/i;
const matchEraPatterns$g = {
    abbreviated: /^(pr\. n\. t\.|po n\. t\.)/i,
    wide: /^(pred Kristusom|pred na[s]im [s]tetjem|po Kristusu|po na[s]em [s]tetju|na[s]ega [s]tetja)/i
};
const parseEraPatterns$g = {
    any: [/^pr/i, /^(po|na[s]em)/i]
};
const matchQuarterPatterns$g = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]\.\s?[c]et\.?/i,
    wide: /^[1234]\. [c]etrtletje/i
};
const parseQuarterPatterns$g = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$g = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan\.|feb\.|mar\.|apr\.|maj|jun\.|jul\.|avg\.|sep\.|okt\.|nov\.|dec\.)/i,
    wide: /^(januar|februar|marec|april|maj|junij|julij|avgust|september|oktober|november|december)/i
};
const parseMonthPatterns$g = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    abbreviated: [
        /^ja/i,
        /^fe/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^av/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    wide: [
        /^ja/i,
        /^fe/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^av/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$g = {
    narrow: /^[nptsc]/i,
    short: /^(ned\.|pon\.|tor\.|sre\.|[c]et\.|pet\.|sob\.)/i,
    abbreviated: /^(ned\.|pon\.|tor\.|sre\.|[c]et\.|pet\.|sob\.)/i,
    wide: /^(nedelja|ponedeljek|torek|sreda|[c]etrtek|petek|sobota)/i
};
const parseDayPatterns$g = {
    narrow: [/^n/i, /^p/i, /^t/i, /^s/i, /^[c]/i, /^p/i, /^s/i],
    any: [/^n/i, /^po/i, /^t/i, /^sr/i, /^[c]/i, /^pe/i, /^so/i]
};
const matchDayPeriodPatterns$g = {
    narrow: /^(d|po?|z?v|n|z?j|24\.00|12\.00)/i,
    any: /^(dop\.|pop\.|o?poln(\.|o[c]i?)|o?pold(\.|ne)|z?ve[c](\.|er)|(po)?no[c]i?|popold(ne|an)|jut(\.|ro)|zjut(\.|raj))/i
};
const parseDayPeriodPatterns$g = {
    narrow: {
        am: /^d/i,
        pm: /^p/i,
        midnight: /^24/i,
        noon: /^12/i,
        morning: /^(z?j)/i,
        afternoon: /^p/i,
        evening: /^(z?v)/i,
        night: /^(n|po)/i
    },
    any: {
        am: /^dop\./i,
        pm: /^pop\./i,
        midnight: /^o?poln/i,
        noon: /^o?pold/i,
        morning: /j/i,
        afternoon: /^pop\./i,
        evening: /^z?ve/i,
        night: /(po)?no/i
    }
};
const match$g = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$g,
        parsePattern: parseOrdinalNumberPattern$g,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$g,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$g,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$g,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$g,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$g,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$g,
        defaultParseWidth: "wide"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$g,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$g,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$g,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$g,
        defaultParseWidth: "any"
    })
};
const sl = {
    code: "sl",
    formatDistance: formatDistance$g,
    formatLong: formatLong$g,
    formatRelative: formatRelative$g,
    localize: localize$g,
    match: match$g,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$f = {
    lessThanXSeconds: {
        one: "m pak se nj sekond",
        other: "m pak se {{count}} sekonda"
    },
    xSeconds: {
        one: "1 sekond",
        other: "{{count}} sekonda"
    },
    halfAMinute: "gjysm minuti",
    lessThanXMinutes: {
        one: "m pak se nj minute",
        other: "m pak se {{count}} minuta"
    },
    xMinutes: {
        one: "1 minut",
        other: "{{count}} minuta"
    },
    aboutXHours: {
        one: "rreth 1 or",
        other: "rreth {{count}} or"
    },
    xHours: {
        one: "1 or",
        other: "{{count}} or"
    },
    xDays: {
        one: "1 dit",
        other: "{{count}} dit"
    },
    aboutXWeeks: {
        one: "rreth 1 jav",
        other: "rreth {{count}} jav"
    },
    xWeeks: {
        one: "1 jav",
        other: "{{count}} jav"
    },
    aboutXMonths: {
        one: "rreth 1 muaj",
        other: "rreth {{count}} muaj"
    },
    xMonths: {
        one: "1 muaj",
        other: "{{count}} muaj"
    },
    aboutXYears: {
        one: "rreth 1 vit",
        other: "rreth {{count}} vite"
    },
    xYears: {
        one: "1 vit",
        other: "{{count}} vite"
    },
    overXYears: {
        one: "mbi 1 vit",
        other: "mbi {{count}} vite"
    },
    almostXYears: {
        one: "pothuajse 1 vit",
        other: "pothuajse {{count}} vite"
    }
};
const formatDistance$f = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$f[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "n " + result;
        }
        else {
            return result + " m par";
        }
    }
    return result;
};
const dateFormats$f = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$f = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$f = {
    full: "{{date}} 'n' {{time}}",
    long: "{{date}} 'n' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$f = {
    date: buildFormatLongFn({
        formats: dateFormats$f,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$f,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$f,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$f = {
    lastWeek: "'t' eeee 'e shkuar n' p",
    yesterday: "'dje n' p",
    today: "'sot n' p",
    tomorrow: "'nesr n' p",
    nextWeek: "eeee 'at' p",
    other: "P"
};
const formatRelative$f = (token, _date, _baseDate, _options) => formatRelativeLocale$f[token];
const eraValues$f = {
    narrow: ["P", "M"],
    abbreviated: ["PK", "MK"],
    wide: ["Para Krishtit", "Mbas Krishtit"]
};
const quarterValues$f = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["4-mujori I", "4-mujori II", "4-mujori III", "4-mujori IV"]
};
const monthValues$f = {
    narrow: ["J", "S", "M", "P", "M", "Q", "K", "G", "S", "T", "N", "D"],
    abbreviated: [
        "Jan",
        "Shk",
        "Mar",
        "Pri",
        "Maj",
        "Qer",
        "Kor",
        "Gus",
        "Sht",
        "Tet",
        "Nn",
        "Dhj"
    ],
    wide: [
        "Janar",
        "Shkurt",
        "Mars",
        "Prill",
        "Maj",
        "Qershor",
        "Korrik",
        "Gusht",
        "Shtator",
        "Tetor",
        "Nntor",
        "Dhjetor"
    ]
};
const dayValues$f = {
    narrow: ["D", "H", "M", "M", "E", "P", "S"],
    short: ["Di", "H", "Ma", "M", "En", "Pr", "Sh"],
    abbreviated: ["Die", "Hn", "Mar", "Mr", "Enj", "Pre", "Sht"],
    wide: ["Diel", "Hn", "Mart", "Mrkur", "Enjte", "Premte", "Shtun"]
};
const dayPeriodValues$f = {
    narrow: {
        am: "p",
        pm: "m",
        midnight: "m",
        noon: "d",
        morning: "mngjes",
        afternoon: "dite",
        evening: "mbrmje",
        night: "nat"
    },
    abbreviated: {
        am: "PD",
        pm: "MD",
        midnight: "mesnt",
        noon: "drek",
        morning: "mngjes",
        afternoon: "mbasdite",
        evening: "mbrmje",
        night: "nat"
    },
    wide: {
        am: "p.d.",
        pm: "m.d.",
        midnight: "mesnt",
        noon: "drek",
        morning: "mngjes",
        afternoon: "mbasdite",
        evening: "mbrmje",
        night: "nat"
    }
};
const formattingDayPeriodValues$f = {
    narrow: {
        am: "p",
        pm: "m",
        midnight: "m",
        noon: "d",
        morning: "n mngjes",
        afternoon: "n mbasdite",
        evening: "n mbrmje",
        night: "n mesnat"
    },
    abbreviated: {
        am: "PD",
        pm: "MD",
        midnight: "mesnat",
        noon: "drek",
        morning: "n mngjes",
        afternoon: "n mbasdite",
        evening: "n mbrmje",
        night: "n mesnat"
    },
    wide: {
        am: "p.d.",
        pm: "m.d.",
        midnight: "mesnat",
        noon: "drek",
        morning: "n mngjes",
        afternoon: "n mbasdite",
        evening: "n mbrmje",
        night: "n mesnat"
    }
};
const ordinalNumber$f = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    if (options2?.unit === "hour")
        return String(number2);
    if (number2 === 1)
        return number2 + "-r";
    if (number2 === 4)
        return number2 + "t";
    return number2 + "-t";
};
const localize$f = {
    ordinalNumber: ordinalNumber$f,
    era: buildLocalizeFn({
        values: eraValues$f,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$f,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$f,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$f,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$f,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$f,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$f = /^(\d+)(-r|-t|t|)?/i;
const parseOrdinalNumberPattern$f = /\d+/i;
const matchEraPatterns$f = {
    narrow: /^(p|m)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(para krishtit|mbas krishtit)/i
};
const parseEraPatterns$f = {
    any: [/^b/i, /^(p|m)/i]
};
const matchQuarterPatterns$f = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234]-mujori (i{1,3}|iv)/i
};
const parseQuarterPatterns$f = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$f = {
    narrow: /^[jsmpqkftnd]/i,
    abbreviated: /^(jan|shk|mar|pri|maj|qer|kor|gus|sht|tet|nn|dhj)/i,
    wide: /^(janar|shkurt|mars|prill|maj|qershor|korrik|gusht|shtator|tetor|nntor|dhjetor)/i
};
const parseMonthPatterns$f = {
    narrow: [
        /^j/i,
        /^s/i,
        /^m/i,
        /^p/i,
        /^m/i,
        /^q/i,
        /^k/i,
        /^g/i,
        /^s/i,
        /^t/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^shk/i,
        /^mar/i,
        /^pri/i,
        /^maj/i,
        /^qer/i,
        /^kor/i,
        /^gu/i,
        /^sht/i,
        /^tet/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$f = {
    narrow: /^[dhmeps]/i,
    short: /^(di|h|ma|m|en|pr|sh)/i,
    abbreviated: /^(die|hn|mar|mr|enj|pre|sht)/i,
    wide: /^(diel|hn|mart|mrkur|enjte|premte|shtun)/i
};
const parseDayPatterns$f = {
    narrow: [/^d/i, /^h/i, /^m/i, /^m/i, /^e/i, /^p/i, /^s/i],
    any: [/^d/i, /^h/i, /^ma/i, /^m/i, /^e/i, /^p/i, /^s/i]
};
const matchDayPeriodPatterns$f = {
    narrow: /^(p|m|me|n (mngjes|mbasdite|mbrmje|mesnat))/i,
    any: /^([pm]\.?\s?d\.?|drek|n (mngjes|mbasdite|mbrmje|mesnat))/i
};
const parseDayPeriodPatterns$f = {
    any: {
        am: /^p/i,
        pm: /^m/i,
        midnight: /^me/i,
        noon: /^dr/i,
        morning: /mngjes/i,
        afternoon: /mbasdite/i,
        evening: /mbrmje/i,
        night: /nat/i
    }
};
const match$f = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$f,
        parsePattern: parseOrdinalNumberPattern$f,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$f,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$f,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$f,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$f,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$f,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$f,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$f,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$f,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$f,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$f,
        defaultParseWidth: "any"
    })
};
const sq = {
    code: "sq",
    formatDistance: formatDistance$f,
    formatLong: formatLong$f,
    formatRelative: formatRelative$f,
    localize: localize$f,
    match: match$f,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$e = {
    lessThanXSeconds: {
        one: {
            standalone: "  1 ",
            withPrepositionAgo: "  1 ",
            withPrepositionIn: "  1 "
        },
        dual: "  {{count}} ",
        other: "  {{count}} "
    },
    xSeconds: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: {
            standalone: "  1 ",
            withPrepositionAgo: "  1 ",
            withPrepositionIn: "  1 "
        },
        dual: "  {{count}} ",
        other: "  {{count}} "
    },
    xMinutes: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: {
            standalone: " 1 ",
            withPrepositionAgo: " 1 ",
            withPrepositionIn: " 1 "
        },
        dual: " {{count}} ",
        other: " {{count}} "
    },
    xHours: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    xDays: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: {
            standalone: " 1 ",
            withPrepositionAgo: " 1 ",
            withPrepositionIn: " 1 "
        },
        dual: " {{count}} ",
        other: " {{count}} "
    },
    xWeeks: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: {
            standalone: " 1 ",
            withPrepositionAgo: " 1 ",
            withPrepositionIn: " 1 "
        },
        dual: " {{count}} ",
        other: " {{count}} "
    },
    xMonths: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: {
            standalone: " 1 ",
            withPrepositionAgo: " 1 ",
            withPrepositionIn: " 1 "
        },
        dual: " {{count}} ",
        other: " {{count}} "
    },
    xYears: {
        one: {
            standalone: "1 ",
            withPrepositionAgo: "1 ",
            withPrepositionIn: "1 "
        },
        dual: "{{count}} ",
        other: "{{count}} "
    },
    overXYears: {
        one: {
            standalone: " 1 ",
            withPrepositionAgo: " 1 ",
            withPrepositionIn: " 1 "
        },
        dual: " {{count}} ",
        other: " {{count}} "
    },
    almostXYears: {
        one: {
            standalone: " 1 ",
            withPrepositionAgo: " 1 ",
            withPrepositionIn: " 1 "
        },
        dual: " {{count}} ",
        other: " {{count}} "
    }
};
const formatDistance$e = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$e[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                result = tokenValue.one.withPrepositionIn;
            }
            else {
                result = tokenValue.one.withPrepositionAgo;
            }
        }
        else {
            result = tokenValue.one.standalone;
        }
    }
    else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
        String(count).substr(-2, 1) !== "1") {
        result = tokenValue.dual.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " " + result;
        }
        else {
            return " " + result;
        }
    }
    return result;
};
const dateFormats$e = {
    full: "EEEE, d. MMMM yyyy.",
    long: "d. MMMM yyyy.",
    medium: "d. MMM yy.",
    short: "dd. MM. yy."
};
const timeFormats$e = {
    full: "HH:mm:ss (zzzz)",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$e = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$e = {
    date: buildFormatLongFn({
        formats: dateFormats$e,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$e,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$e,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$e = {
    lastWeek: (date) => {
        const day = date.getDay();
        switch (day) {
            case 0:
                return "'  ' p";
            case 3:
                return "'  ' p";
            case 6:
                return "'  ' p";
            default:
                return "'' EEEE '' p";
        }
    },
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: (date) => {
        const day = date.getDay();
        switch (day) {
            case 0:
                return "'  ' p";
            case 3:
                return "'  ' p";
            case 6:
                return "'  ' p";
            default:
                return "'' EEEE '' p";
        }
    },
    other: "P"
};
const formatRelative$e = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$e[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$e = {
    narrow: ["...", ""],
    abbreviated: [". .", ". ."],
    wide: [" ", " "]
};
const quarterValues$e = {
    narrow: ["1.", "2.", "3.", "4."],
    abbreviated: ["1. .", "2. .", "3. .", "4. ."],
    wide: ["1. ", "2. ", "3. ", "4. "]
};
const monthValues$e = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$3 = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$e = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingDayPeriodValues$e = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const dayPeriodValues$e = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const ordinalNumber$e = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$e = {
    ordinalNumber: ordinalNumber$e,
    era: buildLocalizeFn({
        values: eraValues$e,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$e,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$e,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$3,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$e,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$e,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$e,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$e = /^(\d+)\./i;
const parseOrdinalNumberPattern$e = /\d+/i;
const matchEraPatterns$e = {
    narrow: /^(\.\.\.|)/i,
    abbreviated: /^(\.\s?\.|\.\s?\.)/i,
    wide: /^( |  | | )/i
};
const parseEraPatterns$e = {
    any: [/^/i, /^(|)/i]
};
const matchQuarterPatterns$e = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]\.\s?\.?/i,
    wide: /^[1234]\. /i
};
const parseQuarterPatterns$e = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$e = {
    narrow: /^(10|11|12|[123456789])\./i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^((|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|))/i
};
const parseMonthPatterns$e = {
    narrow: [
        /^1/i,
        /^2/i,
        /^3/i,
        /^4/i,
        /^5/i,
        /^6/i,
        /^7/i,
        /^8/i,
        /^9/i,
        /^10/i,
        /^11/i,
        /^12/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$e = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$e = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$e = {
    any: /^(|||()?||| |)/i
};
const parseDayPeriodPatterns$e = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: /(\s|)+/i,
        evening: /()/i,
        night: /()/i
    }
};
const match$e = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$e,
        parsePattern: parseOrdinalNumberPattern$e,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$e,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$e,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$e,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$e,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$e,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$e,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$e,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$e,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$e,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$e,
        defaultParseWidth: "any"
    })
};
const sr = {
    code: "sr",
    formatDistance: formatDistance$e,
    formatLong: formatLong$e,
    formatRelative: formatRelative$e,
    localize: localize$e,
    match: match$e,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$d = {
    lessThanXSeconds: {
        one: {
            standalone: "manje od 1 sekunde",
            withPrepositionAgo: "manje od 1 sekunde",
            withPrepositionIn: "manje od 1 sekundu"
        },
        dual: "manje od {{count}} sekunde",
        other: "manje od {{count}} sekundi"
    },
    xSeconds: {
        one: {
            standalone: "1 sekunda",
            withPrepositionAgo: "1 sekunde",
            withPrepositionIn: "1 sekundu"
        },
        dual: "{{count}} sekunde",
        other: "{{count}} sekundi"
    },
    halfAMinute: "pola minute",
    lessThanXMinutes: {
        one: {
            standalone: "manje od 1 minute",
            withPrepositionAgo: "manje od 1 minute",
            withPrepositionIn: "manje od 1 minutu"
        },
        dual: "manje od {{count}} minute",
        other: "manje od {{count}} minuta"
    },
    xMinutes: {
        one: {
            standalone: "1 minuta",
            withPrepositionAgo: "1 minute",
            withPrepositionIn: "1 minutu"
        },
        dual: "{{count}} minute",
        other: "{{count}} minuta"
    },
    aboutXHours: {
        one: {
            standalone: "oko 1 sat",
            withPrepositionAgo: "oko 1 sat",
            withPrepositionIn: "oko 1 sat"
        },
        dual: "oko {{count}} sata",
        other: "oko {{count}} sati"
    },
    xHours: {
        one: {
            standalone: "1 sat",
            withPrepositionAgo: "1 sat",
            withPrepositionIn: "1 sat"
        },
        dual: "{{count}} sata",
        other: "{{count}} sati"
    },
    xDays: {
        one: {
            standalone: "1 dan",
            withPrepositionAgo: "1 dan",
            withPrepositionIn: "1 dan"
        },
        dual: "{{count}} dana",
        other: "{{count}} dana"
    },
    aboutXWeeks: {
        one: {
            standalone: "oko 1 nedelju",
            withPrepositionAgo: "oko 1 nedelju",
            withPrepositionIn: "oko 1 nedelju"
        },
        dual: "oko {{count}} nedelje",
        other: "oko {{count}} nedelje"
    },
    xWeeks: {
        one: {
            standalone: "1 nedelju",
            withPrepositionAgo: "1 nedelju",
            withPrepositionIn: "1 nedelju"
        },
        dual: "{{count}} nedelje",
        other: "{{count}} nedelje"
    },
    aboutXMonths: {
        one: {
            standalone: "oko 1 mesec",
            withPrepositionAgo: "oko 1 mesec",
            withPrepositionIn: "oko 1 mesec"
        },
        dual: "oko {{count}} meseca",
        other: "oko {{count}} meseci"
    },
    xMonths: {
        one: {
            standalone: "1 mesec",
            withPrepositionAgo: "1 mesec",
            withPrepositionIn: "1 mesec"
        },
        dual: "{{count}} meseca",
        other: "{{count}} meseci"
    },
    aboutXYears: {
        one: {
            standalone: "oko 1 godinu",
            withPrepositionAgo: "oko 1 godinu",
            withPrepositionIn: "oko 1 godinu"
        },
        dual: "oko {{count}} godine",
        other: "oko {{count}} godina"
    },
    xYears: {
        one: {
            standalone: "1 godina",
            withPrepositionAgo: "1 godine",
            withPrepositionIn: "1 godinu"
        },
        dual: "{{count}} godine",
        other: "{{count}} godina"
    },
    overXYears: {
        one: {
            standalone: "preko 1 godinu",
            withPrepositionAgo: "preko 1 godinu",
            withPrepositionIn: "preko 1 godinu"
        },
        dual: "preko {{count}} godine",
        other: "preko {{count}} godina"
    },
    almostXYears: {
        one: {
            standalone: "gotovo 1 godinu",
            withPrepositionAgo: "gotovo 1 godinu",
            withPrepositionIn: "gotovo 1 godinu"
        },
        dual: "gotovo {{count}} godine",
        other: "gotovo {{count}} godina"
    }
};
const formatDistance$d = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$d[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        if (options2?.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                result = tokenValue.one.withPrepositionIn;
            }
            else {
                result = tokenValue.one.withPrepositionAgo;
            }
        }
        else {
            result = tokenValue.one.standalone;
        }
    }
    else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
        String(count).substr(-2, 1) !== "1") {
        result = tokenValue.dual.replace("{{count}}", String(count));
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "za " + result;
        }
        else {
            return "pre " + result;
        }
    }
    return result;
};
const dateFormats$d = {
    full: "EEEE, d. MMMM yyyy.",
    long: "d. MMMM yyyy.",
    medium: "d. MMM yy.",
    short: "dd. MM. yy."
};
const timeFormats$d = {
    full: "HH:mm:ss (zzzz)",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$d = {
    full: "{{date}} 'u' {{time}}",
    long: "{{date}} 'u' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$d = {
    date: buildFormatLongFn({
        formats: dateFormats$d,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$d,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$d,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$d = {
    lastWeek: (date) => {
        switch (date.getDay()) {
            case 0:
                return "'prole nedelje u' p";
            case 3:
                return "'prole srede u' p";
            case 6:
                return "'prole subote u' p";
            default:
                return "'proli' EEEE 'u' p";
        }
    },
    yesterday: "'jue u' p",
    today: "'danas u' p",
    tomorrow: "'sutra u' p",
    nextWeek: (date) => {
        switch (date.getDay()) {
            case 0:
                return "'sledee nedelje u' p";
            case 3:
                return "'sledeu sredu u' p";
            case 6:
                return "'sledeu subotu u' p";
            default:
                return "'sledei' EEEE 'u' p";
        }
    },
    other: "P"
};
const formatRelative$d = (token, date, _baseDate, _options) => {
    const format2 = formatRelativeLocale$d[token];
    if (typeof format2 === "function") {
        return format2(date);
    }
    return format2;
};
const eraValues$d = {
    narrow: ["pr.n.e.", "AD"],
    abbreviated: ["pr. Hr.", "po. Hr."],
    wide: ["Pre Hrista", "Posle Hrista"]
};
const quarterValues$d = {
    narrow: ["1.", "2.", "3.", "4."],
    abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
    wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$d = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "avg",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "januar",
        "februar",
        "mart",
        "april",
        "maj",
        "jun",
        "jul",
        "avgust",
        "septembar",
        "oktobar",
        "novembar",
        "decembar"
    ]
};
const formattingMonthValues$2 = {
    narrow: [
        "1.",
        "2.",
        "3.",
        "4.",
        "5.",
        "6.",
        "7.",
        "8.",
        "9.",
        "10.",
        "11.",
        "12."
    ],
    abbreviated: [
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "avg",
        "sep",
        "okt",
        "nov",
        "dec"
    ],
    wide: [
        "januar",
        "februar",
        "mart",
        "april",
        "maj",
        "jun",
        "jul",
        "avgust",
        "septembar",
        "oktobar",
        "novembar",
        "decembar"
    ]
};
const dayValues$d = {
    narrow: ["N", "P", "U", "S", "", "P", "S"],
    short: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
    abbreviated: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
    wide: [
        "nedelja",
        "ponedeljak",
        "utorak",
        "sreda",
        "etvrtak",
        "petak",
        "subota"
    ]
};
const formattingDayPeriodValues$d = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "posle podne",
        evening: "uvee",
        night: "nou"
    }
};
const dayPeriodValues$d = {
    narrow: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "popodne",
        evening: "uvee",
        night: "nou"
    },
    wide: {
        am: "AM",
        pm: "PM",
        midnight: "pono",
        noon: "podne",
        morning: "ujutru",
        afternoon: "posle podne",
        evening: "uvee",
        night: "nou"
    }
};
const ordinalNumber$d = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$d = {
    ordinalNumber: ordinalNumber$d,
    era: buildLocalizeFn({
        values: eraValues$d,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$d,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$d,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$2,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$d,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$d,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$d,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$d = /^(\d+)\./i;
const parseOrdinalNumberPattern$d = /\d+/i;
const matchEraPatterns$d = {
    narrow: /^(pr\.n\.e\.|AD)/i,
    abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
    wide: /^(Pre Hrista|pre nove ere|Posle Hrista|nova era)/i
};
const parseEraPatterns$d = {
    any: [/^pr/i, /^(po|nova)/i]
};
const matchQuarterPatterns$d = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]\.\s?kv\.?/i,
    wide: /^[1234]\. kvartal/i
};
const parseQuarterPatterns$d = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$d = {
    narrow: /^(10|11|12|[123456789])\./i,
    abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
    wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(jun|juna)|(jul|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i
};
const parseMonthPatterns$d = {
    narrow: [
        /^1/i,
        /^2/i,
        /^3/i,
        /^4/i,
        /^5/i,
        /^6/i,
        /^7/i,
        /^8/i,
        /^9/i,
        /^10/i,
        /^11/i,
        /^12/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^avg/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$d = {
    narrow: /^[npusc]/i,
    short: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
    abbreviated: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
    wide: /^(nedelja|ponedeljak|utorak|sreda|(etvrtak|cetvrtak)|petak|subota)/i
};
const parseDayPatterns$d = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$d = {
    any: /^(am|pm|ponoc|pono|(po)?podne|uvece|uvee|nou|posle podne|ujutru)/i
};
const parseDayPeriodPatterns$d = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^pono/i,
        noon: /^pod/i,
        morning: /jutro/i,
        afternoon: /(posle\s|po)+podne/i,
        evening: /(uvece|uvee)/i,
        night: /(nocu|nou)/i
    }
};
const match$d = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$d,
        parsePattern: parseOrdinalNumberPattern$d,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$d,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$d,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$d,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$d,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$d,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$d,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$d,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$d,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$d,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$d,
        defaultParseWidth: "any"
    })
};
const srLatn = {
    code: "sr-Latn",
    formatDistance: formatDistance$d,
    formatLong: formatLong$d,
    formatRelative: formatRelative$d,
    localize: localize$d,
    match: match$d,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$c = {
    lessThanXSeconds: {
        one: "mindre n en sekund",
        other: "mindre n {{count}} sekunder"
    },
    xSeconds: {
        one: "en sekund",
        other: "{{count}} sekunder"
    },
    halfAMinute: "en halv minut",
    lessThanXMinutes: {
        one: "mindre n en minut",
        other: "mindre n {{count}} minuter"
    },
    xMinutes: {
        one: "en minut",
        other: "{{count}} minuter"
    },
    aboutXHours: {
        one: "ungefr en timme",
        other: "ungefr {{count}} timmar"
    },
    xHours: {
        one: "en timme",
        other: "{{count}} timmar"
    },
    xDays: {
        one: "en dag",
        other: "{{count}} dagar"
    },
    aboutXWeeks: {
        one: "ungefr en vecka",
        other: "ungefr {{count}} veckor"
    },
    xWeeks: {
        one: "en vecka",
        other: "{{count}} veckor"
    },
    aboutXMonths: {
        one: "ungefr en mnad",
        other: "ungefr {{count}} mnader"
    },
    xMonths: {
        one: "en mnad",
        other: "{{count}} mnader"
    },
    aboutXYears: {
        one: "ungefr ett r",
        other: "ungefr {{count}} r"
    },
    xYears: {
        one: "ett r",
        other: "{{count}} r"
    },
    overXYears: {
        one: "ver ett r",
        other: "ver {{count}} r"
    },
    almostXYears: {
        one: "nstan ett r",
        other: "nstan {{count}} r"
    }
};
const wordMapping = [
    "noll",
    "en",
    "tv",
    "tre",
    "fyra",
    "fem",
    "sex",
    "sju",
    "tta",
    "nio",
    "tio",
    "elva",
    "tolv"
];
const formatDistance$c = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$c[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count < 13 ? wordMapping[count] : String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return "om " + result;
        }
        else {
            return result + " sedan";
        }
    }
    return result;
};
const dateFormats$c = {
    full: "EEEE d MMMM y",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "y-MM-dd"
};
const timeFormats$c = {
    full: "'kl'. HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$c = {
    full: "{{date}} 'kl.' {{time}}",
    long: "{{date}} 'kl.' {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$c = {
    date: buildFormatLongFn({
        formats: dateFormats$c,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$c,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$c,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$c = {
    lastWeek: "'i' EEEE's kl.' p",
    yesterday: "'igr kl.' p",
    today: "'idag kl.' p",
    tomorrow: "'imorgon kl.' p",
    nextWeek: "EEEE 'kl.' p",
    other: "P"
};
const formatRelative$c = (token, _date, _baseDate, _options) => formatRelativeLocale$c[token];
const eraValues$c = {
    narrow: ["f.Kr.", "e.Kr."],
    abbreviated: ["f.Kr.", "e.Kr."],
    wide: ["fre Kristus", "efter Kristus"]
};
const quarterValues$c = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1:a kvartalet", "2:a kvartalet", "3:e kvartalet", "4:e kvartalet"]
};
const monthValues$c = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
        "jan.",
        "feb.",
        "mars",
        "apr.",
        "maj",
        "juni",
        "juli",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "dec."
    ],
    wide: [
        "januari",
        "februari",
        "mars",
        "april",
        "maj",
        "juni",
        "juli",
        "augusti",
        "september",
        "oktober",
        "november",
        "december"
    ]
};
const dayValues$c = {
    narrow: ["S", "M", "T", "O", "T", "F", "L"],
    short: ["s", "m", "ti", "on", "to", "fr", "l"],
    abbreviated: ["sn", "mn", "tis", "ons", "tors", "fre", "lr"],
    wide: ["sndag", "mndag", "tisdag", "onsdag", "torsdag", "fredag", "lrdag"]
};
const dayPeriodValues$c = {
    narrow: {
        am: "fm",
        pm: "em",
        midnight: "midnatt",
        noon: "middag",
        morning: "morg.",
        afternoon: "efterm.",
        evening: "kvll",
        night: "natt"
    },
    abbreviated: {
        am: "f.m.",
        pm: "e.m.",
        midnight: "midnatt",
        noon: "middag",
        morning: "morgon",
        afternoon: "efterm.",
        evening: "kvll",
        night: "natt"
    },
    wide: {
        am: "frmiddag",
        pm: "eftermiddag",
        midnight: "midnatt",
        noon: "middag",
        morning: "morgon",
        afternoon: "eftermiddag",
        evening: "kvll",
        night: "natt"
    }
};
const formattingDayPeriodValues$c = {
    narrow: {
        am: "fm",
        pm: "em",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morg.",
        afternoon: "p efterm.",
        evening: "p kvllen",
        night: "p natten"
    },
    abbreviated: {
        am: "fm",
        pm: "em",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morg.",
        afternoon: "p efterm.",
        evening: "p kvllen",
        night: "p natten"
    },
    wide: {
        am: "fm",
        pm: "em",
        midnight: "midnatt",
        noon: "middag",
        morning: "p morgonen",
        afternoon: "p eftermiddagen",
        evening: "p kvllen",
        night: "p natten"
    }
};
const ordinalNumber$c = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
            case 1:
            case 2:
                return number2 + ":a";
        }
    }
    return number2 + ":e";
};
const localize$c = {
    ordinalNumber: ordinalNumber$c,
    era: buildLocalizeFn({
        values: eraValues$c,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$c,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$c,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$c,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$c,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$c,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$c = /^(\d+)(:a|:e)?/i;
const parseOrdinalNumberPattern$c = /\d+/i;
const matchEraPatterns$c = {
    narrow: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
    abbreviated: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
    wide: /^(fre Kristus|fre vr tid|efter Kristus|vr tid)/i
};
const parseEraPatterns$c = {
    any: [/^f/i, /^[ev]/i]
};
const matchQuarterPatterns$c = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](:a|:e)? kvartalet/i
};
const parseQuarterPatterns$c = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$c = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar[s]?|apr|maj|jun[i]?|jul[i]?|aug|sep|okt|nov|dec)\.?/i,
    wide: /^(januari|februari|mars|april|maj|juni|juli|augusti|september|oktober|november|december)/i
};
const parseMonthPatterns$c = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$c = {
    narrow: /^[smtofl]/i,
    short: /^(s|m|ti|on|to|fr|l)/i,
    abbreviated: /^(sn|mn|tis|ons|tors|fre|lr)/i,
    wide: /^(sndag|mndag|tisdag|onsdag|torsdag|fredag|lrdag)/i
};
const parseDayPatterns$c = {
    any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$c = {
    any: /^([fe]\.?\s?m\.?|midn(att)?|midd(ag)?|(p) (morgonen|eftermiddagen|kvllen|natten))/i
};
const parseDayPeriodPatterns$c = {
    any: {
        am: /^f/i,
        pm: /^e/i,
        midnight: /^midn/i,
        noon: /^midd/i,
        morning: /morgon/i,
        afternoon: /eftermiddag/i,
        evening: /kvll/i,
        night: /natt/i
    }
};
const match$c = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$c,
        parsePattern: parseOrdinalNumberPattern$c,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$c,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$c,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$c,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$c,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$c,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$c,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$c,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$c,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$c,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$c,
        defaultParseWidth: "any"
    })
};
const sv = {
    code: "sv",
    formatDistance: formatDistance$c,
    formatLong: formatLong$c,
    formatRelative: formatRelative$c,
    localize: localize$c,
    match: match$c,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
function isPluralType(val2) {
    return val2.one !== void 0;
}
const formatDistanceLocale$b = {
    lessThanXSeconds: {
        one: {
            default: "  ",
            in: " ",
            ago: "  "
        },
        other: {
            default: "{{count}}  ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    xSeconds: {
        one: {
            default: "1 ",
            in: "1 ",
            ago: "1  "
        },
        other: {
            default: "{{count}} ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    halfAMinute: {
        default: " ",
        in: " ",
        ago: "  "
    },
    lessThanXMinutes: {
        one: {
            default: "  ",
            in: " ",
            ago: "  "
        },
        other: {
            default: "{{count}}  ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    xMinutes: {
        one: {
            default: "1 ",
            in: "1 ",
            ago: "1  "
        },
        other: {
            default: "{{count}} ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    aboutXHours: {
        one: {
            default: " 1  ",
            in: " 1  ",
            ago: " 1   "
        },
        other: {
            default: " {{count}}  ",
            in: " {{count}}   ",
            ago: " {{count}}  "
        }
    },
    xHours: {
        one: {
            default: "1  ",
            in: "1  ",
            ago: "1   "
        },
        other: {
            default: "{{count}}  ",
            in: "{{count}}  ",
            ago: "{{count}}   "
        }
    },
    xDays: {
        one: {
            default: "1 ",
            in: "1 ",
            ago: "1  "
        },
        other: {
            default: "{{count}} ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    aboutXWeeks: {
        one: {
            default: " 1 ",
            in: " 1 ",
            ago: " 1  "
        },
        other: {
            default: " {{count}} ",
            in: " {{count}} ",
            ago: " {{count}}  "
        }
    },
    xWeeks: {
        one: {
            default: "1 ",
            in: "1 ",
            ago: "1  "
        },
        other: {
            default: "{{count}} ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    aboutXMonths: {
        one: {
            default: " 1 ",
            in: " 1 ",
            ago: " 1  "
        },
        other: {
            default: " {{count}} ",
            in: " {{count}} ",
            ago: " {{count}}  "
        }
    },
    xMonths: {
        one: {
            default: "1 ",
            in: "1 ",
            ago: "1  "
        },
        other: {
            default: "{{count}} ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    aboutXYears: {
        one: {
            default: " 1 ",
            in: " 1 ",
            ago: " 1  "
        },
        other: {
            default: " {{count}} ",
            in: " {{count}} ",
            ago: " {{count}}  "
        }
    },
    xYears: {
        one: {
            default: "1 ",
            in: "1 ",
            ago: "1  "
        },
        other: {
            default: "{{count}} ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    overXYears: {
        one: {
            default: "1  ",
            in: "1  ",
            ago: "1  "
        },
        other: {
            default: "{{count}}  ",
            in: "{{count}} ",
            ago: "{{count}}  "
        }
    },
    almostXYears: {
        one: {
            default: " 1 ",
            in: " 1 ",
            ago: " 1  "
        },
        other: {
            default: " {{count}} ",
            in: " {{count}} ",
            ago: " {{count}}  "
        }
    }
};
const formatDistance$b = (token, count, options2) => {
    const tense = options2?.addSuffix ? options2.comparison && options2.comparison > 0 ? "in" : "ago" : "default";
    const tokenValue = formatDistanceLocale$b[token];
    if (!isPluralType(tokenValue))
        return tokenValue[tense];
    if (count === 1) {
        return tokenValue.one[tense];
    }
    else {
        return tokenValue.other[tense].replace("{{count}}", String(count));
    }
};
const dateFormats$b = {
    full: "EEEE, d MMMM, y",
    long: "d MMMM, y",
    medium: "d MMM, y",
    short: "d/M/yy"
};
const timeFormats$b = {
    full: "a h:mm:ss zzzz",
    long: "a h:mm:ss z",
    medium: "a h:mm:ss",
    short: "a h:mm"
};
const dateTimeFormats$b = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$b = {
    date: buildFormatLongFn({
        formats: dateFormats$b,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$b,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$b,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$b = {
    lastWeek: "'' eeee p ''",
    yesterday: "' ' p ''",
    today: "' ' p ''",
    tomorrow: "' ' p ''",
    nextWeek: "eeee p ''",
    other: "P"
};
const formatRelative$b = (token, _date, _baseDate, _options) => formatRelativeLocale$b[token];
const eraValues$b = {
    narrow: ["..", ".."],
    abbreviated: ["..", ".."],
    // CLDR #1624, #1626
    wide: [" ", " "]
    // CLDR #1620, #1622
};
const quarterValues$b = {
    // CLDR #1644 - #1647
    narrow: ["1", "2", "3", "4"],
    // CLDR #1636 - #1639
    abbreviated: [".1", ".2", ".3", ".4"],
    // CLDR #1628 - #1631
    wide: [
        " ",
        " ",
        " ",
        " "
    ]
};
const monthValues$b = {
    // CLDR #700 - #711
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    // CLDR #1676 - #1687
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        "",
        "",
        "",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    // CLDR #1652 - #1663
    wide: [
        "",
        // January
        "",
        // February
        "",
        // March
        "",
        // April
        "",
        // May
        "",
        // June
        "",
        // July
        "",
        // August
        "",
        // September
        "",
        // October
        "",
        // November
        ""
        // December
    ]
};
const dayValues$b = {
    // CLDR #1766 - #1772
    narrow: ["", "", "", "", "", "", ""],
    // CLDR #1752 - #1758
    short: ["", "", "", "", "", "", ""],
    // CLDR #1738 - #1744
    abbreviated: [".", ".", ".", ".", ".", ".", ""],
    // CLDR #1724 - #1730
    wide: [
        "",
        // Sunday
        "",
        // Monday
        "",
        // Tuesday
        "",
        // Wednesday
        "",
        // Thursday
        "",
        // Friday
        ""
        // Saturday
    ]
};
const dayPeriodValues$b = {
    narrow: {
        am: ".",
        pm: ".",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: ".",
        evening: ".",
        night: "."
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$b = {
    narrow: {
        am: ".",
        pm: ".",
        midnight: ".",
        noon: ".",
        morning: ".",
        afternoon: ".",
        evening: ".",
        night: "."
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$b = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$b = {
    ordinalNumber: ordinalNumber$b,
    era: buildLocalizeFn({
        values: eraValues$b,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$b,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$b,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$b,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$b,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$b,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$b = /^(\d+)()?/i;
const parseOrdinalNumberPattern$b = /\d+/i;
const matchEraPatterns$b = {
    narrow: /^(..|..)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?)/,
    wide: /^(\s|\s)/i
};
const parseEraPatterns$b = {
    any: [/\.?\s?\.?/, /\.?\s?\.?/]
};
const matchQuarterPatterns$b = {
    narrow: /^[1234]/i,
    abbreviated: /^.[1234]/i,
    wide: /^(|||) /i
};
const parseQuarterPatterns$b = {
    narrow: [/1/i, /2/i, /3/i, /4/i],
    any: [
        /(1|.1|)/i,
        /(2|.2|)/i,
        /(3|.3|)/i,
        /(4|.4|)/i
    ]
};
const matchMonthPatterns$b = {
    narrow: /^(||||||||||)$/i,
    abbreviated: /^(.|.|.|.||||.|.|.|.|.)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$b = {
    narrow: [
        /^$/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$b = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    abbreviated: /^(.|.|.|.|.|.|)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$b = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$b = {
    narrow: /^(.|.||||||)/i,
    any: /^(.|.||||||||)/i
};
const parseDayPeriodPatterns$b = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$b = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$b,
        parsePattern: parseOrdinalNumberPattern$b,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$b,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$b,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$b,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$b,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$b,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$b,
        defaultParseWidth: "any"
    })
};
const ta = {
    code: "ta",
    formatDistance: formatDistance$b,
    formatLong: formatLong$b,
    formatRelative: formatRelative$b,
    localize: localize$b,
    match: match$b,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$a = {
    lessThanXSeconds: {
        standalone: {
            one: "  ",
            other: "{{count}}   "
        },
        withPreposition: {
            one: "",
            other: "{{count}} "
        }
    },
    xSeconds: {
        standalone: {
            one: " ",
            // CLDR #1314
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    halfAMinute: {
        standalone: " ",
        withPreposition: " "
    },
    lessThanXMinutes: {
        standalone: {
            one: "   ",
            other: "{{count}}   "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    xMinutes: {
        standalone: {
            one: " ",
            // CLDR #1311
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            // CLDR #1311
            other: "{{count}} "
        }
    },
    aboutXHours: {
        standalone: {
            one: "  ",
            other: " {{count}} "
        },
        withPreposition: {
            one: "  ",
            other: " {{count}} "
        }
    },
    xHours: {
        standalone: {
            one: " ",
            // CLDR #1308
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    xDays: {
        standalone: {
            one: " ",
            // CLDR #1292
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    aboutXWeeks: {
        standalone: {
            one: "  ",
            other: " {{count}} "
        },
        withPreposition: {
            one: "  ",
            other: " {{count}} "
        }
    },
    xWeeks: {
        standalone: {
            one: " ",
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    aboutXMonths: {
        standalone: {
            one: "  ",
            other: " {{count}} "
        },
        withPreposition: {
            one: "  ",
            other: " {{count}} "
        }
    },
    xMonths: {
        standalone: {
            one: " ",
            // CLDR #1281
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    aboutXYears: {
        standalone: {
            one: "  ",
            other: " {{count}} "
        },
        withPreposition: {
            one: "  ",
            other: " {{count}} "
        }
    },
    xYears: {
        standalone: {
            one: " ",
            // CLDR #1275
            other: "{{count}} "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    overXYears: {
        standalone: {
            one: "  ",
            other: "{{count}}  "
        },
        withPreposition: {
            one: " ",
            other: "{{count}} "
        }
    },
    almostXYears: {
        standalone: {
            one: "  ",
            other: " {{count}} "
        },
        withPreposition: {
            one: "  ",
            other: " {{count}} "
        }
    }
};
const formatDistance$a = (token, count, options2) => {
    let result;
    const tokenValue = options2?.addSuffix ? formatDistanceLocale$a[token].withPreposition : formatDistanceLocale$a[token].standalone;
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$a = {
    full: "d, MMMM y, EEEE",
    long: "d MMMM, y",
    medium: "d MMM, y",
    short: "dd-MM-yy"
};
const timeFormats$a = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$a = {
    full: "{{date}} {{time}}''",
    long: "{{date}} {{time}}''",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$a = {
    date: buildFormatLongFn({
        formats: dateFormats$a,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$a,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$a,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$a = {
    lastWeek: "'' eeee p",
    // CLDR #1384
    yesterday: "'' p",
    // CLDR #1393
    today: "' ' p",
    // CLDR #1394
    tomorrow: "'' p",
    // CLDR #1395
    nextWeek: "'' eeee p",
    // CLDR #1386
    other: "P"
};
const formatRelative$a = (token, _date, _baseDate, _options) => formatRelativeLocale$a[token];
const eraValues$a = {
    narrow: ["..", ".."],
    abbreviated: ["..", ".."],
    wide: [" ", ""]
};
const quarterValues$a = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$a = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$a = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$a = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$a = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$a = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + "";
};
const localize$a = {
    ordinalNumber: ordinalNumber$a,
    era: buildLocalizeFn({
        values: eraValues$a,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$a,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$a,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$a,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$a,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$a,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$a = /^(\d+)()?/i;
const parseOrdinalNumberPattern$a = /\d+/i;
const matchEraPatterns$a = {
    narrow: /^(\.\.|\.\.)/i,
    abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
    wide: /^( |  | | )/i
};
const parseEraPatterns$a = {
    any: [/^(|)/i, /^/i]
};
const matchQuarterPatterns$a = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^[1234]()? /i
};
const parseQuarterPatterns$a = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$a = {
    narrow: /^(|||||||||||)/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$a = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$a = {
    narrow: /^(||||||)/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$a = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$a = {
    narrow: /^(|||||||)/i,
    any: /^(|||||||)/i
};
const parseDayPeriodPatterns$a = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$a = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$a,
        parsePattern: parseOrdinalNumberPattern$a,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$a,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$a,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$a,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$a,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$a,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$a,
        defaultParseWidth: "any"
    })
};
const te = {
    code: "te",
    formatDistance: formatDistance$a,
    formatLong: formatLong$a,
    formatRelative: formatRelative$a,
    localize: localize$a,
    match: match$a,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$9 = {
    lessThanXSeconds: {
        one: " 1 ",
        other: " {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: "",
    lessThanXMinutes: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$9 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$9[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            if (token === "halfAMinute") {
                return "" + result;
            }
            else {
                return " " + result;
            }
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats$9 = {
    full: "EEEE do MMMM y",
    long: "do MMMM y",
    medium: "d MMM y",
    short: "dd/MM/yyyy"
};
const timeFormats$9 = {
    full: "H:mm:ss . zzzz",
    long: "H:mm:ss . z",
    medium: "H:mm:ss .",
    short: "H:mm ."
};
const dateTimeFormats$9 = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$9 = {
    date: buildFormatLongFn({
        formats: dateFormats$9,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$9,
        defaultWidth: "medium"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$9,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$9 = {
    lastWeek: "eeee'' p",
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$9 = (token, _date, _baseDate, _options) => formatRelativeLocale$9[token];
const eraValues$9 = {
    narrow: ["B", ""],
    abbreviated: ["BC", ".."],
    wide: ["", ""]
};
const quarterValues$9 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["", "", "", ""]
};
const dayValues$9 = {
    narrow: [".", ".", ".", ".", ".", ".", "."],
    short: [".", ".", ".", ".", ".", ".", "."],
    abbreviated: [".", ".", ".", ".", ".", ".", "."],
    wide: ["", "", "", "", "", "", ""]
};
const monthValues$9 = {
    narrow: [
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        ".."
    ],
    abbreviated: [
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        ".."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$9 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$9 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$9 = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$9 = {
    ordinalNumber: ordinalNumber$9,
    era: buildLocalizeFn({
        values: eraValues$9,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$9,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$9,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$9,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$9,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$9,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$9 = /^\d+/i;
const parseOrdinalNumberPattern$9 = /\d+/i;
const matchEraPatterns$9 = {
    narrow: /^([bB]|[aA]|)/i,
    abbreviated: /^([bB]\.?\s?[cC]\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?|\.?\.?)/i,
    wide: /^(||)/i
};
const parseEraPatterns$9 = {
    any: [/^[bB]/i, /^(^[aA]|\.?\.?|||)/i]
};
const matchQuarterPatterns$9 = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^()? ?[1234]/i
};
const parseQuarterPatterns$9 = {
    any: [/(1||)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns$9 = {
    narrow: /^(\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?)/i,
    abbreviated: /^(\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?')/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$9 = {
    wide: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i,
        /^\.?\.?/i
    ]
};
const matchDayPatterns$9 = {
    narrow: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
    short: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
    abbreviated: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$9 = {
    wide: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^(?!)/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$9 = {
    any: /^(||||(.*?)?.*(||||))/i
};
const parseDayPeriodPatterns$9 = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: //i,
        evening: //i,
        night: //i
    }
};
const match$9 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$9,
        parsePattern: parseOrdinalNumberPattern$9,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$9,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$9,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$9,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$9,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$9,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$9,
        defaultParseWidth: "any"
    })
};
const th = {
    code: "th",
    formatDistance: formatDistance$9,
    formatLong: formatLong$9,
    formatRelative: formatRelative$9,
    localize: localize$9,
    match: match$9,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$8 = {
    lessThanXSeconds: {
        one: "bir saniyeden az",
        other: "{{count}} saniyeden az"
    },
    xSeconds: {
        one: "1 saniye",
        other: "{{count}} saniye"
    },
    halfAMinute: "yarm dakika",
    lessThanXMinutes: {
        one: "bir dakikadan az",
        other: "{{count}} dakikadan az"
    },
    xMinutes: {
        one: "1 dakika",
        other: "{{count}} dakika"
    },
    aboutXHours: {
        one: "yaklak 1 saat",
        other: "yaklak {{count}} saat"
    },
    xHours: {
        one: "1 saat",
        other: "{{count}} saat"
    },
    xDays: {
        one: "1 gn",
        other: "{{count}} gn"
    },
    aboutXWeeks: {
        one: "yaklak 1 hafta",
        other: "yaklak {{count}} hafta"
    },
    xWeeks: {
        one: "1 hafta",
        other: "{{count}} hafta"
    },
    aboutXMonths: {
        one: "yaklak 1 ay",
        other: "yaklak {{count}} ay"
    },
    xMonths: {
        one: "1 ay",
        other: "{{count}} ay"
    },
    aboutXYears: {
        one: "yaklak 1 yl",
        other: "yaklak {{count}} yl"
    },
    xYears: {
        one: "1 yl",
        other: "{{count}} yl"
    },
    overXYears: {
        one: "1 yldan fazla",
        other: "{{count}} yldan fazla"
    },
    almostXYears: {
        one: "neredeyse 1 yl",
        other: "neredeyse {{count}} yl"
    }
};
const formatDistance$8 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$8[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " sonra";
        }
        else {
            return result + " nce";
        }
    }
    return result;
};
const dateFormats$8 = {
    full: "d MMMM y EEEE",
    long: "d MMMM y",
    medium: "d MMM y",
    short: "dd.MM.yyyy"
};
const timeFormats$8 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$8 = {
    full: "{{date}} 'saat' {{time}}",
    long: "{{date}} 'saat' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$8 = {
    date: buildFormatLongFn({
        formats: dateFormats$8,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$8,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$8,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$8 = {
    lastWeek: "'geen hafta' eeee 'saat' p",
    yesterday: "'dn saat' p",
    today: "'bugn saat' p",
    tomorrow: "'yarn saat' p",
    nextWeek: "eeee 'saat' p",
    other: "P"
};
const formatRelative$8 = (token, _date, _baseDate, _options) => formatRelativeLocale$8[token];
const eraValues$8 = {
    narrow: ["M", "MS"],
    abbreviated: ["M", "MS"],
    wide: ["Milattan nce", "Milattan Sonra"]
};
const quarterValues$8 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: ["lk eyrek", "kinci eyrek", "nc eyrek", "Son eyrek"]
};
const monthValues$8 = {
    narrow: ["O", "", "M", "N", "M", "H", "T", "A", "E", "E", "K", "A"],
    abbreviated: [
        "Oca",
        "ub",
        "Mar",
        "Nis",
        "May",
        "Haz",
        "Tem",
        "Au",
        "Eyl",
        "Eki",
        "Kas",
        "Ara"
    ],
    wide: [
        "Ocak",
        "ubat",
        "Mart",
        "Nisan",
        "Mays",
        "Haziran",
        "Temmuz",
        "Austos",
        "Eyll",
        "Ekim",
        "Kasm",
        "Aralk"
    ]
};
const dayValues$8 = {
    narrow: ["P", "P", "S", "", "P", "C", "C"],
    short: ["Pz", "Pt", "Sa", "a", "Pe", "Cu", "Ct"],
    abbreviated: ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cts"],
    wide: [
        "Pazar",
        "Pazartesi",
        "Sal",
        "aramba",
        "Perembe",
        "Cuma",
        "Cumartesi"
    ]
};
const dayPeriodValues$8 = {
    narrow: {
        am: "",
        pm: "s",
        midnight: "gy",
        noon: "",
        morning: "sa",
        afternoon: "s",
        evening: "ak",
        night: "ge"
    },
    abbreviated: {
        am: "",
        pm: "S",
        midnight: "gece yars",
        noon: "le",
        morning: "sabah",
        afternoon: "leden sonra",
        evening: "akam",
        night: "gece"
    },
    wide: {
        am: "..",
        pm: ".S.",
        midnight: "gece yars",
        noon: "le",
        morning: "sabah",
        afternoon: "leden sonra",
        evening: "akam",
        night: "gece"
    }
};
const formattingDayPeriodValues$8 = {
    narrow: {
        am: "",
        pm: "s",
        midnight: "gy",
        noon: "",
        morning: "sa",
        afternoon: "s",
        evening: "ak",
        night: "ge"
    },
    abbreviated: {
        am: "",
        pm: "S",
        midnight: "gece yars",
        noon: "len",
        morning: "sabahleyin",
        afternoon: "leden sonra",
        evening: "akamleyin",
        night: "geceleyin"
    },
    wide: {
        am: "..",
        pm: ".s.",
        midnight: "gece yars",
        noon: "len",
        morning: "sabahleyin",
        afternoon: "leden sonra",
        evening: "akamleyin",
        night: "geceleyin"
    }
};
const ordinalNumber$8 = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    return number2 + ".";
};
const localize$8 = {
    ordinalNumber: ordinalNumber$8,
    era: buildLocalizeFn({
        values: eraValues$8,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$8,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$8,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$8,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$8,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$8,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$8 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$8 = /\d+/i;
const matchEraPatterns$8 = {
    narrow: /^(m|ms)/i,
    abbreviated: /^(m|ms)/i,
    wide: /^(milattan nce|milattan sonra)/i
};
const parseEraPatterns$8 = {
    any: [/(^m|^milattan nce)/i, /(^ms|^milattan sonra)/i]
};
const matchQuarterPatterns$8 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^((i|)lk|(i|)kinci|nc|son) eyrek/i
};
const parseQuarterPatterns$8 = {
    any: [/1/i, /2/i, /3/i, /4/i],
    abbreviated: [/1/i, /2/i, /3/i, /4/i],
    wide: [
        /^(i|)lk eyrek/i,
        /(i|)kinci eyrek/i,
        /nc eyrek/i,
        /son eyrek/i
    ]
};
const matchMonthPatterns$8 = {
    narrow: /^[omnhtaek]/i,
    abbreviated: /^(oca|ub|mar|nis|may|haz|tem|au|eyl|eki|kas|ara)/i,
    wide: /^(ocak|ubat|mart|nisan|mays|haziran|temmuz|austos|eyll|ekim|kasm|aralk)/i
};
const parseMonthPatterns$8 = {
    narrow: [
        /^o/i,
        /^/i,
        /^m/i,
        /^n/i,
        /^m/i,
        /^h/i,
        /^t/i,
        /^a/i,
        /^e/i,
        /^e/i,
        /^k/i,
        /^a/i
    ],
    any: [
        /^o/i,
        /^/i,
        /^mar/i,
        /^n/i,
        /^may/i,
        /^h/i,
        /^t/i,
        /^a/i,
        /^ey/i,
        /^ek/i,
        /^k/i,
        /^ar/i
    ]
};
const matchDayPatterns$8 = {
    narrow: /^[psc]/i,
    short: /^(pz|pt|sa|a|pe|cu|ct)/i,
    abbreviated: /^(paz|pzt|sal|ar|per|cum|cts)/i,
    wide: /^(pazar(?!tesi)|pazartesi|sal|aramba|perembe|cuma(?!rtesi)|cumartesi)/i
};
const parseDayPatterns$8 = {
    narrow: [/^p/i, /^p/i, /^s/i, /^/i, /^p/i, /^c/i, /^c/i],
    any: [/^pz/i, /^pt/i, /^sa/i, /^a/i, /^pe/i, /^cu/i, /^ct/i],
    wide: [
        /^pazar(?!tesi)/i,
        /^pazartesi/i,
        /^sal/i,
        /^aramba/i,
        /^perembe/i,
        /^cuma(?!rtesi)/i,
        /^cumartesi/i
    ]
};
const matchDayPeriodPatterns$8 = {
    narrow: /^(|s|gy||sa|s|ak|ge)/i,
    any: /^(\.?\s?[s]\.?|leden sonra|gece yars|le|(sabah||akam|gece)(leyin))/i
};
const parseDayPeriodPatterns$8 = {
    any: {
        am: /^\.?\.?/i,
        pm: /^\.?s\.?/i,
        midnight: /^(gy|gece yars)/i,
        noon: /^/i,
        morning: /^sa/i,
        afternoon: /^leden sonra/i,
        evening: /^ak/i,
        night: /^ge/i
    }
};
const match$8 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$8,
        parsePattern: parseOrdinalNumberPattern$8,
        valueCallback: function (value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$8,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$8,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$8,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$8,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$8,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$8,
        defaultParseWidth: "any"
    })
};
const tr = {
    code: "tr",
    formatDistance: formatDistance$8,
    formatLong: formatLong$8,
    formatRelative: formatRelative$8,
    localize: localize$8,
    match: match$8,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$7 = {
    lessThanXSeconds: {
        one: "  ",
        other: "  {{count}}"
    },
    xSeconds: {
        one: " ",
        other: " {{count}}"
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "  ",
        other: "  {{count}}"
    },
    xMinutes: {
        one: " ",
        other: " {{count}}"
    },
    aboutXHours: {
        one: "  ",
        other: " {{count}} "
    },
    xHours: {
        one: " ",
        other: " {{count}}"
    },
    xDays: {
        one: " ",
        other: " {{count}}"
    },
    aboutXWeeks: {
        one: " ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "",
        other: " {{count}}"
    },
    aboutXMonths: {
        one: "  ",
        other: " {{count}} "
    },
    xMonths: {
        one: " ",
        other: " {{count}}"
    },
    aboutXYears: {
        one: "  ",
        other: " {{count}} "
    },
    xYears: {
        one: " ",
        other: " {{count}}"
    },
    overXYears: {
        one: "  ",
        other: "  {{count}}"
    },
    almostXYears: {
        one: "  ",
        other: " {{count}} "
    }
};
const formatDistance$7 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$7[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result;
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$7 = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats$7 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats$7 = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$7 = {
    date: buildFormatLongFn({
        formats: dateFormats$7,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$7,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$7,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$7 = {
    lastWeek: "'' eeee '' p",
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: "eeee '' p",
    other: "P"
};
const formatRelative$7 = (token, _date, _baseDate, _options) => formatRelativeLocale$7[token];
const eraValues$7 = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: [" ", " "]
};
const quarterValues$7 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1", "2", "3", "4"],
    wide: [" ", " ", " ", " "]
};
const monthValues$7 = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$7 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$7 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$7 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const ordinalNumber$7 = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$7 = {
    ordinalNumber: ordinalNumber$7,
    era: buildLocalizeFn({
        values: eraValues$7,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$7,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$7,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$7,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$7,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$7,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$7 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$7 = /\d+/i;
const matchEraPatterns$7 = {
    narrow: /^(|)/i,
    wide: /^( | )/i
};
const parseEraPatterns$7 = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$7 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]/i,
    wide: /^ [1234]/i
};
const parseQuarterPatterns$7 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$7 = {
    // eslint-disable-next-line no-misleading-character-class
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$7 = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$7 = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$7 = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$7 = {
    narrow: /^(||||(|) ( | ||))/i,
    any: /^(||||(|) ( | ||))/i
};
const parseDayPeriodPatterns$7 = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: //i,
        afternoon: / /i,
        evening: //i,
        night: //i
    }
};
const match$7 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$7,
        parsePattern: parseOrdinalNumberPattern$7,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$7,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$7,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$7,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$7,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$7,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$7,
        defaultParseWidth: "any"
    })
};
const ug = {
    code: "ug",
    formatDistance: formatDistance$7,
    formatLong: formatLong$7,
    formatRelative: formatRelative$7,
    localize: localize$7,
    match: match$7,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function declension(scheme, count) {
    if (scheme.one !== void 0 && count === 1) {
        return scheme.one;
    }
    const rem10 = count % 10;
    const rem100 = count % 100;
    if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
    }
    else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
    }
    else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
    }
}
function buildLocalizeTokenFn(scheme) {
    return (count, options2) => {
        if (options2 && options2.addSuffix) {
            if (options2.comparison && options2.comparison > 0) {
                if (scheme.future) {
                    return declension(scheme.future, count);
                }
                else {
                    return " " + declension(scheme.regular, count);
                }
            }
            else {
                if (scheme.past) {
                    return declension(scheme.past, count);
                }
                else {
                    return declension(scheme.regular, count) + " ";
                }
            }
        }
        else {
            return declension(scheme.regular, count);
        }
    };
}
const halfAtMinute = (_, options2) => {
    if (options2 && options2.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return " ";
        }
        else {
            return " ";
        }
    }
    return "";
};
const formatDistanceLocale$6 = {
    lessThanXSeconds: buildLocalizeTokenFn({
        regular: {
            one: " ",
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xSeconds: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    halfAMinute: halfAtMinute,
    lessThanXMinutes: buildLocalizeTokenFn({
        regular: {
            one: " ",
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xMinutes: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    aboutXHours: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xHours: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    xDays: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} i",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXWeeks: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xWeeks: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXMonths: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xMonths: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    overXYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    almostXYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    })
};
const formatDistance$6 = (token, count, options2) => {
    options2 = options2 || {};
    return formatDistanceLocale$6[token](count, options2);
};
const dateFormats$6 = {
    full: "EEEE, do MMMM y '.'",
    long: "do MMMM y '.'",
    medium: "d MMM y '.'",
    short: "dd.MM.y"
};
const timeFormats$6 = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$6 = {
    full: "{{date}} '' {{time}}",
    long: "{{date}} '' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong$6 = {
    date: buildFormatLongFn({
        formats: dateFormats$6,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$6,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$6,
        defaultWidth: "full"
    })
};
const accusativeWeekdays = [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
];
function lastWeek(day) {
    const weekday = accusativeWeekdays[day];
    switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
    }
}
function thisWeek(day) {
    const weekday = accusativeWeekdays[day];
    return "' " + weekday + " ' p";
}
function nextWeek(day) {
    const weekday = accusativeWeekdays[day];
    switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
            return "'  " + weekday + " ' p";
        case 1:
        case 2:
        case 4:
            return "'  " + weekday + " ' p";
    }
}
const lastWeekFormat = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek(day);
    }
    else {
        return lastWeek(day);
    }
};
const nextWeekFormat = (dirtyDate, baseDate, options2) => {
    const date = toDate(dirtyDate);
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options2)) {
        return thisWeek(day);
    }
    else {
        return nextWeek(day);
    }
};
const formatRelativeLocale$6 = {
    lastWeek: lastWeekFormat,
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: nextWeekFormat,
    other: "P"
};
const formatRelative$6 = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$6[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$6 = {
    narrow: [" ..", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
};
const quarterValues$6 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$6 = {
    //  3582:2013
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const formattingMonthValues$1 = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        ".",
        "."
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$6 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$6 = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$6 = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    }
};
const ordinalNumber$6 = (dirtyNumber, options2) => {
    const unit = String(options2?.unit);
    const number2 = Number(dirtyNumber);
    let suffix;
    if (unit === "date") {
        if (number2 === 3 || number2 === 23) {
            suffix = "-";
        }
        else {
            suffix = "-";
        }
    }
    else if (unit === "minute" || unit === "second" || unit === "hour") {
        suffix = "-";
    }
    else {
        suffix = "-";
    }
    return number2 + suffix;
};
const localize$6 = {
    ordinalNumber: ordinalNumber$6,
    era: buildLocalizeFn({
        values: eraValues$6,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$6,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$6,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$1,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$6,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$6,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$6,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$6 = /^(\d+)(-?(||||))?/i;
const parseOrdinalNumberPattern$6 = /\d+/i;
const matchEraPatterns$6 = {
    narrow: /^(( )?\.?\s?\.?)/i,
    abbreviated: /^(( )?\.?\s?\.?)/i,
    wide: /^(  | | )/i
};
const parseEraPatterns$6 = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$6 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]??)? .?/i,
    wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$6 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$6 = {
    narrow: /^[]/i,
    abbreviated: /^(||()?||||||()?||()?|)\.?/i,
    wide: /^(||||||||||||||||||||[]?||)/i
};
const parseMonthPatterns$6 = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$6 = {
    narrow: /^[]/i,
    short: /^(||||||)\.?/i,
    abbreviated: /^(||||?|?|)\.?/i,
    wide: /^([]|[][]|[][]|[]|()?|\W*?[]|[])/i
};
const parseDayPatterns$6 = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^[]/i, /^/i, /^[]/i, /^/i, /^\W*?[]/i, /^[]/i]
};
const matchDayPeriodPatterns$6 = {
    narrow: /^([]|\.?|\.?|||||\.?||)/i,
    abbreviated: /^([]|\.?|\.?|||||\.?||)/i,
    wide: /^([]||||||||||)/i
};
const parseDayPeriodPatterns$6 = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^[]/i,
        evening: /^/i,
        night: /^/i
    }
};
const match$6 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$6,
        parsePattern: parseOrdinalNumberPattern$6,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$6,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$6,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$6,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$6,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$6,
        defaultParseWidth: "any"
    })
};
const uk = {
    code: "uk",
    formatDistance: formatDistance$6,
    formatLong: formatLong$6,
    formatRelative: formatRelative$6,
    localize: localize$6,
    match: match$6,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$5 = {
    lessThanXSeconds: {
        one: "sekunddan kam",
        other: "{{count}} sekunddan kam"
    },
    xSeconds: {
        one: "1 sekund",
        other: "{{count}} sekund"
    },
    halfAMinute: "yarim minut",
    lessThanXMinutes: {
        one: "bir minutdan kam",
        other: "{{count}} minutdan kam"
    },
    xMinutes: {
        one: "1 minut",
        other: "{{count}} minut"
    },
    aboutXHours: {
        one: "tahminan 1 soat",
        other: "tahminan {{count}} soat"
    },
    xHours: {
        one: "1 soat",
        other: "{{count}} soat"
    },
    xDays: {
        one: "1 kun",
        other: "{{count}} kun"
    },
    aboutXWeeks: {
        one: "tahminan 1 hafta",
        other: "tahminan {{count}} hafta"
    },
    xWeeks: {
        one: "1 hafta",
        other: "{{count}} hafta"
    },
    aboutXMonths: {
        one: "tahminan 1 oy",
        other: "tahminan {{count}} oy"
    },
    xMonths: {
        one: "1 oy",
        other: "{{count}} oy"
    },
    aboutXYears: {
        one: "tahminan 1 yil",
        other: "tahminan {{count}} yil"
    },
    xYears: {
        one: "1 yil",
        other: "{{count}} yil"
    },
    overXYears: {
        one: "1 yildan ko'p",
        other: "{{count}} yildan ko'p"
    },
    almostXYears: {
        one: "deyarli 1 yil",
        other: "deyarli {{count}} yil"
    }
};
const formatDistance$5 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$5[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " dan keyin";
        }
        else {
            return result + " oldin";
        }
    }
    return result;
};
const dateFormats$5 = {
    full: "EEEE, do MMMM, y",
    long: "do MMMM, y",
    medium: "d MMM, y",
    short: "dd/MM/yyyy"
};
const timeFormats$5 = {
    full: "h:mm:ss zzzz",
    long: "h:mm:ss z",
    medium: "h:mm:ss",
    short: "h:mm"
};
const dateTimeFormats$5 = {
    any: "{{date}}, {{time}}"
};
const formatLong$5 = {
    date: buildFormatLongFn({
        formats: dateFormats$5,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$5,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$5,
        defaultWidth: "any"
    })
};
const formatRelativeLocale$5 = {
    lastWeek: "'oldingi' eeee p 'da'",
    yesterday: "'kecha' p 'da'",
    today: "'bugun' p 'da'",
    tomorrow: "'ertaga' p 'da'",
    nextWeek: "eeee p 'da'",
    other: "P"
};
const formatRelative$5 = (token, _date, _baseDate, _options) => formatRelativeLocale$5[token];
const eraValues$5 = {
    narrow: ["M.A", "M."],
    abbreviated: ["M.A", "M."],
    wide: ["Miloddan Avvalgi", "Milodiy"]
};
const quarterValues$5 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["CH.1", "CH.2", "CH.3", "CH.4"],
    wide: ["1-chi chorak", "2-chi chorak", "3-chi chorak", "4-chi chorak"]
};
const monthValues$5 = {
    narrow: ["Y", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
    abbreviated: [
        "Yan",
        "Fev",
        "Mar",
        "Apr",
        "May",
        "Iyun",
        "Iyul",
        "Avg",
        "Sen",
        "Okt",
        "Noy",
        "Dek"
    ],
    wide: [
        "Yanvar",
        "Fevral",
        "Mart",
        "Aprel",
        "May",
        "Iyun",
        "Iyul",
        "Avgust",
        "Sentabr",
        "Oktabr",
        "Noyabr",
        "Dekabr"
    ]
};
const dayValues$5 = {
    narrow: ["Y", "D", "S", "CH", "P", "J", "SH"],
    short: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
    abbreviated: ["Yak", "Dush", "Sesh", "Chor", "Pay", "Jum", "Shan"],
    wide: [
        "Yakshanba",
        "Dushanba",
        "Seshanba",
        "Chorshanba",
        "Payshanba",
        "Juma",
        "Shanba"
    ]
};
const dayPeriodValues$5 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "y.t",
        noon: "p.",
        morning: "ertalab",
        afternoon: "tushdan keyin",
        evening: "kechqurun",
        night: "tun"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "yarim tun",
        noon: "peshin",
        morning: "ertalab",
        afternoon: "tushdan keyin",
        evening: "kechqurun",
        night: "tun"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "yarim tun",
        noon: "peshin",
        morning: "ertalab",
        afternoon: "tushdan keyin",
        evening: "kechqurun",
        night: "tun"
    }
};
const formattingDayPeriodValues$5 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "y.t",
        noon: "p.",
        morning: "ertalab",
        afternoon: "tushdan keyin",
        evening: "kechqurun",
        night: "tun"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "yarim tun",
        noon: "peshin",
        morning: "ertalab",
        afternoon: "tushdan keyin",
        evening: "kechqurun",
        night: "tun"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "yarim tun",
        noon: "peshin",
        morning: "ertalab",
        afternoon: "tushdan keyin",
        evening: "kechqurun",
        night: "tun"
    }
};
const ordinalNumber$5 = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$5 = {
    ordinalNumber: ordinalNumber$5,
    era: buildLocalizeFn({
        values: eraValues$5,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$5,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$5,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$5,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$5,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$5,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$5 = /^(\d+)(chi)?/i;
const parseOrdinalNumberPattern$5 = /\d+/i;
const matchEraPatterns$5 = {
    narrow: /^(m\.a|m\.)/i,
    abbreviated: /^(m\.a\.?\s?m\.?)/i,
    wide: /^(miloddan avval|miloddan keyin)/i
};
const parseEraPatterns$5 = {
    any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$5 = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](chi)? chorak/i
};
const parseQuarterPatterns$5 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$5 = {
    narrow: /^[yfmasond]/i,
    abbreviated: /^(yan|fev|mar|apr|may|iyun|iyul|avg|sen|okt|noy|dek)/i,
    wide: /^(yanvar|fevral|mart|aprel|may|iyun|iyul|avgust|sentabr|oktabr|noyabr|dekabr)/i
};
const parseMonthPatterns$5 = {
    narrow: [
        /^y/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^i/i,
        /^i/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ya/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^iyun/i,
        /^iyul/i,
        /^av/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns$5 = {
    narrow: /^[ydschj]/i,
    short: /^(ya|du|se|cho|pa|ju|sha)/i,
    abbreviated: /^(yak|dush|sesh|chor|pay|jum|shan)/i,
    wide: /^(yakshanba|dushanba|seshanba|chorshanba|payshanba|juma|shanba)/i
};
const parseDayPatterns$5 = {
    narrow: [/^y/i, /^d/i, /^s/i, /^ch/i, /^p/i, /^j/i, /^sh/i],
    any: [/^ya/i, /^d/i, /^se/i, /^ch/i, /^p/i, /^j/i, /^sh/i]
};
const matchDayPeriodPatterns$5 = {
    narrow: /^(a|p|y\.t|p| (ertalab|tushdan keyin|kechqurun|tun))/i,
    any: /^([ap]\.?\s?m\.?|yarim tun|peshin| (ertalab|tushdan keyin|kechqurun|tun))/i
};
const parseDayPeriodPatterns$5 = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^y\.t/i,
        noon: /^pe/i,
        morning: /ertalab/i,
        afternoon: /tushdan keyin/i,
        evening: /kechqurun/i,
        night: /tun/i
    }
};
const match$5 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$5,
        parsePattern: parseOrdinalNumberPattern$5,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$5,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$5,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$5,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$5,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$5,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$5,
        defaultParseWidth: "any"
    })
};
const uz = {
    code: "uz",
    formatDistance: formatDistance$5,
    formatLong: formatLong$5,
    formatRelative: formatRelative$5,
    localize: localize$5,
    match: match$5,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$4 = {
    lessThanXSeconds: {
        one: "1  ",
        other: "{{count}}  "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: " ",
    lessThanXMinutes: {
        one: "1  ",
        other: "{{count}}  "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: "1  ",
        other: "{{count}}  "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$4 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$4[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " ";
        }
        else {
            return result + " ";
        }
    }
    return result;
};
const dateFormats$4 = {
    full: "EEEE, do MMMM, y",
    long: "do MMMM, y",
    medium: "d MMM, y",
    short: "dd/MM/yyyy"
};
const timeFormats$4 = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
};
const dateTimeFormats$4 = {
    any: "{{date}}, {{time}}"
};
const formatLong$4 = {
    date: buildFormatLongFn({
        formats: dateFormats$4,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$4,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$4,
        defaultWidth: "any"
    })
};
const formatRelativeLocale$4 = {
    lastWeek: "'' eeee p ''",
    yesterday: "'' p ''",
    today: "'' p ''",
    tomorrow: "'' p ''",
    nextWeek: "eeee p ''",
    other: "P"
};
const formatRelative$4 = (token, _date, _baseDate, _options) => formatRelativeLocale$4[token];
const eraValues$4 = {
    narrow: [".", ""],
    abbreviated: [".", ""],
    wide: [" ", ""]
};
const quarterValues$4 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1-.", "2-.", "3-.", "4-."],
    wide: ["1-", "2-", "3-", "4-"]
};
const monthValues$4 = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$4 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayPeriodValues$4 = {
    any: {
        am: "..",
        pm: "..",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$4 = {
    any: {
        am: "..",
        pm: "..",
        midnight: " ",
        noon: "",
        morning: "",
        afternoon: " ",
        evening: "",
        night: ""
    }
};
const ordinalNumber$4 = (dirtyNumber, _options) => {
    return String(dirtyNumber);
};
const localize$4 = {
    ordinalNumber: ordinalNumber$4,
    era: buildLocalizeFn({
        values: eraValues$4,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$4,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$4,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$4,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$4,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$4,
        defaultFormattingWidth: "any"
    })
};
const matchOrdinalNumberPattern$4 = /^(\d+)()?/i;
const parseOrdinalNumberPattern$4 = /\d+/i;
const matchEraPatterns$4 = {
    narrow: /^(\.|\.)/i,
    abbreviated: /^(\.|\.)/i,
    wide: /^( | )/i
};
const parseEraPatterns$4 = {
    any: [/^/i, /^/i]
};
const matchQuarterPatterns$4 = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234]-./i,
    wide: /^[1234]-/i
};
const parseQuarterPatterns$4 = {
    any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$4 = {
    narrow: /^[]/i,
    abbreviated: /^(|||||||||||)/i,
    wide: /^(|||||||||||)/i
};
const parseMonthPatterns$4 = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ],
    any: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
    ]
};
const matchDayPatterns$4 = {
    narrow: /^[]/i,
    short: /^(||||||)/i,
    abbreviated: /^(||||||)/i,
    wide: /^(||||||)/i
};
const parseDayPatterns$4 = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$4 = {
    any: /^(\.\.|\.\.| | |(| ||))/i
};
const parseDayPeriodPatterns$4 = {
    any: {
        am: /^\.\./i,
        pm: /^\.\./i,
        midnight: /^ /i,
        noon: /^ /i,
        morning: //i,
        afternoon: / /i,
        evening: //i,
        night: //i
    }
};
const match$4 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$4,
        parsePattern: parseOrdinalNumberPattern$4,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$4,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$4,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$4,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$4,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$4,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$4,
        defaultParseWidth: "any"
    })
};
const uzCyrl = {
    code: "uz-Cyrl",
    formatDistance: formatDistance$4,
    formatLong: formatLong$4,
    formatRelative: formatRelative$4,
    localize: localize$4,
    match: match$4,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$3 = {
    lessThanXSeconds: {
        one: "di 1 giy",
        other: "di {{count}} giy"
    },
    xSeconds: {
        one: "1 giy",
        other: "{{count}} giy"
    },
    halfAMinute: "na pht",
    lessThanXMinutes: {
        one: "di 1 pht",
        other: "di {{count}} pht"
    },
    xMinutes: {
        one: "1 pht",
        other: "{{count}} pht"
    },
    aboutXHours: {
        one: "khong 1 gi",
        other: "khong {{count}} gi"
    },
    xHours: {
        one: "1 gi",
        other: "{{count}} gi"
    },
    xDays: {
        one: "1 ngy",
        other: "{{count}} ngy"
    },
    aboutXWeeks: {
        one: "khong 1 tun",
        other: "khong {{count}} tun"
    },
    xWeeks: {
        one: "1 tun",
        other: "{{count}} tun"
    },
    aboutXMonths: {
        one: "khong 1 thng",
        other: "khong {{count}} thng"
    },
    xMonths: {
        one: "1 thng",
        other: "{{count}} thng"
    },
    aboutXYears: {
        one: "khong 1 nm",
        other: "khong {{count}} nm"
    },
    xYears: {
        one: "1 nm",
        other: "{{count}} nm"
    },
    overXYears: {
        one: "hn 1 nm",
        other: "hn {{count}} nm"
    },
    almostXYears: {
        one: "gn 1 nm",
        other: "gn {{count}} nm"
    }
};
const formatDistance$3 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$3[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + " na";
        }
        else {
            return result + " trc";
        }
    }
    return result;
};
const dateFormats$3 = {
    // th Su, ngy 25 thng 08 nm 2017
    full: "EEEE, 'ngy' d MMMM 'nm' y",
    // ngy 25 thng 08 nm 2017
    long: "'ngy' d MMMM 'nm' y",
    // 25 thg 08 nm 2017
    medium: "d MMM 'nm' y",
    // 25/08/2017
    short: "dd/MM/y"
};
const timeFormats$3 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
};
const dateTimeFormats$3 = {
    // th Su, ngy 25 thng 08 nm 2017 23:25:59
    full: "{{date}} {{time}}",
    // ngy 25 thng 08 nm 2017 23:25
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$3 = {
    date: buildFormatLongFn({
        formats: dateFormats$3,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$3,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$3,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$3 = {
    lastWeek: "eeee 'tun trc vo lc' p",
    yesterday: "'hm qua vo lc' p",
    today: "'hm nay vo lc' p",
    tomorrow: "'ngy mai vo lc' p",
    nextWeek: "eeee 'ti vo lc' p",
    other: "P"
};
const formatRelative$3 = (token, _date, _baseDate, _options) => formatRelativeLocale$3[token];
const eraValues$3 = {
    narrow: ["TCN", "SCN"],
    abbreviated: ["trc CN", "sau CN"],
    wide: ["trc Cng Nguyn", "sau Cng Nguyn"]
};
const quarterValues$3 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["Qu 1", "Qu 2", "Qu 3", "Qu 4"]
};
const formattingQuarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    // I notice many news outlet use this "qu II/2018"
    wide: ["qu I", "qu II", "qu III", "qu IV"]
};
const monthValues$3 = {
    narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    abbreviated: [
        "Thg 1",
        "Thg 2",
        "Thg 3",
        "Thg 4",
        "Thg 5",
        "Thg 6",
        "Thg 7",
        "Thg 8",
        "Thg 9",
        "Thg 10",
        "Thg 11",
        "Thg 12"
    ],
    wide: [
        "Thng Mt",
        "Thng Hai",
        "Thng Ba",
        "Thng T",
        "Thng Nm",
        "Thng Su",
        "Thng By",
        "Thng Tm",
        "Thng Chn",
        "Thng Mi",
        "Thng Mi Mt",
        "Thng Mi Hai"
    ]
};
const formattingMonthValues = {
    narrow: [
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "10",
        "11",
        "12"
    ],
    abbreviated: [
        "thg 1",
        "thg 2",
        "thg 3",
        "thg 4",
        "thg 5",
        "thg 6",
        "thg 7",
        "thg 8",
        "thg 9",
        "thg 10",
        "thg 11",
        "thg 12"
    ],
    wide: [
        "thng 01",
        "thng 02",
        "thng 03",
        "thng 04",
        "thng 05",
        "thng 06",
        "thng 07",
        "thng 08",
        "thng 09",
        "thng 10",
        "thng 11",
        "thng 12"
    ]
};
const dayValues$3 = {
    narrow: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
    short: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
    abbreviated: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
    wide: [
        "Ch Nht",
        "Th Hai",
        "Th Ba",
        "Th T",
        "Th Nm",
        "Th Su",
        "Th By"
    ]
};
const dayPeriodValues$3 = {
    // narrow date period is extremely rare in Vietnamese
    // I used abbreviated form for noon, morning and afternoon
    // which are regconizable by Vietnamese, others cannot be any shorter
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "na m",
        noon: "tr",
        morning: "sg",
        afternoon: "ch",
        evening: "ti",
        night: "m"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "na m",
        noon: "tra",
        morning: "sng",
        afternoon: "chiu",
        evening: "ti",
        night: "m"
    },
    wide: {
        am: "SA",
        pm: "CH",
        midnight: "na m",
        noon: "tra",
        morning: "sng",
        afternoon: "chiu",
        evening: "ti",
        night: "m"
    }
};
const formattingDayPeriodValues$3 = {
    narrow: {
        am: "am",
        pm: "pm",
        midnight: "na m",
        noon: "tr",
        morning: "sg",
        afternoon: "ch",
        evening: "ti",
        night: "m"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "na m",
        noon: "tra",
        morning: "sng",
        afternoon: "chiu",
        evening: "ti",
        night: "m"
    },
    wide: {
        am: "SA",
        pm: "CH",
        midnight: "na m",
        noon: "gia tra",
        morning: "vo bui sng",
        afternoon: "vo bui chiu",
        evening: "vo bui ti",
        night: "vo ban m"
    }
};
const ordinalNumber$3 = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    const unit = options2?.unit;
    if (unit === "quarter") {
        switch (number2) {
            case 1:
                return "I";
            case 2:
                return "II";
            case 3:
                return "III";
            case 4:
                return "IV";
        }
    }
    else if (unit === "day") {
        switch (number2) {
            case 1:
                return "th 2";
            // meaning 2nd day but it's the first day of the week :D
            case 2:
                return "th 3";
            // meaning 3rd day
            case 3:
                return "th 4";
            // meaning 4th day and so on
            case 4:
                return "th 5";
            case 5:
                return "th 6";
            case 6:
                return "th 7";
            case 7:
                return "ch nht";
        }
    }
    else if (unit === "week") {
        if (number2 === 1) {
            return "th nht";
        }
        else {
            return "th " + number2;
        }
    }
    else if (unit === "dayOfYear") {
        if (number2 === 1) {
            return "u tin";
        }
        else {
            return "th " + number2;
        }
    }
    return String(number2);
};
const localize$3 = {
    ordinalNumber: ordinalNumber$3,
    era: buildLocalizeFn({
        values: eraValues$3,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$3,
        defaultWidth: "wide",
        formattingValues: formattingQuarterValues,
        defaultFormattingWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$3,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$3,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$3,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$3,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$3 = /^(\d+)/i;
const parseOrdinalNumberPattern$3 = /\d+/i;
const matchEraPatterns$3 = {
    narrow: /^(tcn|scn)/i,
    abbreviated: /^(trc CN|sau CN)/i,
    wide: /^(trc Cng Nguyn|sau Cng Nguyn)/i
};
const parseEraPatterns$3 = {
    any: [/^t/i, /^s/i]
};
const matchQuarterPatterns$3 = {
    narrow: /^([1234]|i{1,3}v?)/i,
    abbreviated: /^q([1234]|i{1,3}v?)/i,
    wide: /^qu ([1234]|i{1,3}v?)/i
};
const parseQuarterPatterns$3 = {
    any: [/(1|i)$/i, /(2|ii)$/i, /(3|iii)$/i, /(4|iv)$/i]
};
const matchMonthPatterns$3 = {
    // month number may contain leading 0, 'thg' prefix may have space, underscore or empty before number
    // note the order of '1' since it is a sub-string of '10', so must be lower priority
    narrow: /^(0?[2-9]|10|11|12|0?1)/i,
    // note the order of 'thg 1' since it is sub-string of 'thg 10', so must be lower priority
    abbreviated: /^thg[ _]?(0?[1-9](?!\d)|10|11|12)/i,
    // note the order of 'Mi' since it is sub-string of Mi Mt, so must be lower priority
    wide: /^thng ?(Mt|Hai|Ba|T|Nm|Su|By|Tm|Chn|Mi|Mi ?Mt|Mi ?Hai|0?[1-9](?!\d)|10|11|12)/i
};
const parseMonthPatterns$3 = {
    narrow: [
        /0?1$/i,
        /0?2/i,
        /3/,
        /4/,
        /5/,
        /6/,
        /7/,
        /8/,
        /9/,
        /10/,
        /11/,
        /12/
    ],
    abbreviated: [
        /^thg[ _]?0?1(?!\d)/i,
        /^thg[ _]?0?2/i,
        /^thg[ _]?0?3/i,
        /^thg[ _]?0?4/i,
        /^thg[ _]?0?5/i,
        /^thg[ _]?0?6/i,
        /^thg[ _]?0?7/i,
        /^thg[ _]?0?8/i,
        /^thg[ _]?0?9/i,
        /^thg[ _]?10/i,
        /^thg[ _]?11/i,
        /^thg[ _]?12/i
    ],
    wide: [
        /^thng ?(Mt|0?1(?!\d))/i,
        /^thng ?(Hai|0?2)/i,
        /^thng ?(Ba|0?3)/i,
        /^thng ?(T|0?4)/i,
        /^thng ?(Nm|0?5)/i,
        /^thng ?(Su|0?6)/i,
        /^thng ?(By|0?7)/i,
        /^thng ?(Tm|0?8)/i,
        /^thng ?(Chn|0?9)/i,
        /^thng ?(Mi|10)/i,
        /^thng ?(Mi ?Mt|11)/i,
        /^thng ?(Mi ?Hai|12)/i
    ]
};
const matchDayPatterns$3 = {
    narrow: /^(CN|T2|T3|T4|T5|T6|T7)/i,
    short: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
    abbreviated: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
    wide: /^(Ch ?Nht|Cha ?Nht|th ?Hai|th ?Ba|th ?T|th ?Nm|th ?Su|th ?By)/i
};
const parseDayPatterns$3 = {
    narrow: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
    short: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
    abbreviated: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
    wide: [/(Ch|Cha) ?Nht/i, /Hai/i, /Ba/i, /T/i, /Nm/i, /Su/i, /By/i]
};
const matchDayPeriodPatterns$3 = {
    narrow: /^(a|p|na m|tra|(gi) (sng|chiu|ti|m))/i,
    abbreviated: /^(am|pm|na m|tra|(gi) (sng|chiu|ti|m))/i,
    wide: /^(ch[^i]*|sa|na m|tra|(gi) (sng|chiu|ti|m))/i
};
const parseDayPeriodPatterns$3 = {
    any: {
        am: /^(a|sa)/i,
        pm: /^(p|ch[^i]*)/i,
        midnight: /na m/i,
        noon: /tra/i,
        morning: /sng/i,
        afternoon: /chiu/i,
        evening: /ti/i,
        night: /^m/i
    }
};
const match$3 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$3,
        parsePattern: parseOrdinalNumberPattern$3,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$3,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$3,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$3,
        defaultParseWidth: "wide"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$3,
        defaultParseWidth: "wide"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$3,
        defaultParseWidth: "any"
    })
};
const vi = {
    code: "vi",
    formatDistance: formatDistance$3,
    formatLong: formatLong$3,
    formatRelative: formatRelative$3,
    localize: localize$3,
    match: match$3,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale$2 = {
    lessThanXSeconds: {
        one: " 1 ",
        other: " {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: "",
    lessThanXMinutes: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$2 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$2[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats$2 = {
    full: "y''M''d'' EEEE",
    long: "y''M''d''",
    medium: "yyyy-MM-dd",
    short: "yy-MM-dd"
};
const timeFormats$2 = {
    full: "zzzz a h:mm:ss",
    long: "z a h:mm:ss",
    medium: "a h:mm:ss",
    short: "a h:mm"
};
const dateTimeFormats$2 = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$2 = {
    date: buildFormatLongFn({
        formats: dateFormats$2,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$2,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$2,
        defaultWidth: "full"
    })
};
function checkWeek(date, baseDate, options2) {
    const baseFormat = "eeee p";
    if (isSameWeek(date, baseDate, options2)) {
        return baseFormat;
    }
    else if (date.getTime() > baseDate.getTime()) {
        return "''" + baseFormat;
    }
    return "''" + baseFormat;
}
const formatRelativeLocale$2 = {
    lastWeek: checkWeek,
    // days before yesterday, maybe in this week or last week
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: checkWeek,
    // days after tomorrow, maybe in this week or next week
    other: "PP p"
};
const formatRelative$2 = (token, date, baseDate, options2) => {
    const format2 = formatRelativeLocale$2[token];
    if (typeof format2 === "function") {
        return format2(date, baseDate, options2);
    }
    return format2;
};
const eraValues$2 = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: ["", ""]
};
const quarterValues$2 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["", "", "", ""],
    wide: ["", "", "", ""]
};
const monthValues$2 = {
    narrow: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$2 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$2 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$2 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$2 = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    switch (options2?.unit) {
        case "date":
            return number2.toString() + "";
        case "hour":
            return number2.toString() + "";
        case "minute":
            return number2.toString() + "";
        case "second":
            return number2.toString() + "";
        default:
            return " " + number2.toString();
    }
};
const localize$2 = {
    ordinalNumber: ordinalNumber$2,
    era: buildLocalizeFn({
        values: eraValues$2,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$2,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$2,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$2,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$2,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$2,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$2 = /^(\s*)?\d+(|||)?/i;
const parseOrdinalNumberPattern$2 = /\d+/i;
const matchEraPatterns$2 = {
    narrow: /^()/i,
    abbreviated: /^()/i,
    wide: /^(|)/i
};
const parseEraPatterns$2 = {
    any: [/^()/i, /^()/i]
};
const matchQuarterPatterns$2 = {
    narrow: /^[1234]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i
};
const parseQuarterPatterns$2 = {
    any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns$2 = {
    narrow: /^(|||||||||[])/i,
    abbreviated: /^(|||||||||[]|\d|1[12])/i,
    wide: /^(|||||||||[])/i
};
const parseMonthPatterns$2 = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^(?!(|))/i,
        /^/i,
        /^/i
    ],
    any: [
        /^|1/i,
        /^|2/i,
        /^|3/i,
        /^|4/i,
        /^|5/i,
        /^|6/i,
        /^|7/i,
        /^|8/i,
        /^|9/i,
        /^(?!(|))|10/i,
        /^|11/i,
        /^|12/i
    ]
};
const matchDayPatterns$2 = {
    narrow: /^[]/i,
    short: /^[]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i
};
const parseDayPatterns$2 = {
    any: [//i, //i, //i, //i, //i, //i, //i]
};
const matchDayPeriodPatterns$2 = {
    any: /^(?|?||[]|?||?||)/i
};
const parseDayPeriodPatterns$2 = {
    any: {
        am: /^?/i,
        pm: /^?/i,
        midnight: /^/i,
        noon: /^[]/i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^?/i,
        night: /^/i
    }
};
const match$2 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$2,
        parsePattern: parseOrdinalNumberPattern$2,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$2,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$2,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$2,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$2,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$2,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$2,
        defaultParseWidth: "any"
    })
};
const zhCN = {
    code: "zh-CN",
    formatDistance: formatDistance$2,
    formatLong: formatLong$2,
    formatRelative: formatRelative$2,
    localize: localize$2,
    match: match$2,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const formatDistanceLocale$1 = {
    lessThanXSeconds: {
        one: " 1 ",
        other: " {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: "",
    lessThanXMinutes: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance$1 = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale$1[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats$1 = {
    full: "y''M''d'' EEEE",
    long: "y''M''d''",
    medium: "yyyy-MM-dd",
    short: "yy-MM-dd"
};
const timeFormats$1 = {
    full: "zzzz a h:mm:ss",
    long: "z a h:mm:ss",
    medium: "a h:mm:ss",
    short: "a h:mm"
};
const dateTimeFormats$1 = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong$1 = {
    date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: "full"
    })
};
const formatRelativeLocale$1 = {
    lastWeek: "''eeee p",
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: "''eeee p",
    other: "P"
};
const formatRelative$1 = (token, _date, _baseDate, _options) => formatRelativeLocale$1[token];
const eraValues$1 = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: ["", ""]
};
const quarterValues$1 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["", "", "", ""],
    wide: ["", "", "", ""]
};
const monthValues$1 = {
    narrow: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues$1 = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$1 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues$1 = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber$1 = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    switch (options2?.unit) {
        case "date":
            return number2 + "";
        case "hour":
            return number2 + "";
        case "minute":
            return number2 + "";
        case "second":
            return number2 + "";
        default:
            return " " + number2;
    }
};
const localize$1 = {
    ordinalNumber: ordinalNumber$1,
    era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern$1 = /^(\s*)?\d+(|||)?/i;
const parseOrdinalNumberPattern$1 = /\d+/i;
const matchEraPatterns$1 = {
    narrow: /^()/i,
    abbreviated: /^()/i,
    wide: /^(|)/i
};
const parseEraPatterns$1 = {
    any: [/^()/i, /^()/i]
};
const matchQuarterPatterns$1 = {
    narrow: /^[1234]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i
};
const parseQuarterPatterns$1 = {
    any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns$1 = {
    narrow: /^(|||||||||[])/i,
    abbreviated: /^(|||||||||[]|\d|1[12])/i,
    wide: /^(|||||||||[])/i
};
const parseMonthPatterns$1 = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^(?!(|))/i,
        /^/i,
        /^/i
    ],
    any: [
        /^|1/i,
        /^|2/i,
        /^|3/i,
        /^|4/i,
        /^|5/i,
        /^|6/i,
        /^|7/i,
        /^|8/i,
        /^|9/i,
        /^(?!(|))|10/i,
        /^|11/i,
        /^|12/i
    ]
};
const matchDayPatterns$1 = {
    narrow: /^[]/i,
    short: /^[]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i
};
const parseDayPatterns$1 = {
    any: [//i, //i, //i, //i, //i, //i, //i]
};
const matchDayPeriodPatterns$1 = {
    any: /^(?|?||[]|?||?|)/i
};
const parseDayPeriodPatterns$1 = {
    any: {
        am: /^?/i,
        pm: /^?/i,
        midnight: /^/i,
        noon: /^[]/i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^?/i,
        night: /^/i
    }
};
const match$1 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: "any"
    })
};
const zhHK = {
    code: "zh-HK",
    formatDistance: formatDistance$1,
    formatLong: formatLong$1,
    formatRelative: formatRelative$1,
    localize: localize$1,
    match: match$1,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const formatDistanceLocale = {
    lessThanXSeconds: {
        one: " 1 ",
        other: " {{count}} "
    },
    xSeconds: {
        one: "1 ",
        other: "{{count}} "
    },
    halfAMinute: "",
    lessThanXMinutes: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMinutes: {
        one: "1 ",
        other: "{{count}} "
    },
    xHours: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXHours: {
        one: " 1 ",
        other: " {{count}} "
    },
    xDays: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXWeeks: {
        one: " 1 ",
        other: " {{count}} "
    },
    xWeeks: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXMonths: {
        one: " 1 ",
        other: " {{count}} "
    },
    xMonths: {
        one: "1 ",
        other: "{{count}} "
    },
    aboutXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    xYears: {
        one: "1 ",
        other: "{{count}} "
    },
    overXYears: {
        one: " 1 ",
        other: " {{count}} "
    },
    almostXYears: {
        one: " 1 ",
        other: " {{count}} "
    }
};
const formatDistance = (token, count, options2) => {
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    }
    else if (count === 1) {
        result = tokenValue.one;
    }
    else {
        result = tokenValue.other.replace("{{count}}", String(count));
    }
    if (options2?.addSuffix) {
        if (options2.comparison && options2.comparison > 0) {
            return result + "";
        }
        else {
            return result + "";
        }
    }
    return result;
};
const dateFormats = {
    full: "y''M''d'' EEEE",
    long: "y''M''d''",
    medium: "yyyy-MM-dd",
    short: "yy-MM-dd"
};
const timeFormats = {
    full: "zzzz a h:mm:ss",
    long: "z a h:mm:ss",
    medium: "a h:mm:ss",
    short: "a h:mm"
};
const dateTimeFormats = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}"
};
const formatLong = {
    date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
    })
};
const formatRelativeLocale = {
    lastWeek: "''eeee p",
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: "''eeee p",
    other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
const eraValues = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: ["", ""]
};
const quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["", "", "", ""],
    wide: ["", "", "", ""]
};
const monthValues = {
    narrow: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    abbreviated: [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12"
    ],
    wide: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ]
};
const dayValues = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const formattingDayPeriodValues = {
    narrow: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
};
const ordinalNumber = (dirtyNumber, options2) => {
    const number2 = Number(dirtyNumber);
    switch (options2?.unit) {
        case "date":
            return number2 + "";
        case "hour":
            return number2 + "";
        case "minute":
            return number2 + "";
        case "second":
            return number2 + "";
        default:
            return " " + number2;
    }
};
const localize = {
    ordinalNumber,
    era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
    })
};
const matchOrdinalNumberPattern = /^(\s*)?\d+(|||)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
    narrow: /^()/i,
    abbreviated: /^()/i,
    wide: /^(|)/i
};
const parseEraPatterns = {
    any: [/^()/i, /^()/i]
};
const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i
};
const parseQuarterPatterns = {
    any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns = {
    narrow: /^(|||||||||[])/i,
    abbreviated: /^(|||||||||[]|\d|1[12])/i,
    wide: /^(|||||||||[])/i
};
const parseMonthPatterns = {
    narrow: [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^(?!(|))/i,
        /^/i,
        /^/i
    ],
    any: [
        /^|1/i,
        /^|2/i,
        /^|3/i,
        /^|4/i,
        /^|5/i,
        /^|6/i,
        /^|7/i,
        /^|8/i,
        /^|9/i,
        /^(?!(|))|10/i,
        /^|11/i,
        /^|12/i
    ]
};
const matchDayPatterns = {
    narrow: /^[]/i,
    short: /^[]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i
};
const parseDayPatterns = {
    any: [//i, //i, //i, //i, //i, //i, //i]
};
const matchDayPeriodPatterns = {
    any: /^(?|?||[]|?||?|)/i
};
const parseDayPeriodPatterns = {
    any: {
        am: /^?/i,
        pm: /^?/i,
        midnight: /^/i,
        noon: /^[]/i,
        morning: /^/i,
        afternoon: /^/i,
        evening: /^?/i,
        night: /^/i
    }
};
const match = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
    })
};
const zhTW = {
    code: "zh-TW",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
    }
};
const locales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    af,
    ar,
    arDZ,
    arEG,
    arMA,
    arSA,
    arTN,
    az,
    be,
    beTarask,
    bg,
    bn,
    bs,
    ca,
    ckb,
    cs,
    cy,
    da,
    de,
    deAT,
    el,
    enAU,
    enCA,
    enGB,
    enIE,
    enIN,
    enNZ,
    enUS,
    enZA,
    eo,
    es,
    et,
    eu,
    faIR,
    fi,
    fr,
    frCA,
    frCH,
    fy,
    gd,
    gl,
    gu,
    he,
    hi,
    hr,
    ht,
    hu,
    hy,
    id,
    is,
    it,
    itCH,
    ja,
    jaHira,
    ka,
    kk,
    km,
    kn,
    ko,
    lb,
    lt,
    lv,
    mk,
    mn,
    ms,
    mt,
    nb,
    nl: nl$2,
    nlBE,
    nn,
    oc,
    pl,
    pt,
    ptBR,
    ro,
    ru,
    se,
    sk,
    sl,
    sq,
    sr,
    srLatn,
    sv,
    ta,
    te,
    th,
    tr,
    ug,
    uk,
    uz,
    uzCyrl,
    vi,
    zhCN,
    zhHK,
    zhTW
}, Symbol.toStringTag, { value: "Module" }));
function getLocale(language) {
    if (!language || typeof language !== "string") {
        return enUS;
    }
    let localeKey = language.replace("-", "");
    if (localeKey in locales) {
        return locales[localeKey];
    }
    localeKey = language.replace("-", "").substring(0, 2);
    if (localeKey in locales) {
        return locales[localeKey];
    }
    return enUS;
}
async function getSheetValue(sheetName, cell) {
    const node2 = await getCell$1(sheetName, cell);
    return safeNumber(typeof node2.value === "number" ? node2.value : 0);
}
async function getSheetBoolean(sheetName, cell) {
    const node2 = await getCell$1(sheetName, cell);
    return typeof node2.value === "boolean" ? node2.value : false;
}
function calcBufferedAmount(toBudget, buffered, amount) {
    amount = Math.min(Math.max(amount, -buffered), Math.max(toBudget, 0));
    return buffered + amount;
}
function getBudgetTable() {
    return isReflectBudget() ? "reflect_budgets" : "zero_budgets";
}
function isReflectBudget() {
    const budgetType = firstSync(`SELECT value FROM preferences WHERE id = ?`, ["budgetType"]);
    const val2 = budgetType ? budgetType.value : "envelope";
    return val2 === "tracking";
}
function dbMonth(month) {
    return parseInt(month.replace("-", ""));
}
function getBudgetData(table, month) {
    return all(`
    SELECT b.*, c.is_income, c.hidden, g.hidden AS group_hidden
    FROM ${table} b
    LEFT JOIN categories c ON b.category = c.id
    LEFT JOIN category_groups g ON c.cat_group = g.id
    WHERE c.tombstone = 0 AND b.month = ?
  `, [month]);
}
function getAllMonths(startMonth) {
    const { createdMonths } = get$3().meta();
    let latest = null;
    for (const month of createdMonths) {
        if (latest == null || month > latest) {
            latest = month;
        }
    }
    return rangeInclusive(startMonth, latest);
}
function getBudget({ category, month }) {
    const table = getBudgetTable();
    const existing = firstSync(`SELECT * FROM ${table} WHERE month = ? AND category = ?`, [dbMonth(month), category]);
    return existing ? existing.amount || 0 : 0;
}
function setBudget({ category, month, amount }) {
    amount = safeNumber(typeof amount === "number" ? amount : 0);
    const table = getBudgetTable();
    const existing = firstSync(`SELECT id FROM ${table} WHERE month = ? AND category = ?`, [
        dbMonth(month),
        category
    ]);
    if (existing) {
        return update(table, { id: existing.id, amount });
    }
    return insert(table, {
        id: `${dbMonth(month)}-${category}`,
        month: dbMonth(month),
        category,
        amount
    });
}
function setGoal({ month, category, goal, long_goal }) {
    const table = getBudgetTable();
    const existing = firstSync(`SELECT id FROM ${table} WHERE month = ? AND category = ?`, [
        dbMonth(month),
        category
    ]);
    if (existing) {
        return update(table, {
            id: existing.id,
            goal,
            long_goal
        });
    }
    return insert(table, {
        id: `${dbMonth(month)}-${category}`,
        month: dbMonth(month),
        category,
        goal,
        long_goal
    });
}
function setBuffer(month, amount) {
    const existing = firstSync(`SELECT id FROM zero_budget_months WHERE id = ?`, [month]);
    if (existing) {
        return update("zero_budget_months", {
            id: existing.id,
            buffered: amount
        });
    }
    return insert("zero_budget_months", { id: month, buffered: amount });
}
function setCarryover(table, category, month, flag) {
    const existing = firstSync(`SELECT id FROM ${table} WHERE month = ? AND category = ?`, [
        month,
        category
    ]);
    if (existing) {
        return update(table, { id: existing.id, carryover: flag ? 1 : 0 });
    }
    return insert(table, {
        id: `${month}-${category}`,
        month,
        category,
        carryover: flag ? 1 : 0
    });
}
async function copyPreviousMonth({ month }) {
    const prevMonth$1 = dbMonth(prevMonth(month));
    const table = getBudgetTable();
    const budgetData = await getBudgetData(table, prevMonth$1.toString());
    await batchMessages(async () => {
        budgetData.forEach((prevBudget) => {
            if (prevBudget.is_income === 1 && !isReflectBudget()) {
                return;
            }
            if (prevBudget.hidden === 1 || prevBudget.group_hidden === 1) {
                return;
            }
            setBudget({
                category: prevBudget.category,
                month,
                amount: prevBudget.amount
            });
        });
    });
}
async function copySinglePreviousMonth({ month, category }) {
    const prevMonth$1 = prevMonth(month);
    const newAmount = await getSheetValue(sheetForMonth(prevMonth$1), "budget-" + category);
    await batchMessages(async () => {
        setBudget({ category, month, amount: newAmount });
    });
}
async function setZero({ month }) {
    const categories = await all("SELECT * FROM v_categories WHERE tombstone = 0");
    await batchMessages(async () => {
        categories.forEach((cat) => {
            if (cat.is_income === 1 && !isReflectBudget()) {
                return;
            }
            setBudget({ category: cat.id, month, amount: 0 });
        });
    });
}
async function set3MonthAvg({ month }) {
    const categories = await all(`
  SELECT c.*
  FROM categories c
  LEFT JOIN category_groups g ON c.cat_group = g.id
  WHERE c.tombstone = 0 AND c.hidden = 0 AND g.hidden = 0
  `);
    const prevMonth1 = prevMonth(month);
    const prevMonth2 = prevMonth(prevMonth1);
    const prevMonth3 = prevMonth(prevMonth2);
    await batchMessages(async () => {
        for (const cat of categories) {
            if (cat.is_income === 1 && !isReflectBudget()) {
                continue;
            }
            const spent1 = await getSheetValue(sheetForMonth(prevMonth1), "sum-amount-" + cat.id);
            const spent2 = await getSheetValue(sheetForMonth(prevMonth2), "sum-amount-" + cat.id);
            const spent3 = await getSheetValue(sheetForMonth(prevMonth3), "sum-amount-" + cat.id);
            let avg = Math.round((spent1 + spent2 + spent3) / 3);
            if (cat.is_income === 0) {
                avg *= -1;
            }
            setBudget({ category: cat.id, month, amount: avg });
        }
    });
}
async function set12MonthAvg({ month }) {
    const categories = await all(`
  SELECT c.*
  FROM categories c
  LEFT JOIN category_groups g ON c.cat_group = g.id
  WHERE c.tombstone = 0 AND c.hidden = 0 AND g.hidden = 0
  `);
    await batchMessages(async () => {
        for (const cat of categories) {
            if (cat.is_income === 1 && !isReflectBudget()) {
                continue;
            }
            setNMonthAvg({ month, N: 12, category: cat.id });
        }
    });
}
async function set6MonthAvg({ month }) {
    const categories = await all(`
  SELECT c.*
  FROM categories c
  LEFT JOIN category_groups g ON c.cat_group = g.id
  WHERE c.tombstone = 0 AND c.hidden = 0 AND g.hidden = 0
  `);
    await batchMessages(async () => {
        for (const cat of categories) {
            if (cat.is_income === 1 && !isReflectBudget()) {
                continue;
            }
            setNMonthAvg({ month, N: 6, category: cat.id });
        }
    });
}
async function setNMonthAvg({ month, N, category }) {
    const categoryFromDb = await first("SELECT is_income FROM v_categories WHERE id = ?", [category]);
    let prevMonth$1 = prevMonth(month);
    let sumAmount = 0;
    for (let l = 0; l < N; l++) {
        sumAmount += await getSheetValue(sheetForMonth(prevMonth$1), "sum-amount-" + category);
        prevMonth$1 = prevMonth(prevMonth$1);
    }
    await batchMessages(async () => {
        let avg = Math.round(sumAmount / N);
        if (categoryFromDb.is_income === 0) {
            avg *= -1;
        }
        setBudget({ category, month, amount: avg });
    });
}
async function holdForNextMonth({ month, amount }) {
    const row = await first("SELECT buffered FROM zero_budget_months WHERE id = ?", [month]);
    const sheetName = sheetForMonth(month);
    const toBudget = await getSheetValue(sheetName, "to-budget");
    if (toBudget > 0) {
        const bufferedAmount = calcBufferedAmount(toBudget, row && row.buffered || 0, amount);
        await setBuffer(month, bufferedAmount);
        return true;
    }
    return false;
}
async function resetHold({ month }) {
    await setBuffer(month, 0);
}
async function coverOverspending({ month, to, from }) {
    const sheetName = sheetForMonth(month);
    const toBudgeted = await getSheetValue(sheetName, "budget-" + to);
    const leftover = await getSheetValue(sheetName, "leftover-" + to);
    const leftoverFrom = await getSheetValue(sheetName, from === "to-budget" ? "to-budget" : "leftover-" + from);
    if (leftover >= 0 || leftoverFrom <= 0) {
        return;
    }
    const amountCovered = Math.min(-leftover, leftoverFrom);
    if (from !== "to-budget") {
        const fromBudgeted = await getSheetValue(sheetName, "budget-" + from);
        await setBudget({
            category: from,
            month,
            amount: fromBudgeted - amountCovered
        });
    }
    await batchMessages(async () => {
        await setBudget({
            category: to,
            month,
            amount: toBudgeted + amountCovered
        });
        await addMovementNotes({
            month,
            amount: amountCovered,
            to,
            from
        });
    });
}
async function transferAvailable({ month, amount, category }) {
    const sheetName = sheetForMonth(month);
    const leftover = await getSheetValue(sheetName, "to-budget");
    amount = Math.max(Math.min(amount, leftover), 0);
    const budgeted = await getSheetValue(sheetName, "budget-" + category);
    await setBudget({ category, month, amount: budgeted + amount });
}
async function coverOverbudgeted({ month, category }) {
    const sheetName = sheetForMonth(month);
    const toBudget = await getSheetValue(sheetName, "to-budget");
    const categoryBudget = await getSheetValue(sheetName, "budget-" + category);
    await batchMessages(async () => {
        await setBudget({ category, month, amount: categoryBudget + toBudget });
        await addMovementNotes({
            month,
            amount: -toBudget,
            from: category,
            to: "overbudgeted"
        });
    });
}
async function transferCategory({ month, amount, from, to }) {
    const sheetName = sheetForMonth(month);
    const fromBudgeted = await getSheetValue(sheetName, "budget-" + from);
    await batchMessages(async () => {
        await setBudget({ category: from, month, amount: fromBudgeted - amount });
        if (to !== "to-budget") {
            const toBudgeted = await getSheetValue(sheetName, "budget-" + to);
            await setBudget({ category: to, month, amount: toBudgeted + amount });
        }
        await addMovementNotes({
            month,
            amount,
            to,
            from
        });
    });
}
async function setCategoryCarryover({ startMonth, category, flag }) {
    const table = getBudgetTable();
    const months = getAllMonths(startMonth);
    await batchMessages(async () => {
        for (const month of months) {
            setCarryover(table, category, dbMonth(month).toString(), flag);
        }
    });
}
function addNewLine(notes) {
    return !notes ? "" : `${notes}${notes && "\n"}`;
}
async function addMovementNotes({ month, amount, to, from }) {
    const displayAmount = integerToCurrency(amount);
    const monthBudgetNotesId = `budget-${month}`;
    const existingMonthBudgetNotes = addNewLine(firstSync(`SELECT n.note FROM notes n WHERE n.id = ?`, [monthBudgetNotesId])?.note);
    const locale = getLocale(await getItem("language"));
    const displayDay = format(currentDate(), "MMMM dd", locale);
    const categories = await getCategories$3([from, to].filter((c) => c !== "to-budget" && c !== "overbudgeted"));
    const fromCategoryName = from === "to-budget" ? "To Budget" : categories.find((c) => c.id === from)?.name;
    const toCategoryName = to === "to-budget" ? "To Budget" : to === "overbudgeted" ? "Overbudgeted" : categories.find((c) => c.id === to)?.name;
    const note = `Reassigned ${displayAmount} from ${fromCategoryName}  ${toCategoryName} on ${displayDay}`;
    await update("notes", {
        id: monthBudgetNotesId,
        note: `${existingMonthBudgetNotes}- ${note}`
    });
}
async function resetIncomeCarryover({ month }) {
    const table = getBudgetTable();
    const categories = await all("SELECT * FROM v_categories WHERE is_income = 1 AND tombstone = 0");
    await batchMessages(async () => {
        for (const category of categories) {
            await setCarryover(table, category.id, dbMonth(month).toString(), false);
        }
    });
}
function number$1(v) {
    if (typeof v === "number") {
        return v;
    }
    else if (typeof v === "string") {
        const parsed = parseFloat(v);
        if (isNaN(parsed)) {
            return 0;
        }
        return parsed;
    }
    return 0;
}
function sumAmounts(...amounts) {
    return safeNumber(amounts.reduce((total, amount) => {
        return total + number$1(amount);
    }, 0));
}
function flatten2(arr) {
    return Array.prototype.concat.apply([], arr);
}
function unflatten2(arr) {
    const res = [];
    for (let i = 0; i < arr.length; i += 2) {
        res.push([arr[i], arr[i + 1]]);
    }
    return res;
}
function getBlankSheet(months) {
    const blankMonth = prevMonth(months[0]);
    return sheetForMonth(blankMonth);
}
function createBlankCategory(cat, months) {
    if (months.length > 0) {
        const sheetName = getBlankSheet(months);
        get$3().createStatic(sheetName, `carryover-${cat.id}`, false);
        get$3().createStatic(sheetName, `leftover-${cat.id}`, 0);
        get$3().createStatic(sheetName, `leftover-pos-${cat.id}`, 0);
    }
}
function createBlankMonth(categories, sheetName, months) {
    get$3().createStatic(sheetName, "is-blank", true);
    get$3().createStatic(sheetName, "to-budget", 0);
    get$3().createStatic(sheetName, "buffered", 0);
    categories.forEach((cat) => createBlankCategory(cat, months));
}
function createCategory$4(cat, sheetName, prevSheetName) {
    if (!cat.is_income) {
        get$3().createStatic(sheetName, `budget-${cat.id}`, 0);
        if (get$3().getCellValue(sheetName, `budget-${cat.id}`) == null) {
            get$3().set(resolveName(sheetName, `budget-${cat.id}`), 0);
        }
        get$3().createStatic(sheetName, `carryover-${cat.id}`, false);
        get$3().createDynamic(sheetName, `leftover-${cat.id}`, {
            initialValue: 0,
            dependencies: [
                `budget-${cat.id}`,
                `sum-amount-${cat.id}`,
                `${prevSheetName}!carryover-${cat.id}`,
                `${prevSheetName}!leftover-${cat.id}`,
                `${prevSheetName}!leftover-pos-${cat.id}`
            ],
            run: (budgeted, spent, prevCarryover, prevLeftover, prevLeftoverPos) => {
                return safeNumber(number$1(budgeted) + number$1(spent) + (prevCarryover ? number$1(prevLeftover) : number$1(prevLeftoverPos)));
            }
        });
        get$3().createDynamic(sheetName, "leftover-pos-" + cat.id, {
            initialValue: 0,
            dependencies: [`leftover-${cat.id}`],
            run: (leftover) => {
                return leftover < 0 ? 0 : leftover;
            }
        });
    }
}
function createCategoryGroup$3(group, sheetName) {
    get$3().createDynamic(sheetName, "group-sum-amount-" + group.id, {
        initialValue: 0,
        dependencies: group.categories.map((cat) => `sum-amount-${cat.id}`),
        run: sumAmounts
    });
    if (!group.is_income) {
        get$3().createDynamic(sheetName, "group-budget-" + group.id, {
            initialValue: 0,
            dependencies: group.categories.map((cat) => `budget-${cat.id}`),
            run: sumAmounts
        });
        get$3().createDynamic(sheetName, "group-leftover-" + group.id, {
            initialValue: 0,
            dependencies: group.categories.map((cat) => `leftover-${cat.id}`),
            run: sumAmounts
        });
    }
}
function createSummary$1(groups, categories, prevSheetName, sheetName) {
    const incomeGroup = groups.filter((group) => group.is_income)[0];
    const expenseCategories = categories.filter((cat) => !cat.is_income);
    const incomeCategories = categories.filter((cat) => cat.is_income);
    get$3().createStatic(sheetName, "buffered", 0);
    get$3().createDynamic(sheetName, "from-last-month", {
        initialValue: 0,
        dependencies: [
            `${prevSheetName}!to-budget`,
            `${prevSheetName}!buffered-selected`
        ],
        run: (toBudget, buffered) => safeNumber(number$1(toBudget) + number$1(buffered))
    });
    get$3().createDynamic(sheetName, "total-income", {
        initialValue: 0,
        dependencies: [`group-sum-amount-${incomeGroup.id}`],
        run: (amount) => amount
    });
    get$3().createDynamic(sheetName, "available-funds", {
        initialValue: 0,
        dependencies: ["total-income", "from-last-month"],
        run: (income, fromLastMonth) => safeNumber(number$1(income) + number$1(fromLastMonth))
    });
    get$3().createDynamic(sheetName, "last-month-overspent", {
        initialValue: 0,
        dependencies: flatten2(expenseCategories.map((cat) => [
            `${prevSheetName}!leftover-${cat.id}`,
            `${prevSheetName}!carryover-${cat.id}`
        ])),
        run: (...data) => {
            data = unflatten2(data);
            return safeNumber(data.reduce((total, [leftover, carryover]) => {
                if (carryover) {
                    return total;
                }
                return total + Math.min(0, number$1(leftover));
            }, 0));
        }
    });
    get$3().createDynamic(sheetName, "total-budgeted", {
        initialValue: 0,
        dependencies: groups.filter((group) => !group.is_income).map((group) => `group-budget-${group.id}`),
        run: (...amounts) => {
            return -sumAmounts(...amounts);
        }
    });
    get$3().createDynamic(sheetName, "buffered", { initialValue: 0 });
    get$3().createDynamic(sheetName, "buffered-auto", {
        initialValue: 0,
        dependencies: flatten2(incomeCategories.map((c) => [
            `${sheetName}!sum-amount-${c.id}`,
            `${sheetName}!carryover-${c.id}`
        ])),
        run: (...data) => {
            data = unflatten2(data);
            return safeNumber(data.reduce((total, [sumAmount, carryover]) => {
                if (carryover) {
                    return total + sumAmount;
                }
                return total;
            }, 0));
        }
    });
    get$3().createDynamic(sheetName, "buffered-selected", {
        initialValue: 0,
        dependencies: [`${sheetName}!buffered`, `${sheetName}!buffered-auto`],
        run: (man, auto) => {
            if (man !== 0) {
                return man;
            }
            return auto;
        }
    });
    get$3().createDynamic(sheetName, "to-budget", {
        initialValue: 0,
        dependencies: [
            "available-funds",
            "last-month-overspent",
            "total-budgeted",
            "buffered-selected"
        ],
        run: (available, lastOverspent, totalBudgeted, buffered) => {
            return safeNumber(number$1(available) + number$1(lastOverspent) + number$1(totalBudgeted) - number$1(buffered));
        }
    });
    get$3().createDynamic(sheetName, "total-spent", {
        initialValue: 0,
        dependencies: groups.filter((group) => !group.is_income).map((group) => `group-sum-amount-${group.id}`),
        run: sumAmounts
    });
    get$3().createDynamic(sheetName, "total-leftover", {
        initialValue: 0,
        dependencies: groups.filter((group) => !group.is_income).map((group) => `group-leftover-${group.id}`),
        run: sumAmounts
    });
}
function createBudget$3(meta, categories, months) {
    const blankSheet = getBlankSheet(months);
    if (meta.blankSheet !== blankSheet) {
        get$3().clearSheet(meta.blankSheet);
        createBlankMonth(categories, blankSheet, months);
        meta.blankSheet = blankSheet;
    }
}
function handleCategoryChange$1(months, oldValue, newValue) {
    function addDeps(sheetName, groupId, catId) {
        get$3().addDependencies(sheetName, `group-sum-amount-${groupId}`, [
            `sum-amount-${catId}`
        ]);
        get$3().addDependencies(sheetName, `group-budget-${groupId}`, [
            `budget-${catId}`
        ]);
        get$3().addDependencies(sheetName, `group-leftover-${groupId}`, [
            `leftover-${catId}`
        ]);
    }
    function removeDeps(sheetName, groupId, catId) {
        get$3().removeDependencies(sheetName, `group-sum-amount-${groupId}`, [
            `sum-amount-${catId}`
        ]);
        get$3().removeDependencies(sheetName, `group-budget-${groupId}`, [
            `budget-${catId}`
        ]);
        get$3().removeDependencies(sheetName, `group-leftover-${groupId}`, [
            `leftover-${catId}`
        ]);
    }
    if (oldValue && oldValue.tombstone === 0 && newValue.tombstone === 1) {
        const id2 = newValue.id;
        const groupId = newValue.cat_group;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            removeDeps(sheetName, groupId, id2);
        });
    }
    else if (newValue.tombstone === 0 && (!oldValue || oldValue.tombstone === 1)) {
        createBlankCategory(newValue, months);
        months.forEach((month) => {
            const prevMonth$1 = prevMonth(month);
            const prevSheetName = sheetForMonth(prevMonth$1);
            const sheetName = sheetForMonth(month);
            const { start, end } = bounds(month);
            createCategory$2(newValue, sheetName, prevSheetName, start, end);
            const id2 = newValue.id;
            const groupId = newValue.cat_group;
            get$3().addDependencies(sheetName, "last-month-overspent", [
                `${prevSheetName}!leftover-${id2}`,
                `${prevSheetName}!carryover-${id2}`
            ]);
            addDeps(sheetName, groupId, id2);
            if (newValue.is_income) {
                get$3().addDependencies(sheetName, "buffered-auto", flatten2([
                    `${sheetName}!sum-amount-${id2}`,
                    `${sheetName}!carryover-${id2}`
                ]));
            }
        });
    }
    else if (oldValue && oldValue.cat_group !== newValue.cat_group) {
        const id2 = newValue.id;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            removeDeps(sheetName, oldValue.cat_group, id2);
            addDeps(sheetName, newValue.cat_group, id2);
        });
    }
}
function handleCategoryGroupChange$1(months, oldValue, newValue) {
    function addDeps(sheetName, groupId) {
        get$3().addDependencies(sheetName, "total-budgeted", [
            `group-budget-${groupId}`
        ]);
        get$3().addDependencies(sheetName, "total-spent", [
            `group-sum-amount-${groupId}`
        ]);
        get$3().addDependencies(sheetName, "total-leftover", [
            `group-leftover-${groupId}`
        ]);
    }
    function removeDeps(sheetName, groupId) {
        get$3().removeDependencies(sheetName, "total-budgeted", [
            `group-budget-${groupId}`
        ]);
        get$3().removeDependencies(sheetName, "total-spent", [
            `group-sum-amount-${groupId}`
        ]);
        get$3().removeDependencies(sheetName, "total-leftover", [
            `group-leftover-${groupId}`
        ]);
    }
    if (newValue.tombstone === 1 && oldValue && oldValue.tombstone === 0) {
        const id2 = newValue.id;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            removeDeps(sheetName, id2);
        });
    }
    else if (newValue.tombstone === 0 && (!oldValue || oldValue.tombstone === 1)) {
        const group = newValue;
        if (!group.is_income) {
            months.forEach((month) => {
                const sheetName = sheetForMonth(month);
                const categories = runQuery("SELECT * FROM categories WHERE tombstone = 0 AND cat_group = ?", [group.id], true);
                createCategoryGroup$3({ ...group, categories }, sheetName);
                addDeps(sheetName, group.id);
            });
        }
    }
}
async function createCategory$3(cat, sheetName, prevSheetName) {
    get$3().createStatic(sheetName, `budget-${cat.id}`, 0);
    if (get$3().getCellValue(sheetName, `budget-${cat.id}`) == null) {
        get$3().set(resolveName(sheetName, `budget-${cat.id}`), 0);
    }
    get$3().createDynamic(sheetName, `leftover-${cat.id}`, {
        initialValue: 0,
        dependencies: [
            `budget-${cat.id}`,
            `sum-amount-${cat.id}`,
            `${prevSheetName}!carryover-${cat.id}`,
            `${prevSheetName}!leftover-${cat.id}`
        ],
        run: (budgeted, sumAmount, prevCarryover, prevLeftover) => {
            if (cat.is_income) {
                return safeNumber(number$1(budgeted) - number$1(sumAmount) + (prevCarryover ? number$1(prevLeftover) : 0));
            }
            return safeNumber(number$1(budgeted) + number$1(sumAmount) + (prevCarryover ? number$1(prevLeftover) : 0));
        }
    });
    get$3().createDynamic(sheetName, `spent-with-carryover-${cat.id}`, {
        initialValue: 0,
        dependencies: [
            `budget-${cat.id}`,
            `sum-amount-${cat.id}`,
            `carryover-${cat.id}`
        ],
        // TODO: Why refresh??
        refresh: true,
        run: (budgeted, sumAmount, carryover) => {
            return carryover ? Math.max(0, safeNumber(number$1(budgeted) + number$1(sumAmount))) : sumAmount;
        }
    });
    get$3().createStatic(sheetName, `carryover-${cat.id}`, false);
}
function createCategoryGroup$2(group, sheetName) {
    get$3().createDynamic(sheetName, "group-sum-amount-" + group.id, {
        initialValue: 0,
        dependencies: group.categories.filter((cat) => !cat.hidden).map((cat) => `sum-amount-${cat.id}`),
        run: sumAmounts
    });
    get$3().createDynamic(sheetName, "group-budget-" + group.id, {
        initialValue: 0,
        dependencies: group.categories.filter((cat) => !cat.hidden).map((cat) => `budget-${cat.id}`),
        run: sumAmounts
    });
    get$3().createDynamic(sheetName, "group-leftover-" + group.id, {
        initialValue: 0,
        dependencies: group.categories.filter((cat) => !cat.hidden).map((cat) => `leftover-${cat.id}`),
        run: sumAmounts
    });
}
function createSummary(groups, sheetName) {
    const incomeGroup = groups.filter((group) => group.is_income)[0];
    const expenseGroups = groups.filter((group) => !group.is_income && !group.hidden);
    get$3().createDynamic(sheetName, "total-budgeted", {
        initialValue: 0,
        dependencies: expenseGroups.map((group) => `group-budget-${group.id}`),
        run: sumAmounts
    });
    get$3().createDynamic(sheetName, "total-spent", {
        initialValue: 0,
        refresh: true,
        dependencies: expenseGroups.map((group) => `group-sum-amount-${group.id}`),
        run: sumAmounts
    });
    get$3().createDynamic(sheetName, "total-income", {
        initialValue: 0,
        dependencies: [`group-sum-amount-${incomeGroup.id}`],
        run: (amount) => amount
    });
    get$3().createDynamic(sheetName, "total-leftover", {
        initialValue: 0,
        dependencies: expenseGroups.map((g) => `group-leftover-${g.id}`),
        run: sumAmounts
    });
    get$3().createDynamic(sheetName, "total-budget-income", {
        initialValue: 0,
        dependencies: [`group-budget-${incomeGroup.id}`],
        run: (amount) => amount
    });
    get$3().createDynamic(sheetName, "total-saved", {
        initialValue: 0,
        dependencies: ["total-budget-income", "total-budgeted"],
        run: (income, budgeted) => {
            return income - budgeted;
        }
    });
    get$3().createDynamic(sheetName, "real-saved", {
        initialValue: 0,
        dependencies: ["total-income", "total-spent"],
        run: (income, spent) => {
            return safeNumber(income - -spent);
        }
    });
}
function handleCategoryChange(months, oldValue, newValue) {
    function addDeps(sheetName, groupId, catId) {
        get$3().addDependencies(sheetName, `group-sum-amount-${groupId}`, [
            `sum-amount-${catId}`
        ]);
        get$3().addDependencies(sheetName, `group-budget-${groupId}`, [
            `budget-${catId}`
        ]);
        get$3().addDependencies(sheetName, `group-leftover-${groupId}`, [
            `leftover-${catId}`
        ]);
    }
    function removeDeps(sheetName, groupId, catId) {
        get$3().removeDependencies(sheetName, `group-sum-amount-${groupId}`, [
            `sum-amount-${catId}`
        ]);
        get$3().removeDependencies(sheetName, `group-budget-${groupId}`, [
            `budget-${catId}`
        ]);
        get$3().removeDependencies(sheetName, `group-leftover-${groupId}`, [
            `leftover-${catId}`
        ]);
    }
    if (oldValue && oldValue.tombstone === 0 && newValue.tombstone === 1) {
        const id2 = newValue.id;
        const groupId = newValue.cat_group;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            removeDeps(sheetName, groupId, id2);
        });
    }
    else if (newValue.tombstone === 0 && (!oldValue || oldValue.tombstone === 1)) {
        months.forEach((month) => {
            const prevMonth$1 = prevMonth(month);
            const prevSheetName = sheetForMonth(prevMonth$1);
            const sheetName = sheetForMonth(month);
            const { start, end } = bounds(month);
            createCategory$2(newValue, sheetName, prevSheetName, start, end);
            const id2 = newValue.id;
            const groupId = newValue.cat_group;
            addDeps(sheetName, groupId, id2);
        });
    }
    else if (oldValue && oldValue.cat_group !== newValue.cat_group) {
        const id2 = newValue.id;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            removeDeps(sheetName, oldValue.cat_group, id2);
            addDeps(sheetName, newValue.cat_group, id2);
        });
    }
    else if (oldValue && oldValue.hidden !== newValue.hidden) {
        const id2 = newValue.id;
        const groupId = newValue.cat_group;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            if (newValue.hidden) {
                removeDeps(sheetName, groupId, id2);
            }
            else {
                addDeps(sheetName, groupId, id2);
            }
        });
    }
}
function handleCategoryGroupChange(months, oldValue, newValue) {
    function addDeps(sheetName, groupId) {
        get$3().addDependencies(sheetName, "total-budgeted", [
            `group-budget-${groupId}`
        ]);
        get$3().addDependencies(sheetName, "total-spent", [
            `group-sum-amount-${groupId}`
        ]);
        get$3().addDependencies(sheetName, "total-leftover", [
            `group-leftover-${groupId}`
        ]);
    }
    function removeDeps(sheetName, groupId) {
        get$3().removeDependencies(sheetName, "total-budgeted", [
            `group-budget-${groupId}`
        ]);
        get$3().removeDependencies(sheetName, "total-spent", [
            `group-sum-amount-${groupId}`
        ]);
        get$3().removeDependencies(sheetName, "total-leftover", [
            `group-leftover-${groupId}`
        ]);
    }
    if (newValue.tombstone === 1 && oldValue && oldValue.tombstone === 0) {
        const id2 = newValue.id;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            removeDeps(sheetName, id2);
        });
    }
    else if (newValue.tombstone === 0 && (!oldValue || oldValue.tombstone === 1)) {
        const group = newValue;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            const categories = runQuery("SELECT * FROM categories WHERE tombstone = 0 AND cat_group = ?", [group.id], true);
            createCategoryGroup$2({ ...group, categories }, sheetName);
            addDeps(sheetName, group.id);
        });
    }
    else if (oldValue && oldValue.hidden !== newValue.hidden) {
        const group = newValue;
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            if (newValue.hidden) {
                removeDeps(sheetName, group.id);
            }
            else {
                addDeps(sheetName, group.id);
            }
        });
    }
}
function getBudgetType() {
    const meta = get$3().meta();
    return meta.budgetType || "envelope";
}
function getBudgetRange(start, end) {
    start = getMonth(start);
    end = getMonth(end);
    if (start > end) {
        start = end;
    }
    start = subMonths(start, 3);
    end = addMonths(end, 12);
    return { start, end, range: rangeInclusive(start, end) };
}
function createCategory$2(cat, sheetName, prevSheetName, start, end) {
    get$3().createDynamic(sheetName, "sum-amount-" + cat.id, {
        initialValue: 0,
        run: () => {
            const rows = runQuery(`SELECT SUM(amount) as amount FROM v_transactions_internal_alive t
           LEFT JOIN accounts a ON a.id = t.account
         WHERE t.date >= ${start} AND t.date <= ${end}
           AND category = '${cat.id}' AND a.offbudget = 0`, [], true);
            const row = rows[0];
            const amount = row ? row.amount : 0;
            return amount || 0;
        }
    });
    if (getBudgetType() === "envelope") {
        createCategory$4(cat, sheetName, prevSheetName);
    }
    else {
        createCategory$3(cat, sheetName, prevSheetName);
    }
}
function handleAccountChange(months, oldValue, newValue) {
    if (!oldValue || oldValue.offbudget !== newValue.offbudget) {
        const rows = runQuery(`
        SELECT DISTINCT(category) as category FROM transactions
        WHERE acct = ?
      `, [newValue.id], true);
        months.forEach((month) => {
            const sheetName = sheetForMonth(month);
            rows.forEach((row) => {
                get$3().recompute(resolveName(sheetName, "sum-amount-" + row.category));
            });
        });
    }
}
function handleTransactionChange(transaction2, changedFields) {
    if ((changedFields.has("date") || changedFields.has("acct") || changedFields.has("amount") || changedFields.has("category") || changedFields.has("tombstone") || changedFields.has("isParent")) && transaction2.date && transaction2.category) {
        const month = monthFromDate(fromDateRepr(transaction2.date));
        const sheetName = sheetForMonth(month);
        get$3().recompute(resolveName(sheetName, "sum-amount-" + transaction2.category));
    }
}
function handleCategoryMappingChange(months, oldValue, newValue) {
    months.forEach((month) => {
        const sheetName = sheetForMonth(month);
        if (oldValue) {
            get$3().recompute(resolveName(sheetName, "sum-amount-" + oldValue.transferId));
        }
        get$3().recompute(resolveName(sheetName, "sum-amount-" + newValue.transferId));
    });
}
function handleBudgetMonthChange(budget) {
    const sheetName = sheetForMonth(budget.id);
    get$3().set(`${sheetName}!buffered`, budget.buffered);
}
function handleBudgetChange(budget) {
    if (budget.category) {
        const sheetName = sheetForMonth(budget.month.toString());
        get$3().set(`${sheetName}!budget-${budget.category}`, budget.amount || 0);
        get$3().set(`${sheetName}!carryover-${budget.category}`, budget.carryover === 1 ? true : false);
        get$3().set(`${sheetName}!goal-${budget.category}`, budget.goal);
        get$3().set(`${sheetName}!long-goal-${budget.category}`, budget.long_goal);
    }
}
function triggerBudgetChanges(oldValues, newValues) {
    const { createdMonths = /* @__PURE__ */ new Set() } = get$3().meta();
    const budgetType = getBudgetType();
    startTransaction();
    try {
        newValues.forEach((items, table) => {
            const old = oldValues.get(table);
            items.forEach((newValue) => {
                const oldValue = old && old.get(newValue.id);
                if (table === "zero_budget_months") {
                    handleBudgetMonthChange(newValue);
                }
                else if (table === "zero_budgets" || table === "reflect_budgets") {
                    handleBudgetChange(newValue);
                }
                else if (table === "transactions") {
                    const changed = new Set(Object.keys(getChangedValues(oldValue || {}, newValue) || {}));
                    if (oldValue) {
                        handleTransactionChange(oldValue, changed);
                    }
                    handleTransactionChange(newValue, changed);
                }
                else if (table === "category_mapping") {
                    handleCategoryMappingChange(createdMonths, oldValue, newValue);
                }
                else if (table === "categories") {
                    if (budgetType === "envelope") {
                        handleCategoryChange$1(createdMonths, oldValue, newValue);
                    }
                    else {
                        handleCategoryChange(createdMonths, oldValue, newValue);
                    }
                }
                else if (table === "category_groups") {
                    if (budgetType === "envelope") {
                        handleCategoryGroupChange$1(createdMonths, oldValue, newValue);
                    }
                    else {
                        handleCategoryGroupChange(createdMonths, oldValue, newValue);
                    }
                }
                else if (table === "accounts") {
                    handleAccountChange(createdMonths, oldValue, newValue);
                }
            });
        });
    }
    finally {
        endTransaction();
    }
}
async function doTransfer(categoryIds, transferId) {
    const { createdMonths: months } = get$3().meta();
    [...months].forEach((month) => {
        const totalValue = categoryIds.map((id2) => {
            return getBudget({ month, category: id2 });
        }).reduce((total, value) => total + value, 0);
        const transferValue = getBudget({
            month,
            category: transferId
        });
        setBudget({
            month,
            category: transferId,
            amount: totalValue + transferValue
        });
    });
}
async function createBudget$2(months) {
    const { data: groups } = await aqlQuery(q("category_groups").select("*"));
    const categories = groups.flatMap((group) => group.categories);
    startTransaction();
    const meta = get$3().meta();
    meta.createdMonths = meta.createdMonths || /* @__PURE__ */ new Set();
    const budgetType = getBudgetType();
    if (budgetType === "envelope") {
        createBudget$3(meta, categories, months);
    }
    months.forEach((month) => {
        if (!meta.createdMonths.has(month)) {
            const prevMonth$1 = prevMonth(month);
            const { start, end } = bounds(month);
            const sheetName = sheetForMonth(month);
            const prevSheetName = sheetForMonth(prevMonth$1);
            categories.forEach((cat) => {
                createCategory$2(cat, sheetName, prevSheetName, start, end);
            });
            groups.forEach((group) => {
                if (budgetType === "envelope") {
                    createCategoryGroup$3(group, sheetName);
                }
                else {
                    createCategoryGroup$2(group, sheetName);
                }
            });
            if (budgetType === "envelope") {
                createSummary$1(groups, categories, prevSheetName, sheetName);
            }
            else {
                createSummary(groups, sheetName);
            }
            meta.createdMonths.add(month);
        }
    });
    get$3().setMeta(meta);
    endTransaction();
    await waitOnSpreadsheet();
}
async function createAllBudgets() {
    const earliestTransaction = await first("SELECT * FROM transactions WHERE isChild=0 AND date IS NOT NULL ORDER BY date ASC LIMIT 1");
    const earliestDate = earliestTransaction && fromDateRepr(earliestTransaction.date);
    const currentMonth$1 = currentMonth();
    const { start, end, range: range2 } = getBudgetRange(earliestDate || currentMonth$1, currentMonth$1);
    const meta = get$3().meta();
    const createdMonths = meta.createdMonths || /* @__PURE__ */ new Set();
    const newMonths = range2.filter((m) => !createdMonths.has(m));
    if (newMonths.length > 0) {
        await createBudget$2(range2);
    }
    return { start, end };
}
async function setType(type2) {
    const meta = get$3().meta();
    if (type2 === meta.budgetType) {
        return;
    }
    meta.budgetType = type2;
    meta.createdMonths = /* @__PURE__ */ new Set();
    const nodes = get$3().getNodes();
    transaction(() => {
        for (const name of nodes.keys()) {
            const [sheetName, cellName] = name.split("!");
            if (sheetName.match(/^budget\d+/)) {
                get$3().deleteCell(sheetName, cellName);
            }
        }
    });
    get$3().startCacheBarrier();
    loadUserBudgets(db$1);
    const bounds2 = await createAllBudgets();
    get$3().endCacheBarrier();
    return bounds2;
}
const app$j = createApp();
app$j.events.on("sync", (event) => {
});
const runningMethods = /* @__PURE__ */ new Set();
let currentContext = null;
const mutatingMethods = /* @__PURE__ */ new WeakMap();
let _latestHandlerNames = [];
function mutator(handler) {
    mutatingMethods.set(handler, true);
    return handler;
}
async function flushRunningMethods() {
    await wait(200);
    while (runningMethods.size > 0) {
        await Promise.all([...runningMethods.values()]);
        await wait(100);
    }
}
function wait(time) {
    return new Promise((resolve) => setTimeout(resolve, time));
}
async function runHandler(handler, args, { undoTag, name } = {}) {
    _latestHandlerNames.push(name);
    if (_latestHandlerNames.length > 5) {
        _latestHandlerNames = _latestHandlerNames.slice(-5);
    }
    if (mutatingMethods.has(handler)) {
        return runMutator(() => handler(args), { undoTag });
    }
    if (name === "close-budget") {
        await flushRunningMethods();
    }
    const promise = handler(args);
    runningMethods.add(promise);
    promise.then(() => {
        runningMethods.delete(promise);
    });
    return promise;
}
function _runMutator(func, initialContext = {}) {
    currentContext = initialContext;
    return func().finally(() => {
        currentContext = null;
    });
}
const runMutator = sequential(_runMutator);
function withMutatorContext(context, func) {
    if (currentContext == null && true) {
        captureBreadcrumb("Recent methods: " + _latestHandlerNames.join(", "));
        captureException(new Error("withMutatorContext: mutator not running"));
        return func();
    }
    const prevContext = currentContext;
    currentContext = { ...currentContext, ...context };
    return func().finally(() => {
        currentContext = prevContext;
    });
}
function getMutatorContext() {
    if (currentContext == null) {
        captureBreadcrumb({
            message: "Recent methods: " + _latestHandlerNames.join(", ")
        });
        return {};
    }
    return currentContext;
}
const fetch$1 = globalThis.fetch;
function throwIfNot200(res, text) {
    if (res.status !== 200) {
        if (res.status === 500) {
            throw new PostError(res.status === 500 ? "internal" : text);
        }
        const contentType = res.headers.get("Content-Type");
        if (contentType.toLowerCase().indexOf("application/json") !== -1) {
            const json = JSON.parse(text);
            throw new PostError(json.reason);
        }
        const tunnelErrorHeaders = ["ngrok-error-code"];
        const tunnelError = tunnelErrorHeaders.some((header) => res.headers.has(header));
        if (tunnelError) {
            throw new PostError("network-failure");
        }
        throw new PostError(text);
    }
}
async function post(url, data, headers2 = {}, timeout = null) {
    let text;
    let res;
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const signal = timeout ? controller.signal : null;
        res = await fetch$1(url, {
            method: "POST",
            body: JSON.stringify(data),
            signal,
            headers: {
                ...headers2,
                "Content-Type": "application/json"
            }
        });
        clearTimeout(timeoutId);
        text = await res.text();
    }
    catch (err) {
        throw new PostError("network-failure");
    }
    throwIfNot200(res, text);
    let responseData;
    try {
        responseData = JSON.parse(text);
    }
    catch (err) {
        throw new PostError("parse-json", { meta: text });
    }
    if (responseData.status !== "ok") {
        logger.log("API call failed: " + url + "\nData: " + JSON.stringify(data, null, 2) + "\nResponse: " + JSON.stringify(res, null, 2));
        throw new PostError(responseData.description || responseData.reason || "unknown");
    }
    return responseData.data;
}
async function del(url, data, headers2 = {}, timeout = null) {
    let text;
    let res;
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const signal = timeout ? controller.signal : null;
        res = await fetch$1(url, {
            method: "DELETE",
            body: JSON.stringify(data),
            signal,
            headers: {
                ...headers2,
                "Content-Type": "application/json"
            }
        });
        clearTimeout(timeoutId);
        text = await res.text();
    }
    catch (err) {
        throw new PostError("network-failure");
    }
    throwIfNot200(res, text);
    try {
        res = JSON.parse(text);
    }
    catch (err) {
        throw new PostError("parse-json", { meta: text });
    }
    if (res.status !== "ok") {
        logger.log("API call failed: " + url + "\nData: " + JSON.stringify(data, null, 2) + "\nResponse: " + JSON.stringify(res, null, 2));
        throw new PostError(res.description || res.reason || "unknown");
    }
    return res.data;
}
async function patch(url, data, headers2 = {}, timeout = null) {
    let text;
    let res;
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const signal = timeout ? controller.signal : null;
        res = await fetch$1(url, {
            method: "PATCH",
            body: JSON.stringify(data),
            signal,
            headers: {
                ...headers2,
                "Content-Type": "application/json"
            }
        });
        clearTimeout(timeoutId);
        text = await res.text();
    }
    catch (err) {
        throw new PostError("network-failure");
    }
    throwIfNot200(res, text);
    try {
        res = JSON.parse(text);
    }
    catch (err) {
        throw new PostError("parse-json", { meta: text });
    }
    if (res.status !== "ok") {
        logger.log("API call failed: " + url + "\nData: " + JSON.stringify(data, null, 2) + "\nResponse: " + JSON.stringify(res, null, 2));
        throw new PostError(res.description || res.reason || "unknown");
    }
    return res.data;
}
async function postBinary(url, data, headers2) {
    let res;
    try {
        res = await fetch$1(url, {
            method: "POST",
            body: isBrowser ? data : Buffer.from(data),
            headers: {
                "Content-Length": data.length,
                "Content-Type": "application/actual-sync",
                ...headers2
            }
        });
    }
    catch (err) {
        throw new PostError("network-failure");
    }
    let buffer;
    if (res.arrayBuffer) {
        buffer = Buffer.from(await res.arrayBuffer());
    }
    else {
        buffer = await res.buffer();
    }
    throwIfNot200(res, buffer.toString());
    return buffer;
}
function get$2(url, opts) {
    return fetch$1(url, opts).then((res) => res.text());
}
let prefs = null;
async function loadPrefs(id2) {
    if (process.env.NODE_ENV === "test" && !id2) {
        prefs = getDefaultPrefs("test", "test_LocalPrefs");
        return prefs;
    }
    const fullpath = join$1(getBudgetDir(id2), "metadata.json");
    try {
        prefs = JSON.parse(await readFile(fullpath));
    }
    catch (e) {
        prefs = { id: id2, budgetName: id2 };
    }
    prefs.id = id2;
    return prefs;
}
async function savePrefs(prefsToSet, { avoidSync = false } = {}) {
    Object.assign(prefs, prefsToSet);
    if (!avoidSync) {
        const messages = Object.keys(prefsToSet).map((key) => {
            if (key === "budgetName") {
                return {
                    dataset: "prefs",
                    row: key,
                    column: "value",
                    value: prefsToSet[key],
                    timestamp: Timestamp.send()
                };
            }
            return null;
        }).filter((x) => x);
        if (messages.length > 0) {
            await sendMessages(messages);
        }
    }
    if (process.env.NODE_ENV !== "test") {
        const prefsPath = join$1(getBudgetDir(prefs.id), "metadata.json");
        await writeFile(prefsPath, JSON.stringify(prefs));
    }
}
function unloadPrefs() {
    prefs = null;
}
function getPrefs() {
    return prefs;
}
function getDefaultPrefs(id2, budgetName) {
    return { id: id2, budgetName };
}
let config = null;
function joinURL(base, ...paths) {
    const url = new URL(base);
    url.pathname = join$1(url.pathname, ...paths);
    return url.toString();
}
function isValidBaseURL(base) {
    try {
        return Boolean(new URL(base));
    }
    catch (error) {
        return false;
    }
}
function setServer(url) {
    if (url == null) {
        config = null;
    }
    else {
        config = getServer(url);
    }
}
function getServer(url) {
    if (url) {
        try {
            return {
                BASE_SERVER: url,
                SYNC_SERVER: joinURL(url, "/sync"),
                SIGNUP_SERVER: joinURL(url, "/account"),
                GOCARDLESS_SERVER: joinURL(url, "/gocardless"),
                SIMPLEFIN_SERVER: joinURL(url, "/simplefin"),
                PLUGGYAI_SERVER: joinURL(url, "/pluggyai")
            };
        }
        catch (error) {
            logger.warn("Unable to parse server URL - using the global config.", { config }, error);
            return config;
        }
    }
    return config;
}
let MESSAGE_HISTORY = [
    { type: "marker" }
];
let CURSOR = 0;
const HISTORY_SIZE = 20;
function trimHistory() {
    MESSAGE_HISTORY = MESSAGE_HISTORY.slice(0, CURSOR + 1);
    const markers = MESSAGE_HISTORY.filter((item) => item.type === "marker");
    if (markers.length > HISTORY_SIZE) {
        const slice = markers.slice(-20);
        const cutoff = MESSAGE_HISTORY.indexOf(slice[0]);
        MESSAGE_HISTORY = MESSAGE_HISTORY.slice(cutoff);
        CURSOR = MESSAGE_HISTORY.length - 1;
    }
}
function appendMessages(messages, oldData) {
    const context = getMutatorContext();
    if (context.undoListening && messages.length > 0) {
        trimHistory();
        const { undoTag } = context;
        MESSAGE_HISTORY.push({
            type: "messages",
            messages,
            oldData,
            undoTag
        });
        CURSOR++;
    }
}
function clearUndo() {
    MESSAGE_HISTORY = [{ type: "marker" }];
    CURSOR = 0;
}
function withUndo(func, meta) {
    const context = getMutatorContext();
    if (context.undoDisabled || context.undoListening) {
        return func();
    }
    MESSAGE_HISTORY = MESSAGE_HISTORY.slice(0, CURSOR + 1);
    const marker = { type: "marker", meta };
    if (MESSAGE_HISTORY[MESSAGE_HISTORY.length - 1].type === "marker") {
        MESSAGE_HISTORY[MESSAGE_HISTORY.length - 1] = marker;
    }
    else {
        MESSAGE_HISTORY.push(marker);
        CURSOR++;
    }
    return withMutatorContext({ undoListening: true, undoTag: context.undoTag }, func);
}
function undoable(func, metaFunc) {
    return (...args) => {
        return withUndo(() => {
            return func.apply(null, args);
        }, metaFunc ? metaFunc(...args) : void 0);
    };
}
async function applyUndoAction(messages, meta, undoTag) {
    await withMutatorContext({ undoListening: false }, () => {
        return sendMessages(messages.map((msg) => ({ ...msg, timestamp: Timestamp.send() })));
    });
    messages.reduce((acc, message2) => {
        if (!acc.includes(message2.dataset)) {
            acc.push(message2.dataset);
        }
        return acc;
    }, []);
}
async function undo() {
    const end = CURSOR;
    CURSOR = Math.max(CURSOR - 1, 0);
    while (CURSOR > 0 && MESSAGE_HISTORY[CURSOR].type !== "marker") {
        CURSOR--;
    }
    const meta = MESSAGE_HISTORY[CURSOR].meta;
    const start = Math.max(CURSOR, 0);
    const entries = MESSAGE_HISTORY.slice(start, end + 1).filter((entry) => entry.type === "messages");
    if (entries.length > 0) {
        const toApply = entries.reduce((acc, entry) => {
            return acc.concat(entry.messages.map((message2) => undoMessage(message2, entry.oldData)).filter((x) => x));
        }, []).reverse();
        await applyUndoAction(toApply, meta, entries[0].undoTag);
    }
}
function undoMessage(message2, oldData) {
    const oldItem = getIn(oldData, [message2.dataset, message2.row]);
    if (oldItem) {
        let column = message2.column;
        if (message2.dataset === "spreadsheet_cells") {
            column = "cachedValue";
        }
        return { ...message2, value: oldItem[column] };
    }
    else {
        if (message2.dataset === "spreadsheet_cells") {
            if (message2.column === "expr") {
                return { ...message2, value: null };
            }
            return message2;
        }
        else if (
        // The mapping fields aren't ever deleted... this should be
        // harmless since all they are is meta information. Maybe we
        // should fix this though.
        message2.dataset !== "category_mapping" && message2.dataset !== "payee_mapping") {
            if (message2.dataset === "zero_budget_months" || message2.dataset === "zero_budgets" || message2.dataset === "reflect_budgets") {
                if (["buffered", "amount", "carryover"].includes(message2.column)) {
                    return { ...message2, value: 0 };
                }
                return null;
            }
            else if (message2.dataset === "notes") {
                return { ...message2, value: null };
            }
            return { ...message2, column: "tombstone", value: 1 };
        }
    }
    return null;
}
async function redo() {
    const meta = MESSAGE_HISTORY[CURSOR].type === "marker" ? MESSAGE_HISTORY[CURSOR].meta : null;
    const start = CURSOR;
    CURSOR = Math.min(CURSOR + 1, MESSAGE_HISTORY.length - 1);
    while (CURSOR < MESSAGE_HISTORY.length - 1 && MESSAGE_HISTORY[CURSOR].type !== "marker") {
        CURSOR++;
    }
    const end = CURSOR;
    const entries = MESSAGE_HISTORY.slice(start + 1, end + 1).filter((entry) => entry.type === "messages");
    if (entries.length > 0) {
        const toApply = entries.reduce((acc, entry) => {
            return acc.concat(entry.messages).concat(redoResurrections(entry.messages, entry.oldData));
        }, []);
        await applyUndoAction(toApply, meta, entries[entries.length - 1].undoTag);
    }
}
function redoResurrections(messages, oldData) {
    const resurrect = /* @__PURE__ */ new Set();
    messages.forEach((message2) => {
        const oldItem = getIn(oldData, [message2.dataset, message2.row]);
        if (!oldItem && ![
            "zero_budget_months",
            "zero_budgets",
            "reflect_budgets",
            "notes",
            "category_mapping",
            "payee_mapping"
        ].includes(message2.dataset)) {
            resurrect.add(message2.dataset + "." + message2.row);
        }
    });
    return [...resurrect].map((desc) => {
        const [table, row] = desc.split(".");
        return {
            dataset: table,
            row,
            column: "tombstone",
            value: 0,
            timestamp: Timestamp.send()
        };
    });
}
const ENCRYPTION_ALGORITHM = "aes-256-gcm";
function randomBytes$1(n) {
    return crypto.randomBytes(n);
}
function encrypt$1(masterKey, value) {
    const masterKeyBuffer = masterKey.getValue().raw;
    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, masterKeyBuffer, iv);
    let encrypted = cipher.update(value);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    const authTag = cipher.getAuthTag();
    return {
        value: encrypted,
        meta: {
            keyId: masterKey.getId(),
            algorithm: ENCRYPTION_ALGORITHM,
            iv: iv.toString("base64"),
            authTag: authTag.toString("base64")
        }
    };
}
function decrypt$1(masterKey, encrypted, meta) {
    const masterKeyBuffer = masterKey.getValue().raw;
    const { algorithm, iv: originalIv, authTag: originalAuthTag } = meta;
    const iv = Buffer.from(originalIv, "base64");
    const authTag = Buffer.from(originalAuthTag, "base64");
    const decipher = crypto.createDecipheriv(algorithm, masterKeyBuffer, iv);
    decipher.setAuthTag(authTag);
    let decrypted = decipher.update(encrypted);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted;
}
function createKey$1({ secret, salt }) {
    const buffer = createKeyBuffer({ secret, salt });
    return {
        raw: buffer,
        base64: buffer.toString("base64")
    };
}
function importKey(str) {
    return {
        raw: Buffer.from(str, "base64"),
        base64: str
    };
}
function createKeyBuffer({ numBytes, secret, salt }) {
    return crypto.pbkdf2Sync(secret || crypto.randomBytes(128).toString("base64"), salt || crypto.randomBytes(32).toString("base64"), 1e4, numBytes || 32, "sha512");
}
let keys = {};
class Key {
    constructor({ id: id2 }) {
        this.id = id2 || v4();
    }
    async createFromPassword({ password, salt }) {
        this.value = await createKey$1({ secret: password, salt });
    }
    async createFromBase64(str) {
        this.value = await importKey(str);
    }
    getId() {
        return this.id;
    }
    getValue() {
        return this.value;
    }
    serialize() {
        return {
            id: this.id,
            base64: this.value.base64
        };
    }
}
function getKey(keyId) {
    if (keyId == null || keys[keyId] == null) {
        throw new Error("missing-key");
    }
    return keys[keyId];
}
function hasKey(keyId) {
    return keyId in keys;
}
function encrypt(value, keyId) {
    return encrypt$1(getKey(keyId), value);
}
function decrypt(encrypted, meta) {
    return decrypt$1(getKey(meta.keyId), encrypted, meta);
}
function randomBytes(n) {
    return randomBytes$1(n);
}
async function loadKey(key) {
    let keyInstance;
    if (!(key instanceof Key)) {
        keyInstance = new Key({ id: key.id });
        await keyInstance.createFromBase64(key.base64);
    }
    else {
        keyInstance = key;
    }
    keys[keyInstance.getId()] = keyInstance;
}
function unloadKey(key) {
    delete keys[key.getId()];
}
function unloadAllKeys() {
    keys = {};
}
async function createKey({ id: id2, password, salt }) {
    const key = new Key({ id: id2 });
    await key.createFromPassword({ password, salt });
    return key;
}
function coerceBuffer(value) {
    if (!Buffer.isBuffer(value)) {
        return Buffer.from(value);
    }
    return value;
}
async function encode(groupId, fileId, since, messages) {
    const { encryptKeyId } = getPrefs();
    const requestPb = new SyncProtoBuf.SyncRequest();
    for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const envelopePb = new SyncProtoBuf.MessageEnvelope();
        envelopePb.setTimestamp(msg.timestamp.toString());
        const messagePb = new SyncProtoBuf.Message();
        messagePb.setDataset(msg.dataset);
        messagePb.setRow(msg.row);
        messagePb.setColumn(msg.column);
        messagePb.setValue(msg.value);
        const binaryMsg = messagePb.serializeBinary();
        if (encryptKeyId) {
            const encrypted = new SyncProtoBuf.EncryptedData();
            let result;
            try {
                result = await encrypt(binaryMsg, encryptKeyId);
            }
            catch (e) {
                throw new SyncError("encrypt-failure", {
                    isMissingKey: e.message === "missing-key"
                });
            }
            encrypted.setData(result.value);
            encrypted.setIv(Buffer.from(result.meta.iv, "base64"));
            encrypted.setAuthtag(Buffer.from(result.meta.authTag, "base64"));
            envelopePb.setContent(encrypted.serializeBinary());
            envelopePb.setIsencrypted(true);
        }
        else {
            envelopePb.setContent(binaryMsg);
        }
        requestPb.addMessages(envelopePb);
    }
    requestPb.setGroupid(groupId);
    requestPb.setFileid(fileId);
    requestPb.setKeyid(encryptKeyId);
    requestPb.setSince(since.toString());
    return requestPb.serializeBinary();
}
async function decode(data) {
    const { encryptKeyId } = getPrefs();
    const responsePb = SyncProtoBuf.SyncResponse.deserializeBinary(data);
    const merkle = JSON.parse(responsePb.getMerkle());
    const list = responsePb.getMessagesList();
    const messages = [];
    for (let i = 0; i < list.length; i++) {
        const envelopePb = list[i];
        const timestamp = Timestamp.parse(envelopePb.getTimestamp());
        const encrypted = envelopePb.getIsencrypted();
        let msg;
        if (encrypted) {
            const binary = SyncProtoBuf.EncryptedData.deserializeBinary(envelopePb.getContent());
            let decrypted;
            try {
                decrypted = await decrypt(coerceBuffer(binary.getData()), {
                    keyId: encryptKeyId,
                    algorithm: "aes-256-gcm",
                    iv: coerceBuffer(binary.getIv()),
                    authTag: coerceBuffer(binary.getAuthtag())
                });
            }
            catch (e) {
                logger.log(e);
                throw new SyncError("decrypt-failure", {
                    isMissingKey: e.message === "missing-key"
                });
            }
            msg = SyncProtoBuf.Message.deserializeBinary(decrypted);
        }
        else {
            msg = SyncProtoBuf.Message.deserializeBinary(envelopePb.getContent());
        }
        messages.push({
            timestamp,
            dataset: msg.getDataset(),
            row: msg.getRow(),
            column: msg.getColumn(),
            value: msg.getValue()
        });
    }
    return { messages, merkle };
}
function rebuildMerkleHash() {
    const rows = runQuery("SELECT timestamp FROM messages_crdt", [], true);
    let trie = emptyTrie();
    for (let i = 0; i < rows.length; i++) {
        trie = insert$1(trie, Timestamp.parse(rows[i].timestamp));
    }
    return {
        numMessages: rows.length,
        trie
    };
}
async function repairSync$1() {
    const rebuilt = rebuildMerkleHash();
    const clock2 = getClock();
    clock2.merkle = rebuilt.trie;
    runQuery(cache("INSERT OR REPLACE INTO messages_clock (id, clock) VALUES (1, ?)"), [serializeClock(clock2)]);
}
function isError(value) {
    return value.error !== void 0;
}
async function randomString() {
    return (await randomBytes(12)).toString();
}
async function makeTestMessage(keyId) {
    const messagePb = new SyncProtoBuf.Message();
    messagePb.setDataset(await randomString());
    messagePb.setRow(await randomString());
    messagePb.setColumn(await randomString());
    messagePb.setValue(await randomString());
    const binaryMsg = messagePb.serializeBinary();
    return await encrypt(binaryMsg, keyId);
}
var util = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
    if (hasRequiredConstants)
        return constants;
    hasRequiredConstants = 1;
    constants = {
        /* The local file header */
        LOCHDR: 30,
        // LOC header size
        LOCSIG: 67324752,
        // "PK\003\004"
        LOCVER: 4,
        // version needed to extract
        LOCFLG: 6,
        // general purpose bit flag
        LOCHOW: 8,
        // compression method
        LOCTIM: 10,
        // modification time (2 bytes time, 2 bytes date)
        LOCCRC: 14,
        // uncompressed file crc-32 value
        LOCSIZ: 18,
        // compressed size
        LOCLEN: 22,
        // uncompressed size
        LOCNAM: 26,
        // filename length
        LOCEXT: 28,
        // extra field length
        /* The Data descriptor */
        EXTSIG: 134695760,
        // "PK\007\008"
        EXTHDR: 16,
        // EXT header size
        EXTCRC: 4,
        // uncompressed file crc-32 value
        EXTSIZ: 8,
        // compressed size
        EXTLEN: 12,
        // uncompressed size
        /* The central directory file header */
        CENHDR: 46,
        // CEN header size
        CENSIG: 33639248,
        // "PK\001\002"
        CENVEM: 4,
        // version made by
        CENVER: 6,
        // version needed to extract
        CENFLG: 8,
        // encrypt, decrypt flags
        CENHOW: 10,
        // compression method
        CENTIM: 12,
        // modification time (2 bytes time, 2 bytes date)
        CENCRC: 16,
        // uncompressed file crc-32 value
        CENSIZ: 20,
        // compressed size
        CENLEN: 24,
        // uncompressed size
        CENNAM: 28,
        // filename length
        CENEXT: 30,
        // extra field length
        CENCOM: 32,
        // file comment length
        CENDSK: 34,
        // volume number start
        CENATT: 36,
        // internal file attributes
        CENATX: 38,
        // external file attributes (host system dependent)
        CENOFF: 42,
        // LOC header offset
        /* The entries in the end of central directory */
        ENDHDR: 22,
        // END header size
        ENDSIG: 101010256,
        // "PK\005\006"
        ENDSUB: 8,
        // number of entries on this disk
        ENDTOT: 10,
        // total number of entries
        ENDSIZ: 12,
        // central directory size in bytes
        ENDOFF: 16,
        // offset of first CEN header
        ENDCOM: 20,
        // zip file comment length
        END64HDR: 20,
        // zip64 END header size
        END64SIG: 117853008,
        // zip64 Locator signature, "PK\006\007"
        END64START: 4,
        // number of the disk with the start of the zip64
        END64OFF: 8,
        // relative offset of the zip64 end of central directory
        END64NUMDISKS: 16,
        // total number of disks
        ZIP64SIG: 101075792,
        // zip64 signature, "PK\006\006"
        ZIP64HDR: 56,
        // zip64 record minimum size
        ZIP64LEAD: 12,
        // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
        ZIP64SIZE: 4,
        // zip64 size of the central directory record
        ZIP64VEM: 12,
        // zip64 version made by
        ZIP64VER: 14,
        // zip64 version needed to extract
        ZIP64DSK: 16,
        // zip64 number of this disk
        ZIP64DSKDIR: 20,
        // number of the disk with the start of the record directory
        ZIP64SUB: 24,
        // number of entries on this disk
        ZIP64TOT: 32,
        // total number of entries
        ZIP64SIZB: 40,
        // zip64 central directory size in bytes
        ZIP64OFF: 48,
        // offset of start of central directory with respect to the starting disk number
        ZIP64EXTRA: 56,
        // extensible data sector
        /* Compression methods */
        STORED: 0,
        // no compression
        SHRUNK: 1,
        // shrunk
        REDUCED1: 2,
        // reduced with compression factor 1
        REDUCED2: 3,
        // reduced with compression factor 2
        REDUCED3: 4,
        // reduced with compression factor 3
        REDUCED4: 5,
        // reduced with compression factor 4
        IMPLODED: 6,
        // imploded
        // 7 reserved for Tokenizing compression algorithm
        DEFLATED: 8,
        // deflated
        ENHANCED_DEFLATED: 9,
        // enhanced deflated
        PKWARE: 10,
        // PKWare DCL imploded
        // 11 reserved by PKWARE
        BZIP2: 12,
        //  compressed using BZIP2
        // 13 reserved by PKWARE
        LZMA: 14,
        // LZMA
        // 15-17 reserved by PKWARE
        IBM_TERSE: 18,
        // compressed using IBM TERSE
        IBM_LZ77: 19,
        // IBM LZ77 z
        AES_ENCRYPT: 99,
        // WinZIP AES encryption method
        /* General purpose bit flag */
        // values can obtained with expression 2**bitnr
        FLG_ENC: 1,
        // Bit 0: encrypted file
        FLG_COMP1: 2,
        // Bit 1, compression option
        FLG_COMP2: 4,
        // Bit 2, compression option
        FLG_DESC: 8,
        // Bit 3, data descriptor
        FLG_ENH: 16,
        // Bit 4, enhanced deflating
        FLG_PATCH: 32,
        // Bit 5, indicates that the file is compressed patched data.
        FLG_STR: 64,
        // Bit 6, strong encryption (patented)
        // Bits 7-10: Currently unused.
        FLG_EFS: 2048,
        // Bit 11: Language encoding flag (EFS)
        // Bit 12: Reserved by PKWARE for enhanced compression.
        // Bit 13: encrypted the Central Directory (patented).
        // Bits 14-15: Reserved by PKWARE.
        FLG_MSK: 4096,
        // mask header values
        /* Load type */
        FILE: 2,
        BUFFER: 1,
        NONE: 0,
        /* 4.5 Extensible data fields */
        EF_ID: 0,
        EF_SIZE: 2,
        /* Header IDs */
        ID_ZIP64: 1,
        ID_AVINFO: 7,
        ID_PFS: 8,
        ID_OS2: 9,
        ID_NTFS: 10,
        ID_OPENVMS: 12,
        ID_UNIX: 13,
        ID_FORK: 14,
        ID_PATCH: 15,
        ID_X509_PKCS7: 20,
        ID_X509_CERTID_F: 21,
        ID_X509_CERTID_C: 22,
        ID_STRONGENC: 23,
        ID_RECORD_MGT: 24,
        ID_X509_PKCS7_RL: 25,
        ID_IBM1: 101,
        ID_IBM2: 102,
        ID_POSZIP: 18064,
        EF_ZIP64_OR_32: 4294967295,
        EF_ZIP64_OR_16: 65535,
        EF_ZIP64_SUNCOMP: 0,
        EF_ZIP64_SCOMP: 8,
        EF_ZIP64_RHO: 16,
        EF_ZIP64_DSN: 24
    };
    return constants;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
    if (hasRequiredErrors)
        return errors;
    hasRequiredErrors = 1;
    (function (exports2) {
        const errors2 = {
            /* Header error messages */
            INVALID_LOC: "Invalid LOC header (bad signature)",
            INVALID_CEN: "Invalid CEN header (bad signature)",
            INVALID_END: "Invalid END header (bad signature)",
            /* Descriptor */
            DESCRIPTOR_NOT_EXIST: "No descriptor present",
            DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
            DESCRIPTOR_FAULTY: "Descriptor data is malformed",
            /* ZipEntry error messages*/
            NO_DATA: "Nothing to decompress",
            BAD_CRC: "CRC32 checksum failed {0}",
            FILE_IN_THE_WAY: "There is a file in the way: {0}",
            UNKNOWN_METHOD: "Invalid/unsupported compression method",
            /* Inflater error messages */
            AVAIL_DATA: "inflate::Available inflate data did not terminate",
            INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
            TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
            INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
            INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
            INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
            INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
            INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
            INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
            INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
            /* ADM-ZIP error messages */
            CANT_EXTRACT_FILE: "Could not extract the file",
            CANT_OVERRIDE: "Target file already exists",
            DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
            NO_ZIP: "No zip file was loaded",
            NO_ENTRY: "Entry doesn't exist",
            DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
            FILE_NOT_FOUND: 'File not found: "{0}"',
            NOT_IMPLEMENTED: "Not implemented",
            INVALID_FILENAME: "Invalid filename",
            INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
            INVALID_PASS_PARAM: "Incompatible password parameter",
            WRONG_PASSWORD: "Wrong Password",
            /* ADM-ZIP */
            COMMENT_TOO_LONG: "Comment is too long",
            // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)
            EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
        };
        function E(message2) {
            return function (...args) {
                if (args.length) {
                    message2 = message2.replace(/\{(\d)\}/g, (_, n) => args[n] || "");
                }
                return new Error("ADM-ZIP: " + message2);
            };
        }
        for (const msg of Object.keys(errors2)) {
            exports2[msg] = E(errors2[msg]);
        }
    })(errors);
    return errors;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
    if (hasRequiredUtils)
        return utils;
    hasRequiredUtils = 1;
    const fsystem = fs$1;
    const pth = path;
    const Constants = requireConstants();
    const Errors = requireErrors();
    const isWin = typeof process === "object" && "win32" === process.platform;
    const is_Obj = (obj) => typeof obj === "object" && obj !== null;
    const crcTable = new Uint32Array(256).map((t2, c) => {
        for (let k = 0; k < 8; k++) {
            if ((c & 1) !== 0) {
                c = 3988292384 ^ c >>> 1;
            }
            else {
                c >>>= 1;
            }
        }
        return c >>> 0;
    });
    function Utils(opts) {
        this.sep = pth.sep;
        this.fs = fsystem;
        if (is_Obj(opts)) {
            if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
                this.fs = opts.fs;
            }
        }
    }
    utils = Utils;
    Utils.prototype.makeDir = function (folder) {
        const self2 = this;
        function mkdirSync(fpath) {
            let resolvedPath = fpath.split(self2.sep)[0];
            fpath.split(self2.sep).forEach(function (name) {
                if (!name || name.substr(-1, 1) === ":")
                    return;
                resolvedPath += self2.sep + name;
                var stat;
                try {
                    stat = self2.fs.statSync(resolvedPath);
                }
                catch (e) {
                    self2.fs.mkdirSync(resolvedPath);
                }
                if (stat && stat.isFile())
                    throw Errors.FILE_IN_THE_WAY(`"${resolvedPath}"`);
            });
        }
        mkdirSync(folder);
    };
    Utils.prototype.writeFileTo = function (path2, content, overwrite, attr) {
        const self2 = this;
        if (self2.fs.existsSync(path2)) {
            if (!overwrite)
                return false;
            var stat = self2.fs.statSync(path2);
            if (stat.isDirectory()) {
                return false;
            }
        }
        var folder = pth.dirname(path2);
        if (!self2.fs.existsSync(folder)) {
            self2.makeDir(folder);
        }
        var fd;
        try {
            fd = self2.fs.openSync(path2, "w", 438);
        }
        catch (e) {
            self2.fs.chmodSync(path2, 438);
            fd = self2.fs.openSync(path2, "w", 438);
        }
        if (fd) {
            try {
                self2.fs.writeSync(fd, content, 0, content.length, 0);
            }
            finally {
                self2.fs.closeSync(fd);
            }
        }
        self2.fs.chmodSync(path2, attr || 438);
        return true;
    };
    Utils.prototype.writeFileToAsync = function (path2, content, overwrite, attr, callback) {
        if (typeof attr === "function") {
            callback = attr;
            attr = void 0;
        }
        const self2 = this;
        self2.fs.exists(path2, function (exist) {
            if (exist && !overwrite)
                return callback(false);
            self2.fs.stat(path2, function (err, stat) {
                if (exist && stat.isDirectory()) {
                    return callback(false);
                }
                var folder = pth.dirname(path2);
                self2.fs.exists(folder, function (exists2) {
                    if (!exists2)
                        self2.makeDir(folder);
                    self2.fs.open(path2, "w", 438, function (err2, fd) {
                        if (err2) {
                            self2.fs.chmod(path2, 438, function () {
                                self2.fs.open(path2, "w", 438, function (err3, fd2) {
                                    self2.fs.write(fd2, content, 0, content.length, 0, function () {
                                        self2.fs.close(fd2, function () {
                                            self2.fs.chmod(path2, attr || 438, function () {
                                                callback(true);
                                            });
                                        });
                                    });
                                });
                            });
                        }
                        else if (fd) {
                            self2.fs.write(fd, content, 0, content.length, 0, function () {
                                self2.fs.close(fd, function () {
                                    self2.fs.chmod(path2, attr || 438, function () {
                                        callback(true);
                                    });
                                });
                            });
                        }
                        else {
                            self2.fs.chmod(path2, attr || 438, function () {
                                callback(true);
                            });
                        }
                    });
                });
            });
        });
    };
    Utils.prototype.findFiles = function (path2) {
        const self2 = this;
        function findSync(dir, pattern, recursive) {
            let files = [];
            self2.fs.readdirSync(dir).forEach(function (file) {
                const path3 = pth.join(dir, file);
                const stat = self2.fs.statSync(path3);
                {
                    files.push(pth.normalize(path3) + (stat.isDirectory() ? self2.sep : ""));
                }
                if (stat.isDirectory() && recursive)
                    files = files.concat(findSync(path3, pattern, recursive));
            });
            return files;
        }
        return findSync(path2, void 0, true);
    };
    Utils.prototype.findFilesAsync = function (dir, cb) {
        const self2 = this;
        let results = [];
        self2.fs.readdir(dir, function (err, list) {
            if (err)
                return cb(err);
            let list_length = list.length;
            if (!list_length)
                return cb(null, results);
            list.forEach(function (file) {
                file = pth.join(dir, file);
                self2.fs.stat(file, function (err2, stat) {
                    if (err2)
                        return cb(err2);
                    if (stat) {
                        results.push(pth.normalize(file) + (stat.isDirectory() ? self2.sep : ""));
                        if (stat.isDirectory()) {
                            self2.findFilesAsync(file, function (err3, res) {
                                if (err3)
                                    return cb(err3);
                                results = results.concat(res);
                                if (!--list_length)
                                    cb(null, results);
                            });
                        }
                        else {
                            if (!--list_length)
                                cb(null, results);
                        }
                    }
                });
            });
        });
    };
    Utils.prototype.getAttributes = function () {
    };
    Utils.prototype.setAttributes = function () {
    };
    Utils.crc32update = function (crc, byte) {
        return crcTable[(crc ^ byte) & 255] ^ crc >>> 8;
    };
    Utils.crc32 = function (buf) {
        if (typeof buf === "string") {
            buf = Buffer.from(buf, "utf8");
        }
        let len = buf.length;
        let crc = -1;
        for (let off = 0; off < len;)
            crc = Utils.crc32update(crc, buf[off++]);
        return ~crc >>> 0;
    };
    Utils.methodToString = function (method) {
        switch (method) {
            case Constants.STORED:
                return "STORED (" + method + ")";
            case Constants.DEFLATED:
                return "DEFLATED (" + method + ")";
            default:
                return "UNSUPPORTED (" + method + ")";
        }
    };
    Utils.canonical = function (path2) {
        if (!path2)
            return "";
        const safeSuffix = pth.posix.normalize("/" + path2.split("\\").join("/"));
        return pth.join(".", safeSuffix);
    };
    Utils.zipnamefix = function (path2) {
        if (!path2)
            return "";
        const safeSuffix = pth.posix.normalize("/" + path2.split("\\").join("/"));
        return pth.posix.join(".", safeSuffix);
    };
    Utils.findLast = function (arr, callback) {
        if (!Array.isArray(arr))
            throw new TypeError("arr is not array");
        const len = arr.length >>> 0;
        for (let i = len - 1; i >= 0; i--) {
            if (callback(arr[i], i, arr)) {
                return arr[i];
            }
        }
        return void 0;
    };
    Utils.sanitize = function (prefix, name) {
        prefix = pth.resolve(pth.normalize(prefix));
        var parts = name.split("/");
        for (var i = 0, l = parts.length; i < l; i++) {
            var path2 = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));
            if (path2.indexOf(prefix) === 0) {
                return path2;
            }
        }
        return pth.normalize(pth.join(prefix, pth.basename(name)));
    };
    Utils.toBuffer = function toBuffer(input, encoder) {
        if (Buffer.isBuffer(input)) {
            return input;
        }
        else if (input instanceof Uint8Array) {
            return Buffer.from(input);
        }
        else {
            return typeof input === "string" ? encoder(input) : Buffer.alloc(0);
        }
    };
    Utils.readBigUInt64LE = function (buffer, index) {
        var slice = Buffer.from(buffer.slice(index, index + 8));
        slice.swap64();
        return parseInt(`0x${slice.toString("hex")}`);
    };
    Utils.fromDOS2Date = function (val2) {
        return new Date((val2 >> 25 & 127) + 1980, Math.max((val2 >> 21 & 15) - 1, 0), Math.max(val2 >> 16 & 31, 1), val2 >> 11 & 31, val2 >> 5 & 63, (val2 & 31) << 1);
    };
    Utils.fromDate2DOS = function (val2) {
        let date = 0;
        let time = 0;
        if (val2.getFullYear() > 1979) {
            date = (val2.getFullYear() - 1980 & 127) << 9 | val2.getMonth() + 1 << 5 | val2.getDate();
            time = val2.getHours() << 11 | val2.getMinutes() << 5 | val2.getSeconds() >> 1;
        }
        return date << 16 | time;
    };
    Utils.isWin = isWin;
    Utils.crcTable = crcTable;
    return utils;
}
var fattr;
var hasRequiredFattr;
function requireFattr() {
    if (hasRequiredFattr)
        return fattr;
    hasRequiredFattr = 1;
    const pth = path;
    fattr = function (path2, { fs: fs2 }) {
        var _path = path2 || "", _obj = newAttr(), _stat = null;
        function newAttr() {
            return {
                directory: false,
                readonly: false,
                hidden: false,
                executable: false,
                mtime: 0,
                atime: 0
            };
        }
        if (_path && fs2.existsSync(_path)) {
            _stat = fs2.statSync(_path);
            _obj.directory = _stat.isDirectory();
            _obj.mtime = _stat.mtime;
            _obj.atime = _stat.atime;
            _obj.executable = (73 & _stat.mode) !== 0;
            _obj.readonly = (128 & _stat.mode) === 0;
            _obj.hidden = pth.basename(_path)[0] === ".";
        }
        else {
            console.warn("Invalid path: " + _path);
        }
        return {
            get directory() {
                return _obj.directory;
            },
            get readOnly() {
                return _obj.readonly;
            },
            get hidden() {
                return _obj.hidden;
            },
            get mtime() {
                return _obj.mtime;
            },
            get atime() {
                return _obj.atime;
            },
            get executable() {
                return _obj.executable;
            },
            decodeAttributes: function () {
            },
            encodeAttributes: function () {
            },
            toJSON: function () {
                return {
                    path: _path,
                    isDirectory: _obj.directory,
                    isReadOnly: _obj.readonly,
                    isHidden: _obj.hidden,
                    isExecutable: _obj.executable,
                    mTime: _obj.mtime,
                    aTime: _obj.atime
                };
            },
            toString: function () {
                return JSON.stringify(this.toJSON(), null, "	");
            }
        };
    };
    return fattr;
}
var decoder;
var hasRequiredDecoder;
function requireDecoder() {
    if (hasRequiredDecoder)
        return decoder;
    hasRequiredDecoder = 1;
    decoder = {
        efs: true,
        encode: (data) => Buffer.from(data, "utf8"),
        decode: (data) => data.toString("utf8")
    };
    return decoder;
}
var hasRequiredUtil;
function requireUtil() {
    if (hasRequiredUtil)
        return util.exports;
    hasRequiredUtil = 1;
    util.exports = requireUtils();
    util.exports.Constants = requireConstants();
    util.exports.Errors = requireErrors();
    util.exports.FileAttr = requireFattr();
    util.exports.decoder = requireDecoder();
    return util.exports;
}
var headers = {};
var entryHeader;
var hasRequiredEntryHeader;
function requireEntryHeader() {
    if (hasRequiredEntryHeader)
        return entryHeader;
    hasRequiredEntryHeader = 1;
    var Utils = requireUtil(), Constants = Utils.Constants;
    entryHeader = function () {
        var _verMade = 20, _version = 10, _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;
        _verMade |= Utils.isWin ? 2560 : 768;
        _flags |= Constants.FLG_EFS;
        const _localHeader = {
            extraLen: 0
        };
        const uint32 = (val2) => Math.max(0, val2) >>> 0;
        const uint8 = (val2) => Math.max(0, val2) & 255;
        _time = Utils.fromDate2DOS(/* @__PURE__ */ new Date());
        return {
            get made() {
                return _verMade;
            },
            set made(val2) {
                _verMade = val2;
            },
            get version() {
                return _version;
            },
            set version(val2) {
                _version = val2;
            },
            get flags() {
                return _flags;
            },
            set flags(val2) {
                _flags = val2;
            },
            get flags_efs() {
                return (_flags & Constants.FLG_EFS) > 0;
            },
            set flags_efs(val2) {
                if (val2) {
                    _flags |= Constants.FLG_EFS;
                }
                else {
                    _flags &= ~Constants.FLG_EFS;
                }
            },
            get flags_desc() {
                return (_flags & Constants.FLG_DESC) > 0;
            },
            set flags_desc(val2) {
                if (val2) {
                    _flags |= Constants.FLG_DESC;
                }
                else {
                    _flags &= ~Constants.FLG_DESC;
                }
            },
            get method() {
                return _method;
            },
            set method(val2) {
                switch (val2) {
                    case Constants.STORED:
                        this.version = 10;
                    case Constants.DEFLATED:
                    default:
                        this.version = 20;
                }
                _method = val2;
            },
            get time() {
                return Utils.fromDOS2Date(this.timeval);
            },
            set time(val2) {
                this.timeval = Utils.fromDate2DOS(val2);
            },
            get timeval() {
                return _time;
            },
            set timeval(val2) {
                _time = uint32(val2);
            },
            get timeHighByte() {
                return uint8(_time >>> 8);
            },
            get crc() {
                return _crc;
            },
            set crc(val2) {
                _crc = uint32(val2);
            },
            get compressedSize() {
                return _compressedSize;
            },
            set compressedSize(val2) {
                _compressedSize = uint32(val2);
            },
            get size() {
                return _size;
            },
            set size(val2) {
                _size = uint32(val2);
            },
            get fileNameLength() {
                return _fnameLen;
            },
            set fileNameLength(val2) {
                _fnameLen = val2;
            },
            get extraLength() {
                return _extraLen;
            },
            set extraLength(val2) {
                _extraLen = val2;
            },
            get extraLocalLength() {
                return _localHeader.extraLen;
            },
            set extraLocalLength(val2) {
                _localHeader.extraLen = val2;
            },
            get commentLength() {
                return _comLen;
            },
            set commentLength(val2) {
                _comLen = val2;
            },
            get diskNumStart() {
                return _diskStart;
            },
            set diskNumStart(val2) {
                _diskStart = uint32(val2);
            },
            get inAttr() {
                return _inattr;
            },
            set inAttr(val2) {
                _inattr = uint32(val2);
            },
            get attr() {
                return _attr;
            },
            set attr(val2) {
                _attr = uint32(val2);
            },
            // get Unix file permissions
            get fileAttr() {
                return (_attr || 0) >> 16 & 4095;
            },
            get offset() {
                return _offset;
            },
            set offset(val2) {
                _offset = uint32(val2);
            },
            get encrypted() {
                return (_flags & Constants.FLG_ENC) === Constants.FLG_ENC;
            },
            get centralHeaderSize() {
                return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
            },
            get realDataOffset() {
                return _offset + Constants.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;
            },
            get localHeader() {
                return _localHeader;
            },
            loadLocalHeaderFromBinary: function (input) {
                var data = input.slice(_offset, _offset + Constants.LOCHDR);
                if (data.readUInt32LE(0) !== Constants.LOCSIG) {
                    throw Utils.Errors.INVALID_LOC();
                }
                _localHeader.version = data.readUInt16LE(Constants.LOCVER);
                _localHeader.flags = data.readUInt16LE(Constants.LOCFLG);
                _localHeader.method = data.readUInt16LE(Constants.LOCHOW);
                _localHeader.time = data.readUInt32LE(Constants.LOCTIM);
                _localHeader.crc = data.readUInt32LE(Constants.LOCCRC);
                _localHeader.compressedSize = data.readUInt32LE(Constants.LOCSIZ);
                _localHeader.size = data.readUInt32LE(Constants.LOCLEN);
                _localHeader.fnameLen = data.readUInt16LE(Constants.LOCNAM);
                _localHeader.extraLen = data.readUInt16LE(Constants.LOCEXT);
                const extraStart = _offset + Constants.LOCHDR + _localHeader.fnameLen;
                const extraEnd = extraStart + _localHeader.extraLen;
                return input.slice(extraStart, extraEnd);
            },
            loadFromBinary: function (data) {
                if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {
                    throw Utils.Errors.INVALID_CEN();
                }
                _verMade = data.readUInt16LE(Constants.CENVEM);
                _version = data.readUInt16LE(Constants.CENVER);
                _flags = data.readUInt16LE(Constants.CENFLG);
                _method = data.readUInt16LE(Constants.CENHOW);
                _time = data.readUInt32LE(Constants.CENTIM);
                _crc = data.readUInt32LE(Constants.CENCRC);
                _compressedSize = data.readUInt32LE(Constants.CENSIZ);
                _size = data.readUInt32LE(Constants.CENLEN);
                _fnameLen = data.readUInt16LE(Constants.CENNAM);
                _extraLen = data.readUInt16LE(Constants.CENEXT);
                _comLen = data.readUInt16LE(Constants.CENCOM);
                _diskStart = data.readUInt16LE(Constants.CENDSK);
                _inattr = data.readUInt16LE(Constants.CENATT);
                _attr = data.readUInt32LE(Constants.CENATX);
                _offset = data.readUInt32LE(Constants.CENOFF);
            },
            localHeaderToBinary: function () {
                var data = Buffer.alloc(Constants.LOCHDR);
                data.writeUInt32LE(Constants.LOCSIG, 0);
                data.writeUInt16LE(_version, Constants.LOCVER);
                data.writeUInt16LE(_flags, Constants.LOCFLG);
                data.writeUInt16LE(_method, Constants.LOCHOW);
                data.writeUInt32LE(_time, Constants.LOCTIM);
                data.writeUInt32LE(_crc, Constants.LOCCRC);
                data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
                data.writeUInt32LE(_size, Constants.LOCLEN);
                data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
                data.writeUInt16LE(_localHeader.extraLen, Constants.LOCEXT);
                return data;
            },
            centralHeaderToBinary: function () {
                var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);
                data.writeUInt32LE(Constants.CENSIG, 0);
                data.writeUInt16LE(_verMade, Constants.CENVEM);
                data.writeUInt16LE(_version, Constants.CENVER);
                data.writeUInt16LE(_flags, Constants.CENFLG);
                data.writeUInt16LE(_method, Constants.CENHOW);
                data.writeUInt32LE(_time, Constants.CENTIM);
                data.writeUInt32LE(_crc, Constants.CENCRC);
                data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
                data.writeUInt32LE(_size, Constants.CENLEN);
                data.writeUInt16LE(_fnameLen, Constants.CENNAM);
                data.writeUInt16LE(_extraLen, Constants.CENEXT);
                data.writeUInt16LE(_comLen, Constants.CENCOM);
                data.writeUInt16LE(_diskStart, Constants.CENDSK);
                data.writeUInt16LE(_inattr, Constants.CENATT);
                data.writeUInt32LE(_attr, Constants.CENATX);
                data.writeUInt32LE(_offset, Constants.CENOFF);
                return data;
            },
            toJSON: function () {
                const bytes = function (nr) {
                    return nr + " bytes";
                };
                return {
                    made: _verMade,
                    version: _version,
                    flags: _flags,
                    method: Utils.methodToString(_method),
                    time: this.time,
                    crc: "0x" + _crc.toString(16).toUpperCase(),
                    compressedSize: bytes(_compressedSize),
                    size: bytes(_size),
                    fileNameLength: bytes(_fnameLen),
                    extraLength: bytes(_extraLen),
                    commentLength: bytes(_comLen),
                    diskNumStart: _diskStart,
                    inAttr: _inattr,
                    attr: _attr,
                    offset: _offset,
                    centralHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)
                };
            },
            toString: function () {
                return JSON.stringify(this.toJSON(), null, "	");
            }
        };
    };
    return entryHeader;
}
var mainHeader;
var hasRequiredMainHeader;
function requireMainHeader() {
    if (hasRequiredMainHeader)
        return mainHeader;
    hasRequiredMainHeader = 1;
    var Utils = requireUtil(), Constants = Utils.Constants;
    mainHeader = function () {
        var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;
        return {
            get diskEntries() {
                return _volumeEntries;
            },
            set diskEntries(val2) {
                _volumeEntries = _totalEntries = val2;
            },
            get totalEntries() {
                return _totalEntries;
            },
            set totalEntries(val2) {
                _totalEntries = _volumeEntries = val2;
            },
            get size() {
                return _size;
            },
            set size(val2) {
                _size = val2;
            },
            get offset() {
                return _offset;
            },
            set offset(val2) {
                _offset = val2;
            },
            get commentLength() {
                return _commentLength;
            },
            set commentLength(val2) {
                _commentLength = val2;
            },
            get mainHeaderSize() {
                return Constants.ENDHDR + _commentLength;
            },
            loadFromBinary: function (data) {
                if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) && (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {
                    throw Utils.Errors.INVALID_END();
                }
                if (data.readUInt32LE(0) === Constants.ENDSIG) {
                    _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
                    _totalEntries = data.readUInt16LE(Constants.ENDTOT);
                    _size = data.readUInt32LE(Constants.ENDSIZ);
                    _offset = data.readUInt32LE(Constants.ENDOFF);
                    _commentLength = data.readUInt16LE(Constants.ENDCOM);
                }
                else {
                    _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
                    _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
                    _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);
                    _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);
                    _commentLength = 0;
                }
            },
            toBinary: function () {
                var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
                b.writeUInt32LE(Constants.ENDSIG, 0);
                b.writeUInt32LE(0, 4);
                b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
                b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
                b.writeUInt32LE(_size, Constants.ENDSIZ);
                b.writeUInt32LE(_offset, Constants.ENDOFF);
                b.writeUInt16LE(_commentLength, Constants.ENDCOM);
                b.fill(" ", Constants.ENDHDR);
                return b;
            },
            toJSON: function () {
                const offset = function (nr, len) {
                    let offs = nr.toString(16).toUpperCase();
                    while (offs.length < len)
                        offs = "0" + offs;
                    return "0x" + offs;
                };
                return {
                    diskEntries: _volumeEntries,
                    totalEntries: _totalEntries,
                    size: _size + " bytes",
                    offset: offset(_offset, 4),
                    commentLength: _commentLength
                };
            },
            toString: function () {
                return JSON.stringify(this.toJSON(), null, "	");
            }
        };
    };
    return mainHeader;
}
var hasRequiredHeaders;
function requireHeaders() {
    if (hasRequiredHeaders)
        return headers;
    hasRequiredHeaders = 1;
    headers.EntryHeader = requireEntryHeader();
    headers.MainHeader = requireMainHeader();
    return headers;
}
var methods = {};
var deflater;
var hasRequiredDeflater;
function requireDeflater() {
    if (hasRequiredDeflater)
        return deflater;
    hasRequiredDeflater = 1;
    deflater = function (inbuf) {
        var zlib = require$$0;
        var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };
        return {
            deflate: function () {
                return zlib.deflateRawSync(inbuf, opts);
            },
            deflateAsync: function (callback) {
                var tmp = zlib.createDeflateRaw(opts), parts = [], total = 0;
                tmp.on("data", function (data) {
                    parts.push(data);
                    total += data.length;
                });
                tmp.on("end", function () {
                    var buf = Buffer.alloc(total), written = 0;
                    buf.fill(0);
                    for (var i = 0; i < parts.length; i++) {
                        var part = parts[i];
                        part.copy(buf, written);
                        written += part.length;
                    }
                    callback && callback(buf);
                });
                tmp.end(inbuf);
            }
        };
    };
    return deflater;
}
var inflater;
var hasRequiredInflater;
function requireInflater() {
    if (hasRequiredInflater)
        return inflater;
    hasRequiredInflater = 1;
    const version = +(process?.versions?.node ?? "").split(".")[0] || 0;
    inflater = function (inbuf, expectedLength) {
        var zlib = require$$0;
        const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};
        return {
            inflate: function () {
                return zlib.inflateRawSync(inbuf, option);
            },
            inflateAsync: function (callback) {
                var tmp = zlib.createInflateRaw(option), parts = [], total = 0;
                tmp.on("data", function (data) {
                    parts.push(data);
                    total += data.length;
                });
                tmp.on("end", function () {
                    var buf = Buffer.alloc(total), written = 0;
                    buf.fill(0);
                    for (var i = 0; i < parts.length; i++) {
                        var part = parts[i];
                        part.copy(buf, written);
                        written += part.length;
                    }
                    callback && callback(buf);
                });
                tmp.end(inbuf);
            }
        };
    };
    return inflater;
}
var zipcrypto;
var hasRequiredZipcrypto;
function requireZipcrypto() {
    if (hasRequiredZipcrypto)
        return zipcrypto;
    hasRequiredZipcrypto = 1;
    const { randomFillSync } = crypto;
    const Errors = requireErrors();
    const crctable = new Uint32Array(256).map((t2, crc) => {
        for (let j = 0; j < 8; j++) {
            if (0 !== (crc & 1)) {
                crc = crc >>> 1 ^ 3988292384;
            }
            else {
                crc >>>= 1;
            }
        }
        return crc >>> 0;
    });
    const uMul = (a, b) => Math.imul(a, b) >>> 0;
    const crc32update = (pCrc32, bval) => {
        return crctable[(pCrc32 ^ bval) & 255] ^ pCrc32 >>> 8;
    };
    const genSalt = () => {
        if ("function" === typeof randomFillSync) {
            return randomFillSync(Buffer.alloc(12));
        }
        else {
            return genSalt.node();
        }
    };
    genSalt.node = () => {
        const salt = Buffer.alloc(12);
        const len = salt.length;
        for (let i = 0; i < len; i++)
            salt[i] = Math.random() * 256 & 255;
        return salt;
    };
    const config2 = {
        genSalt
    };
    function Initkeys(pw) {
        const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
        this.keys = new Uint32Array([305419896, 591751049, 878082192]);
        for (let i = 0; i < pass.length; i++) {
            this.updateKeys(pass[i]);
        }
    }
    Initkeys.prototype.updateKeys = function (byteValue) {
        const keys2 = this.keys;
        keys2[0] = crc32update(keys2[0], byteValue);
        keys2[1] += keys2[0] & 255;
        keys2[1] = uMul(keys2[1], 134775813) + 1;
        keys2[2] = crc32update(keys2[2], keys2[1] >>> 24);
        return byteValue;
    };
    Initkeys.prototype.next = function () {
        const k = (this.keys[2] | 2) >>> 0;
        return uMul(k, k ^ 1) >> 8 & 255;
    };
    function make_decrypter(pwd) {
        const keys2 = new Initkeys(pwd);
        return function (data) {
            const result = Buffer.alloc(data.length);
            let pos = 0;
            for (let c of data) {
                result[pos++] = keys2.updateKeys(c ^ keys2.next());
            }
            return result;
        };
    }
    function make_encrypter(pwd) {
        const keys2 = new Initkeys(pwd);
        return function (data, result, pos = 0) {
            if (!result)
                result = Buffer.alloc(data.length);
            for (let c of data) {
                const k = keys2.next();
                result[pos++] = c ^ k;
                keys2.updateKeys(c);
            }
            return result;
        };
    }
    function decrypt2(data, header, pwd) {
        if (!data || !Buffer.isBuffer(data) || data.length < 12) {
            return Buffer.alloc(0);
        }
        const decrypter = make_decrypter(pwd);
        const salt = decrypter(data.slice(0, 12));
        const verifyByte = (header.flags & 8) === 8 ? header.timeHighByte : header.crc >>> 24;
        if (salt[11] !== verifyByte) {
            throw Errors.WRONG_PASSWORD();
        }
        return decrypter(data.slice(12));
    }
    function _salter(data) {
        if (Buffer.isBuffer(data) && data.length >= 12) {
            config2.genSalt = function () {
                return data.slice(0, 12);
            };
        }
        else if (data === "node") {
            config2.genSalt = genSalt.node;
        }
        else {
            config2.genSalt = genSalt;
        }
    }
    function encrypt2(data, header, pwd, oldlike = false) {
        if (data == null)
            data = Buffer.alloc(0);
        if (!Buffer.isBuffer(data))
            data = Buffer.from(data.toString());
        const encrypter = make_encrypter(pwd);
        const salt = config2.genSalt();
        salt[11] = header.crc >>> 24 & 255;
        if (oldlike)
            salt[10] = header.crc >>> 16 & 255;
        const result = Buffer.alloc(data.length + 12);
        encrypter(salt, result);
        return encrypter(data, result, 12);
    }
    zipcrypto = { decrypt: decrypt2, encrypt: encrypt2, _salter };
    return zipcrypto;
}
var hasRequiredMethods;
function requireMethods() {
    if (hasRequiredMethods)
        return methods;
    hasRequiredMethods = 1;
    methods.Deflater = requireDeflater();
    methods.Inflater = requireInflater();
    methods.ZipCrypto = requireZipcrypto();
    return methods;
}
var zipEntry;
var hasRequiredZipEntry;
function requireZipEntry() {
    if (hasRequiredZipEntry)
        return zipEntry;
    hasRequiredZipEntry = 1;
    var Utils = requireUtil(), Headers = requireHeaders(), Constants = Utils.Constants, Methods = requireMethods();
    zipEntry = function (options2, input) {
        var _centralHeader = new Headers.EntryHeader(), _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0), _extralocal = Buffer.alloc(0), _efs = true;
        const opts = options2;
        const decoder2 = typeof opts.decoder === "object" ? opts.decoder : Utils.decoder;
        _efs = decoder2.hasOwnProperty("efs") ? decoder2.efs : false;
        function getCompressedDataFromZip() {
            if (!input || !(input instanceof Uint8Array)) {
                return Buffer.alloc(0);
            }
            _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);
            return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);
        }
        function crc32OK(data) {
            if (!_centralHeader.flags_desc) {
                if (Utils.crc32(data) !== _centralHeader.localHeader.crc) {
                    return false;
                }
            }
            else {
                const descriptor = {};
                const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;
                if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {
                    throw Utils.Errors.DESCRIPTOR_NOT_EXIST();
                }
                if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {
                    descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);
                    descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);
                    descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);
                }
                else if (input.readUInt16LE(dataEndOffset + 12) === 19280) {
                    descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);
                    descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);
                    descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);
                }
                else {
                    throw Utils.Errors.DESCRIPTOR_UNKNOWN();
                }
                if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {
                    throw Utils.Errors.DESCRIPTOR_FAULTY();
                }
                if (Utils.crc32(data) !== descriptor.crc) {
                    return false;
                }
            }
            return true;
        }
        function decompress(async, callback, pass) {
            if (typeof callback === "undefined" && typeof async === "string") {
                pass = async;
                async = void 0;
            }
            if (_isDirectory) {
                if (async && callback) {
                    callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR());
                }
                return Buffer.alloc(0);
            }
            var compressedData = getCompressedDataFromZip();
            if (compressedData.length === 0) {
                if (async && callback)
                    callback(compressedData);
                return compressedData;
            }
            if (_centralHeader.encrypted) {
                if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
                    throw Utils.Errors.INVALID_PASS_PARAM();
                }
                compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);
            }
            var data = Buffer.alloc(_centralHeader.size);
            switch (_centralHeader.method) {
                case Utils.Constants.STORED:
                    compressedData.copy(data);
                    if (!crc32OK(data)) {
                        if (async && callback)
                            callback(data, Utils.Errors.BAD_CRC());
                        throw Utils.Errors.BAD_CRC();
                    }
                    else {
                        if (async && callback)
                            callback(data);
                        return data;
                    }
                case Utils.Constants.DEFLATED:
                    var inflater2 = new Methods.Inflater(compressedData, _centralHeader.size);
                    if (!async) {
                        const result = inflater2.inflate(data);
                        result.copy(data, 0);
                        if (!crc32OK(data)) {
                            throw Utils.Errors.BAD_CRC(`"${decoder2.decode(_entryName)}"`);
                        }
                        return data;
                    }
                    else {
                        inflater2.inflateAsync(function (result) {
                            result.copy(result, 0);
                            if (callback) {
                                if (!crc32OK(result)) {
                                    callback(result, Utils.Errors.BAD_CRC());
                                }
                                else {
                                    callback(result);
                                }
                            }
                        });
                    }
                    break;
                default:
                    if (async && callback)
                        callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD());
                    throw Utils.Errors.UNKNOWN_METHOD();
            }
        }
        function compress(async, callback) {
            if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
                if (async && callback)
                    callback(getCompressedDataFromZip());
                return getCompressedDataFromZip();
            }
            if (uncompressedData.length && !_isDirectory) {
                var compressedData;
                switch (_centralHeader.method) {
                    case Utils.Constants.STORED:
                        _centralHeader.compressedSize = _centralHeader.size;
                        compressedData = Buffer.alloc(uncompressedData.length);
                        uncompressedData.copy(compressedData);
                        if (async && callback)
                            callback(compressedData);
                        return compressedData;
                    default:
                    case Utils.Constants.DEFLATED:
                        var deflater2 = new Methods.Deflater(uncompressedData);
                        if (!async) {
                            var deflated = deflater2.deflate();
                            _centralHeader.compressedSize = deflated.length;
                            return deflated;
                        }
                        else {
                            deflater2.deflateAsync(function (data) {
                                compressedData = Buffer.alloc(data.length);
                                _centralHeader.compressedSize = data.length;
                                data.copy(compressedData);
                                callback && callback(compressedData);
                            });
                        }
                        deflater2 = null;
                        break;
                }
            }
            else if (async && callback) {
                callback(Buffer.alloc(0));
            }
            else {
                return Buffer.alloc(0);
            }
        }
        function readUInt64LE(buffer, offset) {
            return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
        }
        function parseExtra(data) {
            try {
                var offset = 0;
                var signature, size2, part;
                while (offset + 4 < data.length) {
                    signature = data.readUInt16LE(offset);
                    offset += 2;
                    size2 = data.readUInt16LE(offset);
                    offset += 2;
                    part = data.slice(offset, offset + size2);
                    offset += size2;
                    if (Constants.ID_ZIP64 === signature) {
                        parseZip64ExtendedInformation(part);
                    }
                }
            }
            catch (error) {
                throw Utils.Errors.EXTRA_FIELD_PARSE_ERROR();
            }
        }
        function parseZip64ExtendedInformation(data) {
            var size2, compressedSize, offset, diskNumStart;
            if (data.length >= Constants.EF_ZIP64_SCOMP) {
                size2 = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
                if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {
                    _centralHeader.size = size2;
                }
            }
            if (data.length >= Constants.EF_ZIP64_RHO) {
                compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
                if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
                    _centralHeader.compressedSize = compressedSize;
                }
            }
            if (data.length >= Constants.EF_ZIP64_DSN) {
                offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
                if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {
                    _centralHeader.offset = offset;
                }
            }
            if (data.length >= Constants.EF_ZIP64_DSN + 4) {
                diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
                if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
                    _centralHeader.diskNumStart = diskNumStart;
                }
            }
        }
        return {
            get entryName() {
                return decoder2.decode(_entryName);
            },
            get rawEntryName() {
                return _entryName;
            },
            set entryName(val2) {
                _entryName = Utils.toBuffer(val2, decoder2.encode);
                var lastChar = _entryName[_entryName.length - 1];
                _isDirectory = lastChar === 47 || lastChar === 92;
                _centralHeader.fileNameLength = _entryName.length;
            },
            get efs() {
                if (typeof _efs === "function") {
                    return _efs(this.entryName);
                }
                else {
                    return _efs;
                }
            },
            get extra() {
                return _extra;
            },
            set extra(val2) {
                _extra = val2;
                _centralHeader.extraLength = val2.length;
                parseExtra(val2);
            },
            get comment() {
                return decoder2.decode(_comment);
            },
            set comment(val2) {
                _comment = Utils.toBuffer(val2, decoder2.encode);
                _centralHeader.commentLength = _comment.length;
                if (_comment.length > 65535)
                    throw Utils.Errors.COMMENT_TOO_LONG();
            },
            get name() {
                var n = decoder2.decode(_entryName);
                return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop();
            },
            get isDirectory() {
                return _isDirectory;
            },
            getCompressedData: function () {
                return compress(false, null);
            },
            getCompressedDataAsync: function (callback) {
                compress(true, callback);
            },
            setData: function (value) {
                uncompressedData = Utils.toBuffer(value, Utils.decoder.encode);
                if (!_isDirectory && uncompressedData.length) {
                    _centralHeader.size = uncompressedData.length;
                    _centralHeader.method = Utils.Constants.DEFLATED;
                    _centralHeader.crc = Utils.crc32(value);
                    _centralHeader.changed = true;
                }
                else {
                    _centralHeader.method = Utils.Constants.STORED;
                }
            },
            getData: function (pass) {
                if (_centralHeader.changed) {
                    return uncompressedData;
                }
                else {
                    return decompress(false, null, pass);
                }
            },
            getDataAsync: function (callback, pass) {
                if (_centralHeader.changed) {
                    callback(uncompressedData);
                }
                else {
                    decompress(true, callback, pass);
                }
            },
            set attr(attr) {
                _centralHeader.attr = attr;
            },
            get attr() {
                return _centralHeader.attr;
            },
            set header(data) {
                _centralHeader.loadFromBinary(data);
            },
            get header() {
                return _centralHeader;
            },
            packCentralHeader: function () {
                _centralHeader.flags_efs = this.efs;
                _centralHeader.extraLength = _extra.length;
                var header = _centralHeader.centralHeaderToBinary();
                var addpos = Utils.Constants.CENHDR;
                _entryName.copy(header, addpos);
                addpos += _entryName.length;
                _extra.copy(header, addpos);
                addpos += _centralHeader.extraLength;
                _comment.copy(header, addpos);
                return header;
            },
            packLocalHeader: function () {
                let addpos = 0;
                _centralHeader.flags_efs = this.efs;
                _centralHeader.extraLocalLength = _extralocal.length;
                const localHeaderBuf = _centralHeader.localHeaderToBinary();
                const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);
                localHeaderBuf.copy(localHeader, addpos);
                addpos += localHeaderBuf.length;
                _entryName.copy(localHeader, addpos);
                addpos += _entryName.length;
                _extralocal.copy(localHeader, addpos);
                addpos += _extralocal.length;
                return localHeader;
            },
            toJSON: function () {
                const bytes = function (nr) {
                    return "<" + (nr && nr.length + " bytes buffer" || "null") + ">";
                };
                return {
                    entryName: this.entryName,
                    name: this.name,
                    comment: this.comment,
                    isDirectory: this.isDirectory,
                    header: _centralHeader.toJSON(),
                    compressedData: bytes(input),
                    data: bytes(uncompressedData)
                };
            },
            toString: function () {
                return JSON.stringify(this.toJSON(), null, "	");
            }
        };
    };
    return zipEntry;
}
var zipFile;
var hasRequiredZipFile;
function requireZipFile() {
    if (hasRequiredZipFile)
        return zipFile;
    hasRequiredZipFile = 1;
    const ZipEntry = requireZipEntry();
    const Headers = requireHeaders();
    const Utils = requireUtil();
    zipFile = function (inBuffer, options2) {
        var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader2 = new Headers.MainHeader(), loadedEntries = false;
        const temporary = /* @__PURE__ */ new Set();
        const opts = options2;
        const { noSort, decoder: decoder2 } = opts;
        if (inBuffer) {
            readMainHeader(opts.readEntries);
        }
        else {
            loadedEntries = true;
        }
        function makeTemporaryFolders() {
            const foldersList = /* @__PURE__ */ new Set();
            for (const elem of Object.keys(entryTable)) {
                const elements = elem.split("/");
                elements.pop();
                if (!elements.length)
                    continue;
                for (let i = 0; i < elements.length; i++) {
                    const sub = elements.slice(0, i + 1).join("/") + "/";
                    foldersList.add(sub);
                }
            }
            for (const elem of foldersList) {
                if (!(elem in entryTable)) {
                    const tempfolder = new ZipEntry(opts);
                    tempfolder.entryName = elem;
                    tempfolder.attr = 16;
                    tempfolder.temporary = true;
                    entryList.push(tempfolder);
                    entryTable[tempfolder.entryName] = tempfolder;
                    temporary.add(tempfolder);
                }
            }
        }
        function readEntries() {
            loadedEntries = true;
            entryTable = {};
            if (mainHeader2.diskEntries > (inBuffer.length - mainHeader2.offset) / Utils.Constants.CENHDR) {
                throw Utils.Errors.DISK_ENTRY_TOO_LARGE();
            }
            entryList = new Array(mainHeader2.diskEntries);
            var index = mainHeader2.offset;
            for (var i = 0; i < entryList.length; i++) {
                var tmp = index, entry = new ZipEntry(opts, inBuffer);
                entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);
                entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
                if (entry.header.extraLength) {
                    entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
                }
                if (entry.header.commentLength)
                    entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
                index += entry.header.centralHeaderSize;
                entryList[i] = entry;
                entryTable[entry.entryName] = entry;
            }
            temporary.clear();
            makeTemporaryFolders();
        }
        function readMainHeader(readNow) {
            var i = inBuffer.length - Utils.Constants.ENDHDR, max2 = Math.max(0, i - 65535), n = max2, endStart = inBuffer.length, endOffset = -1, commentEnd = 0;
            const trailingSpace = typeof opts.trailingSpace === "boolean" ? opts.trailingSpace : false;
            if (trailingSpace)
                max2 = 0;
            for (i; i >= n; i--) {
                if (inBuffer[i] !== 80)
                    continue;
                if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {
                    endOffset = i;
                    commentEnd = i;
                    endStart = i + Utils.Constants.ENDHDR;
                    n = i - Utils.Constants.END64HDR;
                    continue;
                }
                if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {
                    n = max2;
                    continue;
                }
                if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {
                    endOffset = i;
                    endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;
                    break;
                }
            }
            if (endOffset == -1)
                throw Utils.Errors.INVALID_FORMAT();
            mainHeader2.loadFromBinary(inBuffer.slice(endOffset, endStart));
            if (mainHeader2.commentLength) {
                _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
            }
            if (readNow)
                readEntries();
        }
        function sortEntries() {
            if (entryList.length > 1 && !noSort) {
                entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
            }
        }
        return {
            /**
             * Returns an array of ZipEntry objects existent in the current opened archive
             * @return Array
             */
            get entries() {
                if (!loadedEntries) {
                    readEntries();
                }
                return entryList.filter((e) => !temporary.has(e));
            },
            /**
             * Archive comment
             * @return {String}
             */
            get comment() {
                return decoder2.decode(_comment);
            },
            set comment(val2) {
                _comment = Utils.toBuffer(val2, decoder2.encode);
                mainHeader2.commentLength = _comment.length;
            },
            getEntryCount: function () {
                if (!loadedEntries) {
                    return mainHeader2.diskEntries;
                }
                return entryList.length;
            },
            forEach: function (callback) {
                this.entries.forEach(callback);
            },
            /**
             * Returns a reference to the entry with the given name or null if entry is inexistent
             *
             * @param entryName
             * @return ZipEntry
             */
            getEntry: function (entryName) {
                if (!loadedEntries) {
                    readEntries();
                }
                return entryTable[entryName] || null;
            },
            /**
             * Adds the given entry to the entry list
             *
             * @param entry
             */
            setEntry: function (entry) {
                if (!loadedEntries) {
                    readEntries();
                }
                entryList.push(entry);
                entryTable[entry.entryName] = entry;
                mainHeader2.totalEntries = entryList.length;
            },
            /**
             * Removes the file with the given name from the entry list.
             *
             * If the entry is a directory, then all nested files and directories will be removed
             * @param entryName
             * @returns {void}
             */
            deleteFile: function (entryName, withsubfolders = true) {
                if (!loadedEntries) {
                    readEntries();
                }
                const entry = entryTable[entryName];
                const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);
                list.forEach(this.deleteEntry);
            },
            /**
             * Removes the entry with the given name from the entry list.
             *
             * @param {string} entryName
             * @returns {void}
             */
            deleteEntry: function (entryName) {
                if (!loadedEntries) {
                    readEntries();
                }
                const entry = entryTable[entryName];
                const index = entryList.indexOf(entry);
                if (index >= 0) {
                    entryList.splice(index, 1);
                    delete entryTable[entryName];
                    mainHeader2.totalEntries = entryList.length;
                }
            },
            /**
             *  Iterates and returns all nested files and directories of the given entry
             *
             * @param entry
             * @return Array
             */
            getEntryChildren: function (entry, subfolders = true) {
                if (!loadedEntries) {
                    readEntries();
                }
                if (typeof entry === "object") {
                    if (entry.isDirectory && subfolders) {
                        const list = [];
                        const name = entry.entryName;
                        for (const zipEntry2 of entryList) {
                            if (zipEntry2.entryName.startsWith(name)) {
                                list.push(zipEntry2);
                            }
                        }
                        return list;
                    }
                    else {
                        return [entry];
                    }
                }
                return [];
            },
            /**
             *  How many child elements entry has
             *
             * @param {ZipEntry} entry
             * @return {integer}
             */
            getChildCount: function (entry) {
                if (entry && entry.isDirectory) {
                    const list = this.getEntryChildren(entry);
                    return list.includes(entry) ? list.length - 1 : list.length;
                }
                return 0;
            },
            /**
             * Returns the zip file
             *
             * @return Buffer
             */
            compressToBuffer: function () {
                if (!loadedEntries) {
                    readEntries();
                }
                sortEntries();
                const dataBlock = [];
                const headerBlocks = [];
                let totalSize = 0;
                let dindex = 0;
                mainHeader2.size = 0;
                mainHeader2.offset = 0;
                let totalEntries = 0;
                for (const entry of this.entries) {
                    const compressedData = entry.getCompressedData();
                    entry.header.offset = dindex;
                    const localHeader = entry.packLocalHeader();
                    const dataLength = localHeader.length + compressedData.length;
                    dindex += dataLength;
                    dataBlock.push(localHeader);
                    dataBlock.push(compressedData);
                    const centralHeader = entry.packCentralHeader();
                    headerBlocks.push(centralHeader);
                    mainHeader2.size += centralHeader.length;
                    totalSize += dataLength + centralHeader.length;
                    totalEntries++;
                }
                totalSize += mainHeader2.mainHeaderSize;
                mainHeader2.offset = dindex;
                mainHeader2.totalEntries = totalEntries;
                dindex = 0;
                const outBuffer = Buffer.alloc(totalSize);
                for (const content of dataBlock) {
                    content.copy(outBuffer, dindex);
                    dindex += content.length;
                }
                for (const content of headerBlocks) {
                    content.copy(outBuffer, dindex);
                    dindex += content.length;
                }
                const mh = mainHeader2.toBinary();
                if (_comment) {
                    _comment.copy(mh, Utils.Constants.ENDHDR);
                }
                mh.copy(outBuffer, dindex);
                inBuffer = outBuffer;
                loadedEntries = false;
                return outBuffer;
            },
            toAsyncBuffer: function (onSuccess, onFail, onItemStart, onItemEnd) {
                try {
                    if (!loadedEntries) {
                        readEntries();
                    }
                    sortEntries();
                    const dataBlock = [];
                    const centralHeaders = [];
                    let totalSize = 0;
                    let dindex = 0;
                    let totalEntries = 0;
                    mainHeader2.size = 0;
                    mainHeader2.offset = 0;
                    const compress2Buffer = function (entryLists) {
                        if (entryLists.length > 0) {
                            const entry = entryLists.shift();
                            const name = entry.entryName + entry.extra.toString();
                            if (onItemStart)
                                onItemStart(name);
                            entry.getCompressedDataAsync(function (compressedData) {
                                if (onItemEnd)
                                    onItemEnd(name);
                                entry.header.offset = dindex;
                                const localHeader = entry.packLocalHeader();
                                const dataLength = localHeader.length + compressedData.length;
                                dindex += dataLength;
                                dataBlock.push(localHeader);
                                dataBlock.push(compressedData);
                                const centalHeader = entry.packCentralHeader();
                                centralHeaders.push(centalHeader);
                                mainHeader2.size += centalHeader.length;
                                totalSize += dataLength + centalHeader.length;
                                totalEntries++;
                                compress2Buffer(entryLists);
                            });
                        }
                        else {
                            totalSize += mainHeader2.mainHeaderSize;
                            mainHeader2.offset = dindex;
                            mainHeader2.totalEntries = totalEntries;
                            dindex = 0;
                            const outBuffer = Buffer.alloc(totalSize);
                            dataBlock.forEach(function (content) {
                                content.copy(outBuffer, dindex);
                                dindex += content.length;
                            });
                            centralHeaders.forEach(function (content) {
                                content.copy(outBuffer, dindex);
                                dindex += content.length;
                            });
                            const mh = mainHeader2.toBinary();
                            if (_comment) {
                                _comment.copy(mh, Utils.Constants.ENDHDR);
                            }
                            mh.copy(outBuffer, dindex);
                            inBuffer = outBuffer;
                            loadedEntries = false;
                            onSuccess(outBuffer);
                        }
                    };
                    compress2Buffer(Array.from(this.entries));
                }
                catch (e) {
                    onFail(e);
                }
            }
        };
    };
    return zipFile;
}
var admZip;
var hasRequiredAdmZip;
function requireAdmZip() {
    if (hasRequiredAdmZip)
        return admZip;
    hasRequiredAdmZip = 1;
    const Utils = requireUtil();
    const pth = path;
    const ZipEntry = requireZipEntry();
    const ZipFile = requireZipFile();
    const get_Bool = (...val2) => Utils.findLast(val2, (c) => typeof c === "boolean");
    const get_Str = (...val2) => Utils.findLast(val2, (c) => typeof c === "string");
    const get_Fun = (...val2) => Utils.findLast(val2, (c) => typeof c === "function");
    const defaultOptions2 = {
        // option "noSort" : if true it disables files sorting
        noSort: false,
        // read entries during load (initial loading may be slower)
        readEntries: false,
        // default method is none
        method: Utils.Constants.NONE,
        // file system
        fs: null
    };
    admZip = function (input, options2) {
        let inBuffer = null;
        const opts = Object.assign(/* @__PURE__ */ Object.create(null), defaultOptions2);
        if (input && "object" === typeof input) {
            if (!(input instanceof Uint8Array)) {
                Object.assign(opts, input);
                input = opts.input ? opts.input : void 0;
                if (opts.input)
                    delete opts.input;
            }
            if (Buffer.isBuffer(input)) {
                inBuffer = input;
                opts.method = Utils.Constants.BUFFER;
                input = void 0;
            }
        }
        Object.assign(opts, options2);
        const filetools = new Utils(opts);
        if (typeof opts.decoder !== "object" || typeof opts.decoder.encode !== "function" || typeof opts.decoder.decode !== "function") {
            opts.decoder = Utils.decoder;
        }
        if (input && "string" === typeof input) {
            if (filetools.fs.existsSync(input)) {
                opts.method = Utils.Constants.FILE;
                opts.filename = input;
                inBuffer = filetools.fs.readFileSync(input);
            }
            else {
                throw Utils.Errors.INVALID_FILENAME();
            }
        }
        const _zip = new ZipFile(inBuffer, opts);
        const { canonical, sanitize, zipnamefix } = Utils;
        function getEntry(entry) {
            if (entry && _zip) {
                var item;
                if (typeof entry === "string")
                    item = _zip.getEntry(pth.posix.normalize(entry));
                if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined")
                    item = _zip.getEntry(entry.entryName);
                if (item) {
                    return item;
                }
            }
            return null;
        }
        function fixPath(zipPath) {
            const { join: join2, normalize, sep } = pth.posix;
            return join2(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
        }
        function filenameFilter(filterfn) {
            if (filterfn instanceof RegExp) {
                return /* @__PURE__ */ function (rx) {
                    return function (filename) {
                        return rx.test(filename);
                    };
                }(filterfn);
            }
            else if ("function" !== typeof filterfn) {
                return () => true;
            }
            return filterfn;
        }
        const relativePath = (local, entry) => {
            let lastChar = entry.slice(-1);
            lastChar = lastChar === filetools.sep ? filetools.sep : "";
            return pth.relative(local, entry) + lastChar;
        };
        return {
            /**
             * Extracts the given entry from the archive and returns the content as a Buffer object
             * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
             * @param {Buffer|string} [pass] - password
             * @return Buffer or Null in case of error
             */
            readFile: function (entry, pass) {
                var item = getEntry(entry);
                return item && item.getData(pass) || null;
            },
            /**
             * Returns how many child elements has on entry (directories) on files it is always 0
             * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
             * @returns {integer}
             */
            childCount: function (entry) {
                const item = getEntry(entry);
                if (item) {
                    return _zip.getChildCount(item);
                }
            },
            /**
             * Asynchronous readFile
             * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
             * @param {callback} callback
             *
             * @return Buffer or Null in case of error
             */
            readFileAsync: function (entry, callback) {
                var item = getEntry(entry);
                if (item) {
                    item.getDataAsync(callback);
                }
                else {
                    callback(null, "getEntry failed for:" + entry);
                }
            },
            /**
             * Extracts the given entry from the archive and returns the content as plain text in the given encoding
             * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry
             * @param {string} encoding - Optional. If no encoding is specified utf8 is used
             *
             * @return String
             */
            readAsText: function (entry, encoding) {
                var item = getEntry(entry);
                if (item) {
                    var data = item.getData();
                    if (data && data.length) {
                        return data.toString(encoding || "utf8");
                    }
                }
                return "";
            },
            /**
             * Asynchronous readAsText
             * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
             * @param {callback} callback
             * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used
             *
             * @return String
             */
            readAsTextAsync: function (entry, callback, encoding) {
                var item = getEntry(entry);
                if (item) {
                    item.getDataAsync(function (data, err) {
                        if (err) {
                            callback(data, err);
                            return;
                        }
                        if (data && data.length) {
                            callback(data.toString(encoding || "utf8"));
                        }
                        else {
                            callback("");
                        }
                    });
                }
                else {
                    callback("");
                }
            },
            /**
             * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
             *
             * @param {ZipEntry|string} entry
             * @returns {void}
             */
            deleteFile: function (entry, withsubfolders = true) {
                var item = getEntry(entry);
                if (item) {
                    _zip.deleteFile(item.entryName, withsubfolders);
                }
            },
            /**
             * Remove the entry from the file or directory without affecting any nested entries
             *
             * @param {ZipEntry|string} entry
             * @returns {void}
             */
            deleteEntry: function (entry) {
                var item = getEntry(entry);
                if (item) {
                    _zip.deleteEntry(item.entryName);
                }
            },
            /**
             * Adds a comment to the zip. The zip must be rewritten after adding the comment.
             *
             * @param {string} comment
             */
            addZipComment: function (comment) {
                _zip.comment = comment;
            },
            /**
             * Returns the zip comment
             *
             * @return String
             */
            getZipComment: function () {
                return _zip.comment || "";
            },
            /**
             * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
             * The comment cannot exceed 65535 characters in length
             *
             * @param {ZipEntry} entry
             * @param {string} comment
             */
            addZipEntryComment: function (entry, comment) {
                var item = getEntry(entry);
                if (item) {
                    item.comment = comment;
                }
            },
            /**
             * Returns the comment of the specified entry
             *
             * @param {ZipEntry} entry
             * @return String
             */
            getZipEntryComment: function (entry) {
                var item = getEntry(entry);
                if (item) {
                    return item.comment || "";
                }
                return "";
            },
            /**
             * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
             *
             * @param {ZipEntry} entry
             * @param {Buffer} content
             */
            updateFile: function (entry, content) {
                var item = getEntry(entry);
                if (item) {
                    item.setData(content);
                }
            },
            /**
             * Adds a file from the disk to the archive
             *
             * @param {string} localPath File to add to zip
             * @param {string} [zipPath] Optional path inside the zip
             * @param {string} [zipName] Optional name for the file
             * @param {string} [comment] Optional file comment
             */
            addLocalFile: function (localPath2, zipPath, zipName, comment) {
                if (filetools.fs.existsSync(localPath2)) {
                    zipPath = zipPath ? fixPath(zipPath) : "";
                    const p = pth.win32.basename(pth.win32.normalize(localPath2));
                    zipPath += zipName ? zipName : p;
                    const _attr = filetools.fs.statSync(localPath2);
                    const data = _attr.isFile() ? filetools.fs.readFileSync(localPath2) : Buffer.alloc(0);
                    if (_attr.isDirectory())
                        zipPath += filetools.sep;
                    this.addFile(zipPath, data, comment, _attr);
                }
                else {
                    throw Utils.Errors.FILE_NOT_FOUND(localPath2);
                }
            },
            /**
             * Callback for showing if everything was done.
             *
             * @callback doneCallback
             * @param {Error} err - Error object
             * @param {boolean} done - was request fully completed
             */
            /**
             * Adds a file from the disk to the archive
             *
             * @param {(object|string)} options - options object, if it is string it us used as localPath.
             * @param {string} options.localPath - Local path to the file.
             * @param {string} [options.comment] - Optional file comment.
             * @param {string} [options.zipPath] - Optional path inside the zip
             * @param {string} [options.zipName] - Optional name for the file
             * @param {doneCallback} callback - The callback that handles the response.
             */
            addLocalFileAsync: function (options3, callback) {
                options3 = typeof options3 === "object" ? options3 : { localPath: options3 };
                const localPath2 = pth.resolve(options3.localPath);
                const { comment } = options3;
                let { zipPath, zipName } = options3;
                const self2 = this;
                filetools.fs.stat(localPath2, function (err, stats) {
                    if (err)
                        return callback(err, false);
                    zipPath = zipPath ? fixPath(zipPath) : "";
                    const p = pth.win32.basename(pth.win32.normalize(localPath2));
                    zipPath += zipName ? zipName : p;
                    if (stats.isFile()) {
                        filetools.fs.readFile(localPath2, function (err2, data) {
                            if (err2)
                                return callback(err2, false);
                            self2.addFile(zipPath, data, comment, stats);
                            return setImmediate(callback, void 0, true);
                        });
                    }
                    else if (stats.isDirectory()) {
                        zipPath += filetools.sep;
                        self2.addFile(zipPath, Buffer.alloc(0), comment, stats);
                        return setImmediate(callback, void 0, true);
                    }
                });
            },
            /**
             * Adds a local directory and all its nested files and directories to the archive
             *
             * @param {string} localPath - local path to the folder
             * @param {string} [zipPath] - optional path inside zip
             * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.
             */
            addLocalFolder: function (localPath2, zipPath, filter) {
                filter = filenameFilter(filter);
                zipPath = zipPath ? fixPath(zipPath) : "";
                localPath2 = pth.normalize(localPath2);
                if (filetools.fs.existsSync(localPath2)) {
                    const items = filetools.findFiles(localPath2);
                    const self2 = this;
                    if (items.length) {
                        for (const filepath of items) {
                            const p = pth.join(zipPath, relativePath(localPath2, filepath));
                            if (filter(p)) {
                                self2.addLocalFile(filepath, pth.dirname(p));
                            }
                        }
                    }
                }
                else {
                    throw Utils.Errors.FILE_NOT_FOUND(localPath2);
                }
            },
            /**
             * Asynchronous addLocalFolder
             * @param {string} localPath
             * @param {callback} callback
             * @param {string} [zipPath] optional path inside zip
             * @param {RegExp|function} [filter] optional RegExp or Function if files match will
             *               be included.
             */
            addLocalFolderAsync: function (localPath2, callback, zipPath, filter) {
                filter = filenameFilter(filter);
                zipPath = zipPath ? fixPath(zipPath) : "";
                localPath2 = pth.normalize(localPath2);
                var self2 = this;
                filetools.fs.open(localPath2, "r", function (err) {
                    if (err && err.code === "ENOENT") {
                        callback(void 0, Utils.Errors.FILE_NOT_FOUND(localPath2));
                    }
                    else if (err) {
                        callback(void 0, err);
                    }
                    else {
                        var items = filetools.findFiles(localPath2);
                        var i = -1;
                        var next = function () {
                            i += 1;
                            if (i < items.length) {
                                var filepath = items[i];
                                var p = relativePath(localPath2, filepath).split("\\").join("/");
                                p = p.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
                                if (filter(p)) {
                                    filetools.fs.stat(filepath, function (er0, stats) {
                                        if (er0)
                                            callback(void 0, er0);
                                        if (stats.isFile()) {
                                            filetools.fs.readFile(filepath, function (er1, data) {
                                                if (er1) {
                                                    callback(void 0, er1);
                                                }
                                                else {
                                                    self2.addFile(zipPath + p, data, "", stats);
                                                    next();
                                                }
                                            });
                                        }
                                        else {
                                            self2.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                                            next();
                                        }
                                    });
                                }
                                else {
                                    process.nextTick(() => {
                                        next();
                                    });
                                }
                            }
                            else {
                                callback(true, void 0);
                            }
                        };
                        next();
                    }
                });
            },
            /**
             * Adds a local directory and all its nested files and directories to the archive
             *
             * @param {object | string} options - options object, if it is string it us used as localPath.
             * @param {string} options.localPath - Local path to the folder.
             * @param {string} [options.zipPath] - optional path inside zip.
             * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.
             * @param {function|string} [options.namefix] - optional function to help fix filename
             * @param {doneCallback} callback - The callback that handles the response.
             *
             */
            addLocalFolderAsync2: function (options3, callback) {
                const self2 = this;
                options3 = typeof options3 === "object" ? options3 : { localPath: options3 };
                localPath = pth.resolve(fixPath(options3.localPath));
                let { zipPath, filter, namefix } = options3;
                if (filter instanceof RegExp) {
                    filter = /* @__PURE__ */ function (rx) {
                        return function (filename) {
                            return rx.test(filename);
                        };
                    }(filter);
                }
                else if ("function" !== typeof filter) {
                    filter = function () {
                        return true;
                    };
                }
                zipPath = zipPath ? fixPath(zipPath) : "";
                if (namefix == "latin1") {
                    namefix = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
                }
                if (typeof namefix !== "function")
                    namefix = (str) => str;
                const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));
                const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));
                filetools.fs.open(localPath, "r", function (err) {
                    if (err && err.code === "ENOENT") {
                        callback(void 0, Utils.Errors.FILE_NOT_FOUND(localPath));
                    }
                    else if (err) {
                        callback(void 0, err);
                    }
                    else {
                        filetools.findFilesAsync(localPath, function (err2, fileEntries) {
                            if (err2)
                                return callback(err2);
                            fileEntries = fileEntries.filter((dir) => filter(relPathFix(dir)));
                            if (!fileEntries.length)
                                callback(void 0, false);
                            setImmediate(fileEntries.reverse().reduce(function (next, entry) {
                                return function (err3, done) {
                                    if (err3 || done === false)
                                        return setImmediate(next, err3, false);
                                    self2.addLocalFileAsync({
                                        localPath: entry,
                                        zipPath: pth.dirname(relPathFix(entry)),
                                        zipName: fileNameFix(entry)
                                    }, next);
                                };
                            }, callback));
                        });
                    }
                });
            },
            /**
             * Adds a local directory and all its nested files and directories to the archive
             *
             * @param {string} localPath - path where files will be extracted
             * @param {object} props - optional properties
             * @param {string} [props.zipPath] - optional path inside zip
             * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.
             * @param {function|string} [props.namefix] - optional function to help fix filename
             */
            addLocalFolderPromise: function (localPath2, props) {
                return new Promise((resolve, reject) => {
                    this.addLocalFolderAsync2(Object.assign({ localPath: localPath2 }, props), (err, done) => {
                        if (err)
                            reject(err);
                        if (done)
                            resolve(this);
                    });
                });
            },
            /**
             * Allows you to create a entry (file or directory) in the zip file.
             * If you want to create a directory the entryName must end in / and a null buffer should be provided.
             * Comment and attributes are optional
             *
             * @param {string} entryName
             * @param {Buffer | string} content - file content as buffer or utf8 coded string
             * @param {string} [comment] - file comment
             * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object
             */
            addFile: function (entryName, content, comment, attr) {
                entryName = zipnamefix(entryName);
                let entry = getEntry(entryName);
                const update2 = entry != null;
                if (!update2) {
                    entry = new ZipEntry(opts);
                    entry.entryName = entryName;
                }
                entry.comment = comment || "";
                const isStat = "object" === typeof attr && attr instanceof filetools.fs.Stats;
                if (isStat) {
                    entry.header.time = attr.mtime;
                }
                var fileattr = entry.isDirectory ? 16 : 0;
                let unix = entry.isDirectory ? 16384 : 32768;
                if (isStat) {
                    unix |= 4095 & attr.mode;
                }
                else if ("number" === typeof attr) {
                    unix |= 4095 & attr;
                }
                else {
                    unix |= entry.isDirectory ? 493 : 420;
                }
                fileattr = (fileattr | unix << 16) >>> 0;
                entry.attr = fileattr;
                entry.setData(content);
                if (!update2)
                    _zip.setEntry(entry);
                return entry;
            },
            /**
             * Returns an array of ZipEntry objects representing the files and folders inside the archive
             *
             * @param {string} [password]
             * @returns Array
             */
            getEntries: function (password) {
                _zip.password = password;
                return _zip ? _zip.entries : [];
            },
            /**
             * Returns a ZipEntry object representing the file or folder specified by ``name``.
             *
             * @param {string} name
             * @return ZipEntry
             */
            getEntry: function (name) {
                return getEntry(name);
            },
            getEntryCount: function () {
                return _zip.getEntryCount();
            },
            forEach: function (callback) {
                return _zip.forEach(callback);
            },
            /**
             * Extracts the given entry to the given targetPath
             * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
             *
             * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry
             * @param {string} targetPath - Target folder where to write the file
             * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE
             * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.
             * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.
             * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)
             *
             * @return Boolean
             */
            extractEntryTo: function (entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {
                overwrite = get_Bool(false, overwrite);
                keepOriginalPermission = get_Bool(false, keepOriginalPermission);
                maintainEntryPath = get_Bool(true, maintainEntryPath);
                outFileName = get_Str(keepOriginalPermission, outFileName);
                var item = getEntry(entry);
                if (!item) {
                    throw Utils.Errors.NO_ENTRY();
                }
                var entryName = canonical(item.entryName);
                var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));
                if (item.isDirectory) {
                    var children2 = _zip.getEntryChildren(item);
                    children2.forEach(function (child) {
                        if (child.isDirectory)
                            return;
                        var content2 = child.getData();
                        if (!content2) {
                            throw Utils.Errors.CANT_EXTRACT_FILE();
                        }
                        var name = canonical(child.entryName);
                        var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
                        const fileAttr2 = keepOriginalPermission ? child.header.fileAttr : void 0;
                        filetools.writeFileTo(childName, content2, overwrite, fileAttr2);
                    });
                    return true;
                }
                var content = item.getData(_zip.password);
                if (!content)
                    throw Utils.Errors.CANT_EXTRACT_FILE();
                if (filetools.fs.existsSync(target) && !overwrite) {
                    throw Utils.Errors.CANT_OVERRIDE();
                }
                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                filetools.writeFileTo(target, content, overwrite, fileAttr);
                return true;
            },
            /**
             * Test the archive
             * @param {string} [pass]
             */
            test: function (pass) {
                if (!_zip) {
                    return false;
                }
                for (var entry in _zip.entries) {
                    try {
                        if (entry.isDirectory) {
                            continue;
                        }
                        var content = _zip.entries[entry].getData(pass);
                        if (!content) {
                            return false;
                        }
                    }
                    catch (err) {
                        return false;
                    }
                }
                return true;
            },
            /**
             * Extracts the entire archive to the given location
             *
             * @param {string} targetPath Target location
             * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
             *                  Default is FALSE
             * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
             *                  Default is FALSE
             * @param {string|Buffer} [pass] password
             */
            extractAllTo: function (targetPath, overwrite, keepOriginalPermission, pass) {
                keepOriginalPermission = get_Bool(false, keepOriginalPermission);
                pass = get_Str(keepOriginalPermission, pass);
                overwrite = get_Bool(false, overwrite);
                if (!_zip)
                    throw Utils.Errors.NO_ZIP();
                _zip.entries.forEach(function (entry) {
                    var entryName = sanitize(targetPath, canonical(entry.entryName));
                    if (entry.isDirectory) {
                        filetools.makeDir(entryName);
                        return;
                    }
                    var content = entry.getData(pass);
                    if (!content) {
                        throw Utils.Errors.CANT_EXTRACT_FILE();
                    }
                    const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                    filetools.writeFileTo(entryName, content, overwrite, fileAttr);
                    try {
                        filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
                    }
                    catch (err) {
                        throw Utils.Errors.CANT_EXTRACT_FILE();
                    }
                });
            },
            /**
             * Asynchronous extractAllTo
             *
             * @param {string} targetPath Target location
             * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
             *                  Default is FALSE
             * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
             *                  Default is FALSE
             * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.
             */
            extractAllToAsync: function (targetPath, overwrite, keepOriginalPermission, callback) {
                callback = get_Fun(overwrite, keepOriginalPermission, callback);
                keepOriginalPermission = get_Bool(false, keepOriginalPermission);
                overwrite = get_Bool(false, overwrite);
                if (!callback) {
                    return new Promise((resolve, reject) => {
                        this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function (err) {
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve(this);
                            }
                        });
                    });
                }
                if (!_zip) {
                    callback(Utils.Errors.NO_ZIP());
                    return;
                }
                targetPath = pth.resolve(targetPath);
                const getPath2 = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));
                const getError = (msg, file) => new Error(msg + ': "' + file + '"');
                const dirEntries = [];
                const fileEntries = [];
                _zip.entries.forEach((e) => {
                    if (e.isDirectory) {
                        dirEntries.push(e);
                    }
                    else {
                        fileEntries.push(e);
                    }
                });
                for (const entry of dirEntries) {
                    const dirPath = getPath2(entry);
                    const dirAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                    try {
                        filetools.makeDir(dirPath);
                        if (dirAttr)
                            filetools.fs.chmodSync(dirPath, dirAttr);
                        filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
                    }
                    catch (er) {
                        callback(getError("Unable to create folder", dirPath));
                    }
                }
                fileEntries.reverse().reduce(function (next, entry) {
                    return function (err) {
                        if (err) {
                            next(err);
                        }
                        else {
                            const entryName = pth.normalize(canonical(entry.entryName));
                            const filePath = sanitize(targetPath, entryName);
                            entry.getDataAsync(function (content, err_1) {
                                if (err_1) {
                                    next(err_1);
                                }
                                else if (!content) {
                                    next(Utils.Errors.CANT_EXTRACT_FILE());
                                }
                                else {
                                    const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                                    filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {
                                        if (!succ) {
                                            next(getError("Unable to write file", filePath));
                                        }
                                        filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {
                                            if (err_2) {
                                                next(getError("Unable to set times", filePath));
                                            }
                                            else {
                                                next();
                                            }
                                        });
                                    });
                                }
                            });
                        }
                    };
                }, callback)();
            },
            /**
             * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
             *
             * @param {string} targetFileName
             * @param {function} callback
             */
            writeZip: function (targetFileName, callback) {
                if (arguments.length === 1) {
                    if (typeof targetFileName === "function") {
                        callback = targetFileName;
                        targetFileName = "";
                    }
                }
                if (!targetFileName && opts.filename) {
                    targetFileName = opts.filename;
                }
                if (!targetFileName)
                    return;
                var zipData = _zip.compressToBuffer();
                if (zipData) {
                    var ok = filetools.writeFileTo(targetFileName, zipData, true);
                    if (typeof callback === "function")
                        callback(!ok ? new Error("failed") : null, "");
                }
            },
            /**
                       *
                       * @param {string} targetFileName
                       * @param {object} [props]
                       * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.
                       * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.
            
                       * @returns {Promise<void>}
                       */
            writeZipPromise: function (targetFileName, props) {
                const { overwrite, perm } = Object.assign({ overwrite: true }, props);
                return new Promise((resolve, reject) => {
                    if (!targetFileName && opts.filename)
                        targetFileName = opts.filename;
                    if (!targetFileName)
                        reject("ADM-ZIP: ZIP File Name Missing");
                    this.toBufferPromise().then((zipData) => {
                        const ret = (done) => done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file");
                        filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
                    }, reject);
                });
            },
            /**
             * @returns {Promise<Buffer>} A promise to the Buffer.
             */
            toBufferPromise: function () {
                return new Promise((resolve, reject) => {
                    _zip.toAsyncBuffer(resolve, reject);
                });
            },
            /**
             * Returns the content of the entire zip file as a Buffer object
             *
             * @prop {function} [onSuccess]
             * @prop {function} [onFail]
             * @prop {function} [onItemStart]
             * @prop {function} [onItemEnd]
             * @returns {Buffer}
             */
            toBuffer: function (onSuccess, onFail, onItemStart, onItemEnd) {
                if (typeof onSuccess === "function") {
                    _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
                    return null;
                }
                return _zip.compressToBuffer();
            }
        };
    };
    return admZip;
}
var admZipExports = requireAdmZip();
const AdmZip = /* @__PURE__ */ getDefaultExportFromCjs(admZipExports);
const UPLOAD_FREQUENCY_IN_DAYS = 7;
async function checkHTTPStatus(res) {
    if (res.status !== 200) {
        if (res.status === 403) {
            try {
                const text = await res.text();
                const data = JSON.parse(text)?.data;
                if (data?.reason === "token-expired") {
                    await removeItem("user-token");
                    throw new HTTPError(403, "token-expired");
                }
            }
            catch (e) {
                if (e instanceof HTTPError)
                    throw e;
            }
        }
        return res.text().then((str) => {
            throw new HTTPError(res.status, str);
        });
    }
    else {
        return res;
    }
}
async function fetchJSON(...args) {
    let res = await fetch$1(...args);
    res = await checkHTTPStatus(res);
    return res.json();
}
async function checkKey() {
    const userToken = await getItem("user-token");
    const { cloudFileId, encryptKeyId } = getPrefs();
    let res;
    try {
        res = await post(getServer().SYNC_SERVER + "/user-get-key", {
            token: userToken,
            fileId: cloudFileId
        });
    }
    catch (e) {
        logger.log(e);
        return { valid: false, error: { reason: "network" } };
    }
    return {
        valid: (
        // This == comparison is important, they could be null or undefined
        // eslint-disable-next-line eqeqeq
        res.id == encryptKeyId && (encryptKeyId == null || hasKey(encryptKeyId)))
    };
}
async function resetSyncState(newKeyState) {
    const userToken = await getItem("user-token");
    const { cloudFileId } = getPrefs();
    try {
        await post(getServer().SYNC_SERVER + "/reset-user-file", {
            token: userToken,
            fileId: cloudFileId
        });
    }
    catch (e) {
        if (e instanceof PostError) {
            return {
                error: {
                    reason: e.reason === "unauthorized" ? "unauthorized" : "network"
                }
            };
        }
        return { error: { reason: "internal" } };
    }
    if (newKeyState) {
        try {
            await post(getServer().SYNC_SERVER + "/user-create-key", {
                token: userToken,
                fileId: cloudFileId,
                keyId: newKeyState.key.getId(),
                keySalt: newKeyState.salt,
                testContent: newKeyState.testContent
            });
        }
        catch (e) {
            if (e instanceof PostError) {
                return { error: { reason: "network" } };
            }
            return { error: { reason: "internal" } };
        }
    }
    return {};
}
async function exportBuffer() {
    const { id: id2, budgetName } = getPrefs();
    if (!budgetName) {
        return null;
    }
    const budgetDir = getBudgetDir(id2);
    const zipped = new AdmZip();
    await runMutator(async () => {
        const rawDbContent = await readFile(join$1(budgetDir, "db.sqlite"), "binary");
        const memDb = await openDatabase$1(rawDbContent);
        execQuery$2(memDb, `
        DELETE FROM kvcache;
        DELETE FROM kvcache_key;
      `);
        const dbContent = await exportDatabase(memDb);
        closeDatabase$1(memDb);
        const meta = JSON.parse(await readFile(join$1(budgetDir, "metadata.json")));
        meta.resetClock = true;
        const metaContent = Buffer.from(JSON.stringify(meta), "utf8");
        zipped.addFile("db.sqlite", Buffer.from(dbContent));
        zipped.addFile("metadata.json", metaContent);
    });
    return Buffer.from(zipped.toBuffer());
}
async function importBuffer(fileData, buffer) {
    let zipped, entries;
    try {
        zipped = new AdmZip(buffer);
        entries = zipped.getEntries();
    }
    catch (err) {
        throw FileDownloadError("not-zip-file");
    }
    const dbEntry = entries.find((e) => e.entryName.includes("db.sqlite"));
    const metaEntry = entries.find((e) => e.entryName.includes("metadata.json"));
    if (!dbEntry || !metaEntry) {
        throw FileDownloadError("invalid-zip-file");
    }
    const dbContent = zipped.readFile(dbEntry);
    const metaContent = zipped.readFile(metaEntry);
    let meta;
    try {
        meta = JSON.parse(metaContent.toString("utf8"));
    }
    catch (err) {
        throw FileDownloadError("invalid-meta-file");
    }
    meta = {
        ...meta,
        cloudFileId: fileData.fileId,
        groupId: fileData.groupId,
        lastUploaded: currentDay(),
        encryptKeyId: fileData.encryptMeta ? fileData.encryptMeta.keyId : null
    };
    const budgetDir = getBudgetDir(meta.id);
    if (await exists(budgetDir)) {
        const dbFile = join$1(budgetDir, "db.sqlite");
        const metaFile = join$1(budgetDir, "metadata.json");
        if (await exists(dbFile)) {
            await removeFile$1(dbFile);
        }
        if (await exists(metaFile)) {
            await removeFile$1(metaFile);
        }
    }
    else {
        await mkdir(budgetDir);
    }
    await writeFile(join$1(budgetDir, "db.sqlite"), dbContent);
    await writeFile(join$1(budgetDir, "metadata.json"), JSON.stringify(meta));
    return { id: meta.id };
}
async function upload() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        throw FileUploadError("unauthorized");
    }
    const zipContent = await exportBuffer();
    if (zipContent == null) {
        return;
    }
    const { id: id2, groupId, budgetName, cloudFileId: originalCloudFileId, encryptKeyId } = getPrefs();
    let cloudFileId = originalCloudFileId;
    let uploadContent = zipContent;
    let uploadMeta = null;
    if (encryptKeyId) {
        let encrypted;
        try {
            encrypted = await encrypt(zipContent, encryptKeyId);
        }
        catch (e) {
            throw FileUploadError("encrypt-failure", {
                isMissingKey: e.message === "missing-key"
            });
        }
        uploadContent = encrypted.value;
        uploadMeta = encrypted.meta;
    }
    if (!cloudFileId) {
        cloudFileId = v4();
    }
    let res;
    try {
        res = await fetchJSON(getServer().SYNC_SERVER + "/upload-user-file", {
            method: "POST",
            headers: {
                "Content-Length": uploadContent.length,
                "Content-Type": "application/encrypted-file",
                "X-ACTUAL-TOKEN": userToken,
                "X-ACTUAL-FILE-ID": cloudFileId,
                "X-ACTUAL-NAME": encodeURIComponent(budgetName),
                "X-ACTUAL-FORMAT": 2,
                ...uploadMeta ? { "X-ACTUAL-ENCRYPT-META": JSON.stringify(uploadMeta) } : null,
                ...groupId ? { "X-ACTUAL-GROUP-ID": groupId } : null
                // TODO: fix me
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            },
            body: uploadContent
        });
    }
    catch (err) {
        logger.log("Upload failure", err);
        if (err instanceof PostError) {
            throw FileUploadError(err.reason === "unauthorized" ? "unauthorized" : err.reason || "network");
        }
        throw FileUploadError("internal");
    }
    if (res.status === "ok") {
        if (getPrefs() && getPrefs().id === id2) {
            await savePrefs({
                lastUploaded: currentDay(),
                cloudFileId,
                groupId: res.groupId
            });
        }
    }
    else {
        throw FileUploadError("internal");
    }
}
async function possiblyUpload() {
    const { cloudFileId, groupId, lastUploaded } = getPrefs();
    const threshold = lastUploaded && addDays(lastUploaded, UPLOAD_FREQUENCY_IN_DAYS);
    const currentDay$1 = currentDay();
    if (lastUploaded && currentDay$1 < threshold) {
        return;
    }
    if (!cloudFileId || !groupId) {
        return;
    }
    upload().catch(() => {
    });
}
async function removeFile(fileId) {
    const userToken = await getItem("user-token");
    await post(getServer().SYNC_SERVER + "/delete-user-file", {
        token: userToken,
        fileId
    });
}
async function listRemoteFiles() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return null;
    }
    let res;
    try {
        res = await fetchJSON(getServer().SYNC_SERVER + "/list-user-files", {
            headers: {
                "X-ACTUAL-TOKEN": userToken
            }
        });
    }
    catch (e) {
        logger.log("Unexpected error fetching file list from server", e);
        return null;
    }
    if (res.status === "error") {
        logger.log("Error fetching file list from server", res);
        return null;
    }
    return res.data.map((file) => ({
        ...file,
        hasKey: hasKey(file.encryptKeyId)
    })).filter(Boolean);
}
async function getRemoteFile(fileId) {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return null;
    }
    let res;
    try {
        res = await fetchJSON(getServer().SYNC_SERVER + "/get-user-file-info", {
            headers: {
                "X-ACTUAL-TOKEN": userToken,
                "X-ACTUAL-FILE-ID": fileId
            }
        });
    }
    catch (e) {
        logger.log("Unexpected error fetching file from server", e);
        return null;
    }
    if (res.status === "error") {
        logger.log("Error fetching file from server", res);
        return null;
    }
    return {
        ...res.data,
        hasKey: hasKey(res.data.encryptKeyId)
    };
}
async function download(cloudFileId) {
    const userToken = await getItem("user-token");
    const syncServer = getServer().SYNC_SERVER;
    const userFileFetch = fetch$1(`${syncServer}/download-user-file`, {
        headers: {
            "X-ACTUAL-TOKEN": userToken,
            "X-ACTUAL-FILE-ID": cloudFileId
        }
    }).then(checkHTTPStatus).then((res) => {
        if (res.arrayBuffer) {
            return res.arrayBuffer().then((ab) => Buffer.from(ab));
        }
        return res.buffer();
    }).catch((err) => {
        logger.log("Download failure", err);
        throw FileDownloadError("download-failure");
    });
    const userFileInfoFetch = fetchJSON(`${syncServer}/get-user-file-info`, {
        headers: {
            "X-ACTUAL-TOKEN": userToken,
            "X-ACTUAL-FILE-ID": cloudFileId
        }
    }).catch((err) => {
        logger.log("Error fetching file info", err);
        throw FileDownloadError("internal", { fileId: cloudFileId });
    });
    const [userFileInfoRes, userFileRes] = await Promise.all([
        userFileInfoFetch,
        userFileFetch
    ]);
    if (userFileInfoRes.status !== "ok") {
        logger.log("Could not download file from the server. Are you sure you have the right file ID?", userFileInfoRes);
        throw FileDownloadError("internal", { fileId: cloudFileId });
    }
    const fileData = userFileInfoRes.data;
    let buffer = userFileRes;
    if (fileData.encryptMeta) {
        try {
            buffer = await decrypt(buffer, fileData.encryptMeta);
        }
        catch (e) {
            throw FileDownloadError("decrypt-failure", {
                isMissingKey: e.message === "missing-key"
            });
        }
    }
    return importBuffer(fileData, buffer);
}
async function resetSync$1(keyState) {
    if (!keyState) {
        const { valid, error: error2 } = await checkKey();
        if (error2) {
            return { error: error2 };
        }
        else if (!valid) {
            return { error: { reason: "file-has-new-key" } };
        }
    }
    const { error } = await resetSyncState(keyState);
    if (error) {
        return { error };
    }
    await runMutator(async () => {
        await execQuery(`
      DELETE FROM messages_crdt;
      DELETE FROM messages_clock;
      DELETE FROM transactions WHERE tombstone = 1;
      DELETE FROM accounts WHERE tombstone = 1;
      DELETE FROM payees WHERE tombstone = 1;
      DELETE FROM categories WHERE tombstone = 1;
      DELETE FROM category_groups WHERE tombstone = 1;
      DELETE FROM schedules WHERE tombstone = 1;
      DELETE FROM rules WHERE tombstone = 1;
      ANALYZE;
      VACUUM;
    `);
        await loadClock();
    });
    await savePrefs({
        groupId: null,
        lastSyncedTimestamp: null,
        lastUploaded: null
    });
    if (keyState) {
        const { key } = keyState;
        const { cloudFileId } = getPrefs();
        const keys2 = JSON.parse(await getItem(`encrypt-keys`) || "{}");
        keys2[cloudFileId] = key.serialize();
        await setItem("encrypt-keys", JSON.stringify(keys2));
        await savePrefs({ encryptKeyId: key.getId() });
    }
    try {
        await upload();
    }
    catch (e) {
        if (e.reason) {
            return { error: e };
        }
        captureException(e);
        return { error: { reason: "upload-failure" } };
    }
    finally {
    }
    return {};
}
const FULL_SYNC_DELAY = 1e3;
let SYNCING_MODE = "enabled";
function setSyncingMode(mode) {
    const prevMode = SYNCING_MODE;
    switch (mode) {
        case "enabled":
            SYNCING_MODE = "enabled";
            break;
        case "offline":
            SYNCING_MODE = "offline";
            break;
        case "disabled":
            SYNCING_MODE = "disabled";
            break;
        case "import":
            SYNCING_MODE = "import";
            break;
        default:
            throw new Error("setSyncingMode: invalid mode: " + mode);
    }
    return prevMode;
}
function checkSyncingMode(mode) {
    switch (mode) {
        case "enabled":
            return SYNCING_MODE === "enabled" || SYNCING_MODE === "offline";
        case "disabled":
            return SYNCING_MODE === "disabled" || SYNCING_MODE === "import";
        case "offline":
            return SYNCING_MODE === "offline";
        case "import":
            return SYNCING_MODE === "import";
        default:
            throw new Error("checkSyncingMode: invalid mode: " + mode);
    }
}
function apply(msg, prev) {
    const { dataset, row, column, value } = msg;
    if (dataset === "prefs")
        ;
    else {
        let query;
        try {
            if (prev) {
                query = {
                    sql: `UPDATE ${dataset} SET ${column} = ? WHERE id = ?`,
                    params: [value, row]
                };
            }
            else {
                query = {
                    sql: `INSERT INTO ${dataset} (id, ${column}) VALUES (?, ?)`,
                    params: [row, value]
                };
            }
            runQuery(cache(query.sql), query.params);
        }
        catch (error) {
            throw new SyncError("invalid-schema", {
                error: { message: error.message, stack: error.stack },
                query
            });
        }
    }
}
async function fetchAll(table, ids) {
    let results = [];
    const batchSize = 100;
    for (let i = 0; i < ids.length; i += batchSize) {
        const partIds = ids.slice(i, i + batchSize);
        let sql;
        let column = `${table}.id`;
        if (table === "transactions") {
            sql = `
        SELECT t.*, c.transferId AS category
        FROM transactions t
        LEFT JOIN category_mapping c ON c.id = t.category
      `;
            column = "t.id";
        }
        else {
            sql = `SELECT * FROM ${table}`;
        }
        sql += ` WHERE `;
        sql += partIds.map(() => `${column} = ?`).join(" OR ");
        try {
            const rows = await runQuery(sql, partIds, true);
            results = results.concat(rows);
        }
        catch (error) {
            throw new SyncError("invalid-schema", {
                error: {
                    message: error.message,
                    stack: error.stack
                },
                query: { sql, params: partIds }
            });
        }
    }
    return results;
}
function serializeValue(value) {
    if (value === null) {
        return "0:";
    }
    else if (typeof value === "number") {
        return "N:" + value;
    }
    else if (typeof value === "string") {
        return "S:" + value;
    }
    throw new Error("Unserializable value type: " + JSON.stringify(value));
}
function deserializeValue(value) {
    const type2 = value[0];
    switch (type2) {
        case "0":
            return null;
        case "N":
            return parseFloat(value.slice(2));
        case "S":
            return value.slice(2);
    }
    throw new Error("Invalid type key for value: " + value);
}
let _syncListeners = [];
function addSyncListener(func) {
    _syncListeners.push(func);
    return () => {
        _syncListeners = _syncListeners.filter((f2) => f2 !== func);
    };
}
async function compareMessages(messages) {
    const newMessages = [];
    for (let i = 0; i < messages.length; i++) {
        const message2 = messages[i];
        const { dataset, row, column, timestamp } = message2;
        const timestampStr = timestamp.toString();
        const res = runQuery(cache("SELECT timestamp FROM messages_crdt WHERE dataset = ? AND row = ? AND column = ? AND timestamp >= ?"), [dataset, row, column, timestampStr], true);
        if (res.length === 0) {
            newMessages.push(message2);
        }
        else if (res[0].timestamp !== timestampStr) {
            newMessages.push({ ...message2, old: true });
        }
    }
    return newMessages;
}
function applyMessagesForImport(messages) {
    transaction(() => {
        for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            const { dataset } = msg;
            if (!msg.old) {
                try {
                    apply(msg);
                }
                catch (e) {
                    apply(msg, true);
                }
                if (dataset === "prefs") {
                    throw new Error("Cannot set prefs while importing");
                }
            }
        }
    });
}
const applyMessages = sequential(async (messages) => {
    if (checkSyncingMode("import")) {
        applyMessagesForImport(messages);
        return void 0;
    }
    else if (checkSyncingMode("enabled")) {
        messages = await compareMessages(messages);
    }
    messages = [...messages].sort((m1, m2) => {
        const t1 = m1.timestamp ? m1.timestamp.toString() : "";
        const t2 = m2.timestamp ? m2.timestamp.toString() : "";
        if (t1 < t2) {
            return -1;
        }
        else if (t1 > t2) {
            return 1;
        }
        return 0;
    });
    const idsPerTable = {};
    messages.forEach((msg) => {
        if (msg.dataset === "prefs") {
            return;
        }
        if (idsPerTable[msg.dataset] == null) {
            idsPerTable[msg.dataset] = [];
        }
        idsPerTable[msg.dataset].push(msg.row);
    });
    async function fetchData() {
        const data = /* @__PURE__ */ new Map();
        for (const table of Object.keys(idsPerTable)) {
            const rows = await fetchAll(table, idsPerTable[table]);
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                setIn(data, [table, row.id], row);
            }
        }
        return data;
    }
    const prefsToSet = {};
    const oldData = await fetchData();
    appendMessages(messages, oldData);
    let clock2;
    let currentMerkle;
    if (checkSyncingMode("enabled")) {
        clock2 = getClock();
        currentMerkle = clock2.merkle;
    }
    if (get$3()) {
        get$3().startCacheBarrier();
    }
    transaction(() => {
        const added = /* @__PURE__ */ new Set();
        for (const msg of messages) {
            const { dataset, row, column, timestamp, value } = msg;
            if (!msg.old) {
                apply(msg, getIn(oldData, [dataset, row]) || added.has(dataset + row));
                if (dataset === "prefs") {
                    prefsToSet[row] = value;
                }
                else {
                    added.add(dataset + row);
                }
            }
            if (checkSyncingMode("enabled")) {
                runQuery(cache(`INSERT INTO messages_crdt (timestamp, dataset, row, column, value)
           VALUES (?, ?, ?, ?, ?)`), [timestamp.toString(), dataset, row, column, serializeValue(value)]);
                currentMerkle = insert$1(currentMerkle, timestamp);
            }
            if (dataset === "preferences" && row === "budgetType") {
                setType(value);
            }
        }
        if (checkSyncingMode("enabled")) {
            currentMerkle = prune(currentMerkle);
            runQuery(cache("INSERT OR REPLACE INTO messages_clock (id, clock) VALUES (1, ?)"), [serializeClock({ ...clock2, merkle: currentMerkle })]);
        }
    });
    if (checkSyncingMode("enabled")) {
        clock2.merkle = currentMerkle;
    }
    if (Object.keys(prefsToSet).length > 0) {
        savePrefs(prefsToSet, { avoidSync: true });
    }
    const newData = await fetchData();
    if (get$3()) {
        startTransaction();
        triggerBudgetChanges(oldData, newData);
        get$3().triggerDatabaseChanges(oldData, newData);
        endTransaction();
        get$3().endCacheBarrier();
    }
    _syncListeners.forEach((func) => func(oldData, newData));
    const tables = getTablesFromMessages(messages.filter((msg) => !msg.old));
    app$j.events.emit("sync", {
        type: "applied",
        tables,
        data: newData,
        prevData: oldData
    });
    return messages;
});
function receiveMessages(messages) {
    messages.forEach((msg) => {
        Timestamp.recv(msg.timestamp);
    });
    return runMutator(() => applyMessages(messages));
}
async function _sendMessages(messages) {
    try {
        await applyMessages(messages);
    }
    catch (e) {
        if (e instanceof SyncError) {
            if (e.reason === "invalid-schema") {
                app$j.events.emit("sync", {
                    type: "error",
                    subtype: "apply-failure",
                    meta: e.meta
                });
            }
            else {
                app$j.events.emit("sync", { type: "error", meta: e.meta });
            }
        }
        throw e;
    }
    await scheduleFullSync();
}
let IS_BATCHING = false;
let _BATCHED = [];
async function batchMessages(func) {
    if (IS_BATCHING) {
        await func();
        return;
    }
    IS_BATCHING = true;
    let batched = [];
    try {
        await func();
    }
    finally {
        IS_BATCHING = false;
        batched = _BATCHED;
        _BATCHED = [];
    }
    if (batched.length > 0) {
        await _sendMessages(batched);
    }
}
async function sendMessages(messages) {
    if (IS_BATCHING) {
        _BATCHED = _BATCHED.concat(messages);
    }
    else {
        return _sendMessages(messages);
    }
}
function getMessagesSince(since) {
    return runQuery("SELECT timestamp, dataset, row, column, value FROM messages_crdt WHERE timestamp > ?", [since], true);
}
function clearFullSyncTimeout() {
    if (syncTimeout) {
        clearTimeout(syncTimeout);
        syncTimeout = null;
    }
}
let syncTimeout = null;
function scheduleFullSync() {
    clearFullSyncTimeout();
    if (checkSyncingMode("enabled") && !checkSyncingMode("offline")) {
        if (process.env.NODE_ENV === "test") {
            return fullSync().then((res) => {
                if (isError(res)) {
                    throw res.error;
                }
                return res;
            });
        }
        else {
            syncTimeout = setTimeout(fullSync, FULL_SYNC_DELAY);
        }
    }
}
function getTablesFromMessages(messages) {
    return messages.reduce((acc, message2) => {
        const dataset = message2.dataset === "schedules_next_date" ? "schedules" : message2.dataset;
        if (!acc.includes(dataset)) {
            acc.push(dataset);
        }
        return acc;
    }, []);
}
async function initialFullSync() {
    const result = await fullSync();
    if (isError(result)) {
        await waitOnSpreadsheet();
        return result;
    }
    return {};
}
const fullSync = once(async function () {
    app$j.events.emit("sync", { type: "start" });
    let messages;
    try {
        messages = await _fullSync(null, 0, null);
    }
    catch (e) {
        logger.log(e);
        if (e instanceof SyncError) {
            if (e.reason === "out-of-sync") {
                captureException(e);
                app$j.events.emit("sync", {
                    type: "error",
                    subtype: "out-of-sync",
                    meta: e.meta
                });
            }
            else if (e.reason === "invalid-schema") {
                app$j.events.emit("sync", {
                    type: "error",
                    subtype: "invalid-schema",
                    meta: e.meta
                });
            }
            else if (e.reason === "decrypt-failure" || e.reason === "encrypt-failure") {
                app$j.events.emit("sync", {
                    type: "error",
                    subtype: e.reason,
                    meta: e.meta
                });
            }
            else {
                app$j.events.emit("sync", { type: "error", meta: e.meta });
            }
        }
        else if (e instanceof PostError) {
            logger.log(e);
            if (e.reason === "unauthorized") {
                app$j.events.emit("sync", { type: "unauthorized" });
                setItem("readOnly", "true");
            }
            else if (e.reason === "network-failure") {
                app$j.events.emit("sync", { type: "error", subtype: "network" });
            }
            else {
                app$j.events.emit("sync", { type: "error", subtype: e.reason });
            }
        }
        else {
            captureException(e);
            app$j.events.emit("sync", { type: "error" });
        }
        return { error: { message: e.message, reason: e.reason, meta: e.meta } };
    }
    const tables = getTablesFromMessages(messages);
    app$j.events.emit("sync", {
        type: "success",
        tables,
        syncDisabled: checkSyncingMode("disabled")
    });
    return { messages };
});
async function _fullSync(sinceTimestamp, count, prevDiffTime) {
    const { id: currentId, cloudFileId, groupId, lastSyncedTimestamp } = getPrefs() || {};
    clearFullSyncTimeout();
    if (checkSyncingMode("disabled") || checkSyncingMode("offline") || !currentId) {
        return [];
    }
    const currentTime = getClock().timestamp.toString();
    const since = sinceTimestamp || lastSyncedTimestamp || // Default to 5 minutes ago
        new Timestamp(Date.now() - 5 * 60 * 1e3, 0, "0").toString();
    const messages = getMessagesSince(since);
    const userToken = await getItem("user-token");
    logger.info("Syncing since", since, messages.length, "(attempt: " + count + ")");
    const buffer = await encode(groupId, cloudFileId, since, messages);
    const resBuffer = await postBinary(getServer().SYNC_SERVER + "/sync", buffer, {
        "X-ACTUAL-TOKEN": userToken
    });
    if (!getPrefs() || getPrefs().groupId !== groupId) {
        return [];
    }
    const res = await decode(resBuffer);
    logger.info("Got messages from server", res.messages.length);
    const localTimeChanged = getClock().timestamp.toString() !== currentTime;
    let receivedMessages = [];
    if (res.messages.length > 0) {
        receivedMessages = await receiveMessages(res.messages.map((msg) => ({
            ...msg,
            value: deserializeValue(msg.value)
        })));
    }
    const diffTime = diff(res.merkle, getClock().merkle);
    if (diffTime !== null) {
        if (count >= 10 && diffTime === prevDiffTime || count >= 100) {
            logger.info("SENT -------");
            logger.info(JSON.stringify(messages));
            logger.info("RECEIVED -------");
            logger.info(JSON.stringify(res.messages));
            const rebuiltMerkle = rebuildMerkleHash();
            logger.log(count, "messages:", messages.length, messages.length > 0 ? messages[0] : null, "res.messages:", res.messages.length, res.messages.length > 0 ? res.messages[0] : null, "clientId", getClock().timestamp.node(), "groupId", groupId, "diffTime:", diffTime, diffTime === prevDiffTime, "local clock:", getClock().timestamp.toString(), getClock().merkle.hash, "rebuilt hash:", rebuiltMerkle.numMessages, rebuiltMerkle.trie.hash, "server hash:", res.merkle.hash, "localTimeChanged:", localTimeChanged);
            if (rebuiltMerkle.trie.hash === res.merkle.hash) {
                const clocks = await all("SELECT * FROM messages_clock");
                if (clocks.length !== 1) {
                    logger.log("Bad number of clocks:", clocks.length);
                }
                const hash = deserializeClock(clocks[0].clock).merkle.hash;
                logger.log("Merkle hash in db:", hash);
            }
            throw new SyncError("out-of-sync");
        }
        receivedMessages = receivedMessages.concat(await _fullSync(new Timestamp(diffTime, 0, "0").toString(), 
        // If something local changed while we were syncing, always
        // reset, token the counter. We never want to think syncing failed
        // because we tried to syncing many times and couldn't sync,
        // but it was because the user kept changing stuff in the
        // middle of syncing.
        localTimeChanged ? 0 : count + 1, diffTime));
    }
    else {
        const requiresUpdate = getClock().timestamp.toString() !== lastSyncedTimestamp;
        if (requiresUpdate) {
            await savePrefs({
                lastSyncedTimestamp: getClock().timestamp.toString()
            });
        }
    }
    return receivedMessages;
}
const SORT_INCREMENT = 16384;
function midpoint(items, to) {
    const below = items[to - 1];
    const above = items[to];
    if (!below) {
        return above.sort_order / 2;
    }
    else if (!above) {
        return below.sort_order + SORT_INCREMENT;
    }
    else {
        return (below.sort_order + above.sort_order) / 2;
    }
}
function shoveSortOrders(items, targetId = null) {
    const to = items.findIndex((item) => item.id === targetId);
    const target = items[to];
    const before = items[to - 1];
    const updates = [];
    if (!targetId || to === -1) {
        let order;
        if (items.length > 0) {
            order = items[items.length - 1].sort_order + SORT_INCREMENT;
        }
        else {
            order = SORT_INCREMENT;
        }
        return { updates, sort_order: order };
    }
    else {
        if (target.sort_order - (before ? before.sort_order : 0) <= 2) {
            let next = to;
            let order = Math.floor(items[next].sort_order) + SORT_INCREMENT;
            while (next < items.length) {
                if (order <= items[next].sort_order) {
                    break;
                }
                updates.push({ id: items[next].id, sort_order: order });
                next++;
                order += SORT_INCREMENT;
            }
        }
        return { updates, sort_order: midpoint(items, to) };
    }
}
let dbPath = null;
let db = null;
function getDatabasePath() {
    return dbPath;
}
async function openDatabase(id2) {
    if (db) {
        await closeDatabase$1(db);
    }
    dbPath = join$1(getBudgetDir(id2), "db.sqlite");
    setDatabase(await openDatabase$1(dbPath));
}
async function closeDatabase() {
    if (db) {
        await closeDatabase$1(db);
        setDatabase(null);
    }
}
function setDatabase(db_) {
    db = db_;
    resetQueryCache();
}
function getDatabase() {
    return db;
}
async function loadClock() {
    const row = await first("SELECT * FROM messages_clock");
    if (row) {
        const clock2 = deserializeClock(row.clock);
        setClock(clock2);
    }
    else {
        const timestamp = new Timestamp(0, 0, makeClientId());
        const clock2 = makeClock(timestamp);
        setClock(clock2);
        await runQuery("INSERT INTO messages_clock (id, clock) VALUES (?, ?)", [
            1,
            serializeClock(clock2)
        ]);
    }
}
function runQuery(sql, params, fetchAll2) {
    if (fetchAll2) {
        return runQuery$1(db, sql, params, true);
    }
    else {
        return runQuery$1(db, sql, params, false);
    }
}
function execQuery(sql) {
    execQuery$2(db, sql);
}
let _queryCache = new LRUCache({ max: 100 });
function cache(sql) {
    const cached = _queryCache.get(sql);
    if (cached) {
        return cached;
    }
    const prepared = prepare(db, sql);
    _queryCache.set(sql, prepared);
    return prepared;
}
function resetQueryCache() {
    _queryCache = new LRUCache({ max: 100 });
}
function transaction(fn) {
    return transaction$1(db, fn);
}
function asyncTransaction(fn) {
    return asyncTransaction$1(db, fn);
}
async function all(sql, params) {
    return runQuery(sql, params, true);
}
async function first(sql, params) {
    const arr = await runQuery(sql, params, true);
    return arr.length === 0 ? null : arr[0];
}
function firstSync(sql, params) {
    const arr = runQuery(sql, params, true);
    return arr.length === 0 ? null : arr[0];
}
async function run(sql, params) {
    return runQuery(sql, params);
}
async function select(table, id2) {
    const rows = await runQuery("SELECT * FROM " + table + " WHERE id = ?", [id2], true);
    return rows[0];
}
async function update(table, params) {
    const fields = Object.keys(params).filter((k) => k !== "id");
    if (params.id == null) {
        throw new Error("update: id is required");
    }
    await sendMessages(fields.map((k) => {
        return {
            dataset: table,
            row: params.id,
            column: k,
            value: params[k],
            timestamp: Timestamp.send()
        };
    }));
}
async function insertWithUUID(table, row) {
    if (!row.id) {
        row = { ...row, id: v4() };
    }
    await insert(table, row);
    return row.id;
}
async function insert(table, row) {
    const fields = Object.keys(row).filter((k) => k !== "id");
    if (row.id == null) {
        throw new Error("insert: id is required");
    }
    await sendMessages(fields.map((k) => {
        return {
            dataset: table,
            row: row.id,
            column: k,
            value: row[k],
            timestamp: Timestamp.send()
        };
    }));
}
async function delete_(table, id2) {
    await sendMessages([
        {
            dataset: table,
            row: id2,
            column: "tombstone",
            value: 1,
            timestamp: Timestamp.send()
        }
    ]);
}
async function deleteAll(table) {
    const rows = await all(`
    SELECT id FROM ${table} WHERE tombstone = 0
  `);
    await Promise.all(rows.map(({ id: id2 }) => delete_(table, id2)));
}
async function selectWithSchema(table, sql, params) {
    const rows = await runQuery(sql, params, true);
    const convertedRows = rows.map((row) => convertFromSelect(schema, schemaConfig, table, row)).filter(Boolean);
    return convertedRows;
}
async function selectFirstWithSchema(table, sql, params) {
    const rows = await selectWithSchema(table, sql, params);
    return rows.length > 0 ? rows[0] : null;
}
function insertWithSchema(table, row) {
    if (!row.id) {
        row = { ...row, id: v4() };
    }
    return insertWithUUID(table, convertForInsert(schema, schemaConfig, table, row));
}
function updateWithSchema(table, fields) {
    return update(table, convertForUpdate(schema, schemaConfig, table, fields));
}
async function getCategories$3(ids) {
    const whereIn2 = ids ? `c.id IN (${toSqlQueryParameters(ids)}) AND` : "";
    const query = `SELECT c.* FROM categories c WHERE ${whereIn2} c.tombstone = 0 ORDER BY c.sort_order, c.id`;
    return ids ? await all(query, [...ids]) : await all(query);
}
async function getCategoriesGrouped(ids) {
    const categoryGroupWhereIn = ids ? `cg.id IN (${toSqlQueryParameters(ids)}) AND` : "";
    const categoryGroupQuery = `SELECT cg.* FROM category_groups cg WHERE ${categoryGroupWhereIn} cg.tombstone = 0
    ORDER BY cg.is_income, cg.sort_order, cg.id`;
    const categoryWhereIn = ids ? `c.cat_group IN (${toSqlQueryParameters(ids)}) AND` : "";
    const categoryQuery = `SELECT c.* FROM categories c WHERE ${categoryWhereIn} c.tombstone = 0
    ORDER BY c.sort_order, c.id`;
    const groups = ids ? await all(categoryGroupQuery, [...ids]) : await all(categoryGroupQuery);
    const categories = ids ? await all(categoryQuery, [...ids]) : await all(categoryQuery);
    return groups.map((group) => ({
        ...group,
        categories: categories.filter((c) => c.cat_group === group.id)
    }));
}
async function insertCategoryGroup(group) {
    const existingGroup = await first(`SELECT id, name, hidden FROM category_groups WHERE UPPER(name) = ? and tombstone = 0 LIMIT 1`, [group.name.toUpperCase()]);
    if (existingGroup) {
        throw new Error(`A ${existingGroup.hidden ? "hidden " : ""}${existingGroup.name} category group already exists.`);
    }
    const lastGroup = await first(`
    SELECT sort_order FROM category_groups WHERE tombstone = 0 ORDER BY sort_order DESC, id DESC LIMIT 1
  `);
    const sort_order = (lastGroup ? lastGroup.sort_order : 0) + SORT_INCREMENT;
    group = {
        ...categoryGroupModel$1.validate(group),
        sort_order
    };
    const id2 = await insertWithUUID("category_groups", group);
    return id2;
}
function updateCategoryGroup$1(group) {
    group = categoryGroupModel$1.validate(group, { update: true });
    return update("category_groups", group);
}
async function moveCategoryGroup$1(id2, targetId) {
    const groups = await all(`SELECT id, sort_order FROM category_groups WHERE tombstone = 0 ORDER BY sort_order, id`);
    const { updates, sort_order } = shoveSortOrders(groups, targetId);
    for (const info of updates) {
        await update("category_groups", info);
    }
    await update("category_groups", { id: id2, sort_order });
}
async function deleteCategoryGroup$1(group, transferId) {
    const categories = await all("SELECT * FROM categories WHERE cat_group = ?", [group.id]);
    await Promise.all(categories.map((cat) => deleteCategory$1(cat, transferId)));
    await delete_("category_groups", group.id);
}
async function insertCategory(category, { atEnd } = { atEnd: void 0 }) {
    let sort_order;
    let id_;
    await batchMessages(async () => {
        const existingCatInGroup = await first(`SELECT id FROM categories WHERE cat_group = ? and UPPER(name) = ? and tombstone = 0 LIMIT 1`, [category.cat_group, category.name.toUpperCase()]);
        if (existingCatInGroup) {
            throw new Error(`Category ${category.name} already exists in group ${category.cat_group}`);
        }
        if (atEnd) {
            const lastCat = await first(`
        SELECT sort_order FROM categories WHERE tombstone = 0 ORDER BY sort_order DESC, id DESC LIMIT 1
      `);
            sort_order = (lastCat ? lastCat.sort_order : 0) + SORT_INCREMENT;
        }
        else {
            const categories = await all(`SELECT id, sort_order FROM categories WHERE cat_group = ? AND tombstone = 0 ORDER BY sort_order, id`, [category.cat_group]);
            const { updates, sort_order: order } = shoveSortOrders(categories, categories.length > 0 ? categories[0].id : null);
            for (const info of updates) {
                await update("categories", info);
            }
            sort_order = order;
        }
        category = {
            ...categoryModel$1.validate(category),
            sort_order
        };
        const id2 = await insertWithUUID("categories", category);
        await insert("category_mapping", { id: id2, transferId: id2 });
        id_ = id2;
    });
    return id_;
}
function updateCategory$1(category) {
    category = categoryModel$1.validate(category, { update: true });
    return update("categories", category);
}
async function moveCategory$1(id2, groupId, targetId) {
    if (!groupId) {
        throw new Error("moveCategory: groupId is required");
    }
    const categories = await all(`SELECT id, sort_order FROM categories WHERE cat_group = ? AND tombstone = 0 ORDER BY sort_order, id`, [groupId]);
    const { updates, sort_order } = shoveSortOrders(categories, targetId);
    for (const info of updates) {
        await update("categories", info);
    }
    await update("categories", { id: id2, sort_order, cat_group: groupId });
}
async function deleteCategory$1(category, transferId) {
    if (transferId) {
        const existingTransfers = await all("SELECT * FROM category_mapping WHERE transferId = ?", [category.id]);
        for (const mapping of existingTransfers) {
            await update("category_mapping", {
                id: mapping.id,
                transferId
            });
        }
        await update("category_mapping", { id: category.id, transferId });
    }
    return delete_("categories", category.id);
}
async function getPayee$1(id2) {
    return first(`SELECT * FROM payees WHERE id = ?`, [id2]);
}
async function getAccount(id2) {
    return first(`SELECT * FROM accounts WHERE id = ?`, [id2]);
}
async function insertPayee(payee) {
    payee = payeeModel$1.validate(payee);
    let id2;
    await batchMessages(async () => {
        id2 = await insertWithUUID("payees", payee);
        await insert("payee_mapping", { id: id2, targetId: id2 });
    });
    return id2;
}
async function deletePayee(payee) {
    const { transfer_acct } = await first("SELECT * FROM payees WHERE id = ?", [payee.id]);
    if (transfer_acct) {
        return;
    }
    return delete_("payees", payee.id);
}
async function deleteTransferPayee(payee) {
    return delete_("payees", payee.id);
}
function updatePayee(payee) {
    payee = payeeModel$1.validate(payee, { update: true });
    return update("payees", payee);
}
async function mergePayees$1(target, ids) {
    const dbPayees = await all("SELECT * FROM payees");
    const payees = groupById(dbPayees);
    if (payees[target].transfer_acct != null) {
        return;
    }
    ids = ids.filter((id2) => payees[id2].transfer_acct == null);
    await batchMessages(async () => {
        await Promise.all(ids.map(async (id2) => {
            const mappings = await all("SELECT id FROM payee_mapping WHERE targetId = ?", [id2]);
            await Promise.all(mappings.map((m) => update("payee_mapping", { id: m.id, targetId: target })));
        }));
        await Promise.all(ids.map((id2) => Promise.all([
            update("payee_mapping", { id: id2, targetId: target }),
            delete_("payees", id2)
        ])));
    });
}
function getPayees$2() {
    return all(`
    SELECT p.*, COALESCE(a.name, p.name) AS name FROM payees p
    LEFT JOIN accounts a ON (p.transfer_acct = a.id AND a.tombstone = 0)
    WHERE p.tombstone = 0 AND (p.transfer_acct IS NULL OR a.id IS NOT NULL)
    ORDER BY p.transfer_acct IS NULL DESC, p.name COLLATE NOCASE, a.offbudget, a.sort_order
  `);
}
function getCommonPayees$1() {
    const twelveWeeksAgo = toDateRepr(subWeeks(currentDate(), 12));
    const limit = 10;
    return all(`
    SELECT     p.id as id, p.name as name, p.favorite as favorite,
      p.category as category, TRUE as common, NULL as transfer_acct,
    count(*) as c,
    max(t.date) as latest
    FROM payees p
    LEFT JOIN v_transactions_internal_alive t on t.payee == p.id
    WHERE LENGTH(p.name) > 0
    AND p.tombstone = 0
    AND t.date > ${twelveWeeksAgo}
    GROUP BY p.id
    ORDER BY c DESC ,p.transfer_acct IS NULL DESC, p.name
    COLLATE NOCASE
    LIMIT ${limit}
  `);
}
const orphanedPayeesQuery = `
  SELECT p.id
  FROM payees p
    LEFT JOIN payee_mapping pm ON pm.id = p.id
    LEFT JOIN v_transactions_internal_alive t ON t.payee = pm.targetId
  WHERE p.tombstone = 0
    AND p.transfer_acct IS NULL
    AND t.id IS NULL
    AND NOT EXISTS (
      SELECT 1
      FROM rules r,
      json_each(r.conditions) as cond
      WHERE r.tombstone = 0
        AND json_extract(cond.value, '$.field') = 'description'
        AND json_extract(cond.value, '$.value') = pm.targetId
    );
`;
function syncGetOrphanedPayees() {
    return all(orphanedPayeesQuery);
}
async function getOrphanedPayees$1() {
    const rows = await all(orphanedPayeesQuery);
    return rows.map((row) => row.id);
}
async function getPayeeByName(name) {
    return first(`SELECT * FROM payees WHERE UNICODE_LOWER(name) = ? AND tombstone = 0`, [name.toLowerCase()]);
}
function getAccounts$2() {
    return all(`SELECT a.*, b.name as bankName, b.id as bankId FROM accounts a
       LEFT JOIN banks b ON a.bank = b.id
       WHERE a.tombstone = 0
       ORDER BY sort_order, name`);
}
async function insertAccount(account) {
    const accounts = await all("SELECT * FROM accounts WHERE offbudget = ? ORDER BY sort_order, name", [account.offbudget ? 1 : 0]);
    const { sort_order } = shoveSortOrders(accounts);
    account = accountModel$1.validate({ ...account, sort_order });
    return insertWithUUID("accounts", account);
}
function updateAccount$1(account) {
    account = accountModel$1.validate(account, { update: true });
    return update("accounts", account);
}
function deleteAccount(account) {
    return delete_("accounts", account.id);
}
async function moveAccount$1(id2, targetId) {
    const account = await first("SELECT * FROM accounts WHERE id = ?", [id2]);
    let accounts;
    if (account.closed) {
        accounts = await all(`SELECT id, sort_order FROM accounts WHERE closed = 1 ORDER BY sort_order, name`);
    }
    else {
        accounts = await all(`SELECT id, sort_order FROM accounts WHERE tombstone = 0 AND offbudget = ? ORDER BY sort_order, name`, [account.offbudget ? 1 : 0]);
    }
    const { updates, sort_order } = shoveSortOrders(accounts, targetId);
    await batchMessages(async () => {
        for (const info of updates) {
            update("accounts", info);
        }
        update("accounts", { id: id2, sort_order });
    });
}
async function getTransaction(id2) {
    const rows = await selectWithSchema("transactions", "SELECT * FROM v_transactions WHERE id = ?", [id2]);
    return rows[0];
}
async function getTransactions$1(accountId) {
    if (arguments.length > 1) {
        throw new Error("`getTransactions` was given a second argument, it now only takes a single argument `accountId`");
    }
    return selectWithSchema("transactions", "SELECT * FROM v_transactions WHERE account = ?", [accountId]);
}
function insertTransaction(transaction2) {
    return insertWithSchema("transactions", transaction2);
}
function updateTransaction$2(transaction2) {
    return updateWithSchema("transactions", transaction2);
}
async function deleteTransaction$2(transaction2) {
    return delete_("transactions", transaction2.id);
}
function toSqlQueryParameters(params) {
    return params.map(() => "?").join(",");
}
function getTags$1() {
    return all(`
    SELECT id, tag, color, description
    FROM tags
    WHERE tombstone = 0
    ORDER BY tag
  `);
}
function getAllTags() {
    return all(`
    SELECT id, tag, color, description
    FROM tags
    ORDER BY tag
  `);
}
function insertTag(tag) {
    return insertWithUUID("tags", tag);
}
async function deleteTag$1(tag) {
    return delete_("tags", tag.id);
}
function updateTag$1(tag) {
    return update("tags", tag);
}
function findTags$1() {
    return all(`
    SELECT notes
    FROM transactions
    WHERE tombstone = 0 AND notes LIKE ?
  `, ["%#%"]);
}
async function findOrCreateBank(institution, requisitionId) {
    const bank = await first("SELECT id, bank_id FROM banks WHERE bank_id = ?", [requisitionId]);
    if (bank) {
        return bank;
    }
    const bankData = {
        id: v4(),
        bank_id: requisitionId,
        name: institution.name
    };
    await insertWithUUID("banks", bankData);
    return bankData;
}
async function createPayee$2(description) {
    const row = await first(`SELECT id FROM payees WHERE UNICODE_LOWER(name) = ? AND tombstone = 0`, [description.toLowerCase()]);
    if (row) {
        return row.id;
    }
    else {
        return await insertPayee({ name: description });
    }
}
async function getStartingBalancePayee() {
    let category = await first(`
    SELECT * FROM categories
      WHERE is_income = 1 AND
      LOWER(name) = 'starting balances' AND
      tombstone = 0
  `);
    if (category === null) {
        category = await first("SELECT * FROM categories WHERE is_income = 1 AND tombstone = 0");
    }
    const id2 = await createPayee$2("Starting Balance");
    return {
        id: id2,
        category: category ? category.id : null
    };
}
function num(n) {
    return typeof n === "number" ? n : 0;
}
function SplitTransactionError(total, parent) {
    const difference = num(parent.amount) - total;
    return {
        type: "SplitTransactionError",
        version: 1,
        difference
    };
}
function makeChild(parent, data = {}) {
    const prefix = parent.id === "temp" ? "temp" : "";
    return {
        amount: 0,
        ...data,
        category: "category" in data ? data.category : parent.category,
        payee: "payee" in data ? data.payee : parent.payee,
        id: "id" in data ? data.id : prefix + v4(),
        account: parent.account,
        date: parent.date,
        cleared: parent.cleared != null ? parent.cleared : null,
        reconciled: "reconciled" in data ? data.reconciled : parent.reconciled,
        starting_balance_flag: parent.starting_balance_flag != null ? parent.starting_balance_flag : null,
        is_child: true,
        parent_id: parent.id,
        error: null
    };
}
function recalculateSplit(trans) {
    const total = (trans.subtransactions || []).reduce((acc, t2) => acc + num(t2.amount), 0);
    const { error, ...rest } = trans;
    return {
        ...rest,
        error: total === num(trans.amount) ? null : SplitTransactionError(total, trans)
    };
}
function findParentIndex(transactions, idx) {
    while (idx >= 0) {
        const trans = transactions[idx];
        if (trans.is_parent) {
            return idx;
        }
        idx--;
    }
    return null;
}
function getSplit(transactions, parentIndex) {
    const split = [transactions[parentIndex]];
    let curr = parentIndex + 1;
    while (curr < transactions.length && transactions[curr].is_child) {
        split.push(transactions[curr]);
        curr++;
    }
    return split;
}
function ungroupTransactions(transactions) {
    return transactions.reduce((list, parent) => {
        const { subtransactions, ...trans } = parent;
        const _subtransactions = subtransactions || [];
        list.push(trans);
        for (let i = 0; i < _subtransactions.length; i++) {
            list.push(_subtransactions[i]);
        }
        return list;
    }, []);
}
function groupTransaction(split) {
    return {
        ...split[0],
        subtransactions: split.slice(1)
    };
}
function ungroupTransaction(split) {
    if (split == null) {
        return [];
    }
    return ungroupTransactions([split]);
}
function replaceTransactions(transactions, id2, func) {
    const idx = transactions.findIndex((t2) => t2.id === id2);
    const trans = transactions[idx];
    const transactionsCopy = [...transactions];
    if (idx === -1) {
        throw new Error("Tried to edit unknown transaction id: " + id2);
    }
    if (trans.is_parent || trans.is_child) {
        const parentIndex = findParentIndex(transactions, idx);
        if (parentIndex == null) {
            console.log("Cannot find parent index");
            return {
                data: [],
                diff: { added: [], deleted: [], updated: [] },
                newTransaction: null
            };
        }
        const split = getSplit(transactions, parentIndex);
        let grouped = func(groupTransaction(split));
        const newSplit = ungroupTransaction(grouped);
        let diff2;
        if (newSplit == null) {
            diff2 = { added: [], deleted: [{ id: split[0].id }], updated: [] };
            grouped = { ...split[0], _deleted: true };
            transactionsCopy.splice(parentIndex, split.length);
        }
        else {
            diff2 = diffItems(split, newSplit);
            transactionsCopy.splice(parentIndex, split.length, ...newSplit);
        }
        return { data: transactionsCopy, newTransaction: grouped, diff: diff2 };
    }
    else {
        const grouped = func(trans);
        const newTrans = ungroupTransaction(grouped) || [];
        if (grouped) {
            grouped.subtransactions = grouped.subtransactions || [];
        }
        transactionsCopy.splice(idx, 1, ...newTrans);
        return {
            data: transactionsCopy,
            newTransaction: grouped || {
                ...trans,
                _deleted: true
            },
            diff: diffItems([trans], newTrans)
        };
    }
}
function addSplitTransaction(transactions, id2) {
    return replaceTransactions(transactions, id2, (trans) => {
        if (!trans.is_parent) {
            return trans;
        }
        const prevSub = last(trans.subtransactions || []);
        trans.subtransactions?.push(makeChild(trans, {
            amount: 0,
            sort_order: num(prevSub && prevSub.sort_order) - 1
        }));
        return trans;
    });
}
function updateTransaction$1(transactions, transaction2) {
    return replaceTransactions(transactions, transaction2.id, (trans) => {
        if (trans.is_parent) {
            const parent = trans.id === transaction2.id ? transaction2 : trans;
            const originalSubtransactions = parent.subtransactions ?? trans.subtransactions;
            const sub = originalSubtransactions?.map((t2) => {
                let child = t2;
                if (trans.id === transaction2.id) {
                    const { payee: childPayee, ...rest } = t2;
                    const newPayee = childPayee === trans.payee ? transaction2.payee : childPayee;
                    child = {
                        ...rest,
                        ...newPayee != null ? { payee: newPayee } : {}
                    };
                }
                else if (t2.id === transaction2.id) {
                    child = transaction2;
                }
                return makeChild(parent, child);
            });
            return recalculateSplit({
                ...parent,
                ...sub && { subtransactions: sub }
            });
        }
        else {
            return transaction2;
        }
    });
}
function deleteTransaction$1(transactions, id2) {
    return replaceTransactions(transactions, id2, (trans) => {
        if (trans.is_parent) {
            if (trans.id === id2) {
                return null;
            }
            else if (trans.subtransactions?.length === 1) {
                const { subtransactions, ...rest } = trans;
                return {
                    ...rest,
                    is_parent: false,
                    error: null
                };
            }
            else {
                const sub = trans.subtransactions?.filter((t2) => t2.id !== id2);
                return recalculateSplit({
                    ...trans,
                    ...sub && { subtransactions: sub }
                });
            }
        }
        else {
            return null;
        }
    });
}
function splitTransaction(transactions, id2, createSubtransactions) {
    return replaceTransactions(transactions, id2, (trans) => {
        if (trans.is_parent || trans.is_child) {
            return trans;
        }
        const subtransactions = [
            makeChild(trans)
        ];
        const { error, ...rest } = trans;
        return {
            ...rest,
            is_parent: true,
            error: num(trans.amount) === 0 ? null : SplitTransactionError(0, trans),
            subtransactions: subtransactions.map((t2) => ({
                ...t2,
                sort_order: t2.sort_order || -1
            }))
        };
    });
}
const TYPE_INFO = {
    date: {
        ops: ["is", "isapprox", "gt", "gte", "lt", "lte"],
        nullable: false
    },
    id: {
        ops: [
            "is",
            "contains",
            "matches",
            "oneOf",
            "isNot",
            "doesNotContain",
            "notOneOf",
            "onBudget",
            "offBudget"
        ],
        nullable: true
    },
    saved: {
        ops: [],
        nullable: false
    },
    string: {
        ops: [
            "is",
            "contains",
            "matches",
            "oneOf",
            "isNot",
            "doesNotContain",
            "notOneOf",
            "hasTags"
        ],
        nullable: true
    },
    number: {
        ops: ["is", "isapprox", "isbetween", "gt", "gte", "lt", "lte"],
        nullable: false
    },
    boolean: {
        ops: ["is"],
        nullable: false
    }
};
const FIELD_INFO = {
    imported_payee: {
        type: "string",
        disallowedOps: /* @__PURE__ */ new Set(["hasTags"])
    },
    payee: { type: "id", disallowedOps: /* @__PURE__ */ new Set(["onBudget", "offBudget"]) },
    payee_name: { type: "string" },
    date: { type: "date" },
    notes: { type: "string" },
    amount: { type: "number" },
    category: {
        type: "id",
        disallowedOps: /* @__PURE__ */ new Set(["onBudget", "offBudget"]),
        internalOps: /* @__PURE__ */ new Set(["and"])
    },
    account: { type: "id" },
    cleared: { type: "boolean" },
    reconciled: { type: "boolean" },
    saved: { type: "saved" },
    transfer: { type: "boolean" },
    parent: { type: "boolean" }
};
const fieldInfo = FIELD_INFO;
const FIELD_TYPES = new Map(Object.entries(FIELD_INFO).map(([field, info]) => [
    field,
    info.type
]));
function isValidOp(field, op) {
    const type2 = FIELD_TYPES.get(field);
    if (!type2)
        return false;
    if (fieldInfo[field].disallowedOps?.has(op))
        return false;
    return TYPE_INFO[type2].ops.includes(op) || fieldInfo[field].internalOps?.has(op);
}
function sortNumbers(num1, num2) {
    if (num1 < num2) {
        return [num1, num2];
    }
    return [num2, num1];
}
function getApproxNumberThreshold(number2) {
    return Math.round(Math.abs(number2) * 0.075);
}
let allMappings;
let unlistenSync$1;
async function loadMappings() {
    const categories = (await all("SELECT * FROM category_mapping")).map((r) => [r.id, r.transferId]);
    const payees = (await all("SELECT * FROM payee_mapping")).map((r) => [r.id, r.targetId]);
    allMappings = new Map(categories.concat(payees));
    if (unlistenSync$1) {
        unlistenSync$1();
    }
    unlistenSync$1 = addSyncListener(onApplySync$2);
}
function onApplySync$2(oldValues, newValues) {
    newValues.forEach((items, table) => {
        if (table.indexOf("mapping") !== -1) {
            const field = table === "category_mapping" ? "transferId" : "targetId";
            items.forEach((newValue) => {
                allMappings.set(newValue.id, newValue[field]);
            });
        }
    });
}
function getMappings() {
    return allMappings;
}
var handlebars$1 = { exports: {} };
/**!

 @license
 handlebars v4.7.8

Copyright (C) 2011-2019 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
var handlebars = handlebars$1.exports;
var hasRequiredHandlebars;
function requireHandlebars() {
    if (hasRequiredHandlebars)
        return handlebars$1.exports;
    hasRequiredHandlebars = 1;
    (function (module2, exports2) {
        (function webpackUniversalModuleDefinition(root, factory) {
            module2.exports = factory();
        })(handlebars, function () {
            return (
            /******/
            function (modules) {
                var installedModules = {};
                function __webpack_require__(moduleId) {
                    if (installedModules[moduleId])
                        return installedModules[moduleId].exports;
                    var module3 = installedModules[moduleId] = {
                        /******/
                        exports: {},
                        /******/
                        id: moduleId,
                        /******/
                        loaded: false
                        /******/
                    };
                    modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
                    module3.loaded = true;
                    return module3.exports;
                }
                __webpack_require__.m = modules;
                __webpack_require__.c = installedModules;
                __webpack_require__.p = "";
                return __webpack_require__(0);
            }([
                /* 0 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _handlebarsRuntime = __webpack_require__(2);
                    var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
                    var _handlebarsCompilerAst = __webpack_require__(84);
                    var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
                    var _handlebarsCompilerBase = __webpack_require__(85);
                    var _handlebarsCompilerCompiler = __webpack_require__(90);
                    var _handlebarsCompilerJavascriptCompiler = __webpack_require__(91);
                    var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
                    var _handlebarsCompilerVisitor = __webpack_require__(88);
                    var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
                    var _handlebarsNoConflict = __webpack_require__(83);
                    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
                    var _create = _handlebarsRuntime2["default"].create;
                    function create() {
                        var hb = _create();
                        hb.compile = function (input, options2) {
                            return _handlebarsCompilerCompiler.compile(input, options2, hb);
                        };
                        hb.precompile = function (input, options2) {
                            return _handlebarsCompilerCompiler.precompile(input, options2, hb);
                        };
                        hb.AST = _handlebarsCompilerAst2["default"];
                        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
                        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
                        hb.Parser = _handlebarsCompilerBase.parser;
                        hb.parse = _handlebarsCompilerBase.parse;
                        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
                        return hb;
                    }
                    var inst = create();
                    inst.create = create;
                    _handlebarsNoConflict2["default"](inst);
                    inst.Visitor = _handlebarsCompilerVisitor2["default"];
                    inst["default"] = inst;
                    exports3["default"] = inst;
                    module3.exports = exports3["default"];
                },
                /* 1 */
                /***/
                function (module3, exports3) {
                    exports3["default"] = function (obj) {
                        return obj && obj.__esModule ? obj : {
                            "default": obj
                        };
                    };
                    exports3.__esModule = true;
                },
                /* 2 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireWildcard = __webpack_require__(3)["default"];
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _handlebarsBase = __webpack_require__(4);
                    var base = _interopRequireWildcard(_handlebarsBase);
                    var _handlebarsSafeString = __webpack_require__(77);
                    var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
                    var _handlebarsException = __webpack_require__(6);
                    var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
                    var _handlebarsUtils = __webpack_require__(5);
                    var Utils = _interopRequireWildcard(_handlebarsUtils);
                    var _handlebarsRuntime = __webpack_require__(78);
                    var runtime = _interopRequireWildcard(_handlebarsRuntime);
                    var _handlebarsNoConflict = __webpack_require__(83);
                    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
                    function create() {
                        var hb = new base.HandlebarsEnvironment();
                        Utils.extend(hb, base);
                        hb.SafeString = _handlebarsSafeString2["default"];
                        hb.Exception = _handlebarsException2["default"];
                        hb.Utils = Utils;
                        hb.escapeExpression = Utils.escapeExpression;
                        hb.VM = runtime;
                        hb.template = function (spec) {
                            return runtime.template(spec, hb);
                        };
                        return hb;
                    }
                    var inst = create();
                    inst.create = create;
                    _handlebarsNoConflict2["default"](inst);
                    inst["default"] = inst;
                    exports3["default"] = inst;
                    module3.exports = exports3["default"];
                },
                /* 3 */
                /***/
                function (module3, exports3) {
                    exports3["default"] = function (obj) {
                        if (obj && obj.__esModule) {
                            return obj;
                        }
                        else {
                            var newObj = {};
                            if (obj != null) {
                                for (var key in obj) {
                                    if (Object.prototype.hasOwnProperty.call(obj, key))
                                        newObj[key] = obj[key];
                                }
                            }
                            newObj["default"] = obj;
                            return newObj;
                        }
                    };
                    exports3.__esModule = true;
                },
                /* 4 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.HandlebarsEnvironment = HandlebarsEnvironment;
                    var _utils = __webpack_require__(5);
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    var _helpers = __webpack_require__(10);
                    var _decorators = __webpack_require__(70);
                    var _logger = __webpack_require__(72);
                    var _logger2 = _interopRequireDefault(_logger);
                    var _internalProtoAccess = __webpack_require__(73);
                    var VERSION = "4.7.8";
                    exports3.VERSION = VERSION;
                    var COMPILER_REVISION = 8;
                    exports3.COMPILER_REVISION = COMPILER_REVISION;
                    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
                    exports3.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
                    var REVISION_CHANGES = {
                        1: "<= 1.0.rc.2",
                        // 1.0.rc.2 is actually rev2 but doesn't report it
                        2: "== 1.0.0-rc.3",
                        3: "== 1.0.0-rc.4",
                        4: "== 1.x.x",
                        5: "== 2.0.0-alpha.x",
                        6: ">= 2.0.0-beta.1",
                        7: ">= 4.0.0 <4.3.0",
                        8: ">= 4.3.0"
                    };
                    exports3.REVISION_CHANGES = REVISION_CHANGES;
                    var objectType = "[object Object]";
                    function HandlebarsEnvironment(helpers, partials, decorators) {
                        this.helpers = helpers || {};
                        this.partials = partials || {};
                        this.decorators = decorators || {};
                        _helpers.registerDefaultHelpers(this);
                        _decorators.registerDefaultDecorators(this);
                    }
                    HandlebarsEnvironment.prototype = {
                        constructor: HandlebarsEnvironment,
                        logger: _logger2["default"],
                        log: _logger2["default"].log,
                        registerHelper: function registerHelper(name, fn) {
                            if (_utils.toString.call(name) === objectType) {
                                if (fn) {
                                    throw new _exception2["default"]("Arg not supported with multiple helpers");
                                }
                                _utils.extend(this.helpers, name);
                            }
                            else {
                                this.helpers[name] = fn;
                            }
                        },
                        unregisterHelper: function unregisterHelper(name) {
                            delete this.helpers[name];
                        },
                        registerPartial: function registerPartial(name, partial) {
                            if (_utils.toString.call(name) === objectType) {
                                _utils.extend(this.partials, name);
                            }
                            else {
                                if (typeof partial === "undefined") {
                                    throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
                                }
                                this.partials[name] = partial;
                            }
                        },
                        unregisterPartial: function unregisterPartial(name) {
                            delete this.partials[name];
                        },
                        registerDecorator: function registerDecorator(name, fn) {
                            if (_utils.toString.call(name) === objectType) {
                                if (fn) {
                                    throw new _exception2["default"]("Arg not supported with multiple decorators");
                                }
                                _utils.extend(this.decorators, name);
                            }
                            else {
                                this.decorators[name] = fn;
                            }
                        },
                        unregisterDecorator: function unregisterDecorator(name) {
                            delete this.decorators[name];
                        },
                        /**
                         * Reset the memory of illegal property accesses that have already been logged.
                         * @deprecated should only be used in handlebars test-cases
                         */
                        resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
                            _internalProtoAccess.resetLoggedProperties();
                        }
                    };
                    var log = _logger2["default"].log;
                    exports3.log = log;
                    exports3.createFrame = _utils.createFrame;
                    exports3.logger = _logger2["default"];
                },
                /* 5 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    exports3.extend = extend;
                    exports3.indexOf = indexOf;
                    exports3.escapeExpression = escapeExpression;
                    exports3.isEmpty = isEmpty;
                    exports3.createFrame = createFrame;
                    exports3.blockParams = blockParams;
                    exports3.appendContextPath = appendContextPath;
                    var escape2 = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#x27;",
                        "`": "&#x60;",
                        "=": "&#x3D;"
                    };
                    var badChars = /[&<>"'`=]/g, possible = /[&<>"'`=]/;
                    function escapeChar(chr) {
                        return escape2[chr];
                    }
                    function extend(obj) {
                        for (var i = 1; i < arguments.length; i++) {
                            for (var key in arguments[i]) {
                                if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                                    obj[key] = arguments[i][key];
                                }
                            }
                        }
                        return obj;
                    }
                    var toString = Object.prototype.toString;
                    exports3.toString = toString;
                    var isFunction = function isFunction2(value) {
                        return typeof value === "function";
                    };
                    if (isFunction(/x/)) {
                        exports3.isFunction = isFunction = function (value) {
                            return typeof value === "function" && toString.call(value) === "[object Function]";
                        };
                    }
                    exports3.isFunction = isFunction;
                    var isArray = Array.isArray || function (value) {
                        return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
                    };
                    exports3.isArray = isArray;
                    function indexOf(array, value) {
                        for (var i = 0, len = array.length; i < len; i++) {
                            if (array[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    }
                    function escapeExpression(string) {
                        if (typeof string !== "string") {
                            if (string && string.toHTML) {
                                return string.toHTML();
                            }
                            else if (string == null) {
                                return "";
                            }
                            else if (!string) {
                                return string + "";
                            }
                            string = "" + string;
                        }
                        if (!possible.test(string)) {
                            return string;
                        }
                        return string.replace(badChars, escapeChar);
                    }
                    function isEmpty(value) {
                        if (!value && value !== 0) {
                            return true;
                        }
                        else if (isArray(value) && value.length === 0) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    function createFrame(object) {
                        var frame = extend({}, object);
                        frame._parent = object;
                        return frame;
                    }
                    function blockParams(params, ids) {
                        params.path = ids;
                        return params;
                    }
                    function appendContextPath(contextPath, id2) {
                        return (contextPath ? contextPath + "." : "") + id2;
                    }
                },
                /* 6 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$defineProperty = __webpack_require__(7)["default"];
                    exports3.__esModule = true;
                    var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
                    function Exception(message2, node2) {
                        var loc = node2 && node2.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
                        if (loc) {
                            line = loc.start.line;
                            endLineNumber = loc.end.line;
                            column = loc.start.column;
                            endColumn = loc.end.column;
                            message2 += " - " + line + ":" + column;
                        }
                        var tmp = Error.prototype.constructor.call(this, message2);
                        for (var idx = 0; idx < errorProps.length; idx++) {
                            this[errorProps[idx]] = tmp[errorProps[idx]];
                        }
                        if (Error.captureStackTrace) {
                            Error.captureStackTrace(this, Exception);
                        }
                        try {
                            if (loc) {
                                this.lineNumber = line;
                                this.endLineNumber = endLineNumber;
                                if (_Object$defineProperty) {
                                    Object.defineProperty(this, "column", {
                                        value: column,
                                        enumerable: true
                                    });
                                    Object.defineProperty(this, "endColumn", {
                                        value: endColumn,
                                        enumerable: true
                                    });
                                }
                                else {
                                    this.column = column;
                                    this.endColumn = endColumn;
                                }
                            }
                        }
                        catch (nop) {
                        }
                    }
                    Exception.prototype = new Error();
                    exports3["default"] = Exception;
                    module3.exports = exports3["default"];
                },
                /* 7 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(8), __esModule: true };
                },
                /* 8 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9);
                    module3.exports = function defineProperty(it2, key, desc) {
                        return $.setDesc(it2, key, desc);
                    };
                },
                /* 9 */
                /***/
                function (module3, exports3) {
                    var $Object = Object;
                    module3.exports = {
                        create: $Object.create,
                        getProto: $Object.getPrototypeOf,
                        isEnum: {}.propertyIsEnumerable,
                        getDesc: $Object.getOwnPropertyDescriptor,
                        setDesc: $Object.defineProperty,
                        setDescs: $Object.defineProperties,
                        getKeys: $Object.keys,
                        getNames: $Object.getOwnPropertyNames,
                        getSymbols: $Object.getOwnPropertySymbols,
                        each: [].forEach
                    };
                },
                /* 10 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.registerDefaultHelpers = registerDefaultHelpers;
                    exports3.moveHelperToHooks = moveHelperToHooks;
                    var _helpersBlockHelperMissing = __webpack_require__(11);
                    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
                    var _helpersEach = __webpack_require__(12);
                    var _helpersEach2 = _interopRequireDefault(_helpersEach);
                    var _helpersHelperMissing = __webpack_require__(65);
                    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
                    var _helpersIf = __webpack_require__(66);
                    var _helpersIf2 = _interopRequireDefault(_helpersIf);
                    var _helpersLog = __webpack_require__(67);
                    var _helpersLog2 = _interopRequireDefault(_helpersLog);
                    var _helpersLookup = __webpack_require__(68);
                    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
                    var _helpersWith = __webpack_require__(69);
                    var _helpersWith2 = _interopRequireDefault(_helpersWith);
                    function registerDefaultHelpers(instance2) {
                        _helpersBlockHelperMissing2["default"](instance2);
                        _helpersEach2["default"](instance2);
                        _helpersHelperMissing2["default"](instance2);
                        _helpersIf2["default"](instance2);
                        _helpersLog2["default"](instance2);
                        _helpersLookup2["default"](instance2);
                        _helpersWith2["default"](instance2);
                    }
                    function moveHelperToHooks(instance2, helperName, keepHelper) {
                        if (instance2.helpers[helperName]) {
                            instance2.hooks[helperName] = instance2.helpers[helperName];
                            if (!keepHelper) {
                                delete instance2.helpers[helperName];
                            }
                        }
                    }
                },
                /* 11 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("blockHelperMissing", function (context, options2) {
                            var inverse = options2.inverse, fn = options2.fn;
                            if (context === true) {
                                return fn(this);
                            }
                            else if (context === false || context == null) {
                                return inverse(this);
                            }
                            else if (_utils.isArray(context)) {
                                if (context.length > 0) {
                                    if (options2.ids) {
                                        options2.ids = [options2.name];
                                    }
                                    return instance2.helpers.each(context, options2);
                                }
                                else {
                                    return inverse(this);
                                }
                            }
                            else {
                                if (options2.data && options2.ids) {
                                    var data = _utils.createFrame(options2.data);
                                    data.contextPath = _utils.appendContextPath(options2.data.contextPath, options2.name);
                                    options2 = { data };
                                }
                                return fn(context, options2);
                            }
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 12 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Symbol2 = __webpack_require__(13)["default"];
                    var _Symbol$iterator = __webpack_require__(43)["default"];
                    var _getIterator = __webpack_require__(55)["default"];
                    var _Object$keys = __webpack_require__(60)["default"];
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("each", function (context, options2) {
                            if (!options2) {
                                throw new _exception2["default"]("Must pass iterator to #each");
                            }
                            var fn = options2.fn, inverse = options2.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
                            if (options2.data && options2.ids) {
                                contextPath = _utils.appendContextPath(options2.data.contextPath, options2.ids[0]) + ".";
                            }
                            if (_utils.isFunction(context)) {
                                context = context.call(this);
                            }
                            if (options2.data) {
                                data = _utils.createFrame(options2.data);
                            }
                            function execIteration(field, index, last2) {
                                if (data) {
                                    data.key = field;
                                    data.index = index;
                                    data.first = index === 0;
                                    data.last = !!last2;
                                    if (contextPath) {
                                        data.contextPath = contextPath + field;
                                    }
                                }
                                ret = ret + fn(context[field], {
                                    data,
                                    blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                                });
                            }
                            if (context && typeof context === "object") {
                                if (_utils.isArray(context)) {
                                    for (var j = context.length; i < j; i++) {
                                        if (i in context) {
                                            execIteration(i, i, i === context.length - 1);
                                        }
                                    }
                                }
                                else if (typeof _Symbol2 === "function" && context[_Symbol$iterator]) {
                                    var newContext = [];
                                    var iterator = _getIterator(context);
                                    for (var it2 = iterator.next(); !it2.done; it2 = iterator.next()) {
                                        newContext.push(it2.value);
                                    }
                                    context = newContext;
                                    for (var j = context.length; i < j; i++) {
                                        execIteration(i, i, i === context.length - 1);
                                    }
                                }
                                else {
                                    (function () {
                                        var priorKey = void 0;
                                        _Object$keys(context).forEach(function (key) {
                                            if (priorKey !== void 0) {
                                                execIteration(priorKey, i - 1);
                                            }
                                            priorKey = key;
                                            i++;
                                        });
                                        if (priorKey !== void 0) {
                                            execIteration(priorKey, i - 1, true);
                                        }
                                    })();
                                }
                            }
                            if (i === 0) {
                                ret = inverse(this);
                            }
                            return ret;
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 13 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(14), __esModule: true };
                },
                /* 14 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    __webpack_require__(15);
                    __webpack_require__(42);
                    module3.exports = __webpack_require__(21).Symbol;
                },
                /* 15 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9), global2 = __webpack_require__(16), has = __webpack_require__(17), DESCRIPTORS = __webpack_require__(18), $export = __webpack_require__(20), redefine = __webpack_require__(24), $fails = __webpack_require__(19), shared = __webpack_require__(27), setToStringTag = __webpack_require__(28), uid2 = __webpack_require__(30), wks = __webpack_require__(29), keyOf = __webpack_require__(31), $names = __webpack_require__(36), enumKeys = __webpack_require__(37), isArray = __webpack_require__(38), anObject = __webpack_require__(39), toIObject = __webpack_require__(32), createDesc = __webpack_require__(26), getDesc = $.getDesc, setDesc = $.setDesc, _create = $.create, getNames = $names.get, $Symbol = global2.Symbol, $JSON = global2.JSON, _stringify = $JSON && $JSON.stringify, setter = false, HIDDEN = wks("_hidden"), isEnum = $.isEnum, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), useNative = typeof $Symbol == "function", ObjectProto = Object.prototype;
                    var setSymbolDesc = DESCRIPTORS && $fails(function () {
                        return _create(setDesc({}, "a", {
                            get: function () {
                                return setDesc(this, "a", { value: 7 }).a;
                            }
                        })).a != 7;
                    }) ? function (it2, key, D) {
                        var protoDesc = getDesc(ObjectProto, key);
                        if (protoDesc)
                            delete ObjectProto[key];
                        setDesc(it2, key, D);
                        if (protoDesc && it2 !== ObjectProto)
                            setDesc(ObjectProto, key, protoDesc);
                    } : setDesc;
                    var wrap = function (tag) {
                        var sym = AllSymbols[tag] = _create($Symbol.prototype);
                        sym._k = tag;
                        DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
                            configurable: true,
                            set: function (value) {
                                if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                                    this[HIDDEN][tag] = false;
                                setSymbolDesc(this, tag, createDesc(1, value));
                            }
                        });
                        return sym;
                    };
                    var isSymbol2 = function (it2) {
                        return typeof it2 == "symbol";
                    };
                    var $defineProperty = function defineProperty(it2, key, D) {
                        if (D && has(AllSymbols, key)) {
                            if (!D.enumerable) {
                                if (!has(it2, HIDDEN))
                                    setDesc(it2, HIDDEN, createDesc(1, {}));
                                it2[HIDDEN][key] = true;
                            }
                            else {
                                if (has(it2, HIDDEN) && it2[HIDDEN][key])
                                    it2[HIDDEN][key] = false;
                                D = _create(D, { enumerable: createDesc(0, false) });
                            }
                            return setSymbolDesc(it2, key, D);
                        }
                        return setDesc(it2, key, D);
                    };
                    var $defineProperties = function defineProperties(it2, P) {
                        anObject(it2);
                        var keys2 = enumKeys(P = toIObject(P)), i = 0, l = keys2.length, key;
                        while (l > i)
                            $defineProperty(it2, key = keys2[i++], P[key]);
                        return it2;
                    };
                    var $create = function create(it2, P) {
                        return P === void 0 ? _create(it2) : $defineProperties(_create(it2), P);
                    };
                    var $propertyIsEnumerable = function propertyIsEnumerable(key) {
                        var E = isEnum.call(this, key);
                        return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
                    };
                    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it2, key) {
                        var D = getDesc(it2 = toIObject(it2), key);
                        if (D && has(AllSymbols, key) && !(has(it2, HIDDEN) && it2[HIDDEN][key]))
                            D.enumerable = true;
                        return D;
                    };
                    var $getOwnPropertyNames = function getOwnPropertyNames(it2) {
                        var names = getNames(toIObject(it2)), result = [], i = 0, key;
                        while (names.length > i)
                            if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
                                result.push(key);
                        return result;
                    };
                    var $getOwnPropertySymbols = function getOwnPropertySymbols(it2) {
                        var names = getNames(toIObject(it2)), result = [], i = 0, key;
                        while (names.length > i)
                            if (has(AllSymbols, key = names[i++]))
                                result.push(AllSymbols[key]);
                        return result;
                    };
                    var $stringify = function stringify2(it2) {
                        if (it2 === void 0 || isSymbol2(it2))
                            return;
                        var args = [it2], i = 1, $$ = arguments, replacer, $replacer;
                        while ($$.length > i)
                            args.push($$[i++]);
                        replacer = args[1];
                        if (typeof replacer == "function")
                            $replacer = replacer;
                        if ($replacer || !isArray(replacer))
                            replacer = function (key, value) {
                                if ($replacer)
                                    value = $replacer.call(this, key, value);
                                if (!isSymbol2(value))
                                    return value;
                            };
                        args[1] = replacer;
                        return _stringify.apply($JSON, args);
                    };
                    var buggyJSON = $fails(function () {
                        var S = $Symbol();
                        return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
                    });
                    if (!useNative) {
                        $Symbol = function Symbol2() {
                            if (isSymbol2(this))
                                throw TypeError("Symbol is not a constructor");
                            return wrap(uid2(arguments.length > 0 ? arguments[0] : void 0));
                        };
                        redefine($Symbol.prototype, "toString", function toString() {
                            return this._k;
                        });
                        isSymbol2 = function (it2) {
                            return it2 instanceof $Symbol;
                        };
                        $.create = $create;
                        $.isEnum = $propertyIsEnumerable;
                        $.getDesc = $getOwnPropertyDescriptor;
                        $.setDesc = $defineProperty;
                        $.setDescs = $defineProperties;
                        $.getNames = $names.get = $getOwnPropertyNames;
                        $.getSymbols = $getOwnPropertySymbols;
                        if (DESCRIPTORS && !__webpack_require__(41)) {
                            redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
                        }
                    }
                    var symbolStatics = {
                        // 19.4.2.1 Symbol.for(key)
                        "for": function (key) {
                            return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
                        },
                        // 19.4.2.5 Symbol.keyFor(sym)
                        keyFor: function keyFor(key) {
                            return keyOf(SymbolRegistry, key);
                        },
                        useSetter: function () {
                            setter = true;
                        },
                        useSimple: function () {
                            setter = false;
                        }
                    };
                    $.each.call("hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), function (it2) {
                        var sym = wks(it2);
                        symbolStatics[it2] = useNative ? sym : wrap(sym);
                    });
                    setter = true;
                    $export($export.G + $export.W, { Symbol: $Symbol });
                    $export($export.S, "Symbol", symbolStatics);
                    $export($export.S + $export.F * !useNative, "Object", {
                        // 19.1.2.2 Object.create(O [, Properties])
                        create: $create,
                        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
                        defineProperty: $defineProperty,
                        // 19.1.2.3 Object.defineProperties(O, Properties)
                        defineProperties: $defineProperties,
                        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
                        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
                        // 19.1.2.7 Object.getOwnPropertyNames(O)
                        getOwnPropertyNames: $getOwnPropertyNames,
                        // 19.1.2.8 Object.getOwnPropertySymbols(O)
                        getOwnPropertySymbols: $getOwnPropertySymbols
                    });
                    $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), "JSON", { stringify: $stringify });
                    setToStringTag($Symbol, "Symbol");
                    setToStringTag(Math, "Math", true);
                    setToStringTag(global2.JSON, "JSON", true);
                },
                /* 16 */
                /***/
                function (module3, exports3) {
                    var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
                    if (typeof __g == "number")
                        __g = global2;
                },
                /* 17 */
                /***/
                function (module3, exports3) {
                    var hasOwnProperty = {}.hasOwnProperty;
                    module3.exports = function (it2, key) {
                        return hasOwnProperty.call(it2, key);
                    };
                },
                /* 18 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = !__webpack_require__(19)(function () {
                        return Object.defineProperty({}, "a", { get: function () {
                                return 7;
                            } }).a != 7;
                    });
                },
                /* 19 */
                /***/
                function (module3, exports3) {
                    module3.exports = function (exec) {
                        try {
                            return !!exec();
                        }
                        catch (e) {
                            return true;
                        }
                    };
                },
                /* 20 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var global2 = __webpack_require__(16), core = __webpack_require__(21), ctx = __webpack_require__(22), PROTOTYPE = "prototype";
                    var $export = function (type2, name, source) {
                        var IS_FORCED = type2 & $export.F, IS_GLOBAL = type2 & $export.G, IS_STATIC = type2 & $export.S, IS_PROTO = type2 & $export.P, IS_BIND = type2 & $export.B, IS_WRAP = type2 & $export.W, exports4 = IS_GLOBAL ? core : core[name] || (core[name] = {}), target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE], key, own, out;
                        if (IS_GLOBAL)
                            source = name;
                        for (key in source) {
                            own = !IS_FORCED && target && key in target;
                            if (own && key in exports4)
                                continue;
                            out = own ? target[key] : source[key];
                            exports4[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function (C) {
                                var F = function (param) {
                                    return this instanceof C ? new C(param) : C(param);
                                };
                                F[PROTOTYPE] = C[PROTOTYPE];
                                return F;
                            }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                            if (IS_PROTO)
                                (exports4[PROTOTYPE] || (exports4[PROTOTYPE] = {}))[key] = out;
                        }
                    };
                    $export.F = 1;
                    $export.G = 2;
                    $export.S = 4;
                    $export.P = 8;
                    $export.B = 16;
                    $export.W = 32;
                    module3.exports = $export;
                },
                /* 21 */
                /***/
                function (module3, exports3) {
                    var core = module3.exports = { version: "1.2.6" };
                    if (typeof __e == "number")
                        __e = core;
                },
                /* 22 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var aFunction = __webpack_require__(23);
                    module3.exports = function (fn, that, length) {
                        aFunction(fn);
                        if (that === void 0)
                            return fn;
                        switch (length) {
                            case 1:
                                return function (a) {
                                    return fn.call(that, a);
                                };
                            case 2:
                                return function (a, b) {
                                    return fn.call(that, a, b);
                                };
                            case 3:
                                return function (a, b, c) {
                                    return fn.call(that, a, b, c);
                                };
                        }
                        return function () {
                            return fn.apply(that, arguments);
                        };
                    };
                },
                /* 23 */
                /***/
                function (module3, exports3) {
                    module3.exports = function (it2) {
                        if (typeof it2 != "function")
                            throw TypeError(it2 + " is not a function!");
                        return it2;
                    };
                },
                /* 24 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = __webpack_require__(25);
                },
                /* 25 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9), createDesc = __webpack_require__(26);
                    module3.exports = __webpack_require__(18) ? function (object, key, value) {
                        return $.setDesc(object, key, createDesc(1, value));
                    } : function (object, key, value) {
                        object[key] = value;
                        return object;
                    };
                },
                /* 26 */
                /***/
                function (module3, exports3) {
                    module3.exports = function (bitmap, value) {
                        return {
                            enumerable: !(bitmap & 1),
                            configurable: !(bitmap & 2),
                            writable: !(bitmap & 4),
                            value
                        };
                    };
                },
                /* 27 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var global2 = __webpack_require__(16), SHARED = "__core-js_shared__", store2 = global2[SHARED] || (global2[SHARED] = {});
                    module3.exports = function (key) {
                        return store2[key] || (store2[key] = {});
                    };
                },
                /* 28 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var def = __webpack_require__(9).setDesc, has = __webpack_require__(17), TAG = __webpack_require__(29)("toStringTag");
                    module3.exports = function (it2, tag, stat) {
                        if (it2 && !has(it2 = stat ? it2 : it2.prototype, TAG))
                            def(it2, TAG, { configurable: true, value: tag });
                    };
                },
                /* 29 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var store2 = __webpack_require__(27)("wks"), uid2 = __webpack_require__(30), Symbol2 = __webpack_require__(16).Symbol;
                    module3.exports = function (name) {
                        return store2[name] || (store2[name] = Symbol2 && Symbol2[name] || (Symbol2 || uid2)("Symbol." + name));
                    };
                },
                /* 30 */
                /***/
                function (module3, exports3) {
                    var id2 = 0, px = Math.random();
                    module3.exports = function (key) {
                        return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id2 + px).toString(36));
                    };
                },
                /* 31 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9), toIObject = __webpack_require__(32);
                    module3.exports = function (object, el2) {
                        var O = toIObject(object), keys2 = $.getKeys(O), length = keys2.length, index = 0, key;
                        while (length > index)
                            if (O[key = keys2[index++]] === el2)
                                return key;
                    };
                },
                /* 32 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var IObject = __webpack_require__(33), defined = __webpack_require__(35);
                    module3.exports = function (it2) {
                        return IObject(defined(it2));
                    };
                },
                /* 33 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var cof = __webpack_require__(34);
                    module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function (it2) {
                        return cof(it2) == "String" ? it2.split("") : Object(it2);
                    };
                },
                /* 34 */
                /***/
                function (module3, exports3) {
                    var toString = {}.toString;
                    module3.exports = function (it2) {
                        return toString.call(it2).slice(8, -1);
                    };
                },
                /* 35 */
                /***/
                function (module3, exports3) {
                    module3.exports = function (it2) {
                        if (it2 == void 0)
                            throw TypeError("Can't call method on  " + it2);
                        return it2;
                    };
                },
                /* 36 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var toIObject = __webpack_require__(32), getNames = __webpack_require__(9).getNames, toString = {}.toString;
                    var windowNames = typeof window == "object" && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
                    var getWindowNames = function (it2) {
                        try {
                            return getNames(it2);
                        }
                        catch (e) {
                            return windowNames.slice();
                        }
                    };
                    module3.exports.get = function getOwnPropertyNames(it2) {
                        if (windowNames && toString.call(it2) == "[object Window]")
                            return getWindowNames(it2);
                        return getNames(toIObject(it2));
                    };
                },
                /* 37 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9);
                    module3.exports = function (it2) {
                        var keys2 = $.getKeys(it2), getSymbols = $.getSymbols;
                        if (getSymbols) {
                            var symbols = getSymbols(it2), isEnum = $.isEnum, i = 0, key;
                            while (symbols.length > i)
                                if (isEnum.call(it2, key = symbols[i++]))
                                    keys2.push(key);
                        }
                        return keys2;
                    };
                },
                /* 38 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var cof = __webpack_require__(34);
                    module3.exports = Array.isArray || function (arg) {
                        return cof(arg) == "Array";
                    };
                },
                /* 39 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var isObject = __webpack_require__(40);
                    module3.exports = function (it2) {
                        if (!isObject(it2))
                            throw TypeError(it2 + " is not an object!");
                        return it2;
                    };
                },
                /* 40 */
                /***/
                function (module3, exports3) {
                    module3.exports = function (it2) {
                        return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
                    };
                },
                /* 41 */
                /***/
                function (module3, exports3) {
                    module3.exports = true;
                },
                /* 42 */
                /***/
                function (module3, exports3) {
                },
                /* 43 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(44), __esModule: true };
                },
                /* 44 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    __webpack_require__(45);
                    __webpack_require__(51);
                    module3.exports = __webpack_require__(29)("iterator");
                },
                /* 45 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $at = __webpack_require__(46)(true);
                    __webpack_require__(48)(String, "String", function (iterated) {
                        this._t = String(iterated);
                        this._i = 0;
                    }, function () {
                        var O = this._t, index = this._i, point;
                        if (index >= O.length)
                            return { value: void 0, done: true };
                        point = $at(O, index);
                        this._i += point.length;
                        return { value: point, done: false };
                    });
                },
                /* 46 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var toInteger2 = __webpack_require__(47), defined = __webpack_require__(35);
                    module3.exports = function (TO_STRING) {
                        return function (that, pos) {
                            var s = String(defined(that)), i = toInteger2(pos), l = s.length, a, b;
                            if (i < 0 || i >= l)
                                return TO_STRING ? "" : void 0;
                            a = s.charCodeAt(i);
                            return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
                        };
                    };
                },
                /* 47 */
                /***/
                function (module3, exports3) {
                    var ceil = Math.ceil, floor2 = Math.floor;
                    module3.exports = function (it2) {
                        return isNaN(it2 = +it2) ? 0 : (it2 > 0 ? floor2 : ceil)(it2);
                    };
                },
                /* 48 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var LIBRARY = __webpack_require__(41), $export = __webpack_require__(20), redefine = __webpack_require__(24), hide = __webpack_require__(25), has = __webpack_require__(17), Iterators = __webpack_require__(49), $iterCreate = __webpack_require__(50), setToStringTag = __webpack_require__(28), getProto2 = __webpack_require__(9).getProto, ITERATOR = __webpack_require__(29)("iterator"), BUGGY = !([].keys && "next" in [].keys()), FF_ITERATOR = "@@iterator", KEYS = "keys", VALUES = "values";
                    var returnThis = function () {
                        return this;
                    };
                    module3.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
                        $iterCreate(Constructor, NAME, next);
                        var getMethod = function (kind) {
                            if (!BUGGY && kind in proto2)
                                return proto2[kind];
                            switch (kind) {
                                case KEYS:
                                    return function keys2() {
                                        return new Constructor(this, kind);
                                    };
                                case VALUES:
                                    return function values() {
                                        return new Constructor(this, kind);
                                    };
                            }
                            return function entries() {
                                return new Constructor(this, kind);
                            };
                        };
                        var TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = false, proto2 = Base.prototype, $native = proto2[ITERATOR] || proto2[FF_ITERATOR] || DEFAULT && proto2[DEFAULT], $default = $native || getMethod(DEFAULT), methods2, key;
                        if ($native) {
                            var IteratorPrototype = getProto2($default.call(new Base()));
                            setToStringTag(IteratorPrototype, TAG, true);
                            if (!LIBRARY && has(proto2, FF_ITERATOR))
                                hide(IteratorPrototype, ITERATOR, returnThis);
                            if (DEF_VALUES && $native.name !== VALUES) {
                                VALUES_BUG = true;
                                $default = function values() {
                                    return $native.call(this);
                                };
                            }
                        }
                        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto2[ITERATOR])) {
                            hide(proto2, ITERATOR, $default);
                        }
                        Iterators[NAME] = $default;
                        Iterators[TAG] = returnThis;
                        if (DEFAULT) {
                            methods2 = {
                                values: DEF_VALUES ? $default : getMethod(VALUES),
                                keys: IS_SET ? $default : getMethod(KEYS),
                                entries: !DEF_VALUES ? $default : getMethod("entries")
                            };
                            if (FORCED)
                                for (key in methods2) {
                                    if (!(key in proto2))
                                        redefine(proto2, key, methods2[key]);
                                }
                            else
                                $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods2);
                        }
                        return methods2;
                    };
                },
                /* 49 */
                /***/
                function (module3, exports3) {
                    module3.exports = {};
                },
                /* 50 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9), descriptor = __webpack_require__(26), setToStringTag = __webpack_require__(28), IteratorPrototype = {};
                    __webpack_require__(25)(IteratorPrototype, __webpack_require__(29)("iterator"), function () {
                        return this;
                    });
                    module3.exports = function (Constructor, NAME, next) {
                        Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });
                        setToStringTag(Constructor, NAME + " Iterator");
                    };
                },
                /* 51 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    __webpack_require__(52);
                    var Iterators = __webpack_require__(49);
                    Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
                },
                /* 52 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var addToUnscopables = __webpack_require__(53), step = __webpack_require__(54), Iterators = __webpack_require__(49), toIObject = __webpack_require__(32);
                    module3.exports = __webpack_require__(48)(Array, "Array", function (iterated, kind) {
                        this._t = toIObject(iterated);
                        this._i = 0;
                        this._k = kind;
                    }, function () {
                        var O = this._t, kind = this._k, index = this._i++;
                        if (!O || index >= O.length) {
                            this._t = void 0;
                            return step(1);
                        }
                        if (kind == "keys")
                            return step(0, index);
                        if (kind == "values")
                            return step(0, O[index]);
                        return step(0, [index, O[index]]);
                    }, "values");
                    Iterators.Arguments = Iterators.Array;
                    addToUnscopables("keys");
                    addToUnscopables("values");
                    addToUnscopables("entries");
                },
                /* 53 */
                /***/
                function (module3, exports3) {
                    module3.exports = function () {
                    };
                },
                /* 54 */
                /***/
                function (module3, exports3) {
                    module3.exports = function (done, value) {
                        return { value, done: !!done };
                    };
                },
                /* 55 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(56), __esModule: true };
                },
                /* 56 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    __webpack_require__(51);
                    __webpack_require__(45);
                    module3.exports = __webpack_require__(57);
                },
                /* 57 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var anObject = __webpack_require__(39), get2 = __webpack_require__(58);
                    module3.exports = __webpack_require__(21).getIterator = function (it2) {
                        var iterFn = get2(it2);
                        if (typeof iterFn != "function")
                            throw TypeError(it2 + " is not iterable!");
                        return anObject(iterFn.call(it2));
                    };
                },
                /* 58 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var classof = __webpack_require__(59), ITERATOR = __webpack_require__(29)("iterator"), Iterators = __webpack_require__(49);
                    module3.exports = __webpack_require__(21).getIteratorMethod = function (it2) {
                        if (it2 != void 0)
                            return it2[ITERATOR] || it2["@@iterator"] || Iterators[classof(it2)];
                    };
                },
                /* 59 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var cof = __webpack_require__(34), TAG = __webpack_require__(29)("toStringTag"), ARG = cof(/* @__PURE__ */ function () {
                        return arguments;
                    }()) == "Arguments";
                    module3.exports = function (it2) {
                        var O, T, B;
                        return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (T = (O = Object(it2))[TAG]) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
                    };
                },
                /* 60 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(61), __esModule: true };
                },
                /* 61 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    __webpack_require__(62);
                    module3.exports = __webpack_require__(21).Object.keys;
                },
                /* 62 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var toObject = __webpack_require__(63);
                    __webpack_require__(64)("keys", function ($keys) {
                        return function keys2(it2) {
                            return $keys(toObject(it2));
                        };
                    });
                },
                /* 63 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var defined = __webpack_require__(35);
                    module3.exports = function (it2) {
                        return Object(defined(it2));
                    };
                },
                /* 64 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $export = __webpack_require__(20), core = __webpack_require__(21), fails = __webpack_require__(19);
                    module3.exports = function (KEY, exec) {
                        var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
                        exp[KEY] = exec(fn);
                        $export($export.S + $export.F * fails(function () {
                            fn(1);
                        }), "Object", exp);
                    };
                },
                /* 65 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("helperMissing", function () {
                            if (arguments.length === 1) {
                                return void 0;
                            }
                            else {
                                throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                            }
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 66 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("if", function (conditional, options2) {
                            if (arguments.length != 2) {
                                throw new _exception2["default"]("#if requires exactly one argument");
                            }
                            if (_utils.isFunction(conditional)) {
                                conditional = conditional.call(this);
                            }
                            if (!options2.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                                return options2.inverse(this);
                            }
                            else {
                                return options2.fn(this);
                            }
                        });
                        instance2.registerHelper("unless", function (conditional, options2) {
                            if (arguments.length != 2) {
                                throw new _exception2["default"]("#unless requires exactly one argument");
                            }
                            return instance2.helpers["if"].call(this, conditional, {
                                fn: options2.inverse,
                                inverse: options2.fn,
                                hash: options2.hash
                            });
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 67 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("log", function () {
                            var args = [void 0], options2 = arguments[arguments.length - 1];
                            for (var i = 0; i < arguments.length - 1; i++) {
                                args.push(arguments[i]);
                            }
                            var level = 1;
                            if (options2.hash.level != null) {
                                level = options2.hash.level;
                            }
                            else if (options2.data && options2.data.level != null) {
                                level = options2.data.level;
                            }
                            args[0] = level;
                            instance2.log.apply(instance2, args);
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 68 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("lookup", function (obj, field, options2) {
                            if (!obj) {
                                return obj;
                            }
                            return options2.lookupProperty(obj, field);
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 69 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    exports3["default"] = function (instance2) {
                        instance2.registerHelper("with", function (context, options2) {
                            if (arguments.length != 2) {
                                throw new _exception2["default"]("#with requires exactly one argument");
                            }
                            if (_utils.isFunction(context)) {
                                context = context.call(this);
                            }
                            var fn = options2.fn;
                            if (!_utils.isEmpty(context)) {
                                var data = options2.data;
                                if (options2.data && options2.ids) {
                                    data = _utils.createFrame(options2.data);
                                    data.contextPath = _utils.appendContextPath(options2.data.contextPath, options2.ids[0]);
                                }
                                return fn(context, {
                                    data,
                                    blockParams: _utils.blockParams([context], [data && data.contextPath])
                                });
                            }
                            else {
                                return options2.inverse(this);
                            }
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 70 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.registerDefaultDecorators = registerDefaultDecorators;
                    var _decoratorsInline = __webpack_require__(71);
                    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
                    function registerDefaultDecorators(instance2) {
                        _decoratorsInline2["default"](instance2);
                    }
                },
                /* 71 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    exports3["default"] = function (instance2) {
                        instance2.registerDecorator("inline", function (fn, props, container, options2) {
                            var ret = fn;
                            if (!props.partials) {
                                props.partials = {};
                                ret = function (context, options3) {
                                    var original = container.partials;
                                    container.partials = _utils.extend({}, original, props.partials);
                                    var ret2 = fn(context, options3);
                                    container.partials = original;
                                    return ret2;
                                };
                            }
                            props.partials[options2.args[0]] = options2.fn;
                            return ret;
                        });
                    };
                    module3.exports = exports3["default"];
                },
                /* 72 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    var logger2 = {
                        methodMap: ["debug", "info", "warn", "error"],
                        level: "info",
                        // Maps a given level value to the `methodMap` indexes above.
                        lookupLevel: function lookupLevel(level) {
                            if (typeof level === "string") {
                                var levelMap = _utils.indexOf(logger2.methodMap, level.toLowerCase());
                                if (levelMap >= 0) {
                                    level = levelMap;
                                }
                                else {
                                    level = parseInt(level, 10);
                                }
                            }
                            return level;
                        },
                        // Can be overridden in the host environment
                        log: function log(level) {
                            level = logger2.lookupLevel(level);
                            if (typeof console !== "undefined" && logger2.lookupLevel(logger2.level) <= level) {
                                var method = logger2.methodMap[level];
                                if (!console[method]) {
                                    method = "log";
                                }
                                for (var _len = arguments.length, message2 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                    message2[_key - 1] = arguments[_key];
                                }
                                console[method].apply(console, message2);
                            }
                        }
                    };
                    exports3["default"] = logger2;
                    module3.exports = exports3["default"];
                },
                /* 73 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$create = __webpack_require__(74)["default"];
                    var _Object$keys = __webpack_require__(60)["default"];
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.createProtoAccessControl = createProtoAccessControl;
                    exports3.resultIsAllowed = resultIsAllowed;
                    exports3.resetLoggedProperties = resetLoggedProperties;
                    var _createNewLookupObject = __webpack_require__(76);
                    var _logger = __webpack_require__(72);
                    var _logger2 = _interopRequireDefault(_logger);
                    var loggedProperties = _Object$create(null);
                    function createProtoAccessControl(runtimeOptions) {
                        var defaultMethodWhiteList = _Object$create(null);
                        defaultMethodWhiteList["constructor"] = false;
                        defaultMethodWhiteList["__defineGetter__"] = false;
                        defaultMethodWhiteList["__defineSetter__"] = false;
                        defaultMethodWhiteList["__lookupGetter__"] = false;
                        var defaultPropertyWhiteList = _Object$create(null);
                        defaultPropertyWhiteList["__proto__"] = false;
                        return {
                            properties: {
                                whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
                                defaultValue: runtimeOptions.allowProtoPropertiesByDefault
                            },
                            methods: {
                                whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
                                defaultValue: runtimeOptions.allowProtoMethodsByDefault
                            }
                        };
                    }
                    function resultIsAllowed(result, protoAccessControl, propertyName) {
                        if (typeof result === "function") {
                            return checkWhiteList(protoAccessControl.methods, propertyName);
                        }
                        else {
                            return checkWhiteList(protoAccessControl.properties, propertyName);
                        }
                    }
                    function checkWhiteList(protoAccessControlForType, propertyName) {
                        if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
                            return protoAccessControlForType.whitelist[propertyName] === true;
                        }
                        if (protoAccessControlForType.defaultValue !== void 0) {
                            return protoAccessControlForType.defaultValue;
                        }
                        logUnexpecedPropertyAccessOnce(propertyName);
                        return false;
                    }
                    function logUnexpecedPropertyAccessOnce(propertyName) {
                        if (loggedProperties[propertyName] !== true) {
                            loggedProperties[propertyName] = true;
                            _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
                        }
                    }
                    function resetLoggedProperties() {
                        _Object$keys(loggedProperties).forEach(function (propertyName) {
                            delete loggedProperties[propertyName];
                        });
                    }
                },
                /* 74 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(75), __esModule: true };
                },
                /* 75 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var $ = __webpack_require__(9);
                    module3.exports = function create(P, D) {
                        return $.create(P, D);
                    };
                },
                /* 76 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$create = __webpack_require__(74)["default"];
                    exports3.__esModule = true;
                    exports3.createNewLookupObject = createNewLookupObject;
                    var _utils = __webpack_require__(5);
                    function createNewLookupObject() {
                        for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
                            sources[_key] = arguments[_key];
                        }
                        return _utils.extend.apply(void 0, [_Object$create(null)].concat(sources));
                    }
                },
                /* 77 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    function SafeString(string) {
                        this.string = string;
                    }
                    SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
                        return "" + this.string;
                    };
                    exports3["default"] = SafeString;
                    module3.exports = exports3["default"];
                },
                /* 78 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$seal = __webpack_require__(79)["default"];
                    var _Object$keys = __webpack_require__(60)["default"];
                    var _interopRequireWildcard = __webpack_require__(3)["default"];
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.checkRevision = checkRevision;
                    exports3.template = template;
                    exports3.wrapProgram = wrapProgram;
                    exports3.resolvePartial = resolvePartial;
                    exports3.invokePartial = invokePartial;
                    exports3.noop = noop2;
                    var _utils = __webpack_require__(5);
                    var Utils = _interopRequireWildcard(_utils);
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    var _base = __webpack_require__(4);
                    var _helpers = __webpack_require__(10);
                    var _internalWrapHelper = __webpack_require__(82);
                    var _internalProtoAccess = __webpack_require__(73);
                    function checkRevision(compilerInfo) {
                        var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
                        if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
                            return;
                        }
                        if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
                            var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                            throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
                        }
                        else {
                            throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
                        }
                    }
                    function template(templateSpec, env) {
                        if (!env) {
                            throw new _exception2["default"]("No environment passed to template");
                        }
                        if (!templateSpec || !templateSpec.main) {
                            throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
                        }
                        templateSpec.main.decorator = templateSpec.main_d;
                        env.VM.checkRevision(templateSpec.compiler);
                        var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
                        function invokePartialWrapper(partial, context, options2) {
                            if (options2.hash) {
                                context = Utils.extend({}, context, options2.hash);
                                if (options2.ids) {
                                    options2.ids[0] = true;
                                }
                            }
                            partial = env.VM.resolvePartial.call(this, partial, context, options2);
                            var extendedOptions = Utils.extend({}, options2, {
                                hooks: this.hooks,
                                protoAccessControl: this.protoAccessControl
                            });
                            var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
                            if (result == null && env.compile) {
                                options2.partials[options2.name] = env.compile(partial, templateSpec.compilerOptions, env);
                                result = options2.partials[options2.name](context, extendedOptions);
                            }
                            if (result != null) {
                                if (options2.indent) {
                                    var lines = result.split("\n");
                                    for (var i = 0, l = lines.length; i < l; i++) {
                                        if (!lines[i] && i + 1 === l) {
                                            break;
                                        }
                                        lines[i] = options2.indent + lines[i];
                                    }
                                    result = lines.join("\n");
                                }
                                return result;
                            }
                            else {
                                throw new _exception2["default"]("The partial " + options2.name + " could not be compiled when running in runtime-only mode");
                            }
                        }
                        var container = {
                            strict: function strict(obj, name, loc) {
                                if (!obj || !(name in obj)) {
                                    throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
                                        loc
                                    });
                                }
                                return container.lookupProperty(obj, name);
                            },
                            lookupProperty: function lookupProperty(parent, propertyName) {
                                var result = parent[propertyName];
                                if (result == null) {
                                    return result;
                                }
                                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                                    return result;
                                }
                                if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
                                    return result;
                                }
                                return void 0;
                            },
                            lookup: function lookup(depths, name) {
                                var len = depths.length;
                                for (var i = 0; i < len; i++) {
                                    var result = depths[i] && container.lookupProperty(depths[i], name);
                                    if (result != null) {
                                        return depths[i][name];
                                    }
                                }
                            },
                            lambda: function lambda(current, context) {
                                return typeof current === "function" ? current.call(context) : current;
                            },
                            escapeExpression: Utils.escapeExpression,
                            invokePartial: invokePartialWrapper,
                            fn: function fn(i) {
                                var ret2 = templateSpec[i];
                                ret2.decorator = templateSpec[i + "_d"];
                                return ret2;
                            },
                            programs: [],
                            program: function program(i, data, declaredBlockParams, blockParams, depths) {
                                var programWrapper = this.programs[i], fn = this.fn(i);
                                if (data || depths || blockParams || declaredBlockParams) {
                                    programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                                }
                                else if (!programWrapper) {
                                    programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                                }
                                return programWrapper;
                            },
                            data: function data(value, depth) {
                                while (value && depth--) {
                                    value = value._parent;
                                }
                                return value;
                            },
                            mergeIfNeeded: function mergeIfNeeded(param, common) {
                                var obj = param || common;
                                if (param && common && param !== common) {
                                    obj = Utils.extend({}, common, param);
                                }
                                return obj;
                            },
                            // An empty object to use as replacement for null-contexts
                            nullContext: _Object$seal({}),
                            noop: env.VM.noop,
                            compilerInfo: templateSpec.compiler
                        };
                        function ret(context) {
                            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
                            var data = options2.data;
                            ret._setup(options2);
                            if (!options2.partial && templateSpec.useData) {
                                data = initData(context, data);
                            }
                            var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
                            if (templateSpec.useDepths) {
                                if (options2.depths) {
                                    depths = context != options2.depths[0] ? [context].concat(options2.depths) : options2.depths;
                                }
                                else {
                                    depths = [context];
                                }
                            }
                            function main(context2) {
                                return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
                            }
                            main = executeDecorators(templateSpec.main, main, container, options2.depths || [], data, blockParams);
                            return main(context, options2);
                        }
                        ret.isTop = true;
                        ret._setup = function (options2) {
                            if (!options2.partial) {
                                var mergedHelpers = Utils.extend({}, env.helpers, options2.helpers);
                                wrapHelpersToPassLookupProperty(mergedHelpers, container);
                                container.helpers = mergedHelpers;
                                if (templateSpec.usePartial) {
                                    container.partials = container.mergeIfNeeded(options2.partials, env.partials);
                                }
                                if (templateSpec.usePartial || templateSpec.useDecorators) {
                                    container.decorators = Utils.extend({}, env.decorators, options2.decorators);
                                }
                                container.hooks = {};
                                container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options2);
                                var keepHelperInHelpers = options2.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
                                _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
                                _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
                            }
                            else {
                                container.protoAccessControl = options2.protoAccessControl;
                                container.helpers = options2.helpers;
                                container.partials = options2.partials;
                                container.decorators = options2.decorators;
                                container.hooks = options2.hooks;
                            }
                        };
                        ret._child = function (i, data, blockParams, depths) {
                            if (templateSpec.useBlockParams && !blockParams) {
                                throw new _exception2["default"]("must pass block params");
                            }
                            if (templateSpec.useDepths && !depths) {
                                throw new _exception2["default"]("must pass parent depths");
                            }
                            return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                        };
                        return ret;
                    }
                    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                        function prog(context) {
                            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
                            var currentDepths = depths;
                            if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
                                currentDepths = [context].concat(depths);
                            }
                            return fn(container, context, container.helpers, container.partials, options2.data || data, blockParams && [options2.blockParams].concat(blockParams), currentDepths);
                        }
                        prog = executeDecorators(fn, prog, container, depths, data, blockParams);
                        prog.program = i;
                        prog.depth = depths ? depths.length : 0;
                        prog.blockParams = declaredBlockParams || 0;
                        return prog;
                    }
                    function resolvePartial(partial, context, options2) {
                        if (!partial) {
                            if (options2.name === "@partial-block") {
                                partial = options2.data["partial-block"];
                            }
                            else {
                                partial = options2.partials[options2.name];
                            }
                        }
                        else if (!partial.call && !options2.name) {
                            options2.name = partial;
                            partial = options2.partials[partial];
                        }
                        return partial;
                    }
                    function invokePartial(partial, context, options2) {
                        var currentPartialBlock = options2.data && options2.data["partial-block"];
                        options2.partial = true;
                        if (options2.ids) {
                            options2.data.contextPath = options2.ids[0] || options2.data.contextPath;
                        }
                        var partialBlock = void 0;
                        if (options2.fn && options2.fn !== noop2) {
                            (function () {
                                options2.data = _base.createFrame(options2.data);
                                var fn = options2.fn;
                                partialBlock = options2.data["partial-block"] = function partialBlockWrapper(context2) {
                                    var options3 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
                                    options3.data = _base.createFrame(options3.data);
                                    options3.data["partial-block"] = currentPartialBlock;
                                    return fn(context2, options3);
                                };
                                if (fn.partials) {
                                    options2.partials = Utils.extend({}, options2.partials, fn.partials);
                                }
                            })();
                        }
                        if (partial === void 0 && partialBlock) {
                            partial = partialBlock;
                        }
                        if (partial === void 0) {
                            throw new _exception2["default"]("The partial " + options2.name + " could not be found");
                        }
                        else if (partial instanceof Function) {
                            return partial(context, options2);
                        }
                    }
                    function noop2() {
                        return "";
                    }
                    function initData(context, data) {
                        if (!data || !("root" in data)) {
                            data = data ? _base.createFrame(data) : {};
                            data.root = context;
                        }
                        return data;
                    }
                    function executeDecorators(fn, prog, container, depths, data, blockParams) {
                        if (fn.decorator) {
                            var props = {};
                            prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                            Utils.extend(prog, props);
                        }
                        return prog;
                    }
                    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
                        _Object$keys(mergedHelpers).forEach(function (helperName) {
                            var helper = mergedHelpers[helperName];
                            mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
                        });
                    }
                    function passLookupPropertyOption(helper, container) {
                        var lookupProperty = container.lookupProperty;
                        return _internalWrapHelper.wrapHelper(helper, function (options2) {
                            return Utils.extend({ lookupProperty }, options2);
                        });
                    }
                },
                /* 79 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    module3.exports = { "default": __webpack_require__(80), __esModule: true };
                },
                /* 80 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    __webpack_require__(81);
                    module3.exports = __webpack_require__(21).Object.seal;
                },
                /* 81 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var isObject = __webpack_require__(40);
                    __webpack_require__(64)("seal", function ($seal) {
                        return function seal(it2) {
                            return $seal && isObject(it2) ? $seal(it2) : it2;
                        };
                    });
                },
                /* 82 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    exports3.wrapHelper = wrapHelper;
                    function wrapHelper(helper, transformOptionsFn) {
                        if (typeof helper !== "function") {
                            return helper;
                        }
                        var wrapper = function wrapper2() {
                            var options2 = arguments[arguments.length - 1];
                            arguments[arguments.length - 1] = transformOptionsFn(options2);
                            return helper.apply(this, arguments);
                        };
                        return wrapper;
                    }
                },
                /* 83 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    exports3["default"] = function (Handlebars) {
                        (function () {
                            if (typeof globalThis === "object")
                                return;
                            Object.prototype.__defineGetter__("__magic__", function () {
                                return this;
                            });
                            __magic__.globalThis = __magic__;
                            delete Object.prototype.__magic__;
                        })();
                        var $Handlebars = globalThis.Handlebars;
                        Handlebars.noConflict = function () {
                            if (globalThis.Handlebars === Handlebars) {
                                globalThis.Handlebars = $Handlebars;
                            }
                            return Handlebars;
                        };
                    };
                    module3.exports = exports3["default"];
                },
                /* 84 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    var AST = {
                        // Public API used to evaluate derived attributes regarding AST nodes
                        helpers: {
                            // a mustache is definitely a helper if:
                            // * it is an eligible helper, and
                            // * it has at least one parameter or hash segment
                            helperExpression: function helperExpression(node2) {
                                return node2.type === "SubExpression" || (node2.type === "MustacheStatement" || node2.type === "BlockStatement") && !!(node2.params && node2.params.length || node2.hash);
                            },
                            scopedId: function scopedId(path2) {
                                return /^\.|this\b/.test(path2.original);
                            },
                            // an ID is simple if it only has one part, and that part is not
                            // `..` or `this`.
                            simpleId: function simpleId(path2) {
                                return path2.parts.length === 1 && !AST.helpers.scopedId(path2) && !path2.depth;
                            }
                        }
                    };
                    exports3["default"] = AST;
                    module3.exports = exports3["default"];
                },
                /* 85 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    var _interopRequireWildcard = __webpack_require__(3)["default"];
                    exports3.__esModule = true;
                    exports3.parseWithoutProcessing = parseWithoutProcessing;
                    exports3.parse = parse2;
                    var _parser = __webpack_require__(86);
                    var _parser2 = _interopRequireDefault(_parser);
                    var _whitespaceControl = __webpack_require__(87);
                    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
                    var _helpers = __webpack_require__(89);
                    var Helpers = _interopRequireWildcard(_helpers);
                    var _utils = __webpack_require__(5);
                    exports3.parser = _parser2["default"];
                    var yy = {};
                    _utils.extend(yy, Helpers);
                    function parseWithoutProcessing(input, options2) {
                        if (input.type === "Program") {
                            return input;
                        }
                        _parser2["default"].yy = yy;
                        yy.locInfo = function (locInfo) {
                            return new yy.SourceLocation(options2 && options2.srcName, locInfo);
                        };
                        var ast = _parser2["default"].parse(input);
                        return ast;
                    }
                    function parse2(input, options2) {
                        var ast = parseWithoutProcessing(input, options2);
                        var strip = new _whitespaceControl2["default"](options2);
                        return strip.accept(ast);
                    }
                },
                /* 86 */
                /***/
                function (module3, exports3) {
                    exports3.__esModule = true;
                    var handlebars2 = function () {
                        var parser2 = {
                            trace: function trace() {
                            },
                            yy: {},
                            symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
                            terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
                            productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
                            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
                                var $0 = $$.length - 1;
                                switch (yystate) {
                                    case 1:
                                        return $$[$0 - 1];
                                    case 2:
                                        this.$ = yy.prepareProgram($$[$0]);
                                        break;
                                    case 3:
                                        this.$ = $$[$0];
                                        break;
                                    case 4:
                                        this.$ = $$[$0];
                                        break;
                                    case 5:
                                        this.$ = $$[$0];
                                        break;
                                    case 6:
                                        this.$ = $$[$0];
                                        break;
                                    case 7:
                                        this.$ = $$[$0];
                                        break;
                                    case 8:
                                        this.$ = $$[$0];
                                        break;
                                    case 9:
                                        this.$ = {
                                            type: "CommentStatement",
                                            value: yy.stripComment($$[$0]),
                                            strip: yy.stripFlags($$[$0], $$[$0]),
                                            loc: yy.locInfo(this._$)
                                        };
                                        break;
                                    case 10:
                                        this.$ = {
                                            type: "ContentStatement",
                                            original: $$[$0],
                                            value: $$[$0],
                                            loc: yy.locInfo(this._$)
                                        };
                                        break;
                                    case 11:
                                        this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                        break;
                                    case 12:
                                        this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                                        break;
                                    case 13:
                                        this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                                        break;
                                    case 14:
                                        this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                                        break;
                                    case 15:
                                        this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                        break;
                                    case 16:
                                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                        break;
                                    case 17:
                                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                        break;
                                    case 18:
                                        this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                                        break;
                                    case 19:
                                        var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                                        program.chained = true;
                                        this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
                                        break;
                                    case 20:
                                        this.$ = $$[$0];
                                        break;
                                    case 21:
                                        this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                                        break;
                                    case 22:
                                        this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                        break;
                                    case 23:
                                        this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                        break;
                                    case 24:
                                        this.$ = {
                                            type: "PartialStatement",
                                            name: $$[$0 - 3],
                                            params: $$[$0 - 2],
                                            hash: $$[$0 - 1],
                                            indent: "",
                                            strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                                            loc: yy.locInfo(this._$)
                                        };
                                        break;
                                    case 25:
                                        this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                        break;
                                    case 26:
                                        this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                                        break;
                                    case 27:
                                        this.$ = $$[$0];
                                        break;
                                    case 28:
                                        this.$ = $$[$0];
                                        break;
                                    case 29:
                                        this.$ = {
                                            type: "SubExpression",
                                            path: $$[$0 - 3],
                                            params: $$[$0 - 2],
                                            hash: $$[$0 - 1],
                                            loc: yy.locInfo(this._$)
                                        };
                                        break;
                                    case 30:
                                        this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                                        break;
                                    case 31:
                                        this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                                        break;
                                    case 32:
                                        this.$ = yy.id($$[$0 - 1]);
                                        break;
                                    case 33:
                                        this.$ = $$[$0];
                                        break;
                                    case 34:
                                        this.$ = $$[$0];
                                        break;
                                    case 35:
                                        this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                                        break;
                                    case 36:
                                        this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                                        break;
                                    case 37:
                                        this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                                        break;
                                    case 38:
                                        this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                                        break;
                                    case 39:
                                        this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                                        break;
                                    case 40:
                                        this.$ = $$[$0];
                                        break;
                                    case 41:
                                        this.$ = $$[$0];
                                        break;
                                    case 42:
                                        this.$ = yy.preparePath(true, $$[$0], this._$);
                                        break;
                                    case 43:
                                        this.$ = yy.preparePath(false, $$[$0], this._$);
                                        break;
                                    case 44:
                                        $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                                        this.$ = $$[$0 - 2];
                                        break;
                                    case 45:
                                        this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                                        break;
                                    case 46:
                                        this.$ = [];
                                        break;
                                    case 47:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 48:
                                        this.$ = [];
                                        break;
                                    case 49:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 50:
                                        this.$ = [];
                                        break;
                                    case 51:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 58:
                                        this.$ = [];
                                        break;
                                    case 59:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 64:
                                        this.$ = [];
                                        break;
                                    case 65:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 70:
                                        this.$ = [];
                                        break;
                                    case 71:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 78:
                                        this.$ = [];
                                        break;
                                    case 79:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 82:
                                        this.$ = [];
                                        break;
                                    case 83:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 86:
                                        this.$ = [];
                                        break;
                                    case 87:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 90:
                                        this.$ = [];
                                        break;
                                    case 91:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 94:
                                        this.$ = [];
                                        break;
                                    case 95:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 98:
                                        this.$ = [$$[$0]];
                                        break;
                                    case 99:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                    case 100:
                                        this.$ = [$$[$0]];
                                        break;
                                    case 101:
                                        $$[$0 - 1].push($$[$0]);
                                        break;
                                }
                            },
                            table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
                            defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
                            parseError: function parseError(str, hash) {
                                throw new Error(str);
                            },
                            parse: function parse2(input) {
                                var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0;
                                this.lexer.setInput(input);
                                this.lexer.yy = this.yy;
                                this.yy.lexer = this.lexer;
                                this.yy.parser = this;
                                if (typeof this.lexer.yylloc == "undefined")
                                    this.lexer.yylloc = {};
                                var yyloc = this.lexer.yylloc;
                                lstack.push(yyloc);
                                var ranges = this.lexer.options && this.lexer.options.ranges;
                                if (typeof this.yy.parseError === "function")
                                    this.parseError = this.yy.parseError;
                                function lex() {
                                    var token;
                                    token = self2.lexer.lex() || 1;
                                    if (typeof token !== "number") {
                                        token = self2.symbols_[token] || token;
                                    }
                                    return token;
                                }
                                var symbol, state, action, r, yyval = {}, p, len, newState, expected;
                                while (true) {
                                    state = stack[stack.length - 1];
                                    if (this.defaultActions[state]) {
                                        action = this.defaultActions[state];
                                    }
                                    else {
                                        if (symbol === null || typeof symbol == "undefined") {
                                            symbol = lex();
                                        }
                                        action = table[state] && table[state][symbol];
                                    }
                                    if (typeof action === "undefined" || !action.length || !action[0]) {
                                        var errStr = "";
                                        {
                                            expected = [];
                                            for (p in table[state])
                                                if (this.terminals_[p] && p > 2) {
                                                    expected.push("'" + this.terminals_[p] + "'");
                                                }
                                            if (this.lexer.showPosition) {
                                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                            }
                                            else {
                                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                            }
                                            this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                                        }
                                    }
                                    if (action[0] instanceof Array && action.length > 1) {
                                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                                    }
                                    switch (action[0]) {
                                        case 1:
                                            stack.push(symbol);
                                            vstack.push(this.lexer.yytext);
                                            lstack.push(this.lexer.yylloc);
                                            stack.push(action[1]);
                                            symbol = null;
                                            {
                                                yyleng = this.lexer.yyleng;
                                                yytext = this.lexer.yytext;
                                                yylineno = this.lexer.yylineno;
                                                yyloc = this.lexer.yylloc;
                                            }
                                            break;
                                        case 2:
                                            len = this.productions_[action[1]][1];
                                            yyval.$ = vstack[vstack.length - len];
                                            yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                                            if (ranges) {
                                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                                            }
                                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                                            if (typeof r !== "undefined") {
                                                return r;
                                            }
                                            if (len) {
                                                stack = stack.slice(0, -1 * len * 2);
                                                vstack = vstack.slice(0, -1 * len);
                                                lstack = lstack.slice(0, -1 * len);
                                            }
                                            stack.push(this.productions_[action[1]][0]);
                                            vstack.push(yyval.$);
                                            lstack.push(yyval._$);
                                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                                            stack.push(newState);
                                            break;
                                        case 3:
                                            return true;
                                    }
                                }
                                return true;
                            }
                        };
                        var lexer = function () {
                            var lexer2 = {
                                EOF: 1,
                                parseError: function parseError(str, hash) {
                                    if (this.yy.parser) {
                                        this.yy.parser.parseError(str, hash);
                                    }
                                    else {
                                        throw new Error(str);
                                    }
                                },
                                setInput: function setInput(input) {
                                    this._input = input;
                                    this._more = this._less = this.done = false;
                                    this.yylineno = this.yyleng = 0;
                                    this.yytext = this.matched = this.match = "";
                                    this.conditionStack = ["INITIAL"];
                                    this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                                    if (this.options.ranges)
                                        this.yylloc.range = [0, 0];
                                    this.offset = 0;
                                    return this;
                                },
                                input: function input() {
                                    var ch = this._input[0];
                                    this.yytext += ch;
                                    this.yyleng++;
                                    this.offset++;
                                    this.match += ch;
                                    this.matched += ch;
                                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                                    if (lines) {
                                        this.yylineno++;
                                        this.yylloc.last_line++;
                                    }
                                    else {
                                        this.yylloc.last_column++;
                                    }
                                    if (this.options.ranges)
                                        this.yylloc.range[1]++;
                                    this._input = this._input.slice(1);
                                    return ch;
                                },
                                unput: function unput(ch) {
                                    var len = ch.length;
                                    var lines = ch.split(/(?:\r\n?|\n)/g);
                                    this._input = ch + this._input;
                                    this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                                    this.offset -= len;
                                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                                    this.match = this.match.substr(0, this.match.length - 1);
                                    this.matched = this.matched.substr(0, this.matched.length - 1);
                                    if (lines.length - 1)
                                        this.yylineno -= lines.length - 1;
                                    var r = this.yylloc.range;
                                    this.yylloc = {
                                        first_line: this.yylloc.first_line,
                                        last_line: this.yylineno + 1,
                                        first_column: this.yylloc.first_column,
                                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                                    };
                                    if (this.options.ranges) {
                                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                                    }
                                    return this;
                                },
                                more: function more() {
                                    this._more = true;
                                    return this;
                                },
                                less: function less(n) {
                                    this.unput(this.match.slice(n));
                                },
                                pastInput: function pastInput() {
                                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                                    return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
                                },
                                upcomingInput: function upcomingInput() {
                                    var next = this.match;
                                    if (next.length < 20) {
                                        next += this._input.substr(0, 20 - next.length);
                                    }
                                    return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
                                },
                                showPosition: function showPosition() {
                                    var pre = this.pastInput();
                                    var c = new Array(pre.length + 1).join("-");
                                    return pre + this.upcomingInput() + "\n" + c + "^";
                                },
                                next: function next() {
                                    if (this.done) {
                                        return this.EOF;
                                    }
                                    if (!this._input)
                                        this.done = true;
                                    var token, match2, tempMatch, index, lines;
                                    if (!this._more) {
                                        this.yytext = "";
                                        this.match = "";
                                    }
                                    var rules = this._currentRules();
                                    for (var i = 0; i < rules.length; i++) {
                                        tempMatch = this._input.match(this.rules[rules[i]]);
                                        if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
                                            match2 = tempMatch;
                                            index = i;
                                            if (!this.options.flex)
                                                break;
                                        }
                                    }
                                    if (match2) {
                                        lines = match2[0].match(/(?:\r\n?|\n).*/g);
                                        if (lines)
                                            this.yylineno += lines.length;
                                        this.yylloc = {
                                            first_line: this.yylloc.last_line,
                                            last_line: this.yylineno + 1,
                                            first_column: this.yylloc.last_column,
                                            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
                                        };
                                        this.yytext += match2[0];
                                        this.match += match2[0];
                                        this.matches = match2;
                                        this.yyleng = this.yytext.length;
                                        if (this.options.ranges) {
                                            this.yylloc.range = [this.offset, this.offset += this.yyleng];
                                        }
                                        this._more = false;
                                        this._input = this._input.slice(match2[0].length);
                                        this.matched += match2[0];
                                        token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                                        if (this.done && this._input)
                                            this.done = false;
                                        if (token)
                                            return token;
                                        else
                                            return;
                                    }
                                    if (this._input === "") {
                                        return this.EOF;
                                    }
                                    else {
                                        return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
                                    }
                                },
                                lex: function lex() {
                                    var r = this.next();
                                    if (typeof r !== "undefined") {
                                        return r;
                                    }
                                    else {
                                        return this.lex();
                                    }
                                },
                                begin: function begin(condition) {
                                    this.conditionStack.push(condition);
                                },
                                popState: function popState() {
                                    return this.conditionStack.pop();
                                },
                                _currentRules: function _currentRules() {
                                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                                },
                                topState: function topState() {
                                    return this.conditionStack[this.conditionStack.length - 2];
                                },
                                pushState: function begin(condition) {
                                    this.begin(condition);
                                }
                            };
                            lexer2.options = {};
                            lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                                function strip(start, end) {
                                    return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
                                }
                                switch ($avoiding_name_collisions) {
                                    case 0:
                                        if (yy_.yytext.slice(-2) === "\\\\") {
                                            strip(0, 1);
                                            this.begin("mu");
                                        }
                                        else if (yy_.yytext.slice(-1) === "\\") {
                                            strip(0, 1);
                                            this.begin("emu");
                                        }
                                        else {
                                            this.begin("mu");
                                        }
                                        if (yy_.yytext)
                                            return 15;
                                        break;
                                    case 1:
                                        return 15;
                                    case 2:
                                        this.popState();
                                        return 15;
                                    case 3:
                                        this.begin("raw");
                                        return 15;
                                    case 4:
                                        this.popState();
                                        if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                                            return 15;
                                        }
                                        else {
                                            strip(5, 9);
                                            return "END_RAW_BLOCK";
                                        }
                                    case 5:
                                        return 15;
                                    case 6:
                                        this.popState();
                                        return 14;
                                    case 7:
                                        return 65;
                                    case 8:
                                        return 68;
                                    case 9:
                                        return 19;
                                    case 10:
                                        this.popState();
                                        this.begin("raw");
                                        return 23;
                                    case 11:
                                        return 55;
                                    case 12:
                                        return 60;
                                    case 13:
                                        return 29;
                                    case 14:
                                        return 47;
                                    case 15:
                                        this.popState();
                                        return 44;
                                    case 16:
                                        this.popState();
                                        return 44;
                                    case 17:
                                        return 34;
                                    case 18:
                                        return 39;
                                    case 19:
                                        return 51;
                                    case 20:
                                        return 48;
                                    case 21:
                                        this.unput(yy_.yytext);
                                        this.popState();
                                        this.begin("com");
                                        break;
                                    case 22:
                                        this.popState();
                                        return 14;
                                    case 23:
                                        return 48;
                                    case 24:
                                        return 73;
                                    case 25:
                                        return 72;
                                    case 26:
                                        return 72;
                                    case 27:
                                        return 87;
                                    case 28:
                                        break;
                                    case 29:
                                        this.popState();
                                        return 54;
                                    case 30:
                                        this.popState();
                                        return 33;
                                    case 31:
                                        yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                                        return 80;
                                    case 32:
                                        yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                                        return 80;
                                    case 33:
                                        return 85;
                                    case 34:
                                        return 82;
                                    case 35:
                                        return 82;
                                    case 36:
                                        return 83;
                                    case 37:
                                        return 84;
                                    case 38:
                                        return 81;
                                    case 39:
                                        return 75;
                                    case 40:
                                        return 77;
                                    case 41:
                                        return 72;
                                    case 42:
                                        yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                                        return 72;
                                    case 43:
                                        return "INVALID";
                                    case 44:
                                        return 5;
                                }
                            };
                            lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
                            lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
                            return lexer2;
                        }();
                        parser2.lexer = lexer;
                        function Parser2() {
                            this.yy = {};
                        }
                        Parser2.prototype = parser2;
                        parser2.Parser = Parser2;
                        return new Parser2();
                    }();
                    exports3["default"] = handlebars2;
                    module3.exports = exports3["default"];
                },
                /* 87 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _visitor = __webpack_require__(88);
                    var _visitor2 = _interopRequireDefault(_visitor);
                    function WhitespaceControl() {
                        var options2 = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
                        this.options = options2;
                    }
                    WhitespaceControl.prototype = new _visitor2["default"]();
                    WhitespaceControl.prototype.Program = function (program) {
                        var doStandalone = !this.options.ignoreStandalone;
                        var isRoot = !this.isRootSeen;
                        this.isRootSeen = true;
                        var body = program.body;
                        for (var i = 0, l = body.length; i < l; i++) {
                            var current = body[i], strip = this.accept(current);
                            if (!strip) {
                                continue;
                            }
                            var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
                            if (strip.close) {
                                omitRight(body, i, true);
                            }
                            if (strip.open) {
                                omitLeft(body, i, true);
                            }
                            if (doStandalone && inlineStandalone) {
                                omitRight(body, i);
                                if (omitLeft(body, i)) {
                                    if (current.type === "PartialStatement") {
                                        current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
                                    }
                                }
                            }
                            if (doStandalone && openStandalone) {
                                omitRight((current.program || current.inverse).body);
                                omitLeft(body, i);
                            }
                            if (doStandalone && closeStandalone) {
                                omitRight(body, i);
                                omitLeft((current.inverse || current.program).body);
                            }
                        }
                        return program;
                    };
                    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
                        this.accept(block.program);
                        this.accept(block.inverse);
                        var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
                        if (inverse && inverse.chained) {
                            firstInverse = inverse.body[0].program;
                            while (lastInverse.chained) {
                                lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
                            }
                        }
                        var strip = {
                            open: block.openStrip.open,
                            close: block.closeStrip.close,
                            // Determine the standalone candiacy. Basically flag our content as being possibly standalone
                            // so our parent can determine if we actually are standalone
                            openStandalone: isNextWhitespace(program.body),
                            closeStandalone: isPrevWhitespace((firstInverse || program).body)
                        };
                        if (block.openStrip.close) {
                            omitRight(program.body, null, true);
                        }
                        if (inverse) {
                            var inverseStrip = block.inverseStrip;
                            if (inverseStrip.open) {
                                omitLeft(program.body, null, true);
                            }
                            if (inverseStrip.close) {
                                omitRight(firstInverse.body, null, true);
                            }
                            if (block.closeStrip.open) {
                                omitLeft(lastInverse.body, null, true);
                            }
                            if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
                                omitLeft(program.body);
                                omitRight(firstInverse.body);
                            }
                        }
                        else if (block.closeStrip.open) {
                            omitLeft(program.body, null, true);
                        }
                        return strip;
                    };
                    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
                        return mustache.strip;
                    };
                    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node2) {
                        var strip = node2.strip || {};
                        return {
                            inlineStandalone: true,
                            open: strip.open,
                            close: strip.close
                        };
                    };
                    function isPrevWhitespace(body, i, isRoot) {
                        if (i === void 0) {
                            i = body.length;
                        }
                        var prev = body[i - 1], sibling = body[i - 2];
                        if (!prev) {
                            return isRoot;
                        }
                        if (prev.type === "ContentStatement") {
                            return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
                        }
                    }
                    function isNextWhitespace(body, i, isRoot) {
                        if (i === void 0) {
                            i = -1;
                        }
                        var next = body[i + 1], sibling = body[i + 2];
                        if (!next) {
                            return isRoot;
                        }
                        if (next.type === "ContentStatement") {
                            return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
                        }
                    }
                    function omitRight(body, i, multiple) {
                        var current = body[i == null ? 0 : i + 1];
                        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
                            return;
                        }
                        var original = current.value;
                        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
                        current.rightStripped = current.value !== original;
                    }
                    function omitLeft(body, i, multiple) {
                        var current = body[i == null ? body.length - 1 : i - 1];
                        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
                            return;
                        }
                        var original = current.value;
                        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
                        current.leftStripped = current.value !== original;
                        return current.leftStripped;
                    }
                    exports3["default"] = WhitespaceControl;
                    module3.exports = exports3["default"];
                },
                /* 88 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    function Visitor() {
                        this.parents = [];
                    }
                    Visitor.prototype = {
                        constructor: Visitor,
                        mutating: false,
                        // Visits a given value. If mutating, will replace the value if necessary.
                        acceptKey: function acceptKey(node2, name) {
                            var value = this.accept(node2[name]);
                            if (this.mutating) {
                                if (value && !Visitor.prototype[value.type]) {
                                    throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node2.type);
                                }
                                node2[name] = value;
                            }
                        },
                        // Performs an accept operation with added sanity check to ensure
                        // required keys are not removed.
                        acceptRequired: function acceptRequired(node2, name) {
                            this.acceptKey(node2, name);
                            if (!node2[name]) {
                                throw new _exception2["default"](node2.type + " requires " + name);
                            }
                        },
                        // Traverses a given array. If mutating, empty respnses will be removed
                        // for child elements.
                        acceptArray: function acceptArray(array) {
                            for (var i = 0, l = array.length; i < l; i++) {
                                this.acceptKey(array, i);
                                if (!array[i]) {
                                    array.splice(i, 1);
                                    i--;
                                    l--;
                                }
                            }
                        },
                        accept: function accept(object) {
                            if (!object) {
                                return;
                            }
                            if (!this[object.type]) {
                                throw new _exception2["default"]("Unknown type: " + object.type, object);
                            }
                            if (this.current) {
                                this.parents.unshift(this.current);
                            }
                            this.current = object;
                            var ret = this[object.type](object);
                            this.current = this.parents.shift();
                            if (!this.mutating || ret) {
                                return ret;
                            }
                            else if (ret !== false) {
                                return object;
                            }
                        },
                        Program: function Program(program) {
                            this.acceptArray(program.body);
                        },
                        MustacheStatement: visitSubExpression,
                        Decorator: visitSubExpression,
                        BlockStatement: visitBlock,
                        DecoratorBlock: visitBlock,
                        PartialStatement: visitPartial,
                        PartialBlockStatement: function PartialBlockStatement(partial) {
                            visitPartial.call(this, partial);
                            this.acceptKey(partial, "program");
                        },
                        ContentStatement: function ContentStatement() {
                        },
                        CommentStatement: function CommentStatement() {
                        },
                        SubExpression: visitSubExpression,
                        PathExpression: function PathExpression() {
                        },
                        StringLiteral: function StringLiteral() {
                        },
                        NumberLiteral: function NumberLiteral() {
                        },
                        BooleanLiteral: function BooleanLiteral() {
                        },
                        UndefinedLiteral: function UndefinedLiteral() {
                        },
                        NullLiteral: function NullLiteral() {
                        },
                        Hash: function Hash(hash) {
                            this.acceptArray(hash.pairs);
                        },
                        HashPair: function HashPair(pair) {
                            this.acceptRequired(pair, "value");
                        }
                    };
                    function visitSubExpression(mustache) {
                        this.acceptRequired(mustache, "path");
                        this.acceptArray(mustache.params);
                        this.acceptKey(mustache, "hash");
                    }
                    function visitBlock(block) {
                        visitSubExpression.call(this, block);
                        this.acceptKey(block, "program");
                        this.acceptKey(block, "inverse");
                    }
                    function visitPartial(partial) {
                        this.acceptRequired(partial, "name");
                        this.acceptArray(partial.params);
                        this.acceptKey(partial, "hash");
                    }
                    exports3["default"] = Visitor;
                    module3.exports = exports3["default"];
                },
                /* 89 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.SourceLocation = SourceLocation;
                    exports3.id = id2;
                    exports3.stripFlags = stripFlags;
                    exports3.stripComment = stripComment;
                    exports3.preparePath = preparePath;
                    exports3.prepareMustache = prepareMustache;
                    exports3.prepareRawBlock = prepareRawBlock;
                    exports3.prepareBlock = prepareBlock;
                    exports3.prepareProgram = prepareProgram;
                    exports3.preparePartialBlock = preparePartialBlock;
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    function validateClose(open, close) {
                        close = close.path ? close.path.original : close;
                        if (open.path.original !== close) {
                            var errorNode = { loc: open.path.loc };
                            throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
                        }
                    }
                    function SourceLocation(source, locInfo) {
                        this.source = source;
                        this.start = {
                            line: locInfo.first_line,
                            column: locInfo.first_column
                        };
                        this.end = {
                            line: locInfo.last_line,
                            column: locInfo.last_column
                        };
                    }
                    function id2(token) {
                        if (/^\[.*\]$/.test(token)) {
                            return token.substring(1, token.length - 1);
                        }
                        else {
                            return token;
                        }
                    }
                    function stripFlags(open, close) {
                        return {
                            open: open.charAt(2) === "~",
                            close: close.charAt(close.length - 3) === "~"
                        };
                    }
                    function stripComment(comment) {
                        return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
                    }
                    function preparePath(data, parts, loc) {
                        loc = this.locInfo(loc);
                        var original = data ? "@" : "", dig = [], depth = 0;
                        for (var i = 0, l = parts.length; i < l; i++) {
                            var part = parts[i].part, isLiteral = parts[i].original !== part;
                            original += (parts[i].separator || "") + part;
                            if (!isLiteral && (part === ".." || part === "." || part === "this")) {
                                if (dig.length > 0) {
                                    throw new _exception2["default"]("Invalid path: " + original, { loc });
                                }
                                else if (part === "..") {
                                    depth++;
                                }
                            }
                            else {
                                dig.push(part);
                            }
                        }
                        return {
                            type: "PathExpression",
                            data,
                            depth,
                            parts: dig,
                            original,
                            loc
                        };
                    }
                    function prepareMustache(path2, params, hash, open, strip, locInfo) {
                        var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
                        var decorator = /\*/.test(open);
                        return {
                            type: decorator ? "Decorator" : "MustacheStatement",
                            path: path2,
                            params,
                            hash,
                            escaped,
                            strip,
                            loc: this.locInfo(locInfo)
                        };
                    }
                    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
                        validateClose(openRawBlock, close);
                        locInfo = this.locInfo(locInfo);
                        var program = {
                            type: "Program",
                            body: contents,
                            strip: {},
                            loc: locInfo
                        };
                        return {
                            type: "BlockStatement",
                            path: openRawBlock.path,
                            params: openRawBlock.params,
                            hash: openRawBlock.hash,
                            program,
                            openStrip: {},
                            inverseStrip: {},
                            closeStrip: {},
                            loc: locInfo
                        };
                    }
                    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
                        if (close && close.path) {
                            validateClose(openBlock, close);
                        }
                        var decorator = /\*/.test(openBlock.open);
                        program.blockParams = openBlock.blockParams;
                        var inverse = void 0, inverseStrip = void 0;
                        if (inverseAndProgram) {
                            if (decorator) {
                                throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
                            }
                            if (inverseAndProgram.chain) {
                                inverseAndProgram.program.body[0].closeStrip = close.strip;
                            }
                            inverseStrip = inverseAndProgram.strip;
                            inverse = inverseAndProgram.program;
                        }
                        if (inverted) {
                            inverted = inverse;
                            inverse = program;
                            program = inverted;
                        }
                        return {
                            type: decorator ? "DecoratorBlock" : "BlockStatement",
                            path: openBlock.path,
                            params: openBlock.params,
                            hash: openBlock.hash,
                            program,
                            inverse,
                            openStrip: openBlock.strip,
                            inverseStrip,
                            closeStrip: close && close.strip,
                            loc: this.locInfo(locInfo)
                        };
                    }
                    function prepareProgram(statements, loc) {
                        if (!loc && statements.length) {
                            var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
                            if (firstLoc && lastLoc) {
                                loc = {
                                    source: firstLoc.source,
                                    start: {
                                        line: firstLoc.start.line,
                                        column: firstLoc.start.column
                                    },
                                    end: {
                                        line: lastLoc.end.line,
                                        column: lastLoc.end.column
                                    }
                                };
                            }
                        }
                        return {
                            type: "Program",
                            body: statements,
                            strip: {},
                            loc
                        };
                    }
                    function preparePartialBlock(open, program, close, locInfo) {
                        validateClose(open, close);
                        return {
                            type: "PartialBlockStatement",
                            name: open.path,
                            params: open.params,
                            hash: open.hash,
                            program,
                            openStrip: open.strip,
                            closeStrip: close && close.strip,
                            loc: this.locInfo(locInfo)
                        };
                    }
                },
                /* 90 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$create = __webpack_require__(74)["default"];
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    exports3.Compiler = Compiler;
                    exports3.precompile = precompile;
                    exports3.compile = compile;
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    var _utils = __webpack_require__(5);
                    var _ast = __webpack_require__(84);
                    var _ast2 = _interopRequireDefault(_ast);
                    var slice = [].slice;
                    function Compiler() {
                    }
                    Compiler.prototype = {
                        compiler: Compiler,
                        equals: function equals(other) {
                            var len = this.opcodes.length;
                            if (other.opcodes.length !== len) {
                                return false;
                            }
                            for (var i = 0; i < len; i++) {
                                var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
                                if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
                                    return false;
                                }
                            }
                            len = this.children.length;
                            for (var i = 0; i < len; i++) {
                                if (!this.children[i].equals(other.children[i])) {
                                    return false;
                                }
                            }
                            return true;
                        },
                        guid: 0,
                        compile: function compile2(program, options2) {
                            this.sourceNode = [];
                            this.opcodes = [];
                            this.children = [];
                            this.options = options2;
                            this.stringParams = options2.stringParams;
                            this.trackIds = options2.trackIds;
                            options2.blockParams = options2.blockParams || [];
                            options2.knownHelpers = _utils.extend(_Object$create(null), {
                                helperMissing: true,
                                blockHelperMissing: true,
                                each: true,
                                "if": true,
                                unless: true,
                                "with": true,
                                log: true,
                                lookup: true
                            }, options2.knownHelpers);
                            return this.accept(program);
                        },
                        compileProgram: function compileProgram(program) {
                            var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
                            this.usePartial = this.usePartial || result.usePartial;
                            this.children[guid] = result;
                            this.useDepths = this.useDepths || result.useDepths;
                            return guid;
                        },
                        accept: function accept(node2) {
                            if (!this[node2.type]) {
                                throw new _exception2["default"]("Unknown type: " + node2.type, node2);
                            }
                            this.sourceNode.unshift(node2);
                            var ret = this[node2.type](node2);
                            this.sourceNode.shift();
                            return ret;
                        },
                        Program: function Program(program) {
                            this.options.blockParams.unshift(program.blockParams);
                            var body = program.body, bodyLength = body.length;
                            for (var i = 0; i < bodyLength; i++) {
                                this.accept(body[i]);
                            }
                            this.options.blockParams.shift();
                            this.isSimple = bodyLength === 1;
                            this.blockParams = program.blockParams ? program.blockParams.length : 0;
                            return this;
                        },
                        BlockStatement: function BlockStatement(block) {
                            transformLiteralToPath(block);
                            var program = block.program, inverse = block.inverse;
                            program = program && this.compileProgram(program);
                            inverse = inverse && this.compileProgram(inverse);
                            var type2 = this.classifySexpr(block);
                            if (type2 === "helper") {
                                this.helperSexpr(block, program, inverse);
                            }
                            else if (type2 === "simple") {
                                this.simpleSexpr(block);
                                this.opcode("pushProgram", program);
                                this.opcode("pushProgram", inverse);
                                this.opcode("emptyHash");
                                this.opcode("blockValue", block.path.original);
                            }
                            else {
                                this.ambiguousSexpr(block, program, inverse);
                                this.opcode("pushProgram", program);
                                this.opcode("pushProgram", inverse);
                                this.opcode("emptyHash");
                                this.opcode("ambiguousBlockValue");
                            }
                            this.opcode("append");
                        },
                        DecoratorBlock: function DecoratorBlock(decorator) {
                            var program = decorator.program && this.compileProgram(decorator.program);
                            var params = this.setupFullMustacheParams(decorator, program, void 0), path2 = decorator.path;
                            this.useDecorators = true;
                            this.opcode("registerDecorator", params.length, path2.original);
                        },
                        PartialStatement: function PartialStatement(partial) {
                            this.usePartial = true;
                            var program = partial.program;
                            if (program) {
                                program = this.compileProgram(partial.program);
                            }
                            var params = partial.params;
                            if (params.length > 1) {
                                throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
                            }
                            else if (!params.length) {
                                if (this.options.explicitPartialContext) {
                                    this.opcode("pushLiteral", "undefined");
                                }
                                else {
                                    params.push({ type: "PathExpression", parts: [], depth: 0 });
                                }
                            }
                            var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
                            if (isDynamic) {
                                this.accept(partial.name);
                            }
                            this.setupFullMustacheParams(partial, program, void 0, true);
                            var indent = partial.indent || "";
                            if (this.options.preventIndent && indent) {
                                this.opcode("appendContent", indent);
                                indent = "";
                            }
                            this.opcode("invokePartial", isDynamic, partialName, indent);
                            this.opcode("append");
                        },
                        PartialBlockStatement: function PartialBlockStatement(partialBlock) {
                            this.PartialStatement(partialBlock);
                        },
                        MustacheStatement: function MustacheStatement(mustache) {
                            this.SubExpression(mustache);
                            if (mustache.escaped && !this.options.noEscape) {
                                this.opcode("appendEscaped");
                            }
                            else {
                                this.opcode("append");
                            }
                        },
                        Decorator: function Decorator(decorator) {
                            this.DecoratorBlock(decorator);
                        },
                        ContentStatement: function ContentStatement(content) {
                            if (content.value) {
                                this.opcode("appendContent", content.value);
                            }
                        },
                        CommentStatement: function CommentStatement() {
                        },
                        SubExpression: function SubExpression(sexpr) {
                            transformLiteralToPath(sexpr);
                            var type2 = this.classifySexpr(sexpr);
                            if (type2 === "simple") {
                                this.simpleSexpr(sexpr);
                            }
                            else if (type2 === "helper") {
                                this.helperSexpr(sexpr);
                            }
                            else {
                                this.ambiguousSexpr(sexpr);
                            }
                        },
                        ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
                            var path2 = sexpr.path, name = path2.parts[0], isBlock = program != null || inverse != null;
                            this.opcode("getContext", path2.depth);
                            this.opcode("pushProgram", program);
                            this.opcode("pushProgram", inverse);
                            path2.strict = true;
                            this.accept(path2);
                            this.opcode("invokeAmbiguous", name, isBlock);
                        },
                        simpleSexpr: function simpleSexpr(sexpr) {
                            var path2 = sexpr.path;
                            path2.strict = true;
                            this.accept(path2);
                            this.opcode("resolvePossibleLambda");
                        },
                        helperSexpr: function helperSexpr(sexpr, program, inverse) {
                            var params = this.setupFullMustacheParams(sexpr, program, inverse), path2 = sexpr.path, name = path2.parts[0];
                            if (this.options.knownHelpers[name]) {
                                this.opcode("invokeKnownHelper", params.length, name);
                            }
                            else if (this.options.knownHelpersOnly) {
                                throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
                            }
                            else {
                                path2.strict = true;
                                path2.falsy = true;
                                this.accept(path2);
                                this.opcode("invokeHelper", params.length, path2.original, _ast2["default"].helpers.simpleId(path2));
                            }
                        },
                        PathExpression: function PathExpression(path2) {
                            this.addDepth(path2.depth);
                            this.opcode("getContext", path2.depth);
                            var name = path2.parts[0], scoped = _ast2["default"].helpers.scopedId(path2), blockParamId = !path2.depth && !scoped && this.blockParamIndex(name);
                            if (blockParamId) {
                                this.opcode("lookupBlockParam", blockParamId, path2.parts);
                            }
                            else if (!name) {
                                this.opcode("pushContext");
                            }
                            else if (path2.data) {
                                this.options.data = true;
                                this.opcode("lookupData", path2.depth, path2.parts, path2.strict);
                            }
                            else {
                                this.opcode("lookupOnContext", path2.parts, path2.falsy, path2.strict, scoped);
                            }
                        },
                        StringLiteral: function StringLiteral(string) {
                            this.opcode("pushString", string.value);
                        },
                        NumberLiteral: function NumberLiteral(number2) {
                            this.opcode("pushLiteral", number2.value);
                        },
                        BooleanLiteral: function BooleanLiteral(bool) {
                            this.opcode("pushLiteral", bool.value);
                        },
                        UndefinedLiteral: function UndefinedLiteral() {
                            this.opcode("pushLiteral", "undefined");
                        },
                        NullLiteral: function NullLiteral() {
                            this.opcode("pushLiteral", "null");
                        },
                        Hash: function Hash(hash) {
                            var pairs = hash.pairs, i = 0, l = pairs.length;
                            this.opcode("pushHash");
                            for (; i < l; i++) {
                                this.pushParam(pairs[i].value);
                            }
                            while (i--) {
                                this.opcode("assignToHash", pairs[i].key);
                            }
                            this.opcode("popHash");
                        },
                        // HELPERS
                        opcode: function opcode(name) {
                            this.opcodes.push({
                                opcode: name,
                                args: slice.call(arguments, 1),
                                loc: this.sourceNode[0].loc
                            });
                        },
                        addDepth: function addDepth(depth) {
                            if (!depth) {
                                return;
                            }
                            this.useDepths = true;
                        },
                        classifySexpr: function classifySexpr(sexpr) {
                            var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
                            var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
                            var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
                            var isEligible = !isBlockParam && (isHelper || isSimple);
                            if (isEligible && !isHelper) {
                                var _name = sexpr.path.parts[0], options2 = this.options;
                                if (options2.knownHelpers[_name]) {
                                    isHelper = true;
                                }
                                else if (options2.knownHelpersOnly) {
                                    isEligible = false;
                                }
                            }
                            if (isHelper) {
                                return "helper";
                            }
                            else if (isEligible) {
                                return "ambiguous";
                            }
                            else {
                                return "simple";
                            }
                        },
                        pushParams: function pushParams(params) {
                            for (var i = 0, l = params.length; i < l; i++) {
                                this.pushParam(params[i]);
                            }
                        },
                        pushParam: function pushParam(val2) {
                            var value = val2.value != null ? val2.value : val2.original || "";
                            if (this.stringParams) {
                                if (value.replace) {
                                    value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
                                }
                                if (val2.depth) {
                                    this.addDepth(val2.depth);
                                }
                                this.opcode("getContext", val2.depth || 0);
                                this.opcode("pushStringParam", value, val2.type);
                                if (val2.type === "SubExpression") {
                                    this.accept(val2);
                                }
                            }
                            else {
                                if (this.trackIds) {
                                    var blockParamIndex = void 0;
                                    if (val2.parts && !_ast2["default"].helpers.scopedId(val2) && !val2.depth) {
                                        blockParamIndex = this.blockParamIndex(val2.parts[0]);
                                    }
                                    if (blockParamIndex) {
                                        var blockParamChild = val2.parts.slice(1).join(".");
                                        this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
                                    }
                                    else {
                                        value = val2.original || value;
                                        if (value.replace) {
                                            value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
                                        }
                                        this.opcode("pushId", val2.type, value);
                                    }
                                }
                                this.accept(val2);
                            }
                        },
                        setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
                            var params = sexpr.params;
                            this.pushParams(params);
                            this.opcode("pushProgram", program);
                            this.opcode("pushProgram", inverse);
                            if (sexpr.hash) {
                                this.accept(sexpr.hash);
                            }
                            else {
                                this.opcode("emptyHash", omitEmpty);
                            }
                            return params;
                        },
                        blockParamIndex: function blockParamIndex(name) {
                            for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
                                var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
                                if (blockParams && param >= 0) {
                                    return [depth, param];
                                }
                            }
                        }
                    };
                    function precompile(input, options2, env) {
                        if (input == null || typeof input !== "string" && input.type !== "Program") {
                            throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
                        }
                        options2 = options2 || {};
                        if (!("data" in options2)) {
                            options2.data = true;
                        }
                        if (options2.compat) {
                            options2.useDepths = true;
                        }
                        var ast = env.parse(input, options2), environment = new env.Compiler().compile(ast, options2);
                        return new env.JavaScriptCompiler().compile(environment, options2);
                    }
                    function compile(input, options2, env) {
                        if (options2 === void 0)
                            options2 = {};
                        if (input == null || typeof input !== "string" && input.type !== "Program") {
                            throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
                        }
                        options2 = _utils.extend({}, options2);
                        if (!("data" in options2)) {
                            options2.data = true;
                        }
                        if (options2.compat) {
                            options2.useDepths = true;
                        }
                        var compiled = void 0;
                        function compileInput() {
                            var ast = env.parse(input, options2), environment = new env.Compiler().compile(ast, options2), templateSpec = new env.JavaScriptCompiler().compile(environment, options2, void 0, true);
                            return env.template(templateSpec);
                        }
                        function ret(context, execOptions) {
                            if (!compiled) {
                                compiled = compileInput();
                            }
                            return compiled.call(this, context, execOptions);
                        }
                        ret._setup = function (setupOptions) {
                            if (!compiled) {
                                compiled = compileInput();
                            }
                            return compiled._setup(setupOptions);
                        };
                        ret._child = function (i, data, blockParams, depths) {
                            if (!compiled) {
                                compiled = compileInput();
                            }
                            return compiled._child(i, data, blockParams, depths);
                        };
                        return ret;
                    }
                    function argEquals(a, b) {
                        if (a === b) {
                            return true;
                        }
                        if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
                            for (var i = 0; i < a.length; i++) {
                                if (!argEquals(a[i], b[i])) {
                                    return false;
                                }
                            }
                            return true;
                        }
                    }
                    function transformLiteralToPath(sexpr) {
                        if (!sexpr.path.parts) {
                            var literal = sexpr.path;
                            sexpr.path = {
                                type: "PathExpression",
                                data: false,
                                depth: 0,
                                parts: [literal.original + ""],
                                original: literal.original + "",
                                loc: literal.loc
                            };
                        }
                    }
                },
                /* 91 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$keys = __webpack_require__(60)["default"];
                    var _interopRequireDefault = __webpack_require__(1)["default"];
                    exports3.__esModule = true;
                    var _base = __webpack_require__(4);
                    var _exception = __webpack_require__(6);
                    var _exception2 = _interopRequireDefault(_exception);
                    var _utils = __webpack_require__(5);
                    var _codeGen = __webpack_require__(92);
                    var _codeGen2 = _interopRequireDefault(_codeGen);
                    function Literal(value) {
                        this.value = value;
                    }
                    function JavaScriptCompiler() {
                    }
                    JavaScriptCompiler.prototype = {
                        // PUBLIC API: You can override these methods in a subclass to provide
                        // alternative compiled forms for name lookup and buffering semantics
                        nameLookup: function nameLookup(parent, name) {
                            return this.internalNameLookup(parent, name);
                        },
                        depthedLookup: function depthedLookup(name) {
                            return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
                        },
                        compilerInfo: function compilerInfo() {
                            var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
                            return [revision, versions];
                        },
                        appendToBuffer: function appendToBuffer(source, location, explicit) {
                            if (!_utils.isArray(source)) {
                                source = [source];
                            }
                            source = this.source.wrap(source, location);
                            if (this.environment.isSimple) {
                                return ["return ", source, ";"];
                            }
                            else if (explicit) {
                                return ["buffer += ", source, ";"];
                            }
                            else {
                                source.appendToBuffer = true;
                                return source;
                            }
                        },
                        initializeBuffer: function initializeBuffer() {
                            return this.quotedString("");
                        },
                        // END PUBLIC API
                        internalNameLookup: function internalNameLookup(parent, name) {
                            this.lookupPropertyFunctionIsUsed = true;
                            return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
                        },
                        lookupPropertyFunctionIsUsed: false,
                        compile: function compile(environment, options2, context, asObject) {
                            this.environment = environment;
                            this.options = options2;
                            this.stringParams = this.options.stringParams;
                            this.trackIds = this.options.trackIds;
                            this.precompile = !asObject;
                            this.name = this.environment.name;
                            this.isChild = !!context;
                            this.context = context || {
                                decorators: [],
                                programs: [],
                                environments: []
                            };
                            this.preamble();
                            this.stackSlot = 0;
                            this.stackVars = [];
                            this.aliases = {};
                            this.registers = { list: [] };
                            this.hashes = [];
                            this.compileStack = [];
                            this.inlineStack = [];
                            this.blockParams = [];
                            this.compileChildren(environment, options2);
                            this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
                            this.useBlockParams = this.useBlockParams || environment.useBlockParams;
                            var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
                            for (i = 0, l = opcodes.length; i < l; i++) {
                                opcode = opcodes[i];
                                this.source.currentLocation = opcode.loc;
                                firstLoc = firstLoc || opcode.loc;
                                this[opcode.opcode].apply(this, opcode.args);
                            }
                            this.source.currentLocation = firstLoc;
                            this.pushSource("");
                            if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                                throw new _exception2["default"]("Compile completed with content left on stack");
                            }
                            if (!this.decorators.isEmpty()) {
                                this.useDecorators = true;
                                this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
                                this.decorators.push("return fn;");
                                if (asObject) {
                                    this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
                                }
                                else {
                                    this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
                                    this.decorators.push("}\n");
                                    this.decorators = this.decorators.merge();
                                }
                            }
                            else {
                                this.decorators = void 0;
                            }
                            var fn = this.createFunctionContext(asObject);
                            if (!this.isChild) {
                                var ret = {
                                    compiler: this.compilerInfo(),
                                    main: fn
                                };
                                if (this.decorators) {
                                    ret.main_d = this.decorators;
                                    ret.useDecorators = true;
                                }
                                var _context = this.context;
                                var programs = _context.programs;
                                var decorators = _context.decorators;
                                for (i = 0, l = programs.length; i < l; i++) {
                                    if (programs[i]) {
                                        ret[i] = programs[i];
                                        if (decorators[i]) {
                                            ret[i + "_d"] = decorators[i];
                                            ret.useDecorators = true;
                                        }
                                    }
                                }
                                if (this.environment.usePartial) {
                                    ret.usePartial = true;
                                }
                                if (this.options.data) {
                                    ret.useData = true;
                                }
                                if (this.useDepths) {
                                    ret.useDepths = true;
                                }
                                if (this.useBlockParams) {
                                    ret.useBlockParams = true;
                                }
                                if (this.options.compat) {
                                    ret.compat = true;
                                }
                                if (!asObject) {
                                    ret.compiler = JSON.stringify(ret.compiler);
                                    this.source.currentLocation = { start: { line: 1, column: 0 } };
                                    ret = this.objectLiteral(ret);
                                    if (options2.srcName) {
                                        ret = ret.toStringWithSourceMap({ file: options2.destName });
                                        ret.map = ret.map && ret.map.toString();
                                    }
                                    else {
                                        ret = ret.toString();
                                    }
                                }
                                else {
                                    ret.compilerOptions = this.options;
                                }
                                return ret;
                            }
                            else {
                                return fn;
                            }
                        },
                        preamble: function preamble() {
                            this.lastContext = 0;
                            this.source = new _codeGen2["default"](this.options.srcName);
                            this.decorators = new _codeGen2["default"](this.options.srcName);
                        },
                        createFunctionContext: function createFunctionContext(asObject) {
                            var _this = this;
                            var varDeclarations = "";
                            var locals = this.stackVars.concat(this.registers.list);
                            if (locals.length > 0) {
                                varDeclarations += ", " + locals.join(", ");
                            }
                            var aliasCount = 0;
                            _Object$keys(this.aliases).forEach(function (alias) {
                                var node2 = _this.aliases[alias];
                                if (node2.children && node2.referenceCount > 1) {
                                    varDeclarations += ", alias" + ++aliasCount + "=" + alias;
                                    node2.children[0] = "alias" + aliasCount;
                                }
                            });
                            if (this.lookupPropertyFunctionIsUsed) {
                                varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
                            }
                            var params = ["container", "depth0", "helpers", "partials", "data"];
                            if (this.useBlockParams || this.useDepths) {
                                params.push("blockParams");
                            }
                            if (this.useDepths) {
                                params.push("depths");
                            }
                            var source = this.mergeSource(varDeclarations);
                            if (asObject) {
                                params.push(source);
                                return Function.apply(this, params);
                            }
                            else {
                                return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
                            }
                        },
                        mergeSource: function mergeSource(varDeclarations) {
                            var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
                            this.source.each(function (line) {
                                if (line.appendToBuffer) {
                                    if (bufferStart) {
                                        line.prepend("  + ");
                                    }
                                    else {
                                        bufferStart = line;
                                    }
                                    bufferEnd = line;
                                }
                                else {
                                    if (bufferStart) {
                                        if (!sourceSeen) {
                                            appendFirst = true;
                                        }
                                        else {
                                            bufferStart.prepend("buffer += ");
                                        }
                                        bufferEnd.add(";");
                                        bufferStart = bufferEnd = void 0;
                                    }
                                    sourceSeen = true;
                                    if (!isSimple) {
                                        appendOnly = false;
                                    }
                                }
                            });
                            if (appendOnly) {
                                if (bufferStart) {
                                    bufferStart.prepend("return ");
                                    bufferEnd.add(";");
                                }
                                else if (!sourceSeen) {
                                    this.source.push('return "";');
                                }
                            }
                            else {
                                varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
                                if (bufferStart) {
                                    bufferStart.prepend("return buffer + ");
                                    bufferEnd.add(";");
                                }
                                else {
                                    this.source.push("return buffer;");
                                }
                            }
                            if (varDeclarations) {
                                this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
                            }
                            return this.source.merge();
                        },
                        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
                            return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
                        },
                        // [blockValue]
                        //
                        // On stack, before: hash, inverse, program, value
                        // On stack, after: return value of blockHelperMissing
                        //
                        // The purpose of this opcode is to take a block of the form
                        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
                        // replace it on the stack with the result of properly
                        // invoking blockHelperMissing.
                        blockValue: function blockValue(name) {
                            var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
                            this.setupHelperArgs(name, 0, params);
                            var blockName = this.popStack();
                            params.splice(1, 0, blockName);
                            this.push(this.source.functionCall(blockHelperMissing, "call", params));
                        },
                        // [ambiguousBlockValue]
                        //
                        // On stack, before: hash, inverse, program, value
                        // Compiler value, before: lastHelper=value of last found helper, if any
                        // On stack, after, if no lastHelper: same as [blockValue]
                        // On stack, after, if lastHelper: value
                        ambiguousBlockValue: function ambiguousBlockValue() {
                            var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
                            this.setupHelperArgs("", 0, params, true);
                            this.flushInline();
                            var current = this.topStack();
                            params.splice(1, 0, current);
                            this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
                        },
                        // [appendContent]
                        //
                        // On stack, before: ...
                        // On stack, after: ...
                        //
                        // Appends the string value of `content` to the current buffer
                        appendContent: function appendContent(content) {
                            if (this.pendingContent) {
                                content = this.pendingContent + content;
                            }
                            else {
                                this.pendingLocation = this.source.currentLocation;
                            }
                            this.pendingContent = content;
                        },
                        // [append]
                        //
                        // On stack, before: value, ...
                        // On stack, after: ...
                        //
                        // Coerces `value` to a String and appends it to the current buffer.
                        //
                        // If `value` is truthy, or 0, it is coerced into a string and appended
                        // Otherwise, the empty string is appended
                        append: function append() {
                            if (this.isInline()) {
                                this.replaceStack(function (current) {
                                    return [" != null ? ", current, ' : ""'];
                                });
                                this.pushSource(this.appendToBuffer(this.popStack()));
                            }
                            else {
                                var local = this.popStack();
                                this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
                                if (this.environment.isSimple) {
                                    this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
                                }
                            }
                        },
                        // [appendEscaped]
                        //
                        // On stack, before: value, ...
                        // On stack, after: ...
                        //
                        // Escape `value` and append it to the buffer
                        appendEscaped: function appendEscaped() {
                            this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
                        },
                        // [getContext]
                        //
                        // On stack, before: ...
                        // On stack, after: ...
                        // Compiler value, after: lastContext=depth
                        //
                        // Set the value of the `lastContext` compiler value to the depth
                        getContext: function getContext(depth) {
                            this.lastContext = depth;
                        },
                        // [pushContext]
                        //
                        // On stack, before: ...
                        // On stack, after: currentContext, ...
                        //
                        // Pushes the value of the current context onto the stack.
                        pushContext: function pushContext() {
                            this.pushStackLiteral(this.contextName(this.lastContext));
                        },
                        // [lookupOnContext]
                        //
                        // On stack, before: ...
                        // On stack, after: currentContext[name], ...
                        //
                        // Looks up the value of `name` on the current context and pushes
                        // it onto the stack.
                        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
                            var i = 0;
                            if (!scoped && this.options.compat && !this.lastContext) {
                                this.push(this.depthedLookup(parts[i++]));
                            }
                            else {
                                this.pushContext();
                            }
                            this.resolvePath("context", parts, i, falsy, strict);
                        },
                        // [lookupBlockParam]
                        //
                        // On stack, before: ...
                        // On stack, after: blockParam[name], ...
                        //
                        // Looks up the value of `parts` on the given block param and pushes
                        // it onto the stack.
                        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
                            this.useBlockParams = true;
                            this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
                            this.resolvePath("context", parts, 1);
                        },
                        // [lookupData]
                        //
                        // On stack, before: ...
                        // On stack, after: data, ...
                        //
                        // Push the data lookup operator
                        lookupData: function lookupData(depth, parts, strict) {
                            if (!depth) {
                                this.pushStackLiteral("data");
                            }
                            else {
                                this.pushStackLiteral("container.data(data, " + depth + ")");
                            }
                            this.resolvePath("data", parts, 0, true, strict);
                        },
                        resolvePath: function resolvePath2(type2, parts, i, falsy, strict) {
                            var _this2 = this;
                            if (this.options.strict || this.options.assumeObjects) {
                                this.push(strictLookup(this.options.strict && strict, this, parts, i, type2));
                                return;
                            }
                            var len = parts.length;
                            for (; i < len; i++) {
                                this.replaceStack(function (current) {
                                    var lookup = _this2.nameLookup(current, parts[i], type2);
                                    if (!falsy) {
                                        return [" != null ? ", lookup, " : ", current];
                                    }
                                    else {
                                        return [" && ", lookup];
                                    }
                                });
                            }
                        },
                        // [resolvePossibleLambda]
                        //
                        // On stack, before: value, ...
                        // On stack, after: resolved value, ...
                        //
                        // If the `value` is a lambda, replace it on the stack by
                        // the return value of the lambda
                        resolvePossibleLambda: function resolvePossibleLambda() {
                            this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
                        },
                        // [pushStringParam]
                        //
                        // On stack, before: ...
                        // On stack, after: string, currentContext, ...
                        //
                        // This opcode is designed for use in string mode, which
                        // provides the string value of a parameter along with its
                        // depth rather than resolving it immediately.
                        pushStringParam: function pushStringParam(string, type2) {
                            this.pushContext();
                            this.pushString(type2);
                            if (type2 !== "SubExpression") {
                                if (typeof string === "string") {
                                    this.pushString(string);
                                }
                                else {
                                    this.pushStackLiteral(string);
                                }
                            }
                        },
                        emptyHash: function emptyHash(omitEmpty) {
                            if (this.trackIds) {
                                this.push("{}");
                            }
                            if (this.stringParams) {
                                this.push("{}");
                                this.push("{}");
                            }
                            this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
                        },
                        pushHash: function pushHash() {
                            if (this.hash) {
                                this.hashes.push(this.hash);
                            }
                            this.hash = { values: {}, types: [], contexts: [], ids: [] };
                        },
                        popHash: function popHash() {
                            var hash = this.hash;
                            this.hash = this.hashes.pop();
                            if (this.trackIds) {
                                this.push(this.objectLiteral(hash.ids));
                            }
                            if (this.stringParams) {
                                this.push(this.objectLiteral(hash.contexts));
                                this.push(this.objectLiteral(hash.types));
                            }
                            this.push(this.objectLiteral(hash.values));
                        },
                        // [pushString]
                        //
                        // On stack, before: ...
                        // On stack, after: quotedString(string), ...
                        //
                        // Push a quoted version of `string` onto the stack
                        pushString: function pushString(string) {
                            this.pushStackLiteral(this.quotedString(string));
                        },
                        // [pushLiteral]
                        //
                        // On stack, before: ...
                        // On stack, after: value, ...
                        //
                        // Pushes a value onto the stack. This operation prevents
                        // the compiler from creating a temporary variable to hold
                        // it.
                        pushLiteral: function pushLiteral(value) {
                            this.pushStackLiteral(value);
                        },
                        // [pushProgram]
                        //
                        // On stack, before: ...
                        // On stack, after: program(guid), ...
                        //
                        // Push a program expression onto the stack. This takes
                        // a compile-time guid and converts it into a runtime-accessible
                        // expression.
                        pushProgram: function pushProgram(guid) {
                            if (guid != null) {
                                this.pushStackLiteral(this.programExpression(guid));
                            }
                            else {
                                this.pushStackLiteral(null);
                            }
                        },
                        // [registerDecorator]
                        //
                        // On stack, before: hash, program, params..., ...
                        // On stack, after: ...
                        //
                        // Pops off the decorator's parameters, invokes the decorator,
                        // and inserts the decorator into the decorators list.
                        registerDecorator: function registerDecorator(paramSize, name) {
                            var foundDecorator = this.nameLookup("decorators", name, "decorator"), options2 = this.setupHelperArgs(name, paramSize);
                            this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options2]), " || fn;"]);
                        },
                        // [invokeHelper]
                        //
                        // On stack, before: hash, inverse, program, params..., ...
                        // On stack, after: result of helper invocation
                        //
                        // Pops off the helper's parameters, invokes the helper,
                        // and pushes the helper's return value onto the stack.
                        //
                        // If the helper is not found, `helperMissing` is called.
                        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
                            var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
                            var possibleFunctionCalls = [];
                            if (isSimple) {
                                possibleFunctionCalls.push(helper.name);
                            }
                            possibleFunctionCalls.push(nonHelper);
                            if (!this.options.strict) {
                                possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
                            }
                            var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
                            var functionCall2 = this.source.functionCall(functionLookupCode, "call", helper.callParams);
                            this.push(functionCall2);
                        },
                        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
                            var result = [];
                            result.push(items[0]);
                            for (var i = 1; i < items.length; i++) {
                                result.push(separator, items[i]);
                            }
                            return result;
                        },
                        // [invokeKnownHelper]
                        //
                        // On stack, before: hash, inverse, program, params..., ...
                        // On stack, after: result of helper invocation
                        //
                        // This operation is used when the helper is known to exist,
                        // so a `helperMissing` fallback is not required.
                        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
                            var helper = this.setupHelper(paramSize, name);
                            this.push(this.source.functionCall(helper.name, "call", helper.callParams));
                        },
                        // [invokeAmbiguous]
                        //
                        // On stack, before: hash, inverse, program, params..., ...
                        // On stack, after: result of disambiguation
                        //
                        // This operation is used when an expression like `{{foo}}`
                        // is provided, but we don't know at compile-time whether it
                        // is a helper or a path.
                        //
                        // This operation emits more code than the other options,
                        // and can be avoided by passing the `knownHelpers` and
                        // `knownHelpersOnly` flags at compile-time.
                        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
                            this.useRegister("helper");
                            var nonHelper = this.popStack();
                            this.emptyHash();
                            var helper = this.setupHelper(0, name, helperCall);
                            var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
                            var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
                            if (!this.options.strict) {
                                lookup[0] = "(helper = ";
                                lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
                            }
                            this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
                        },
                        // [invokePartial]
                        //
                        // On stack, before: context, ...
                        // On stack after: result of partial invocation
                        //
                        // This operation pops off a context, invokes a partial with that context,
                        // and pushes the result of the invocation back.
                        invokePartial: function invokePartial(isDynamic, name, indent) {
                            var params = [], options2 = this.setupParams(name, 1, params);
                            if (isDynamic) {
                                name = this.popStack();
                                delete options2.name;
                            }
                            if (indent) {
                                options2.indent = JSON.stringify(indent);
                            }
                            options2.helpers = "helpers";
                            options2.partials = "partials";
                            options2.decorators = "container.decorators";
                            if (!isDynamic) {
                                params.unshift(this.nameLookup("partials", name, "partial"));
                            }
                            else {
                                params.unshift(name);
                            }
                            if (this.options.compat) {
                                options2.depths = "depths";
                            }
                            options2 = this.objectLiteral(options2);
                            params.push(options2);
                            this.push(this.source.functionCall("container.invokePartial", "", params));
                        },
                        // [assignToHash]
                        //
                        // On stack, before: value, ..., hash, ...
                        // On stack, after: ..., hash, ...
                        //
                        // Pops a value off the stack and assigns it to the current hash
                        assignToHash: function assignToHash(key) {
                            var value = this.popStack(), context = void 0, type2 = void 0, id2 = void 0;
                            if (this.trackIds) {
                                id2 = this.popStack();
                            }
                            if (this.stringParams) {
                                type2 = this.popStack();
                                context = this.popStack();
                            }
                            var hash = this.hash;
                            if (context) {
                                hash.contexts[key] = context;
                            }
                            if (type2) {
                                hash.types[key] = type2;
                            }
                            if (id2) {
                                hash.ids[key] = id2;
                            }
                            hash.values[key] = value;
                        },
                        pushId: function pushId(type2, name, child) {
                            if (type2 === "BlockParam") {
                                this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
                            }
                            else if (type2 === "PathExpression") {
                                this.pushString(name);
                            }
                            else if (type2 === "SubExpression") {
                                this.pushStackLiteral("true");
                            }
                            else {
                                this.pushStackLiteral("null");
                            }
                        },
                        // HELPERS
                        compiler: JavaScriptCompiler,
                        compileChildren: function compileChildren(environment, options2) {
                            var children2 = environment.children, child = void 0, compiler = void 0;
                            for (var i = 0, l = children2.length; i < l; i++) {
                                child = children2[i];
                                compiler = new this.compiler();
                                var existing = this.matchExistingProgram(child);
                                if (existing == null) {
                                    this.context.programs.push("");
                                    var index = this.context.programs.length;
                                    child.index = index;
                                    child.name = "program" + index;
                                    this.context.programs[index] = compiler.compile(child, options2, this.context, !this.precompile);
                                    this.context.decorators[index] = compiler.decorators;
                                    this.context.environments[index] = child;
                                    this.useDepths = this.useDepths || compiler.useDepths;
                                    this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
                                    child.useDepths = this.useDepths;
                                    child.useBlockParams = this.useBlockParams;
                                }
                                else {
                                    child.index = existing.index;
                                    child.name = "program" + existing.index;
                                    this.useDepths = this.useDepths || existing.useDepths;
                                    this.useBlockParams = this.useBlockParams || existing.useBlockParams;
                                }
                            }
                        },
                        matchExistingProgram: function matchExistingProgram(child) {
                            for (var i = 0, len = this.context.environments.length; i < len; i++) {
                                var environment = this.context.environments[i];
                                if (environment && environment.equals(child)) {
                                    return environment;
                                }
                            }
                        },
                        programExpression: function programExpression(guid) {
                            var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
                            if (this.useBlockParams || this.useDepths) {
                                programParams.push("blockParams");
                            }
                            if (this.useDepths) {
                                programParams.push("depths");
                            }
                            return "container.program(" + programParams.join(", ") + ")";
                        },
                        useRegister: function useRegister(name) {
                            if (!this.registers[name]) {
                                this.registers[name] = true;
                                this.registers.list.push(name);
                            }
                        },
                        push: function push(expr) {
                            if (!(expr instanceof Literal)) {
                                expr = this.source.wrap(expr);
                            }
                            this.inlineStack.push(expr);
                            return expr;
                        },
                        pushStackLiteral: function pushStackLiteral(item) {
                            this.push(new Literal(item));
                        },
                        pushSource: function pushSource(source) {
                            if (this.pendingContent) {
                                this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
                                this.pendingContent = void 0;
                            }
                            if (source) {
                                this.source.push(source);
                            }
                        },
                        replaceStack: function replaceStack(callback) {
                            var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
                            if (!this.isInline()) {
                                throw new _exception2["default"]("replaceStack on non-inline");
                            }
                            var top = this.popStack(true);
                            if (top instanceof Literal) {
                                stack = [top.value];
                                prefix = ["(", stack];
                                usedLiteral = true;
                            }
                            else {
                                createdStack = true;
                                var _name = this.incrStack();
                                prefix = ["((", this.push(_name), " = ", top, ")"];
                                stack = this.topStack();
                            }
                            var item = callback.call(this, stack);
                            if (!usedLiteral) {
                                this.popStack();
                            }
                            if (createdStack) {
                                this.stackSlot--;
                            }
                            this.push(prefix.concat(item, ")"));
                        },
                        incrStack: function incrStack() {
                            this.stackSlot++;
                            if (this.stackSlot > this.stackVars.length) {
                                this.stackVars.push("stack" + this.stackSlot);
                            }
                            return this.topStackName();
                        },
                        topStackName: function topStackName() {
                            return "stack" + this.stackSlot;
                        },
                        flushInline: function flushInline() {
                            var inlineStack = this.inlineStack;
                            this.inlineStack = [];
                            for (var i = 0, len = inlineStack.length; i < len; i++) {
                                var entry = inlineStack[i];
                                if (entry instanceof Literal) {
                                    this.compileStack.push(entry);
                                }
                                else {
                                    var stack = this.incrStack();
                                    this.pushSource([stack, " = ", entry, ";"]);
                                    this.compileStack.push(stack);
                                }
                            }
                        },
                        isInline: function isInline() {
                            return this.inlineStack.length;
                        },
                        popStack: function popStack(wrapped) {
                            var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
                            if (!wrapped && item instanceof Literal) {
                                return item.value;
                            }
                            else {
                                if (!inline) {
                                    if (!this.stackSlot) {
                                        throw new _exception2["default"]("Invalid stack pop");
                                    }
                                    this.stackSlot--;
                                }
                                return item;
                            }
                        },
                        topStack: function topStack() {
                            var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
                            if (item instanceof Literal) {
                                return item.value;
                            }
                            else {
                                return item;
                            }
                        },
                        contextName: function contextName(context) {
                            if (this.useDepths && context) {
                                return "depths[" + context + "]";
                            }
                            else {
                                return "depth" + context;
                            }
                        },
                        quotedString: function quotedString(str) {
                            return this.source.quotedString(str);
                        },
                        objectLiteral: function objectLiteral(obj) {
                            return this.source.objectLiteral(obj);
                        },
                        aliasable: function aliasable(name) {
                            var ret = this.aliases[name];
                            if (ret) {
                                ret.referenceCount++;
                                return ret;
                            }
                            ret = this.aliases[name] = this.source.wrap(name);
                            ret.aliasable = true;
                            ret.referenceCount = 1;
                            return ret;
                        },
                        setupHelper: function setupHelper(paramSize, name, blockHelper) {
                            var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
                            var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
                            return {
                                params,
                                paramsInit,
                                name: foundHelper,
                                callParams: [callContext].concat(params)
                            };
                        },
                        setupParams: function setupParams(helper, paramSize, params) {
                            var options2 = {}, contexts = [], types = [], ids = [], objectArgs = !params, param = void 0;
                            if (objectArgs) {
                                params = [];
                            }
                            options2.name = this.quotedString(helper);
                            options2.hash = this.popStack();
                            if (this.trackIds) {
                                options2.hashIds = this.popStack();
                            }
                            if (this.stringParams) {
                                options2.hashTypes = this.popStack();
                                options2.hashContexts = this.popStack();
                            }
                            var inverse = this.popStack(), program = this.popStack();
                            if (program || inverse) {
                                options2.fn = program || "container.noop";
                                options2.inverse = inverse || "container.noop";
                            }
                            var i = paramSize;
                            while (i--) {
                                param = this.popStack();
                                params[i] = param;
                                if (this.trackIds) {
                                    ids[i] = this.popStack();
                                }
                                if (this.stringParams) {
                                    types[i] = this.popStack();
                                    contexts[i] = this.popStack();
                                }
                            }
                            if (objectArgs) {
                                options2.args = this.source.generateArray(params);
                            }
                            if (this.trackIds) {
                                options2.ids = this.source.generateArray(ids);
                            }
                            if (this.stringParams) {
                                options2.types = this.source.generateArray(types);
                                options2.contexts = this.source.generateArray(contexts);
                            }
                            if (this.options.data) {
                                options2.data = "data";
                            }
                            if (this.useBlockParams) {
                                options2.blockParams = "blockParams";
                            }
                            return options2;
                        },
                        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
                            var options2 = this.setupParams(helper, paramSize, params);
                            options2.loc = JSON.stringify(this.source.currentLocation);
                            options2 = this.objectLiteral(options2);
                            if (useRegister) {
                                this.useRegister("options");
                                params.push("options");
                                return ["options=", options2];
                            }
                            else if (params) {
                                params.push(options2);
                                return "";
                            }
                            else {
                                return options2;
                            }
                        }
                    };
                    (function () {
                        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
                        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
                        for (var i = 0, l = reservedWords.length; i < l; i++) {
                            compilerWords[reservedWords[i]] = true;
                        }
                    })();
                    JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
                        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
                    };
                    function strictLookup(requireTerminal, compiler, parts, i, type2) {
                        var stack = compiler.popStack(), len = parts.length;
                        if (requireTerminal) {
                            len--;
                        }
                        for (; i < len; i++) {
                            stack = compiler.nameLookup(stack, parts[i], type2);
                        }
                        if (requireTerminal) {
                            return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
                        }
                        else {
                            return stack;
                        }
                    }
                    exports3["default"] = JavaScriptCompiler;
                    module3.exports = exports3["default"];
                },
                /* 92 */
                /***/
                function (module3, exports3, __webpack_require__) {
                    var _Object$keys = __webpack_require__(60)["default"];
                    exports3.__esModule = true;
                    var _utils = __webpack_require__(5);
                    var SourceNode = void 0;
                    try {
                        var SourceMap;
                        if (false)
                            ;
                    }
                    catch (err) {
                    }
                    if (!SourceNode) {
                        SourceNode = function (line, column, srcFile, chunks) {
                            this.src = "";
                            if (chunks) {
                                this.add(chunks);
                            }
                        };
                        SourceNode.prototype = {
                            add: function add2(chunks) {
                                if (_utils.isArray(chunks)) {
                                    chunks = chunks.join("");
                                }
                                this.src += chunks;
                            },
                            prepend: function prepend(chunks) {
                                if (_utils.isArray(chunks)) {
                                    chunks = chunks.join("");
                                }
                                this.src = chunks + this.src;
                            },
                            toStringWithSourceMap: function toStringWithSourceMap() {
                                return { code: this.toString() };
                            },
                            toString: function toString() {
                                return this.src;
                            }
                        };
                    }
                    function castChunk(chunk, codeGen, loc) {
                        if (_utils.isArray(chunk)) {
                            var ret = [];
                            for (var i = 0, len = chunk.length; i < len; i++) {
                                ret.push(codeGen.wrap(chunk[i], loc));
                            }
                            return ret;
                        }
                        else if (typeof chunk === "boolean" || typeof chunk === "number") {
                            return chunk + "";
                        }
                        return chunk;
                    }
                    function CodeGen(srcFile) {
                        this.srcFile = srcFile;
                        this.source = [];
                    }
                    CodeGen.prototype = {
                        isEmpty: function isEmpty() {
                            return !this.source.length;
                        },
                        prepend: function prepend(source, loc) {
                            this.source.unshift(this.wrap(source, loc));
                        },
                        push: function push(source, loc) {
                            this.source.push(this.wrap(source, loc));
                        },
                        merge: function merge() {
                            var source = this.empty();
                            this.each(function (line) {
                                source.add(["  ", line, "\n"]);
                            });
                            return source;
                        },
                        each: function each(iter) {
                            for (var i = 0, len = this.source.length; i < len; i++) {
                                iter(this.source[i]);
                            }
                        },
                        empty: function empty() {
                            var loc = this.currentLocation || { start: {} };
                            return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
                        },
                        wrap: function wrap(chunk) {
                            var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
                            if (chunk instanceof SourceNode) {
                                return chunk;
                            }
                            chunk = castChunk(chunk, this, loc);
                            return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
                        },
                        functionCall: function functionCall2(fn, type2, params) {
                            params = this.generateList(params);
                            return this.wrap([fn, type2 ? "." + type2 + "(" : "(", params, ")"]);
                        },
                        quotedString: function quotedString(str) {
                            return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
                        },
                        objectLiteral: function objectLiteral(obj) {
                            var _this = this;
                            var pairs = [];
                            _Object$keys(obj).forEach(function (key) {
                                var value = castChunk(obj[key], _this);
                                if (value !== "undefined") {
                                    pairs.push([_this.quotedString(key), ":", value]);
                                }
                            });
                            var ret = this.generateList(pairs);
                            ret.prepend("{");
                            ret.add("}");
                            return ret;
                        },
                        generateList: function generateList(entries) {
                            var ret = this.empty();
                            for (var i = 0, len = entries.length; i < len; i++) {
                                if (i) {
                                    ret.add(",");
                                }
                                ret.add(castChunk(entries[i], this));
                            }
                            return ret;
                        },
                        generateArray: function generateArray(entries) {
                            var ret = this.generateList(entries);
                            ret.prepend("[");
                            ret.add("]");
                            return ret;
                        }
                    };
                    exports3["default"] = CodeGen;
                    module3.exports = exports3["default"];
                }
                /******/
            ]));
        });
    })(handlebars$1);
    return handlebars$1.exports;
}
var handlebarsExports = requireHandlebars();
function getStatus(nextDate, completed, hasTrans, upcomingLength = "7") {
    const upcomingDays = getUpcomingDays(upcomingLength);
    const today = currentDay();
    if (completed) {
        return "completed";
    }
    else if (hasTrans) {
        return "paid";
    }
    else if (nextDate === today) {
        return "due";
    }
    else if (nextDate > today && nextDate <= addDays(today, upcomingDays)) {
        return "upcoming";
    }
    else if (nextDate < today) {
        return "missed";
    }
    else {
        return "scheduled";
    }
}
function getHasTransactionsQuery(schedules) {
    const filters = schedules.map((schedule) => {
        const dateCond = schedule._conditions.find((c) => c.field === "date");
        return {
            $and: {
                schedule: schedule.id,
                date: {
                    $gte: dateCond && dateCond.op === "is" ? schedule.next_date : subDays(schedule.next_date, 2)
                }
            }
        };
    });
    return q("transactions").options({ splits: "all" }).filter({ $or: filters }).orderBy({ date: "desc" }).select(["schedule", "date"]);
}
function recurConfigToRSchedule(config2) {
    const base = {
        start: parseDate$1(config2.start),
        // @ts-ignore: issues with https://gitlab.com/john.carroll.p/rschedule/-/issues/86
        frequency: config2.frequency.toUpperCase(),
        byHourOfDay: [12]
    };
    if (config2.interval) {
        base.interval = config2.interval;
    }
    switch (config2.endMode) {
        case "after_n_occurrences":
            base.count = config2.endOccurrences;
            break;
        case "on_date":
            base.end = parseDate$1(config2.endDate);
            break;
    }
    const abbrevDay = (name) => name.slice(0, 2).toUpperCase();
    switch (config2.frequency) {
        case "daily":
            return [base];
        case "weekly":
            return [base];
        case "monthly":
            if (config2.patterns && config2.patterns.length > 0) {
                const days = config2.patterns.filter((p) => p.type === "day");
                const dayNames = config2.patterns.filter((p) => p.type !== "day");
                return [
                    days.length > 0 && { ...base, byDayOfMonth: days.map((p) => p.value) },
                    dayNames.length > 0 && {
                        ...base,
                        byDayOfWeek: dayNames.map((p) => [abbrevDay(p.type), p.value])
                    }
                ].filter(Boolean);
            }
            else {
                return [base];
            }
        case "yearly":
            return [base];
        default:
            throw new Error("Invalid recurring date config");
    }
}
function extractScheduleConds(conditions) {
    return {
        payee: conditions.find((cond) => cond.op === "is" && cond.field === "payee") || conditions.find((cond) => cond.op === "is" && cond.field === "description") || null,
        account: conditions.find((cond) => cond.op === "is" && cond.field === "account") || conditions.find((cond) => cond.op === "is" && cond.field === "acct") || null,
        amount: conditions.find((cond) => (cond.op === "is" || cond.op === "isapprox" || cond.op === "isbetween") && cond.field === "amount") || null,
        date: conditions.find((cond) => (cond.op === "is" || cond.op === "isapprox") && cond.field === "date") || null
    };
}
function getNextDate(dateCond, start = new Date(currentDay()), noSkipWeekend = false) {
    start = startOfDay(start);
    const cond = new Condition(dateCond.op, "date", dateCond.value, null);
    const value = cond.getValue();
    if (value.type === "date") {
        return value.date;
    }
    else if (value.type === "recur") {
        let dates = value.schedule.occurrences({ start, take: 1 }).toArray();
        if (dates.length === 0) {
            dates = value.schedule.occurrences({ reverse: true, take: 1 }).toArray();
        }
        if (dates.length > 0) {
            let date = dates[0].date;
            if (value.schedule.data.skipWeekend && !noSkipWeekend) {
                date = getDateWithSkippedWeekend(date, value.schedule.data.weekendSolve);
            }
            return dayFromDate(date);
        }
    }
    return null;
}
function getDateWithSkippedWeekend(date, solveMode) {
    if (isWeekend(date)) {
        if (solveMode === "after") {
            return nextMonday(date);
        }
        else if (solveMode === "before") {
            return previousFriday(date);
        }
        else {
            throw new Error("Unknown weekend solve mode, this should not happen!");
        }
    }
    return date;
}
function getScheduledAmount(amount, inverse = false) {
    if (amount == null)
        return 0;
    if (typeof amount === "number") {
        return inverse ? -amount : amount;
    }
    const avg = (amount.num1 + amount.num2) / 2;
    return inverse ? -Math.round(avg) : Math.round(avg);
}
function getUpcomingDays(upcomingLength = "7", today = currentDay()) {
    const month = getMonth(today);
    switch (upcomingLength) {
        case "currentMonth": {
            const day = getDay(today);
            const end = getDay(getMonthEnd(today));
            return end - day;
        }
        case "oneMonth": {
            return differenceInCalendarDays(nextMonth(month), month);
        }
        default:
            if (upcomingLength.includes("-")) {
                const [num2, unit] = upcomingLength.split("-");
                const value = Math.max(1, parseInt(num2, 10));
                switch (unit) {
                    case "day":
                        return value;
                    case "week":
                        return value * 7;
                    case "month":
                        const future = addMonths(today, value);
                        return differenceInCalendarDays(future, month) + 1;
                    case "year":
                        const futureYear = addYears(today, value);
                        return differenceInCalendarDays(futureYear, month) + 1;
                    default:
                        return 7;
                }
            }
            return parseInt(upcomingLength, 10);
    }
}
let InvalidDateAdapterError$1 = class InvalidDateAdapterError extends Error {
};
let dateAdapterConfig$1;
let DateAdapterBase$1 = class DateAdapterBase {
    constructor(_date, options2) {
        this.metadata = {};
        this.duration = options2 && options2.duration || 0;
        this.generators = options2 && options2.generators && options2.generators.slice() || [];
        if (!Number.isInteger(this.duration) || this.duration < 0) {
            throw new InvalidDateAdapterError$1("duration must be a non-negative integer");
        }
    }
    static set adapter(value) {
        if (dateAdapterConfig$1) {
            throw new Error(`"${dateAdapterConfig$1.name}" has already been configured.`);
        }
        dateAdapterConfig$1 = value;
    }
    static get adapter() {
        if (!dateAdapterConfig$1) {
            throw new Error("No date adapter has been configured. See rSchedule docs.");
        }
        return dateAdapterConfig$1;
    }
    static isDate(_object) {
        throw unimplementedError$1("isDate()");
    }
    static fromDate(_date, _options) {
        throw unimplementedError$1("fromDate()");
    }
    static fromJSON(_json) {
        throw unimplementedError$1("fromJSON()");
    }
    static fromDateTime(_datetime) {
        throw unimplementedError$1("fromDateTime()");
    }
    /**
     * Returns a string in simplified extended ISO format (ISO 8601).
     *
     * _Note: this method is intended for testing and its
     * implementation isn't particularly performant._
     */
    toISOString() {
        return this.set("timezone", "UTC").toDateTime().toISOString();
    }
    toDateTime() {
        const date = DateTime$1.fromJSON(Object.assign(Object.assign({}, this.toJSON()), {
            generators: this.generators,
            metadata: this.metadata
        }));
        return date;
    }
};
DateAdapterBase$1.hasTimezoneSupport = false;
function unimplementedError$1(name) {
    return new Error(`You must implement the "${name}" method for this DateAdapter class`);
}
var DateAdapter$1;
(function (DateAdapter2) {
    DateAdapter2.WEEKDAYS = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
    DateAdapter2.MILLISECONDS_IN_SECOND = 1e3;
    DateAdapter2.MILLISECONDS_IN_MINUTE = DateAdapter2.MILLISECONDS_IN_SECOND * 60;
    DateAdapter2.MILLISECONDS_IN_HOUR = DateAdapter2.MILLISECONDS_IN_MINUTE * 60;
    DateAdapter2.MILLISECONDS_IN_DAY = DateAdapter2.MILLISECONDS_IN_HOUR * 24;
    DateAdapter2.MILLISECONDS_IN_WEEK = DateAdapter2.MILLISECONDS_IN_DAY * 7;
})(DateAdapter$1 || (DateAdapter$1 = {}));
let InvalidDateTimeError$1 = class InvalidDateTimeError extends Error {
};
let DateTime$1 = class DateTime {
    constructor(date, timezone, duration, generators, options2 = {}) {
        this.metadata = {};
        this.date = new Date(date);
        this.timezone = timezone || null;
        this.duration = duration || 0;
        this.generators = generators && generators.slice() || [];
        if (!Number.isInteger(this.duration) || this.duration < 0) {
            throw new InvalidDateTimeError$1("duration must be a non-negative integer");
        }
        if (options2.metadata) {
            Object.assign(this.metadata, options2.metadata);
        }
        this.assertIsValid();
    }
    // /**
    //  * Similar to `Array.isArray()`, `isInstance()` provides a surefire method
    //  * of determining if an object is a `DateTime` by checking against the
    //  * global symbol registry.
    //  */
    // static isInstance(object: any): object is DateTime {
    //   return !!(object && object[DATETIME_ID]);
    // }
    static fromJSON(json) {
        const date = new Date(Date.UTC(json.year, json.month - 1, json.day, json.hour, json.minute, json.second, json.millisecond));
        return new DateTime(date, json.timezone, json.duration, json.generators, {
            metadata: json.metadata
        });
    }
    static fromDateAdapter(adapter) {
        return DateTime.fromJSON(Object.assign(Object.assign({}, adapter.toJSON()), {
            generators: adapter.generators,
            metadata: adapter.metadata
        }));
    }
    /**
     * Returns `undefined` if `duration` is `0`. Else returns
     * the `end` date.
     */
    get end() {
        if (!this.duration)
            return;
        if (this._end)
            return this._end;
        this._end = this.add(this.duration, "millisecond");
        return this._end;
    }
    // While we constrain the argument to be another DateAdapter in typescript
    // we handle the case of someone passing in another type of object in javascript
    isEqual(object) {
        if (!object) {
            return false;
        }
        assertSameTimeZone$1(this, object);
        return this.valueOf() === object.valueOf();
    }
    isBefore(object) {
        assertSameTimeZone$1(this, object);
        return this.valueOf() < object.valueOf();
    }
    isBeforeOrEqual(object) {
        assertSameTimeZone$1(this, object);
        return this.valueOf() <= object.valueOf();
    }
    isAfter(object) {
        assertSameTimeZone$1(this, object);
        return this.valueOf() > object.valueOf();
    }
    isAfterOrEqual(object) {
        assertSameTimeZone$1(this, object);
        return this.valueOf() >= object.valueOf();
    }
    isOccurring(object) {
        if (!this.duration) {
            throw new Error("DateTime#isOccurring() is only applicable to DateTimes with durations");
        }
        assertSameTimeZone$1(this, object);
        return object.isAfterOrEqual(this) && object.isBeforeOrEqual(this.add(this.duration, "millisecond"));
    }
    add(amount, unit) {
        switch (unit) {
            case "generator": {
                const generators = this.generators.slice();
                generators.unshift(amount);
                return new DateTime(this.date, this.timezone, this.duration, generators);
            }
            case "year":
                return this.forkDateTime(addUTCYears$1(this.date, amount));
            case "month":
                return this.forkDateTime(addUTCMonths$1(this.date, amount));
            case "week":
                return this.forkDateTime(addUTCWeeks$1(this.date, amount));
            case "day":
                return this.forkDateTime(addUTCDays$1(this.date, amount));
            case "hour":
                return this.forkDateTime(addUTCHours$1(this.date, amount));
            case "minute":
                return this.forkDateTime(addUTCMinutes$1(this.date, amount));
            case "second":
                return this.forkDateTime(addUTCSeconds$1(this.date, amount));
            case "millisecond":
                return this.forkDateTime(addUTCMilliseconds$1(this.date, amount));
            default:
                throw new Error("Invalid unit provided to `DateTime#add`");
        }
    }
    subtract(amount, unit) {
        switch (unit) {
            case "year":
                return this.forkDateTime(subUTCYears$1(this.date, amount));
            case "month":
                return this.forkDateTime(subUTCMonths$1(this.date, amount));
            case "week":
                return this.forkDateTime(subUTCWeeks$1(this.date, amount));
            case "day":
                return this.forkDateTime(subUTCDays$1(this.date, amount));
            case "hour":
                return this.forkDateTime(subUTCHours$1(this.date, amount));
            case "minute":
                return this.forkDateTime(subUTCMinutes$1(this.date, amount));
            case "second":
                return this.forkDateTime(subUTCSeconds$1(this.date, amount));
            case "millisecond":
                return this.forkDateTime(subUTCMilliseconds$1(this.date, amount));
            default:
                throw new Error("Invalid unit provided to `DateTime#subtract`");
        }
    }
    get(unit) {
        switch (unit) {
            case "year":
                return this.date.getUTCFullYear();
            case "month":
                return this.date.getUTCMonth() + 1;
            case "yearday":
                return getUTCYearDay$1(this.date);
            case "weekday":
                return DateAdapter$1.WEEKDAYS[this.date.getUTCDay()];
            case "day":
                return this.date.getUTCDate();
            case "hour":
                return this.date.getUTCHours();
            case "minute":
                return this.date.getUTCMinutes();
            case "second":
                return this.date.getUTCSeconds();
            case "millisecond":
                return this.date.getUTCMilliseconds();
            default:
                throw new Error("Invalid unit provided to `DateTime#set`");
        }
    }
    set(unit, value) {
        if (unit === "duration") {
            return new DateTime(this.date, this.timezone, value, this.generators);
        }
        if (unit === "generators") {
            return new DateTime(this.date, this.timezone, this.duration, value);
        }
        let date = new Date(this.date);
        switch (unit) {
            case "year":
                date.setUTCFullYear(value);
                break;
            case "month": {
                const length = monthLength$1(value, date.getUTCFullYear());
                const day = date.getUTCDate();
                if (day > length) {
                    date.setUTCDate(1);
                    date.setUTCMonth(value);
                    date = subUTCDays$1(date, 1);
                }
                else {
                    date.setUTCMonth(value - 1);
                }
                break;
            }
            case "day":
                date.setUTCDate(value);
                break;
            case "hour":
                date.setUTCHours(value);
                break;
            case "minute":
                date.setUTCMinutes(value);
                break;
            case "second":
                date.setUTCSeconds(value);
                break;
            case "millisecond":
                date.setUTCMilliseconds(value);
                break;
            default:
                throw new Error("Invalid unit provided to `DateTime#set`");
        }
        return this.forkDateTime(date);
    }
    granularity(granularity, opt = {}) {
        let date = this.forkDateTime(this.date);
        switch (granularity) {
            case "year":
                date = date.set("month", 1);
            case "month":
                date = date.set("day", 1);
                break;
            case "week":
                date = setDateToStartOfWeek$1(date, opt.weekStart);
        }
        switch (granularity) {
            case "year":
            case "month":
            case "week":
            case "day":
                date = date.set("hour", 0);
            case "hour":
                date = date.set("minute", 0);
            case "minute":
                date = date.set("second", 0);
            case "second":
                date = date.set("millisecond", 0);
            case "millisecond":
                return date;
            default:
                throw new Error("Invalid granularity provided to `DateTime#granularity`: " + granularity);
        }
    }
    endGranularity(granularity, opt = {}) {
        let date = this.forkDateTime(this.date);
        switch (granularity) {
            case "year":
                date = date.set("month", 12);
            case "month":
                date = date.set("day", monthLength$1(date.get("month"), date.get("year")));
                break;
            case "week":
                date = setDateToEndOfWeek$1(date, opt.weekStart);
        }
        switch (granularity) {
            case "year":
            case "month":
            case "week":
            case "day":
                date = date.set("hour", 23);
            case "hour":
                date = date.set("minute", 59);
            case "minute":
                date = date.set("second", 59);
            case "second":
                date = date.set("millisecond", 999);
            case "millisecond":
                return date;
            default:
                throw new Error("Invalid granularity provided to `DateTime#granularity`: " + granularity);
        }
    }
    toISOString() {
        return this.date.toISOString();
    }
    toDateTime() {
        return this;
    }
    toJSON() {
        const json = {
            timezone: this.timezone,
            year: this.get("year"),
            month: this.get("month"),
            day: this.get("day"),
            hour: this.get("hour"),
            minute: this.get("minute"),
            second: this.get("second"),
            millisecond: this.get("millisecond")
        };
        if (this.duration) {
            json.duration = this.duration;
        }
        return json;
    }
    valueOf() {
        return this.date.valueOf();
    }
    assertIsValid() {
        if (isNaN(this.valueOf())) {
            throw new InvalidDateTimeError$1("DateTime has invalid date.");
        }
        return true;
    }
    forkDateTime(date) {
        return new DateTime(date, this.timezone, this.duration, this.generators);
    }
};
function assertSameTimeZone$1(x, y) {
    if (x.timezone !== y.timezone) {
        throw new InvalidDateTimeError$1("Attempted to compare a datetime to another date in a different timezone: " + JSON.stringify(x) + " and " + JSON.stringify(y));
    }
    return true;
}
function setDateToStartOfWeek$1(date, wkst) {
    const index = orderedWeekdays$1(wkst).indexOf(date.get("weekday"));
    return date.subtract(index, "day");
}
function setDateToEndOfWeek$1(date, wkst) {
    const index = orderedWeekdays$1(wkst).indexOf(date.get("weekday"));
    return date.add(6 - index, "day");
}
function dateTimeSortComparer(a, b) {
    if (a.isAfter(b))
        return 1;
    if (a.isBefore(b))
        return -1;
    if (a.duration && b.duration) {
        if (a.duration > b.duration)
            return 1;
        if (a.duration < b.duration)
            return -1;
    }
    return 0;
}
function uniqDateTimes(dates) {
    return Array.from(new Map(dates.map((date) => [date.toISOString(), date])).values());
}
function orderedWeekdays$1(wkst = "SU") {
    const wkdays = DateAdapter$1.WEEKDAYS.slice();
    let index = wkdays.indexOf(wkst);
    while (index !== 0) {
        shiftArray$1(wkdays);
        index--;
    }
    return wkdays;
}
function shiftArray$1(array, from = "first") {
    if (array.length === 0) {
        return array;
    }
    else if (from === "first") {
        array.push(array.shift());
    }
    else {
        array.unshift(array.pop());
    }
    return array;
}
function getDifferenceBetweenWeekdays(x, y) {
    if (x === y)
        return 0;
    const result = DateAdapter$1.WEEKDAYS.indexOf(x) - DateAdapter$1.WEEKDAYS.indexOf(y);
    return result > 0 ? 7 - result : Math.abs(result);
}
function monthLength$1(month, year) {
    const block = {
        1: 31,
        2: getDaysInFebruary$1(year),
        3: 31,
        4: 30,
        5: 31,
        6: 30,
        7: 31,
        8: 31,
        9: 30,
        10: 31,
        11: 30,
        12: 31
    };
    return block[month];
}
function getDaysInFebruary$1(year) {
    return isLeapYear$1(year) ? 29 : 28;
}
function isLeapYear$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function getUTCYearDay$1(now) {
    const start = new Date(Date.UTC(now.getUTCFullYear(), 0, 1));
    const diff2 = now.valueOf() - start.valueOf();
    return 1 + Math.floor(diff2 / DateAdapter$1.MILLISECONDS_IN_DAY);
}
function toInteger$1(input) {
    if (input === null || input === true || input === false) {
        return NaN;
    }
    const int = Number(input);
    if (isNaN(int)) {
        return int;
    }
    return int < 0 ? Math.ceil(int) : Math.floor(int);
}
function addMilliseconds$1(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
        throw new TypeError("2 arguments required, but only " + arguments.length + " present");
    }
    const timestamp = dirtyDate.valueOf();
    const amount = toInteger$1(dirtyAmount);
    return new Date(timestamp + amount);
}
function addUTCYears$1(date, input) {
    const amount = toInteger$1(input);
    return addUTCMonths$1(date, amount * 12);
}
function addUTCMonths$1(date, input) {
    const amount = toInteger$1(input);
    date = new Date(date);
    const desiredMonth = date.getUTCMonth() + amount;
    const dateWithDesiredMonth = /* @__PURE__ */ new Date(0);
    dateWithDesiredMonth.setUTCFullYear(date.getUTCFullYear(), desiredMonth, 1);
    dateWithDesiredMonth.setUTCHours(0, 0, 0, 0);
    const daysInMonth = monthLength$1(dateWithDesiredMonth.getUTCMonth() + 1, dateWithDesiredMonth.getUTCFullYear());
    date.setUTCMonth(desiredMonth, Math.min(daysInMonth, date.getUTCDate()));
    return date;
}
function addUTCWeeks$1(date, input) {
    const amount = toInteger$1(input);
    const days = amount * 7;
    return addUTCDays$1(date, days);
}
function addUTCDays$1(date, input) {
    return addUTCMilliseconds$1(date, toInteger$1(input) * DateAdapter$1.MILLISECONDS_IN_DAY);
}
function addUTCHours$1(date, input) {
    const amount = toInteger$1(input);
    return addMilliseconds$1(date, amount * DateAdapter$1.MILLISECONDS_IN_HOUR);
}
function addUTCMinutes$1(date, input) {
    const amount = toInteger$1(input);
    return addMilliseconds$1(date, amount * DateAdapter$1.MILLISECONDS_IN_MINUTE);
}
function addUTCSeconds$1(date, input) {
    const amount = toInteger$1(input);
    return addMilliseconds$1(date, amount * DateAdapter$1.MILLISECONDS_IN_SECOND);
}
function addUTCMilliseconds$1(date, input) {
    const amount = toInteger$1(input);
    const timestamp = date.getTime();
    return new Date(timestamp + amount);
}
function subUTCYears$1(date, amount) {
    return addUTCYears$1(date, -amount);
}
function subUTCMonths$1(date, amount) {
    return addUTCMonths$1(date, -amount);
}
function subUTCWeeks$1(date, amount) {
    return addUTCWeeks$1(date, -amount);
}
function subUTCDays$1(date, amount) {
    return addUTCDays$1(date, -amount);
}
function subUTCHours$1(date, amount) {
    return addUTCHours$1(date, -amount);
}
function subUTCMinutes$1(date, amount) {
    return addUTCMinutes$1(date, -amount);
}
function subUTCSeconds$1(date, amount) {
    return addUTCSeconds$1(date, -amount);
}
function subUTCMilliseconds$1(date, amount) {
    return addUTCMilliseconds$1(date, -amount);
}
class ArgumentError extends Error {
}
class InfiniteLoopError extends Error {
}
function numberSortComparer(a, b) {
    if (a > b) {
        return 1;
    }
    else if (b > a) {
        return -1;
    }
    else {
        return 0;
    }
}
function freqToGranularity(freq) {
    switch (freq) {
        case "YEARLY":
            return "year";
        case "MONTHLY":
            return "month";
        case "WEEKLY":
            return "week";
        case "DAILY":
            return "day";
        case "HOURLY":
            return "hour";
        case "MINUTELY":
            return "minute";
        case "SECONDLY":
            return "second";
        case "MILLISECONDLY":
            return "millisecond";
        default:
            throw new Error("unknown freq passed to freqToGranularity()");
    }
}
function cloneJSON(json) {
    return JSON.parse(JSON.stringify(json));
}
function dateInputToDateAdapter(date) {
    return date instanceof DateTime$1 ? DateAdapterBase$1.adapter.fromDateTime(date) : date instanceof DateAdapterBase$1 ? date : DateAdapterBase$1.adapter.fromDate(date);
}
function dateInputToDateTime(date, timezone) {
    if (date instanceof DateTime$1) {
        if (date.timezone !== timezone) {
            return DateAdapterBase$1.adapter.fromDateTime(date).set("timezone", timezone).toDateTime();
        }
        return date;
    }
    return date instanceof DateAdapterBase$1 ? date.set("timezone", timezone).toDateTime() : DateAdapterBase$1.adapter.fromDate(date).set("timezone", timezone).toDateTime();
}
function normalizeDateTimeTimezone$1(date, timezone) {
    if (date.timezone !== timezone) {
        return DateAdapterBase$1.adapter.fromDateTime(date).set("timezone", timezone).toDateTime();
    }
    return date;
}
class RuleOptionError extends Error {
}
function normalizeDefaultOptions(options2) {
    let start;
    if (options2.start instanceof DateTime$1) {
        start = options2.start;
    }
    else if (options2.start instanceof DateAdapterBase$1) {
        start = options2.start.toDateTime();
    }
    else if (DateAdapterBase$1.adapter.isDate(options2.start)) {
        start = DateAdapterBase$1.adapter.fromDate(options2.start).toDateTime();
    }
    else {
        throw new RuleOptionError('"start" must be either a `DateAdapter` instance or an instance of the date a DateAdapter is wrapping (e.g. `StandardDateAdapter` wraps a `Date`)');
    }
    let end;
    if (options2.end) {
        if (options2.end instanceof DateTime$1) {
            end = options2.end;
        }
        else if (options2.end instanceof DateAdapterBase$1) {
            end = options2.end.toDateTime();
        }
        else if (DateAdapterBase$1.adapter.isDate(options2.end)) {
            end = DateAdapterBase$1.adapter.fromDate(options2.end).toDateTime();
        }
        else {
            throw new RuleOptionError('"end" must be either be `undefined`, a `DateAdapter` instance, or an instance of the date a DateAdapter is wrapping (e.g. `StandardDateAdapter` wraps a `Date`)');
        }
    }
    if (options2.duration !== void 0) {
        if (!Number.isInteger(options2.duration)) {
            throw new RuleOptionError('"duration" expects a whole number');
        }
        if (options2.duration <= 0) {
            throw new RuleOptionError('"duration" must be greater than 0');
        }
    }
    if (options2.count !== void 0) {
        if (!Number.isInteger(options2.count)) {
            throw new RuleOptionError('"count" must be a whole number');
        }
        if (options2.count < 0) {
            throw new RuleOptionError('"count" must be greater than 0');
        }
    }
    if (options2.end !== void 0 && options2.count !== void 0) {
        throw new RuleOptionError('"end" and "count" cannot both be present');
    }
    return {
        start,
        end,
        count: options2.count,
        duration: options2.duration
    };
}
function normalizeRuleOptions(recurrenceModules, options2) {
    const normOptions = normalizeDefaultOptions(options2);
    const startOptions = cloneJSON(options2);
    recurrenceModules.forEach((mod) => {
        mod.normalizeOptions(startOptions, normOptions);
    });
    Object.keys(normOptions).forEach((key) => {
        if (normOptions[key] === void 0) {
            delete normOptions[key];
        }
    });
    return normOptions;
}
function cloneRuleOptions(options2) {
    const obj = cloneJSON(options2);
    obj.start = options2.start;
    if (options2.end)
        obj.end = options2.end;
    return obj;
}
class RecurrenceRuleError extends Error {
}
class ValidDateTime {
    constructor(date) {
        this.date = date;
    }
}
class InvalidDateTime {
    constructor(date) {
        this.date = date;
    }
}
function recurrenceRulesReducer(rules) {
    return (iterator) => rules.reduce((prev, curr) => {
        const rule = curr.get(iterator);
        if (rule)
            prev.push(rule);
        return prev;
    }, []);
}
class RecurrenceRulesIterator {
    constructor(recurrenceRules, options2, args) {
        this.options = options2;
        this.args = args;
        this.rules = [];
        this.iterator = // prettier-ignore
            this.options.count === void 0 ? this.iterate() : this.args.reverse ? this.iterateWithReverseCount() : this.iterateWithCount();
        this.options = Object.assign(Object.assign({}, cloneJSON(options2)), {
            start: options2.start,
            end: options2.end
        });
        this.reverse = this.options.count === void 0 && args.reverse || false;
        const { start, end } = this.normalizeDateTimeArgs(args);
        if (options2.count !== void 0) {
            this.start = options2.start;
        }
        else if (start && options2.start) {
            this.start = start.isAfterOrEqual(options2.start) ? start : options2.start;
        }
        else {
            this.start = start || options2.start;
        }
        if (end && options2.end) {
            this.end = end.isBeforeOrEqual(options2.end) ? end : options2.end;
        }
        else {
            this.end = end || options2.end;
        }
        if (this.args.reverse && !(options2.count !== void 0 || this.end)) {
            throw new Error("When iterating in reverse, the rule must have an `end` or `count` property or you must provide an `end` argument.");
        }
        this.isInfinite = !this.end && this.options.count === void 0;
        this.hasDuration = !!this.options.duration;
        this.rules = Array.isArray(recurrenceRules) ? recurrenceRules : recurrenceRules(this);
    }
    [Symbol.iterator]() {
        return this.iterator;
    }
    next(args) {
        return this.iterator.next(args);
    }
    /**
     * In the pipe controller, we have an extra level of indirection with
     * the `run()` and `iterate()` methods. The `iterate()` method is the
     * method which actually runs the logic in the pipes. If we didn't
     * need to account for the `count` property of a rule, we would *only*
     * need the iterate method... so much simpler. But we do need to account
     * for rules with a `count` property.
     *
     * Rules with a `count` property need to begin iteration at the beginning
     * because the `count` is always from the rule's start time. So if someone
     * passes in a new start time as an argument to a rule with `count`, we
     * need to secretly iterate from the beginning, tracking the number of
     * iterations, and then only start yielding dates when we reach the section
     * the user cares about (or, if we hit our `count` quota, cancel iterating).
     *
     * Additionally, we need to handle iterating in reverse. In this case, we build
     * up a cache of dates between the rule's start time and the reverse iteration
     * start date. Once we hit the reverse iteration start date, we start
     * yielding dates in the cache, in reverse order.
     *
     * In general, I imagine the count number, if used, will be small. But a large
     * count will definitely have a negative performance affect. I don't think
     * there's anything to be done about this.
     */
    *iterateWithReverseCount() {
        const dates = Array.from(this.iterateWithCount()).reverse();
        let yieldArgs;
        const dateCache = dates.slice();
        let date = dateCache.shift();
        while (date) {
            if (yieldArgs && yieldArgs.skipToDate && date.isAfter(yieldArgs.skipToDate)) {
                date = dateCache.shift();
                continue;
            }
            yieldArgs = yield date;
            if (yieldArgs && yieldArgs.skipToDate && yieldArgs.skipToDate.isAfterOrEqual(date)) {
                throw new Error("A provided `skipToDate` option must be greater than the last yielded date (or smaller, in the case of reverse iteration)");
            }
            date = dateCache.shift();
        }
        return void 0;
    }
    *iterateWithCount() {
        if (this.options.count === 0)
            return;
        const iterable = this.iterate();
        const start = this.args.start || this.start;
        let date = iterable.next().value;
        let index = 1;
        let yieldArgs;
        while (date && index <= this.options.count) {
            index++;
            if (date.isBefore(start)) {
                date = iterable.next().value;
                continue;
            }
            if (yieldArgs && yieldArgs.skipToDate && date.isBefore(yieldArgs.skipToDate)) {
                date = iterable.next().value;
                continue;
            }
            yieldArgs = yield date;
            if (yieldArgs && yieldArgs.skipToDate && yieldArgs.skipToDate.isBeforeOrEqual(date)) {
                throw new Error("A provided `skipToDate` option must be greater than the last yielded date (or smaller, in the case of reverse iteration)");
            }
            date = iterable.next().value;
        }
        return void 0;
    }
    *iterate() {
        let startingDate = this.start;
        if (this.reverse)
            startingDate = this.end;
        let date = this.nextDate(startingDate);
        while (date) {
            const args = yield this.normalizeRunOutput(date);
            if (args && args.skipToDate) {
                if (this.reverse ? args.skipToDate.isAfterOrEqual(date) : args.skipToDate.isBeforeOrEqual(date)) {
                    throw new Error("A provided `skipToDate` option must be greater than the last yielded date (or smaller, in the case of reverse iteration)");
                }
                date = this.nextDate(args.skipToDate);
            }
            else {
                date = this.nextDate(this.reverse ? date.subtract(1, "millisecond") : date.add(1, "millisecond"));
            }
        }
        return void 0;
    }
    /**
     * Loops through the recurrence rules until a valid date is found.
     */
    nextDate(start) {
        let result = this.runRules(start.set("generators", []));
        if (this.isDatePastEnd(result.date))
            return null;
        let index = 0;
        while (result instanceof InvalidDateTime && index < 50) {
            result = this.runRules(result.date);
            if (this.isDatePastEnd(result.date))
                return null;
            index++;
        }
        if (result instanceof InvalidDateTime) {
            throw new RecurrenceRuleError(`Failed to find a matching occurrence in ${index} iterations. Last iterated date: "${result.date.toISOString()}"`);
        }
        if (this.reverse ? start.isBefore(result.date) : start.isAfter(result.date)) {
            throw new RecurrenceRuleError("An error occurred in a recurrence rule. If this happened using the rSchedule provided recurrence rules, you should open an issue in the rSchedule repo. The maintainer is going to want to know how to recreate the error.");
        }
        return result.date;
    }
    /**
     * Performs one run of the recurrence rules and returns the result.
     * It's a slightly optimized reducer function.
     */
    runRules(start) {
        let result = new ValidDateTime(start);
        for (const rule of this.rules) {
            if (result instanceof InvalidDateTime) {
                return result;
            }
            result = rule.run(result.date);
        }
        return result;
    }
    isDatePastEnd(date) {
        return this.reverse ? date.isBefore(this.start) : this.end && date.isAfter(this.end);
    }
    normalizeRunOutput(date) {
        return this.hasDuration ? date.set("duration", this.options.duration) : date;
    }
    normalizeDateTimeArgs(args) {
        return {
            start: args.start && normalizeDateTimeTimezone$1(args.start, this.options.start.timezone),
            end: args.end && normalizeDateTimeTimezone$1(args.end, this.options.start.timezone)
        };
    }
}
class OccurrenceGenerator {
    constructor(args = {}) {
        this.timezone = args.timezone !== void 0 ? args.timezone : null;
        this.maxDuration = args.maxDuration || 0;
    }
    /** Returns the first occurrence or, if there are no occurrences, null. */
    get firstDate() {
        if (this._firstDate !== void 0)
            return this._firstDate;
        const start = this._run().next().value;
        this._firstDate = start ? this.dateAdapter.fromDateTime(start) : null;
        return this._firstDate;
    }
    /** If generator is infinite, returns `null`. Otherwise returns the end date */
    get lastDate() {
        if (this._lastDate !== void 0)
            return this._lastDate;
        if (this.isInfinite) {
            this._lastDate = null;
            return null;
        }
        const end = this._run({ reverse: true }).next().value;
        this._lastDate = end ? this.dateAdapter.fromDateTime(end) : null;
        return this._lastDate;
    }
    pipe(...operators) {
        return operators.reduce((prev, curr) => curr({ base: prev, timezone: this.timezone }), this);
    }
    /**
       * Processes the object's rules/dates and returns an iterable for the occurrences.
       *
       * Options object:
       * - `start` the date to begin iteration on
       * - `end` the date to end iteration on
       * - `take` the max number of dates to take before ending iteration
       * - `reverse` whether to iterate in reverse or not
       *
       * Examples:
       *
       * ```
       * const iterator = schedule.occurrences({ start: new Date(), take: 5 });
       
       * for (const date of iterator) {
       *   // do stuff
       * }
    
       * iterator.toArray() // returns Date array
       * iterator.next().value // returns next Date
       * ```
       *
       */
    occurrences(args = {}) {
        return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
    }
    /**
     * Iterates over the object's occurrences and bundles them into collections
     * with a specified granularity (default is `"YEARLY"`). Make sure to
     * read about each option & combination of options below.
     *
     * Options object:
     *   - start?: DateAdapter
     *   - end?: DateAdapter
     *   - take?: number
     *   - reverse?: NOT SUPPORTED
     *   - granularity?: CollectionsGranularity
     *   - weekStart?: DateAdapter.Weekday
     *   - skipEmptyPeriods?: boolean
     *
     * Returned `Collection` object:
     *
     *   - `dates` property containing an array of DateAdapter objects.
     *   - `granularity` property containing the granularity.
     *     - `CollectionsGranularity` === `RuleOptions.Frequency`.
     *     - default is `"YEARLY"`
     *   - `periodStart` property containing a DateAdapter equal to the period's
     *     start time.
     *   - `periodEnd` property containing a DateAdapter equal to the period's
     *     end time.
     *
     * #### Details:
     *
     * `collections()` always returns full periods. This means that the `start` argument is
     * transformed to be the start of whatever period the `start` argument is in, and the
     * `end` argument is transformed to be the end of whatever period the `end` argument is
     * in.
     *
     * - Example: with granularity `"YEARLY"`, the `start` argument will be transformed to be the
     *   start of the year passed in the `start` argument, and the `end` argument will be transformed
     *   to be the end of the year passed in the `end` argument.
     *
     * By default, the `periodStart` value of `Collection` objects produced by this method increments linearly.
     * This means the returned `Collection#dates` property may have length 0. This can be changed by
     * passing the `skipEmptyPeriods: true` option, in which case the `periodStart` from one collection to the
     * next can "jump".
     *
     * - Example 1: if your object's first occurrence is 2019/2/1 (February 1st) and you call
     *   `collection({skipEmptyPeriods: true, granularity: 'DAILY', start: new Date(2019,0,1)})`
     *   (so starting on January 1st), the first Collection produced will have a `periodStart` in February.
     *
     * - Example 2: if your object's first occurrence is 2019/2/1 (February 1st) and you call
     *   `collection({granularity: 'DAILY', start: new Date(2019,0,1)})`
     *   (so starting on January 1st), the first collection produced will have a `Collection#periodStart`
     *   of January 1st and have `Collection#dates === []`. Similarly, the next 30 collections produced
     *   (Jan 2nd - 31st) will all contain an empty array for the `dates` property. Then the February 1st
     *   `Collection` will contain dates.
     *
     * When giving a `take` argument to `collections()`, you are specifying
     * the number of `Collection` objects to return (rather than occurrences).
     *
     * When choosing a granularity of `"WEEKLY"`, the `weekStart` option is required.
     *
     * When choosing a granularity of `"MONTHLY"`:
     *
     * - If the `weekStart` option *is not* present, will generate collections with
     *   the `periodStart` and `periodEnd` at the beginning and end of each month.
     *
     * - If the `weekStart` option *is* present, will generate collections with the
     *   `periodStart` equal to the start of the first week of the month, and the
     *   `periodEnd` equal to the end of the last week of the month. This behavior could be
     *   desired when rendering opportunities in a calendar view, where the calendar renders
     *   full weeks (which may result in the calendar displaying dates in the
     *   previous or next months).
     *
     */
    collections(args = {}) {
        return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
    }
    /**
     * Returns true if an occurrence starts on or between the provided start/end
     * datetimes. If the `excludeEnds` option is provided, then occurrences
     * equal to the start/end times are ignored.
     *
     * If the occurrence generator has a duration, and `excludeEnds !== true`,
     * and a `maxDuration` argument is supplied (either in the constructor or
     * here), then any occurrence that's time overlaps with the start/end times
     * return true.
     */
    occursBetween(startInput, endInput, options2 = {}) {
        const start = this.normalizeDateInput(startInput);
        const end = this.normalizeDateInput(endInput);
        if (this.hasDuration && !options2.excludeEnds) {
            const maxDuration = this.getMaxDuration("occursBetween", options2);
            const iterator = this._run({
                start: start.subtract(maxDuration, "millisecond"),
                end,
                reverse: true
            });
            for (const day of iterator) {
                if (day.end.isBefore(start))
                    continue;
                return true;
            }
            return false;
        }
        for (const day of this._run({ start, end })) {
            if (options2.excludeEnds) {
                if (day.isEqual(start)) {
                    continue;
                }
                if (day.isEqual(end)) {
                    break;
                }
            }
            return true;
        }
        return false;
    }
    occursOn(rawArgs) {
        const args = this.normalizeOccursOnArgs(rawArgs);
        if (args.weekday) {
            if (this.isInfinite && !args.before) {
                throw new ArgumentError("When calling `occursOn()` with a `weekday` argument and an occurrence object that has infinite occurrences, you must include a `before` argument as well.");
            }
            const start = args.after && (args.excludeEnds ? args.after.add(1, "day") : args.after);
            const end = args.before && (args.excludeEnds ? args.before.subtract(1, "day") : args.before);
            const iterator = this._run({ start, end });
            let date = iterator.next().value;
            if (!date)
                return false;
            while (date) {
                if (date.get("weekday") === args.weekday) {
                    return true;
                }
                date = iterator.next({
                    skipToDate: date.add(getDifferenceBetweenWeekdays(date.get("weekday"), args.weekday), "day").granularity("day")
                }).value;
            }
            return false;
        }
        if (!args.date) {
            throw new ArgumentError(`"occursOn()" must be called with either a "date" or "weekday" argument`);
        }
        if (this.hasDuration) {
            const maxDuration = this.getMaxDuration("occursOn", args);
            const iterator = this._run({
                start: args.date.subtract(maxDuration, "millisecond"),
                end: args.date
            });
            for (const date of iterator) {
                if (date.end.isBefore(args.date))
                    continue;
                if (date.isAfter(args.date))
                    return false;
                return true;
            }
            return false;
        }
        for (const day of this._run({ start: args.date, end: args.date })) {
            return !!day;
        }
        return false;
    }
    /**
     * Returns true if an occurrence starts after the provided datetime.
     * If the `excludeStart` option is provided, then occurrences
     * equal to the provided datetime are ignored.
     *
     * If the occurrence generator has a duration, and `excludeStart !== true`,
     * and a `maxDuration` argument is supplied (either in the constructor or
     * here), then any occurrence that's end time is after/equal to the provided
     * datetime return true.
     */
    occursAfter(date, options2 = {}) {
        const adapter = this.normalizeDateInput(date);
        if (this.hasDuration && !options2.excludeStart) {
            const maxDuration = this.getMaxDuration("occursAfter", options2);
            const iterator = this._run({
                start: adapter.subtract(maxDuration, "millisecond")
            });
            for (const date2 of iterator) {
                if (date2.end.isBefore(adapter))
                    continue;
                return true;
            }
            return false;
        }
        for (const day of this._run({ start: adapter })) {
            if (options2.excludeStart && day.isEqual(adapter)) {
                continue;
            }
            return true;
        }
        return false;
    }
    /**
     * Returns true if an occurrence starts before the provided datetime.
     * If the `excludeStart` option is provided, then occurrences
     * equal to the provided datetime are ignored.
     *
     * If the occurrence generator has a duration, and `excludeStart` is
     * also provided, then this will only return true if an occurrence
     * both starts and ends before the provided datetime.
     */
    occursBefore(date, options2 = {}) {
        const adapter = this.normalizeDateInput(date);
        if (this.hasDuration && options2.excludeStart) {
            for (const day of this._run({ end: adapter, reverse: true })) {
                if (day.end.isAfterOrEqual(adapter))
                    continue;
                return true;
            }
            return false;
        }
        for (const day of this._run({ end: adapter, reverse: true })) {
            if (options2.excludeStart && day.isEqual(adapter)) {
                continue;
            }
            return true;
        }
        return false;
    }
    get dateAdapter() {
        return DateAdapterBase$1.adapter;
    }
    normalizeOccurrencesArgs(rawArgs) {
        return Object.assign(Object.assign({}, rawArgs), {
            start: this.normalizeDateInput(rawArgs.start),
            end: this.normalizeDateInput(rawArgs.end)
        });
    }
    normalizeCollectionsArgs(rawArgs) {
        if (rawArgs.reverse !== void 0) {
            throw new ArgumentError("`collections()` does not support the `reverse` option at this time.");
        }
        return Object.assign(Object.assign({}, rawArgs), {
            start: this.normalizeDateInput(rawArgs.start),
            end: this.normalizeDateInput(rawArgs.end)
        });
    }
    normalizeOccursOnArgs(rawArgs = {}) {
        return Object.assign(Object.assign({}, rawArgs), {
            date: this.normalizeDateInput(rawArgs.date),
            after: this.normalizeDateInput(rawArgs.after),
            before: this.normalizeDateInput(rawArgs.before),
            excludeDates: rawArgs.excludeDates && rawArgs.excludeDates.map((date) => this.normalizeDateInput(date))
        });
    }
    normalizeRunArgs(args) {
        return Object.assign(Object.assign({}, args), {
            start: this.normalizeDateInput(args.start),
            end: this.normalizeDateInput(args.end)
        });
    }
    normalizeDateInput(date) {
        return date ? dateInputToDateTime(date, this.timezone) : void 0;
    }
    normalizeDateInputToAdapter(date) {
        if (!date)
            return;
        return dateInputToDateAdapter(date);
    }
    normalizeRunOutput(date) {
        return normalizeDateTimeTimezone$1(date, this.timezone);
    }
    getMaxDuration(method, options2) {
        const maxDuration = options2.maxDuration || this.maxDuration;
        if (!Number.isInteger(maxDuration)) {
            throw new ArgumentError(`When an occurrence generator has a duration, a 'maxDuration' argument must be supplied to ${method}().`);
        }
        return maxDuration;
    }
}
class OccurrenceIterator {
    constructor(iterable, args) {
        this.iterable = iterable;
        this.args = args;
        this[Symbol.iterator] = () => this.occurrenceIterator();
        this.iterator = iterable._run(args);
        this.isInfinite = iterable.isInfinite;
    }
    next(args) {
        return this.occurrenceIterator(args).next();
    }
    toArray() {
        if (this.args.end || this.args.take || !this.isInfinite) {
            return Array.from(this.occurrenceIterator());
        }
        throw new InfiniteLoopError("OccurrenceIterator#toArray() can only be called if the iterator is not infinite, or you provide and `end` argument, or you provide a `take` argument.");
    }
    *occurrenceIterator(rawArgs) {
        let args = this.normalizeRunArgs(rawArgs);
        let date = this.iterator.next(args).value;
        while (date) {
            const yieldArgs = yield this.normalizeDateOutput(date);
            args = this.normalizeRunArgs(yieldArgs);
            date = this.iterator.next(args).value;
        }
        return void 0;
    }
    normalizeRunArgs(args) {
        return {
            skipToDate: this.normalizeDateInput(args && args.skipToDate)
        };
    }
    normalizeDateInput(date) {
        return date ? dateInputToDateTime(date, this.iterable.timezone) : void 0;
    }
    normalizeDateOutput(date) {
        if (!date)
            return;
        return date ? DateAdapterBase$1.adapter.fromDateTime(date) : void 0;
    }
}
class Collection {
    constructor(dates = [], granularity, periodStart, periodEnd) {
        this.dates = dates;
        this.granularity = granularity;
        this.periodStart = periodStart;
        this.periodEnd = periodEnd;
    }
}
class CollectionIterator {
    constructor(iterable, args) {
        this.iterable = iterable;
        this.args = args;
        this.granularity = "year";
        this[Symbol.iterator] = () => this.iterator;
        if (args.granularity) {
            this.granularity = args.granularity;
            if (this.granularity === "week" && !args.weekStart) {
                throw new Error('"week" granularity requires `weekStart` arg');
            }
        }
        if (args.weekStart) {
            this.weekStart = args.weekStart;
        }
        if (args.reverse) {
            throw new Error("`OccurrenceGenerator#collections()` does not support iterating in reverse. Though `OccurrenceGenerator#occurrences()` does support iterating in reverse.");
        }
        this.args = Object.assign(Object.assign({}, args), {
            start: args.start || iterable._run().next().value,
            end: args.end && this.getPeriod(args.end).end
        });
        this.startDate = this.args.start && this.normalizeDateOutput(this.getPeriod(this.args.start).start) || null;
        this.iterator = this.collectionIterator();
    }
    next() {
        return this.iterator.next();
    }
    /**
     * While `next()` and `[Symbol.iterator]` both share state,
     * `toArray()` does not share state and always returns the whole
     * collections array.
     */
    toArray() {
        if (this.args.end || this.args.take || !this.iterable.isInfinite) {
            const collections = [];
            for (const collection of this.collectionIterator()) {
                collections.push(collection);
            }
            return collections;
        }
        throw new InfiniteLoopError("CollectionIterator#toArray() can only be called if the iterator is not infinite, or you provide and `end` argument, or you provide a `take` argument.");
    }
    normalizeDateOutput(date) {
        if (!date)
            return;
        return DateAdapterBase$1.adapter.fromDateTime(date);
    }
    *collectionIterator() {
        if (!this.startDate)
            return;
        let iterator = this.occurrenceIterator();
        let date = iterator.next().value;
        if (!date)
            return;
        let period = this.getPeriod(this.args.start);
        let dates = [];
        let index = 0;
        while (date && (this.args.take === void 0 || this.args.take > index)) {
            while (date && date.isBeforeOrEqual(period.end)) {
                dates.push(date);
                date = iterator.next().value;
            }
            yield new Collection(dates.map((date2) => this.normalizeDateOutput(date2)), this.granularity, this.normalizeDateOutput(period.start), this.normalizeDateOutput(period.end));
            if (!date)
                return;
            dates = [];
            period = !this.args.skipEmptyPeriods ? this.getPeriod(this.incrementPeriod(period.period)) : this.getPeriod(date);
            if (this.granularity === "month" && this.weekStart) {
                iterator = this.iterable._run({
                    start: period.start,
                    end: this.args.end
                });
                date = iterator.next().value;
            }
            index++;
        }
    }
    getPeriod(date) {
        let start;
        let end;
        let period;
        if (this.granularity === "month" && this.weekStart) {
            start = date.granularity("month").granularity("week", { weekStart: this.weekStart });
            end = date.endGranularity("month").endGranularity("week", { weekStart: this.weekStart });
            period = date.granularity("month");
        }
        else {
            start = date.granularity(this.granularity, { weekStart: this.weekStart });
            end = date.endGranularity(this.granularity, { weekStart: this.weekStart });
            period = start;
        }
        return { start, end, period };
    }
    incrementPeriod(date) {
        return date.add(1, this.granularity);
    }
    occurrenceIterator() {
        let start = this.args.start || this.iterable._run().next().value;
        if (!start)
            return this.iterable._run(this.args);
        start = this.getPeriod(start).start;
        return this.iterable._run({
            start,
            end: this.args.end
        });
    }
}
class Operator extends OccurrenceGenerator {
    constructor(streams, config2) {
        super(config2);
        this.streams = streams;
        this.config = config2;
        this.timezone = config2.timezone;
        this.streams = streams.map((stream) => stream instanceof Operator ? stream : stream.set("timezone", this.timezone));
        this.isInfinite = this.calculateIsInfinite();
        this.hasDuration = this.calculateHasDuration();
    }
    normalizeDateInput(date) {
        if (!date)
            return;
        return dateInputToDateTime(date, this.timezone);
    }
    normalizeRunOutput(date) {
        return normalizeDateTimeTimezone$1(date, this.timezone);
    }
}
class IterableWrapper {
    constructor(generator, runArgs) {
        this.runArgs = runArgs;
        this.stream = generator._run(this.runArgs);
        this.next();
    }
    next(args) {
        const { done, value } = this.stream.next(args);
        this.done = typeof done === "boolean" ? done : true;
        this.value = value;
        return { done, value };
    }
}
function processYieldArgs(streams, options2 = {}, yieldArgs = {}) {
    if (!yieldArgs.skipToDate || streams.length === 0)
        return;
    if (options2.reverse ? streams.every((s) => s.value.isBeforeOrEqual(yieldArgs.skipToDate)) : streams.every((s) => s.value.isAfterOrEqual(yieldArgs.skipToDate))) {
        throw new Error("A provided `skipToDate` option must be greater than the last yielded date (or smaller, in the case of reverse iteration)");
    }
    for (const stream of streams) {
        if (stream.done)
            continue;
        if (options2.reverse ? stream.value.isBeforeOrEqual(yieldArgs.skipToDate) : stream.value.isAfterOrEqual(yieldArgs.skipToDate)) {
            continue;
        }
        stream.next(yieldArgs);
    }
}
function streamsComparer(a, b) {
    if (a.done && b.done)
        return 0;
    if (a.done)
        return 1;
    if (b.done)
        return -1;
    if (a.value.isAfter(b.value))
        return 1;
    return -1;
}
function streamsReverseComparer(a, b) {
    if (a.done && b.done)
        return 0;
    if (a.done)
        return -1;
    if (b.done)
        return 1;
    if (a.value.isAfter(b.value))
        return -1;
    return 1;
}
function selectNextIterable(streams, options2 = {}, yieldArgs = {}) {
    processYieldArgs(streams, options2, yieldArgs);
    return streams.sort(options2.reverse ? streamsReverseComparer : streamsComparer).filter((s) => !s.done).shift();
}
function add(...streams) {
    return (options2) => new AddOperator(streams, options2);
}
class AddOperator extends Operator {
    set(_, value) {
        return new AddOperator(this.streams.map((stream) => stream.set("timezone", value)), Object.assign(Object.assign({}, this.config), {
            base: this.config.base && this.config.base.set("timezone", value),
            timezone: value
        }));
    }
    *_run(args = {}) {
        const wrappedStreams = this.streams.map((input) => new IterableWrapper(input, args));
        if (this.config.base) {
            wrappedStreams.push(new IterableWrapper(this.config.base, args));
        }
        if (wrappedStreams.length === 0)
            return;
        let stream = selectNextIterable(wrappedStreams, args);
        while (stream && !stream.done) {
            const yieldArgs = yield this.normalizeRunOutput(stream.value);
            if (!(yieldArgs && yieldArgs.skipToDate)) {
                stream.next();
            }
            stream = selectNextIterable(wrappedStreams, args, yieldArgs);
        }
    }
    calculateIsInfinite() {
        return this.config.base && this.config.base.isInfinite || this.streams.some((stream) => stream.isInfinite);
    }
    calculateHasDuration() {
        const streamsDuration = this.streams.every((stream) => stream.hasDuration);
        if (!this.config.base)
            return streamsDuration;
        return this.config.base.hasDuration && streamsDuration;
    }
}
class Dates extends OccurrenceGenerator {
    constructor(args = {}) {
        super(args);
        this.adapters = [];
        this.isInfinite = false;
        this.maxDuration = 0;
        this.datetimes = [];
        this.data = args.data;
        if (args.dates) {
            this.adapters = args.dates.map((date) => {
                let adapter = this.normalizeDateInputToAdapter(date);
                if (args.duration && !adapter.duration) {
                    adapter = adapter.set("duration", args.duration);
                }
                return adapter.set("timezone", this.timezone);
            });
            this.datetimes = this.adapters.map((adapter) => adapter.toDateTime());
        }
        this.hasDuration = this.datetimes.every((date) => !!date.duration);
        if (this.hasDuration) {
            this.maxDuration = this.adapters.reduce((prev, curr) => curr.duration > prev ? curr.duration : prev, 0);
        }
    }
    get length() {
        return this.adapters.length;
    }
    /** Returns the first occurrence or, if there are no occurrences, null. */
    get firstDate() {
        return this.adapters[0] || null;
    }
    /** Returns the last occurrence or, if there are no occurrences, null. */
    get lastDate() {
        return this.adapters[this.length - 1] || null;
    }
    occurrences(args = {}) {
        return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
    }
    collections(args = {}) {
        return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
    }
    add(value) {
        return new Dates({
            dates: [...this.adapters, value],
            timezone: this.timezone,
            data: this.data
        });
    }
    remove(value) {
        const dates = this.adapters.slice();
        const input = this.normalizeDateInputToAdapter(value);
        const index = dates.findIndex((date) => date.valueOf() === input.valueOf());
        if (index >= 0) {
            dates.splice(index, 1);
        }
        return new Dates({
            dates,
            timezone: this.timezone,
            data: this.data
        });
    }
    set(prop, value, options2 = {}) {
        let timezone = this.timezone;
        let dates = this.adapters.slice();
        if (prop === "timezone") {
            if (value === this.timezone)
                return this;
            else if (options2.keepLocalTime) {
                dates = this.adapters.map((adapter) => {
                    const json = adapter.toJSON();
                    json.timezone = value;
                    return this.dateAdapter.fromJSON(json);
                });
            }
            timezone = value;
        }
        else if (prop === "dates") {
            dates = value;
        }
        else if (prop === "duration") {
            dates = dates.map((date) => date.set("duration", value || 0));
        }
        else {
            throw new ArgumentError(`Unexpected prop argument "${prop}". Accepted values are "timezone" or "dates"`);
        }
        return new Dates({
            dates,
            data: this.data,
            timezone
        });
    }
    filter(fn) {
        return new Dates({
            dates: this.adapters.filter(fn),
            data: this.data,
            timezone: this.timezone
        });
    }
    *_run(args = {}) {
        let dates = this.datetimes.sort(dateTimeSortComparer);
        if (args.start) {
            dates = dates.filter((date2) => date2.isAfterOrEqual(args.start));
        }
        if (args.end) {
            dates = dates.filter((date2) => date2.isBeforeOrEqual(args.end));
        }
        if (args.reverse) {
            dates = dates.slice().reverse();
        }
        if (args.take) {
            dates = dates.slice(0, args.take);
        }
        const dateCache = dates.slice();
        let date = dateCache.shift();
        let yieldArgs;
        while (date) {
            if (yieldArgs && yieldArgs.skipToDate && (args.reverse ? yieldArgs.skipToDate.isBefore(date) : yieldArgs.skipToDate.isAfter(date))) {
                date = dateCache.shift();
                continue;
            }
            date = date.add(this, "generator");
            yieldArgs = yield this.normalizeRunOutput(date);
            if (yieldArgs && yieldArgs.skipToDate && (args.reverse ? yieldArgs.skipToDate.isAfterOrEqual(date) : yieldArgs.skipToDate.isBeforeOrEqual(date))) {
                throw new Error("A provided `skipToDate` option must be greater than the last yielded date (or smaller, in the case of reverse iteration)");
            }
            date = dateCache.shift();
        }
        return void 0;
    }
}
class InvalidDateAdapterError2 extends Error {
}
let dateAdapterConfig;
class DateAdapterBase2 {
    constructor(_date, options2) {
        this.metadata = {};
        this.duration = options2 && options2.duration || 0;
        this.generators = options2 && options2.generators && options2.generators.slice() || [];
        if (!Number.isInteger(this.duration) || this.duration < 0) {
            throw new InvalidDateAdapterError2("duration must be a non-negative integer");
        }
    }
    static set adapter(value) {
        if (dateAdapterConfig) {
            throw new Error(`"${dateAdapterConfig.name}" has already been configured.`);
        }
        dateAdapterConfig = value;
    }
    static get adapter() {
        if (!dateAdapterConfig) {
            throw new Error("No date adapter has been configured. See rSchedule docs.");
        }
        return dateAdapterConfig;
    }
    static isDate(_object) {
        throw unimplementedError("isDate()");
    }
    static fromDate(_date, _options) {
        throw unimplementedError("fromDate()");
    }
    static fromJSON(_json) {
        throw unimplementedError("fromJSON()");
    }
    static fromDateTime(_datetime) {
        throw unimplementedError("fromDateTime()");
    }
    /**
     * Returns a string in simplified extended ISO format (ISO 8601).
     *
     * _Note: this method is intended for testing and its
     * implementation isn't particularly performant._
     */
    toISOString() {
        return this.set("timezone", "UTC").toDateTime().toISOString();
    }
    toDateTime() {
        const date = DateTime2.fromJSON(Object.assign(Object.assign({}, this.toJSON()), {
            generators: this.generators,
            metadata: this.metadata
        }));
        return date;
    }
}
DateAdapterBase2.hasTimezoneSupport = false;
function unimplementedError(name) {
    return new Error(`You must implement the "${name}" method for this DateAdapter class`);
}
var DateAdapter;
(function (DateAdapter2) {
    DateAdapter2.WEEKDAYS = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
    DateAdapter2.MILLISECONDS_IN_SECOND = 1e3;
    DateAdapter2.MILLISECONDS_IN_MINUTE = DateAdapter2.MILLISECONDS_IN_SECOND * 60;
    DateAdapter2.MILLISECONDS_IN_HOUR = DateAdapter2.MILLISECONDS_IN_MINUTE * 60;
    DateAdapter2.MILLISECONDS_IN_DAY = DateAdapter2.MILLISECONDS_IN_HOUR * 24;
    DateAdapter2.MILLISECONDS_IN_WEEK = DateAdapter2.MILLISECONDS_IN_DAY * 7;
})(DateAdapter || (DateAdapter = {}));
class InvalidDateTimeError2 extends Error {
}
class DateTime2 {
    constructor(date, timezone, duration, generators, options2 = {}) {
        this.metadata = {};
        this.date = new Date(date);
        this.timezone = timezone || null;
        this.duration = duration || 0;
        this.generators = generators && generators.slice() || [];
        if (!Number.isInteger(this.duration) || this.duration < 0) {
            throw new InvalidDateTimeError2("duration must be a non-negative integer");
        }
        if (options2.metadata) {
            Object.assign(this.metadata, options2.metadata);
        }
        this.assertIsValid();
    }
    // /**
    //  * Similar to `Array.isArray()`, `isInstance()` provides a surefire method
    //  * of determining if an object is a `DateTime` by checking against the
    //  * global symbol registry.
    //  */
    // static isInstance(object: any): object is DateTime {
    //   return !!(object && object[DATETIME_ID]);
    // }
    static fromJSON(json) {
        const date = new Date(Date.UTC(json.year, json.month - 1, json.day, json.hour, json.minute, json.second, json.millisecond));
        return new DateTime2(date, json.timezone, json.duration, json.generators, {
            metadata: json.metadata
        });
    }
    static fromDateAdapter(adapter) {
        return DateTime2.fromJSON(Object.assign(Object.assign({}, adapter.toJSON()), {
            generators: adapter.generators,
            metadata: adapter.metadata
        }));
    }
    /**
     * Returns `undefined` if `duration` is `0`. Else returns
     * the `end` date.
     */
    get end() {
        if (!this.duration)
            return;
        if (this._end)
            return this._end;
        this._end = this.add(this.duration, "millisecond");
        return this._end;
    }
    // While we constrain the argument to be another DateAdapter in typescript
    // we handle the case of someone passing in another type of object in javascript
    isEqual(object) {
        if (!object) {
            return false;
        }
        assertSameTimeZone(this, object);
        return this.valueOf() === object.valueOf();
    }
    isBefore(object) {
        assertSameTimeZone(this, object);
        return this.valueOf() < object.valueOf();
    }
    isBeforeOrEqual(object) {
        assertSameTimeZone(this, object);
        return this.valueOf() <= object.valueOf();
    }
    isAfter(object) {
        assertSameTimeZone(this, object);
        return this.valueOf() > object.valueOf();
    }
    isAfterOrEqual(object) {
        assertSameTimeZone(this, object);
        return this.valueOf() >= object.valueOf();
    }
    isOccurring(object) {
        if (!this.duration) {
            throw new Error("DateTime#isOccurring() is only applicable to DateTimes with durations");
        }
        assertSameTimeZone(this, object);
        return object.isAfterOrEqual(this) && object.isBeforeOrEqual(this.add(this.duration, "millisecond"));
    }
    add(amount, unit) {
        switch (unit) {
            case "generator": {
                const generators = this.generators.slice();
                generators.unshift(amount);
                return new DateTime2(this.date, this.timezone, this.duration, generators);
            }
            case "year":
                return this.forkDateTime(addUTCYears(this.date, amount));
            case "month":
                return this.forkDateTime(addUTCMonths(this.date, amount));
            case "week":
                return this.forkDateTime(addUTCWeeks(this.date, amount));
            case "day":
                return this.forkDateTime(addUTCDays(this.date, amount));
            case "hour":
                return this.forkDateTime(addUTCHours(this.date, amount));
            case "minute":
                return this.forkDateTime(addUTCMinutes(this.date, amount));
            case "second":
                return this.forkDateTime(addUTCSeconds(this.date, amount));
            case "millisecond":
                return this.forkDateTime(addUTCMilliseconds(this.date, amount));
            default:
                throw new Error("Invalid unit provided to `DateTime#add`");
        }
    }
    subtract(amount, unit) {
        switch (unit) {
            case "year":
                return this.forkDateTime(subUTCYears(this.date, amount));
            case "month":
                return this.forkDateTime(subUTCMonths(this.date, amount));
            case "week":
                return this.forkDateTime(subUTCWeeks(this.date, amount));
            case "day":
                return this.forkDateTime(subUTCDays(this.date, amount));
            case "hour":
                return this.forkDateTime(subUTCHours(this.date, amount));
            case "minute":
                return this.forkDateTime(subUTCMinutes(this.date, amount));
            case "second":
                return this.forkDateTime(subUTCSeconds(this.date, amount));
            case "millisecond":
                return this.forkDateTime(subUTCMilliseconds(this.date, amount));
            default:
                throw new Error("Invalid unit provided to `DateTime#subtract`");
        }
    }
    get(unit) {
        switch (unit) {
            case "year":
                return this.date.getUTCFullYear();
            case "month":
                return this.date.getUTCMonth() + 1;
            case "yearday":
                return getUTCYearDay(this.date);
            case "weekday":
                return DateAdapter.WEEKDAYS[this.date.getUTCDay()];
            case "day":
                return this.date.getUTCDate();
            case "hour":
                return this.date.getUTCHours();
            case "minute":
                return this.date.getUTCMinutes();
            case "second":
                return this.date.getUTCSeconds();
            case "millisecond":
                return this.date.getUTCMilliseconds();
            default:
                throw new Error("Invalid unit provided to `DateTime#set`");
        }
    }
    set(unit, value) {
        if (unit === "duration") {
            return new DateTime2(this.date, this.timezone, value, this.generators);
        }
        if (unit === "generators") {
            return new DateTime2(this.date, this.timezone, this.duration, value);
        }
        let date = new Date(this.date);
        switch (unit) {
            case "year":
                date.setUTCFullYear(value);
                break;
            case "month": {
                const length = monthLength(value, date.getUTCFullYear());
                const day = date.getUTCDate();
                if (day > length) {
                    date.setUTCDate(1);
                    date.setUTCMonth(value);
                    date = subUTCDays(date, 1);
                }
                else {
                    date.setUTCMonth(value - 1);
                }
                break;
            }
            case "day":
                date.setUTCDate(value);
                break;
            case "hour":
                date.setUTCHours(value);
                break;
            case "minute":
                date.setUTCMinutes(value);
                break;
            case "second":
                date.setUTCSeconds(value);
                break;
            case "millisecond":
                date.setUTCMilliseconds(value);
                break;
            default:
                throw new Error("Invalid unit provided to `DateTime#set`");
        }
        return this.forkDateTime(date);
    }
    granularity(granularity, opt = {}) {
        let date = this.forkDateTime(this.date);
        switch (granularity) {
            case "year":
                date = date.set("month", 1);
            case "month":
                date = date.set("day", 1);
                break;
            case "week":
                date = setDateToStartOfWeek(date, opt.weekStart);
        }
        switch (granularity) {
            case "year":
            case "month":
            case "week":
            case "day":
                date = date.set("hour", 0);
            case "hour":
                date = date.set("minute", 0);
            case "minute":
                date = date.set("second", 0);
            case "second":
                date = date.set("millisecond", 0);
            case "millisecond":
                return date;
            default:
                throw new Error("Invalid granularity provided to `DateTime#granularity`: " + granularity);
        }
    }
    endGranularity(granularity, opt = {}) {
        let date = this.forkDateTime(this.date);
        switch (granularity) {
            case "year":
                date = date.set("month", 12);
            case "month":
                date = date.set("day", monthLength(date.get("month"), date.get("year")));
                break;
            case "week":
                date = setDateToEndOfWeek(date, opt.weekStart);
        }
        switch (granularity) {
            case "year":
            case "month":
            case "week":
            case "day":
                date = date.set("hour", 23);
            case "hour":
                date = date.set("minute", 59);
            case "minute":
                date = date.set("second", 59);
            case "second":
                date = date.set("millisecond", 999);
            case "millisecond":
                return date;
            default:
                throw new Error("Invalid granularity provided to `DateTime#granularity`: " + granularity);
        }
    }
    toISOString() {
        return this.date.toISOString();
    }
    toDateTime() {
        return this;
    }
    toJSON() {
        const json = {
            timezone: this.timezone,
            year: this.get("year"),
            month: this.get("month"),
            day: this.get("day"),
            hour: this.get("hour"),
            minute: this.get("minute"),
            second: this.get("second"),
            millisecond: this.get("millisecond")
        };
        if (this.duration) {
            json.duration = this.duration;
        }
        return json;
    }
    valueOf() {
        return this.date.valueOf();
    }
    assertIsValid() {
        if (isNaN(this.valueOf())) {
            throw new InvalidDateTimeError2("DateTime has invalid date.");
        }
        return true;
    }
    forkDateTime(date) {
        return new DateTime2(date, this.timezone, this.duration, this.generators);
    }
}
function assertSameTimeZone(x, y) {
    if (x.timezone !== y.timezone) {
        throw new InvalidDateTimeError2("Attempted to compare a datetime to another date in a different timezone: " + JSON.stringify(x) + " and " + JSON.stringify(y));
    }
    return true;
}
function setDateToStartOfWeek(date, wkst) {
    const index = orderedWeekdays(wkst).indexOf(date.get("weekday"));
    return date.subtract(index, "day");
}
function setDateToEndOfWeek(date, wkst) {
    const index = orderedWeekdays(wkst).indexOf(date.get("weekday"));
    return date.add(6 - index, "day");
}
function orderedWeekdays(wkst = "SU") {
    const wkdays = DateAdapter.WEEKDAYS.slice();
    let index = wkdays.indexOf(wkst);
    while (index !== 0) {
        shiftArray(wkdays);
        index--;
    }
    return wkdays;
}
function shiftArray(array, from = "first") {
    if (array.length === 0) {
        return array;
    }
    else if (from === "first") {
        array.push(array.shift());
    }
    else {
        array.unshift(array.pop());
    }
    return array;
}
function monthLength(month, year) {
    const block = {
        1: 31,
        2: getDaysInFebruary(year),
        3: 31,
        4: 30,
        5: 31,
        6: 30,
        7: 31,
        8: 31,
        9: 30,
        10: 31,
        11: 30,
        12: 31
    };
    return block[month];
}
function getDaysInFebruary(year) {
    return isLeapYear(year) ? 29 : 28;
}
function isLeapYear(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function getUTCYearDay(now) {
    const start = new Date(Date.UTC(now.getUTCFullYear(), 0, 1));
    const diff2 = now.valueOf() - start.valueOf();
    return 1 + Math.floor(diff2 / DateAdapter.MILLISECONDS_IN_DAY);
}
function toInteger(input) {
    if (input === null || input === true || input === false) {
        return NaN;
    }
    const int = Number(input);
    if (isNaN(int)) {
        return int;
    }
    return int < 0 ? Math.ceil(int) : Math.floor(int);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
    if (arguments.length < 2) {
        throw new TypeError("2 arguments required, but only " + arguments.length + " present");
    }
    const timestamp = dirtyDate.valueOf();
    const amount = toInteger(dirtyAmount);
    return new Date(timestamp + amount);
}
function addUTCYears(date, input) {
    const amount = toInteger(input);
    return addUTCMonths(date, amount * 12);
}
function addUTCMonths(date, input) {
    const amount = toInteger(input);
    date = new Date(date);
    const desiredMonth = date.getUTCMonth() + amount;
    const dateWithDesiredMonth = /* @__PURE__ */ new Date(0);
    dateWithDesiredMonth.setUTCFullYear(date.getUTCFullYear(), desiredMonth, 1);
    dateWithDesiredMonth.setUTCHours(0, 0, 0, 0);
    const daysInMonth = monthLength(dateWithDesiredMonth.getUTCMonth() + 1, dateWithDesiredMonth.getUTCFullYear());
    date.setUTCMonth(desiredMonth, Math.min(daysInMonth, date.getUTCDate()));
    return date;
}
function addUTCWeeks(date, input) {
    const amount = toInteger(input);
    const days = amount * 7;
    return addUTCDays(date, days);
}
function addUTCDays(date, input) {
    return addUTCMilliseconds(date, toInteger(input) * DateAdapter.MILLISECONDS_IN_DAY);
}
function addUTCHours(date, input) {
    const amount = toInteger(input);
    return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_HOUR);
}
function addUTCMinutes(date, input) {
    const amount = toInteger(input);
    return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_MINUTE);
}
function addUTCSeconds(date, input) {
    const amount = toInteger(input);
    return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_SECOND);
}
function addUTCMilliseconds(date, input) {
    const amount = toInteger(input);
    const timestamp = date.getTime();
    return new Date(timestamp + amount);
}
function subUTCYears(date, amount) {
    return addUTCYears(date, -amount);
}
function subUTCMonths(date, amount) {
    return addUTCMonths(date, -amount);
}
function subUTCWeeks(date, amount) {
    return addUTCWeeks(date, -amount);
}
function subUTCDays(date, amount) {
    return addUTCDays(date, -amount);
}
function subUTCHours(date, amount) {
    return addUTCHours(date, -amount);
}
function subUTCMinutes(date, amount) {
    return addUTCMinutes(date, -amount);
}
function subUTCSeconds(date, amount) {
    return addUTCSeconds(date, -amount);
}
function subUTCMilliseconds(date, amount) {
    return addUTCMilliseconds(date, -amount);
}
function normalizeDateTimeTimezone(date, timezone) {
    if (date.timezone !== timezone) {
        return DateAdapterBase2.adapter.fromDateTime(date).set("timezone", timezone).toDateTime();
    }
    return date;
}
class RuleBase extends OccurrenceGenerator {
    constructor(recurrenceRules, config2, options2 = {}) {
        super(options2);
        this.recurrenceRules = recurrenceRules;
        this.options = cloneRuleOptions(config2);
        this.normOptions = normalizeRuleOptions(this.recurrenceRules, this.options);
        this.timezone = options2.timezone !== void 0 ? options2.timezone : this.normOptions.start.timezone;
        this.data = options2.data;
        this.hasDuration = !!config2.duration;
        if (this.hasDuration)
            this.duration = config2.duration;
        this.isInfinite = this.normOptions.end === void 0 && this.normOptions.count === void 0;
    }
    occurrences(args = {}) {
        return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
    }
    collections(args = {}) {
        return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
    }
    *_run(rawArgs = {}) {
        const args = this.normalizeRunArgs(rawArgs);
        const iterator = new RecurrenceRulesIterator(recurrenceRulesReducer(this.recurrenceRules), this.normOptions, args);
        let date = iterator.next().value;
        let index = 0;
        while (date && (args.take === void 0 || index < args.take)) {
            index++;
            date = date.add(this, "generator");
            const yieldArgs = yield this.normalizeRunOutput(date);
            if (yieldArgs === null || yieldArgs === void 0 ? void 0 : yieldArgs.skipToDate) {
                date = iterator.next(Object.assign(Object.assign({}, yieldArgs), {
                    skipToDate: normalizeDateTimeTimezone(yieldArgs.skipToDate, iterator.start.timezone)
                })).value;
            }
            else {
                date = iterator.next(yieldArgs).value;
            }
        }
        return void 0;
    }
}
let Rule$1 = class Rule extends RuleBase {
    /**
     * Create a new Rule object with the specified rule config and options.
     *
     * ### Options
     *
     * - **timezone**: the timezone that yielded occurrences should be in. Note,
     *   this does not change the rule config. Occurrences are first found using
     *   the unmodified rule config, and then converted to the timezone specified
     *   here before being yielded.
     * - **data**: arbitrary data you can associate with this rule. This
     *   is the only mutable property of `Rule` objects.
     *
     * ### Rule Config
     *
     * - #### frequency
     *
     *   The frequency rule part identifies the type of recurrence rule. Valid values
     *   include `"SECONDLY"`, `"MINUTELY"`, `"HOURLY"`, `"DAILY"`, `"WEEKLY"`,
     *   `"MONTHLY"`, or `"YEARLY"`.
     *
     * - #### start
     *
     *   The start of the rule (not necessarily the first occurrence).
     *   Either a `DateAdapter` instance, date object, or `DateTime` object.
     *   The type of date object depends on the `DateAdapter` class used for this
     *   `Rule`.
     *
     * - #### end?
     *
     *   The end of the rule (not necessarily the last occurrence).
     *   Either a `DateAdapter` instance, date object, or `DateTime` object.
     *   The type of date object depends on the `DateAdapter` class used for this
     *   `Rule`.
     *
     * - #### duration?
     *
     *   A length of time expressed in milliseconds.
     *
     * - #### interval?
     *
     *   The interval rule part contains a positive integer representing at
     *   which intervals the recurrence rule repeats. The default value is
     *   `1`, meaning every second for a SECONDLY rule, every minute for a
     *   MINUTELY rule, every hour for an HOURLY rule, every day for a
     *   DAILY rule, every week for a WEEKLY rule, every month for a
     *   MONTHLY rule, and every year for a YEARLY rule. For example,
     *   within a DAILY rule, a value of `8` means every eight days.
     *
     * - #### count?
     *
     *   The count rule part defines the number of occurrences at which to
     *   range-bound the recurrence. `count` and `end` are both two different
     *   ways of specifying how a recurrence completes.
     *
     * - #### weekStart?
     *
     *   The weekStart rule part specifies the day on which the workweek starts.
     *   Valid values are `"MO"`, `"TU"`, `"WE"`, `"TH"`, `"FR"`, `"SA"`, and `"SU"`.
     *   This is significant when a WEEKLY rule has an interval greater than 1,
     *   and a `byDayOfWeek` rule part is specified. The
     *   default value is `"MO"`.
     *
     * - #### bySecondOfMinute?
     *
     *   The bySecondOfMinute rule part expects an array of seconds
     *   within a minute. Valid values are 0 to 60.
     *
     * - #### byMinuteOfHour?
     *
     *   The byMinuteOfHour rule part expects an array of minutes within an hour.
     *   Valid values are 0 to 59.
     *
     * - #### byHourOfDay?
     *
     *   The byHourOfDay rule part expects an array of hours of the day.
     *   Valid values are 0 to 23.
     *
     * - #### byDayOfWeek?
     *
     *   *note: the byDayOfWeek rule part is kinda complex. Blame the ICAL spec.*
     *
     *   The byDayOfWeek rule part expects an array. Each array entry can
     *   be a day of the week (`"SU"`, `"MO"` , `"TU"`, `"WE"`, `"TH"`,
     *   `"FR"`, `"SA"`). If the rule's `frequency` is either MONTHLY or YEARLY,
     *   Any entry can also be a tuple where the first value of the tuple is a
     *   day of the week and the second value is an positive/negative integer
     *   (e.g. `["SU", 1]`). In this case, the number indicates the nth occurrence of
     *   the specified day within the MONTHLY or YEARLY rule.
     *
     *   The behavior of byDayOfWeek changes depending on the `frequency`
     *   of the rule.
     *
     *   Within a MONTHLY rule, `["MO", 1]` represents the first Monday
     *   within the month, whereas `["MO", -1]` represents the last Monday
     *   of the month.
     *
     *   Within a YEARLY rule, the numeric value in a byDayOfWeek tuple entry
     *   corresponds to an offset within the month when the byMonthOfYear rule part is
     *   present, and corresponds to an offset within the year otherwise.
     *
     *   Regardless of rule `frequency`, if a byDayOfWeek entry is a string
     *   (rather than a tuple), it means "all of these days" within the specified
     *   frequency (e.g. within a MONTHLY rule, `"MO"` represents all Mondays within
     *   the month).
     *
     * - #### byDayOfMonth?
     *
     *   The byDayOfMonth rule part expects an array of days
     *   of the month. Valid values are 1 to 31 or -31 to -1.
     *
     *   For example, -10 represents the tenth to the last day of the month.
     *   The byDayOfMonth rule part *must not* be specified when the rule's
     *   `frequency` is set to WEEKLY.
     *
     * - #### byMonthOfYear?
     *
     *   The byMonthOfYear rule part expects an array of months
     *   of the year. Valid values are 1 to 12.
     *
     */
    constructor(config2, options2 = {}) {
        super(Rule.recurrenceRules, config2, options2);
    }
    set(prop, value, tzoptions = {}) {
        let options2 = cloneRuleOptions(this.options);
        let timezone = this.timezone;
        if (prop === "timezone") {
            if (value === this.timezone && !tzoptions.keepLocalTime)
                return this;
            else if (tzoptions.keepLocalTime) {
                const json = this.normalizeDateInput(options2.start).toJSON();
                json.timezone = value;
                const adapter = this.dateAdapter.fromJSON(json);
                options2.start = options2.start instanceof this.dateAdapter ? adapter : options2.start instanceof DateTime$1 ? adapter.toDateTime() : adapter.date;
            }
            timezone = value;
        }
        else if (prop === "options") {
            options2 = value;
        }
        else {
            options2[prop] = value;
        }
        return new Rule(options2, {
            data: this.data,
            maxDuration: this.maxDuration,
            timezone
        });
    }
};
Rule$1.recurrenceRules = [];
class ScheduleBase extends OccurrenceGenerator {
    /**
     * Create a new Schedule object with the specified options.
     *
     * The order of precidence for rrules, rdates, exrules, and exdates is:
     *
     * 1. rrules are included
     * 2. exrules are excluded
     * 3. rdates are included
     * 4. exdates are excluded
     *
     */
    constructor(options2) {
        super(options2);
        this.data = options2.data;
    }
    occurrences(args = {}) {
        return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
    }
    collections(args = {}) {
        return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
    }
    *_run(args = {}) {
        const count = args.take;
        delete args.take;
        const iterator = this.occurrenceStream._run(args);
        let date = iterator.next().value;
        let index = 0;
        while (date && (count === void 0 || count > index)) {
            date = date.add(this, "generator");
            const yieldArgs = yield this.normalizeRunOutput(date);
            date = iterator.next(yieldArgs).value;
            index++;
        }
        return void 0;
    }
}
function subtract(...streams) {
    return (options2) => new SubtractOperator(streams, options2);
}
class SubtractOperator extends Operator {
    /** Not actually used but necessary for IRunnable interface */
    set(_, value) {
        return new SubtractOperator(this.streams.map((stream) => stream.set("timezone", value)), Object.assign(Object.assign({}, this.config), {
            base: this.config.base && this.config.base.set("timezone", value),
            timezone: value
        }));
    }
    *_run(args = {}) {
        if (!this.config.base)
            return;
        const inclusion = new IterableWrapper(this.config.base, args);
        const exclusion = new IterableWrapper(new AddOperator(this.streams, {
            timezone: this.config.timezone
        }), args);
        cycleStreams(inclusion, exclusion, args);
        while (!inclusion.done) {
            const yieldArgs = yield this.normalizeRunOutput(inclusion.value);
            if (!(yieldArgs && yieldArgs.skipToDate)) {
                inclusion.next();
            }
            cycleStreams(inclusion, exclusion, args, yieldArgs);
        }
    }
    calculateIsInfinite() {
        return !!(this.config.base && this.config.base.isInfinite);
    }
    calculateHasDuration() {
        return !!(this.config.base && this.config.base.hasDuration);
    }
}
function cycleStreams(inclusion, exclusion, options2 = {}, yieldArgs = {}) {
    processYieldArgs([inclusion, exclusion], options2, yieldArgs);
    iterateExclusion(inclusion, exclusion, options2);
    while (!inclusion.done && !exclusion.done && inclusion.value.isEqual(exclusion.value)) {
        inclusion.next();
        iterateExclusion(inclusion, exclusion, options2);
    }
}
function iterateExclusion(inclusion, exclusion, options2 = {}) {
    if (options2.reverse) {
        while (!exclusion.done && !inclusion.done && exclusion.value.isAfter(inclusion.value)) {
            exclusion.next();
        }
        return;
    }
    while (!exclusion.done && !inclusion.done && exclusion.value.isBefore(inclusion.value)) {
        exclusion.next();
    }
}
function unique() {
    return (options2) => new UniqueOperator([], options2);
}
class UniqueOperator extends Operator {
    /** Not actually used but necessary for IRunnable interface */
    set(_, value) {
        return new UniqueOperator([], Object.assign(Object.assign({}, this.config), {
            base: this.config.base && this.config.base.set("timezone", value),
            timezone: value
        }));
    }
    *_run(args = {}) {
        if (!this.config.base)
            return;
        const stream = new IterableWrapper(this.config.base, args);
        while (!stream.done) {
            const yieldArgs = yield this.normalizeRunOutput(stream.value);
            const lastValue = stream.value;
            stream.next(yieldArgs);
            while (!(yieldArgs && yieldArgs.skipToDate) && !stream.done && stream.value.isEqual(lastValue)) {
                stream.next();
            }
        }
    }
    calculateIsInfinite() {
        return !!(this.config.base && this.config.base.isInfinite);
    }
    calculateHasDuration() {
        return !!(this.config.base && this.config.base.hasDuration);
    }
}
class Schedule extends ScheduleBase {
    /**
     * Create a new Schedule object with the specified options.
     *
     * The order of precidence for rrules, rdates, exrules, and exdates is:
     *
     * 1. rrules are included
     * 2. exrules are excluded
     * 3. rdates are included
     * 4. exdates are excluded
     *
     * ### Options
     *
     * - **timezone**: The timezone that yielded occurrences should be *displayed* in.
     *   Note, this one affects the *displayed* timezone of yielded occurrences.
     *   For rules, occurrences are first found using the unmodified rule
     *   config (including whatever timezone the `start` datetime is defined
     *   in), and then converted to the timezone specified here before being
     *   yielded. By default, the timezone is *local* time (`null`). So if you don't
     *   want your rules to be displayed in local time, you must supply a
     *   timezone argument.
     * - **data**: arbitrary data you can associate with this Schedule. This
     *   is the only mutable property of `Schedule` objects.
     * - **maxDuration**: currently unused.
     * - **rrules**: rules specifying when occurrences happen. See the "Rule Config"
     *   section below.
     * - **rdates**: individual dates that should be _included_ in the schedule.
     * - **exdates**: individual dates that should be _excluded_ from the schedule.
     * - **exrules**: rules specifying when occurrences shouldn't happen. See the
     *   "Rule Config" section below.
     *
     * ### Rule Config
     *
     * - #### frequency
     *
     *   The frequency rule part identifies the type of recurrence rule. Valid values
     *   include `"SECONDLY"`, `"MINUTELY"`, `"HOURLY"`, `"DAILY"`, `"WEEKLY"`,
     *   `"MONTHLY"`, or `"YEARLY"`.
     *
     * - #### start
     *
     *   The start of the rule (not necessarily the first occurrence).
     *   Either a `DateAdapter` instance, date object, or `DateTime` object.
     *   The type of date object depends on the `DateAdapter` class used for this
     *   `Rule`.
     *
     * - #### end?
     *
     *   The end of the rule (not necessarily the last occurrence).
     *   Either a `DateAdapter` instance, date object, or `DateTime` object.
     *   The type of date object depends on the `DateAdapter` class used for this
     *   `Rule`.
     *
     * - #### duration?
     *
     *   A length of time expressed in milliseconds.
     *
     * - #### interval?
     *
     *   The interval rule part contains a positive integer representing at
     *   which intervals the recurrence rule repeats. The default value is
     *   `1`, meaning every second for a SECONDLY rule, every minute for a
     *   MINUTELY rule, every hour for an HOURLY rule, every day for a
     *   DAILY rule, every week for a WEEKLY rule, every month for a
     *   MONTHLY rule, and every year for a YEARLY rule. For example,
     *   within a DAILY rule, a value of `8` means every eight days.
     *
     * - #### count?
     *
     *   The count rule part defines the number of occurrences at which to
     *   range-bound the recurrence. `count` and `end` are both two different
     *   ways of specifying how a recurrence completes.
     *
     * - #### weekStart?
     *
     *   The weekStart rule part specifies the day on which the workweek starts.
     *   Valid values are `"MO"`, `"TU"`, `"WE"`, `"TH"`, `"FR"`, `"SA"`, and `"SU"`.
     *   This is significant when a WEEKLY rule has an interval greater than 1,
     *   and a `byDayOfWeek` rule part is specified. The
     *   default value is `"MO"`.
     *
     * - #### bySecondOfMinute?
     *
     *   The bySecondOfMinute rule part expects an array of seconds
     *   within a minute. Valid values are 0 to 60.
     *
     * - #### byMinuteOfHour?
     *
     *   The byMinuteOfHour rule part expects an array of minutes within an hour.
     *   Valid values are 0 to 59.
     *
     * - #### byHourOfDay?
     *
     *   The byHourOfDay rule part expects an array of hours of the day.
     *   Valid values are 0 to 23.
     *
     * - #### byDayOfWeek?
     *
     *   *note: the byDayOfWeek rule part is kinda complex. Blame the ICAL spec.*
     *
     *   The byDayOfWeek rule part expects an array. Each array entry can
     *   be a day of the week (`"SU"`, `"MO"` , `"TU"`, `"WE"`, `"TH"`,
     *   `"FR"`, `"SA"`). If the rule's `frequency` is either MONTHLY or YEARLY,
     *   Any entry can also be a tuple where the first value of the tuple is a
     *   day of the week and the second value is an positive/negative integer
     *   (e.g. `["SU", 1]`). In this case, the number indicates the nth occurrence of
     *   the specified day within the MONTHLY or YEARLY rule.
     *
     *   The behavior of byDayOfWeek changes depending on the `frequency`
     *   of the rule.
     *
     *   Within a MONTHLY rule, `["MO", 1]` represents the first Monday
     *   within the month, whereas `["MO", -1]` represents the last Monday
     *   of the month.
     *
     *   Within a YEARLY rule, the numeric value in a byDayOfWeek tuple entry
     *   corresponds to an offset within the month when the byMonthOfYear rule part is
     *   present, and corresponds to an offset within the year otherwise.
     *
     *   Regardless of rule `frequency`, if a byDayOfWeek entry is a string
     *   (rather than a tuple), it means "all of these days" within the specified
     *   frequency (e.g. within a MONTHLY rule, `"MO"` represents all Mondays within
     *   the month).
     *
     * - #### byDayOfMonth?
     *
     *   The byDayOfMonth rule part expects an array of days
     *   of the month. Valid values are 1 to 31 or -31 to -1.
     *
     *   For example, -10 represents the tenth to the last day of the month.
     *   The byDayOfMonth rule part *must not* be specified when the rule's
     *   `frequency` is set to WEEKLY.
     *
     * - #### byMonthOfYear?
     *
     *   The byMonthOfYear rule part expects an array of months
     *   of the year. Valid values are 1 to 12.
     *
     */
    constructor(options2 = {}) {
        super(options2);
        this.rrules = [];
        this.exrules = [];
        for (const prop of ["rrules", "exrules"]) {
            const arg = options2[prop];
            if (arg) {
                this[prop] = arg.map((ruleArgs) => {
                    if (ruleArgs instanceof Rule$1) {
                        return ruleArgs.set("timezone", this.timezone);
                    }
                    else {
                        return new Rule$1(ruleArgs, {
                            timezone: this.timezone
                        });
                    }
                });
            }
        }
        for (const prop of ["rdates", "exdates"]) {
            const arg = options2[prop];
            if (arg) {
                this[prop] = arg instanceof Dates ? arg.set("timezone", this.timezone) : new Dates({
                    dates: arg,
                    timezone: this.timezone
                });
            }
            else {
                this[prop] = new Dates({
                    timezone: this.timezone
                });
            }
        }
        this.hasDuration = this.rrules.every((rule) => rule.hasDuration) && this.exrules.every((rule) => rule.hasDuration) && this.rdates.hasDuration && this.exdates.hasDuration;
        this.isInfinite = this.rrules.some((rule) => rule.isInfinite);
        this.occurrenceStream = [
            add(...this.rrules),
            subtract(...this.exrules),
            add(this.rdates),
            subtract(this.exdates),
            unique()
        ].reduce((prev, curr) => curr({ base: prev, timezone: this.timezone }), void 0);
    }
    add(prop, value) {
        const rrules = this.rrules.slice();
        const exrules = this.exrules.slice();
        let rdates = this.rdates;
        let exdates = this.exdates;
        switch (prop) {
            case "rrule":
                rrules.push(value);
                break;
            case "exrule":
                exrules.push(value);
                break;
            case "rdate":
                rdates = this.rdates.add(value);
                break;
            case "exdate":
                exdates = this.exdates.add(value);
                break;
        }
        return new Schedule({
            timezone: this.timezone,
            data: this.data,
            rrules,
            exrules,
            rdates,
            exdates
        });
    }
    remove(prop, value) {
        let rrules = this.rrules;
        let exrules = this.exrules;
        let rdates = this.rdates;
        let exdates = this.exdates;
        switch (prop) {
            case "rrule":
                rrules = rrules.filter((rule) => rule !== value);
                break;
            case "exrule":
                exrules = exrules.filter((rule) => rule !== value);
                break;
            case "rdate":
                rdates = this.rdates.remove(value);
                break;
            case "exdate":
                exdates = this.exdates.remove(value);
                break;
        }
        return new Schedule({
            timezone: this.timezone,
            data: this.data,
            rrules,
            exrules,
            rdates,
            exdates
        });
    }
    set(prop, value, options2 = {}) {
        let timezone = this.timezone;
        let rrules = this.rrules;
        let exrules = this.exrules;
        let rdates = this.rdates;
        let exdates = this.exdates;
        switch (prop) {
            case "timezone":
                if (value === this.timezone && !options2.keepLocalTime)
                    return this;
                else if (options2.keepLocalTime) {
                    rrules = rrules.map((rule) => rule.set("timezone", value, options2));
                    exrules = exrules.map((rule) => rule.set("timezone", value, options2));
                    rdates = rdates.set("timezone", value, options2);
                    exdates = exdates.set("timezone", value, options2);
                }
                timezone = value;
                break;
            case "rrules":
                rrules = value;
                break;
            case "exrules":
                exrules = value;
                break;
            case "rdates":
                rdates = value;
                break;
            case "exdates":
                exdates = value;
                break;
        }
        return new Schedule({
            timezone,
            data: this.data,
            rrules,
            exrules,
            rdates,
            exdates
        });
    }
}
class RecurrenceRule {
    constructor(processor) {
        this.processor = processor;
        this.start = processor.start;
        this.end = processor.end;
        this.options = processor.options;
    }
}
class FrequencyRule extends RecurrenceRule {
    constructor(processor, initDate) {
        super(processor);
        this.initDate = initDate;
        this.intervalUnit = freqToGranularity(this.options.frequency);
        this.firstIntervalStartDate = this.normalizedStartDate(this.options.start);
        this.intervalStartDate = this.firstIntervalStartDate;
        this.intervalEndDate = this.normalizedEndDate(this.firstIntervalStartDate);
        this.skipToInterval(this.initDate);
    }
    run(date) {
        return this.validateDate(new ValidDateTime(date));
    }
    validateDate(arg) {
        const { date } = arg;
        if (arg instanceof ValidDateTime && this.dateIsWithinInterval(date)) {
            return arg;
        }
        this.skipToInterval(date);
        return new InvalidDateTime(
        // if the interval is 1, date will always be within the interval
        this.dateIsWithinInterval(date) ? date : this.setToCurrentInterval());
    }
    setToCurrentInterval() {
        return this.intervalStartDate;
    }
    normalizedStartDate(date) {
        if (this.options.frequency === "WEEKLY") {
            return date.granularity("week", { weekStart: this.options.weekStart });
        }
        return date.granularity(this.intervalUnit);
    }
    normalizedEndDate(start) {
        switch (this.options.frequency) {
            case "YEARLY":
                return start.add(1, "year");
            case "MONTHLY":
                return start.add(1, "month");
            case "WEEKLY":
                return start.add(1, "week");
            case "DAILY":
                return start.add(1, "day");
            case "HOURLY":
                return start.add(1, "hour");
            case "MINUTELY":
                return start.add(1, "minute");
            case "SECONDLY":
                return start.add(1, "second");
            case "MILLISECONDLY":
                return start.add(1, "millisecond");
            default:
                throw new Error(`Unknown frequency ${this.options.frequency}`);
        }
    }
    skipToInterval(date) {
        const amount = this.intervalDifference(date);
        this.intervalStartDate = this.firstIntervalStartDate.add(amount, this.intervalUnit);
        this.intervalEndDate = this.normalizedEndDate(this.intervalStartDate);
    }
    dateIsWithinInterval(date) {
        return this.intervalStartDate.isBeforeOrEqual(date) && this.intervalEndDate.isAfter(date);
    }
    intervalDifference(date) {
        return intervalDifferenceBetweenDates({
            first: this.firstIntervalStartDate,
            second: date,
            unit: this.intervalUnit,
            interval: this.options.interval,
            weekStart: this.options.weekStart,
            direction: "after"
        });
    }
}
function intervalDifferenceBetweenDates({ first: first2, second, unit, interval, weekStart, direction }) {
    let difference = (() => {
        let intervalDuration;
        let months;
        switch (unit) {
            case "year":
                months = (second.get("year") - first2.get("year")) * 12;
                months = months + second.get("month") - first2.get("month");
                return Math.floor(months / 12);
            case "month":
                months = (second.get("year") - first2.get("year")) * 12;
                months = months + second.get("month") - first2.get("month");
                return months;
            case "week":
                first2 = first2.granularity("week", { weekStart });
                intervalDuration = DateAdapter$1.MILLISECONDS_IN_WEEK;
                break;
            case "day":
                intervalDuration = DateAdapter$1.MILLISECONDS_IN_DAY;
                break;
            case "hour":
                intervalDuration = DateAdapter$1.MILLISECONDS_IN_HOUR;
                break;
            case "minute":
                intervalDuration = DateAdapter$1.MILLISECONDS_IN_MINUTE;
                break;
            case "second":
                intervalDuration = DateAdapter$1.MILLISECONDS_IN_SECOND;
                break;
            case "millisecond":
                intervalDuration = 1;
                break;
            default:
                throw new Error("Unexpected `unit` value");
        }
        const diff2 = second.valueOf() - first2.valueOf();
        return Math.floor(diff2 / intervalDuration);
    })();
    const fn = direction === "after" ? Math.ceil : Math.floor;
    difference = fn(difference / interval) * interval;
    return difference;
}
class RevFrequencyRule extends FrequencyRule {
    setToCurrentInterval() {
        return this.intervalEndDate.subtract(1, "millisecond");
    }
    intervalDifference(date) {
        return intervalDifferenceBetweenDates({
            first: this.firstIntervalStartDate,
            second: date,
            unit: this.intervalUnit,
            interval: this.options.interval,
            weekStart: this.options.weekStart,
            direction: "before"
        });
    }
}
const FREQUENCIES = [
    "MILLISECONDLY",
    "SECONDLY",
    "MINUTELY",
    "HOURLY",
    "DAILY",
    "WEEKLY",
    "MONTHLY",
    "YEARLY"
];
const FrequencyRuleModule = {
    name: "FrequencyRule",
    get: (processor) => {
        if (processor.options.byMillisecondOfSecond !== void 0 || processor.options.frequency !== "MILLISECONDLY") {
            return null;
        }
        if (processor.reverse)
            return new RevFrequencyRule(processor, processor.end);
        return new FrequencyRule(processor, processor.start);
    },
    normalizeOptions: (options2, norm) => {
        if (!FREQUENCIES.includes(options2.frequency)) {
            throw new RuleOptionError(`"frequency" must be one of ${JSON.stringify(FREQUENCIES)}`);
        }
        if (options2.interval !== void 0) {
            if (!Number.isInteger(options2.interval)) {
                throw new RuleOptionError('"interval" expects a whole number');
            }
            if (options2.interval < 1) {
                throw new RuleOptionError('"interval" cannot be less than 1');
            }
        }
        if (options2.weekStart !== void 0) {
            if (!DateAdapter$1.WEEKDAYS.includes(options2.weekStart)) {
                throw new RuleOptionError(`"weekStart" must be one of ${JSON.stringify(DateAdapter$1.WEEKDAYS)}`);
            }
        }
        norm.frequency = options2.frequency;
        norm.interval = options2.interval || 1;
        norm.weekStart = options2.weekStart || "MO";
    },
    deps: () => [FrequencyRuleModule]
};
function ruleOptionFilled(option) {
    return Array.isArray(option) && option.length > 0;
}
const freqCache = /* @__PURE__ */ new WeakMap();
class RecurrenceRuleBase extends RecurrenceRule {
    constructor(processor) {
        super(processor);
        if (!freqCache.has(this.processor)) {
            freqCache.set(this.processor, new FrequencyRule(processor, processor.start));
        }
        this.frequency = freqCache.get(this.processor);
    }
    validateDate(arg) {
        return this.frequency.validateDate(arg);
    }
}
class RevRecurrenceRuleBase extends RecurrenceRule {
    constructor(processor) {
        super(processor);
        if (!freqCache.has(this.processor)) {
            freqCache.set(this.processor, new RevFrequencyRule(processor, processor.end));
        }
        this.frequency = freqCache.get(this.processor);
    }
    validateDate(arg) {
        return this.frequency.validateDate(arg);
    }
}
class RevByTimeOfUnitRule extends RevRecurrenceRuleBase {
    run(date) {
        const currentTime = date.get(this.granularity);
        for (const time of this.option) {
            if (currentTime < time)
                continue;
            if (currentTime === time) {
                return this.validateDate(new ValidDateTime(date));
            }
            return this.validateDate(new InvalidDateTime(date.endGranularity(this.baseGranularity).set(this.granularity, time)));
        }
        return this.validateDate(new InvalidDateTime(date.endGranularity(this.baseGranularity).subtract(1, this.baseGranularity).set(this.granularity, this.option[0])));
    }
}
class RevByMillisecondOfSecondRule extends RevByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "second";
        this.granularity = "millisecond";
        this.option = this.options.byMillisecondOfSecond.slice().reverse();
    }
}
class ByTimeOfUnitRule extends RecurrenceRuleBase {
    run(date) {
        const currentTime = date.get(this.granularity);
        for (const time of this.option) {
            if (currentTime > time)
                continue;
            if (currentTime === time) {
                return this.validateDate(new ValidDateTime(date));
            }
            return this.validateDate(new InvalidDateTime(date.granularity(this.baseGranularity).set(this.granularity, time)));
        }
        return this.validateDate(new InvalidDateTime(date.granularity(this.baseGranularity).add(1, this.baseGranularity).set(this.granularity, this.option[0])));
    }
}
class ByMillisecondOfSecondRule extends ByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "second";
        this.granularity = "millisecond";
        this.option = this.options.byMillisecondOfSecond;
    }
}
const ByMillisecondOfSecondRuleModule = {
    name: "ByMillisecondOfSecond",
    get: (processor) => {
        if (processor.options.byMillisecondOfSecond === void 0)
            return null;
        if (processor.reverse)
            return new RevByMillisecondOfSecondRule(processor);
        return new ByMillisecondOfSecondRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.byMillisecondOfSecond !== void 0) {
            if (!ruleOptionFilled(options2.byMillisecondOfSecond)) {
                throw new RuleOptionError('"byMillisecondOfSecond" expects a non-empty array');
            }
            if (options2.byMillisecondOfSecond.some((num2) => num2 < 0 || num2 > 999)) {
                throw new RuleOptionError('"byMillisecondOfSecond" values must be >= 0 && <= 999');
            }
            norm.byMillisecondOfSecond = options2.byMillisecondOfSecond;
            norm.byMillisecondOfSecond.sort(numberSortComparer);
        }
        else if (options2.frequency !== "MILLISECONDLY") {
            norm.byMillisecondOfSecond = [norm.start.get("millisecond")];
        }
    },
    deps: () => [FrequencyRuleModule, ByMillisecondOfSecondRuleModule]
};
class RevBySecondOfMinuteRule extends RevByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "minute";
        this.granularity = "second";
        this.option = this.options.bySecondOfMinute.slice().reverse();
    }
}
class BySecondOfMinuteRule extends ByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "minute";
        this.granularity = "second";
        this.option = this.options.bySecondOfMinute;
    }
}
const BySecondOfMinuteRuleModule = {
    name: "BySecondOfMinute",
    get: (processor) => {
        if (processor.options.bySecondOfMinute === void 0)
            return null;
        if (processor.reverse)
            return new RevBySecondOfMinuteRule(processor);
        return new BySecondOfMinuteRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.bySecondOfMinute !== void 0) {
            if (!ruleOptionFilled(options2.bySecondOfMinute)) {
                throw new RuleOptionError('"bySecondOfMinute" expects a non-empty array');
            }
            if (options2.bySecondOfMinute.some((num2) => num2 < 0 || num2 > 60)) {
                throw new RuleOptionError('"bySecondOfMinute" values must be >= 0 && <= 60');
            }
            norm.bySecondOfMinute = options2.bySecondOfMinute;
            norm.bySecondOfMinute.sort(numberSortComparer);
        }
        else if (!["SECONDLY", "MILLISECONDLY"].includes(options2.frequency)) {
            norm.bySecondOfMinute = [norm.start.get("second")];
        }
    },
    deps: () => [FrequencyRuleModule, BySecondOfMinuteRuleModule, ByMillisecondOfSecondRuleModule]
};
class RevByMinuteOfHourRule extends RevByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "hour";
        this.granularity = "minute";
        this.option = this.options.byMinuteOfHour.slice().reverse();
    }
}
class ByMinuteOfHourRule extends ByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "hour";
        this.granularity = "minute";
        this.option = this.options.byMinuteOfHour;
    }
}
const ByMinuteOfHourRuleModule = {
    name: "ByMinuteOfHour",
    get: (processor) => {
        if (processor.options.byMinuteOfHour === void 0)
            return null;
        if (processor.reverse)
            return new RevByMinuteOfHourRule(processor);
        return new ByMinuteOfHourRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.byMinuteOfHour !== void 0) {
            if (!ruleOptionFilled(options2.byMinuteOfHour)) {
                throw new RuleOptionError('"byMinuteOfHour" expects a non-empty array');
            }
            if (options2.byMinuteOfHour.some((num2) => num2 < 0 || num2 > 59)) {
                throw new RuleOptionError('"byMinuteOfHour" values must be >= 0 && <= 59');
            }
            norm.byMinuteOfHour = options2.byMinuteOfHour;
            norm.byMinuteOfHour.sort(numberSortComparer);
        }
        else if (!["MINUTELY", "SECONDLY", "MILLISECONDLY"].includes(options2.frequency)) {
            norm.byMinuteOfHour = [norm.start.get("minute")];
        }
    },
    deps: () => [
        FrequencyRuleModule,
        ByMinuteOfHourRuleModule,
        BySecondOfMinuteRuleModule,
        ByMillisecondOfSecondRuleModule
    ]
};
class RevByHourOfDayRule extends RevByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "day";
        this.granularity = "hour";
        this.option = this.options.byHourOfDay.slice().reverse();
    }
}
class ByHourOfDayRule extends ByTimeOfUnitRule {
    constructor() {
        super(...arguments);
        this.baseGranularity = "day";
        this.granularity = "hour";
        this.option = this.options.byHourOfDay;
    }
}
const ByHourOfDayRuleModule = {
    name: "ByHourOfDay",
    get: (processor) => {
        if (processor.options.byHourOfDay === void 0)
            return null;
        if (processor.reverse)
            return new RevByHourOfDayRule(processor);
        return new ByHourOfDayRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.byHourOfDay !== void 0) {
            if (!ruleOptionFilled(options2.byHourOfDay)) {
                throw new RuleOptionError('"byHourOfDay" expects a non-empty array');
            }
            if (options2.byHourOfDay.some((num2) => num2 < 0 || num2 > 23)) {
                throw new RuleOptionError('"byHourOfDay" values must be >= 0 && <= 23');
            }
            norm.byHourOfDay = options2.byHourOfDay;
            norm.byHourOfDay.sort(numberSortComparer);
        }
        else if (["YEARLY", "MONTHLY", "WEEKLY", "DAILY"].includes(options2.frequency)) {
            norm.byHourOfDay = [norm.start.get("hour")];
        }
    },
    deps: () => [
        FrequencyRuleModule,
        ByHourOfDayRuleModule,
        ByMinuteOfHourRuleModule,
        BySecondOfMinuteRuleModule,
        ByMillisecondOfSecondRuleModule
    ]
};
function getNextWeekday(date, weekday) {
    return date.add(getDifferenceBetweenWeekdays(date.get("weekday"), weekday), "day");
}
function getNthWeekdayOfMonth(date, weekday, nth) {
    let base = date.set("day", 1);
    if (nth < 0) {
        base = base.add(1, "month");
    }
    base = getNextWeekday(base, weekday);
    return nth < 0 ? base.add(nth, "week") : base.add(nth - 1, "week");
}
class ByDayOfMonthRule extends RecurrenceRuleBase {
    run(date) {
        const normalizedByDayOfMonth = normalizeByDayOfMonth(date, this.options.byDayOfMonth, this.options.byDayOfWeek);
        const currentDay2 = date.get("day");
        for (const day of normalizedByDayOfMonth) {
            if (currentDay2 > day)
                continue;
            if (currentDay2 === day) {
                return this.validateDate(new ValidDateTime(date));
            }
            return this.validateDate(new InvalidDateTime(date.granularity("month").set("day", day)));
        }
        let next;
        let nextMonth2 = date;
        let index = 0;
        while (!next && index < 30) {
            nextMonth2 = nextMonth2.granularity("month").add(1, "month");
            next = normalizeByDayOfMonth(nextMonth2, this.options.byDayOfMonth, this.options.byDayOfWeek)[0];
            index++;
        }
        if (index >= 13) {
            throw new RecurrenceRuleError("byDayOfMonth Infinite while loop");
        }
        return this.validateDate(new InvalidDateTime(nextMonth2.set("day", next)));
    }
}
function normalizeByDayOfMonth(date, byDayOfMonth, byDayOfWeek) {
    const lengthOfMonth = date.endGranularity("month").get("day");
    let normalizedByDayOfMonth = byDayOfMonth.filter((day) => lengthOfMonth >= Math.abs(day)).map((day) => day > 0 ? day : lengthOfMonth + day + 1);
    if (byDayOfWeek) {
        const base = date.granularity("month");
        const filteredByDayOfMonth = [];
        byDayOfWeek.forEach((entry) => {
            if (typeof entry === "string") {
                filteredByDayOfMonth.push(...normalizedByDayOfMonth.filter((day) => base.set("day", day).get("weekday") === entry));
                return;
            }
            const nthWeekdayOfMonth = getNthWeekdayOfMonth(date, ...entry).get("day");
            if (normalizedByDayOfMonth.includes(nthWeekdayOfMonth)) {
                filteredByDayOfMonth.push(nthWeekdayOfMonth);
            }
        });
        normalizedByDayOfMonth = Array.from(new Set(filteredByDayOfMonth));
    }
    return normalizedByDayOfMonth.sort((a, b) => {
        if (a > b)
            return 1;
        if (a < b)
            return -1;
        else
            return 0;
    });
}
class RevByDayOfMonthRule extends RevRecurrenceRuleBase {
    run(date) {
        const normalizedByDayOfMonth = normalizeByDayOfMonth(date, this.options.byDayOfMonth, this.options.byDayOfWeek).reverse();
        const currentDay2 = date.get("day");
        for (const day of normalizedByDayOfMonth) {
            if (currentDay2 < day)
                continue;
            if (currentDay2 === day) {
                return this.validateDate(new ValidDateTime(date));
            }
            return this.validateDate(new InvalidDateTime(date.endGranularity("month").set("day", day)));
        }
        let next;
        let nextMonth2 = date;
        let index = 0;
        while (!next && index < 30) {
            nextMonth2 = nextMonth2.endGranularity("month").subtract(1, "month");
            next = normalizeByDayOfMonth(nextMonth2, this.options.byDayOfMonth, this.options.byDayOfWeek).pop();
            index++;
        }
        if (index >= 13) {
            throw new RecurrenceRuleError("byDayOfMonth Infinite while loop");
        }
        return this.validateDate(new InvalidDateTime(nextMonth2.set("day", next)));
    }
}
const ByDayOfMonthRuleModule = {
    name: "ByDayOfMonth",
    get: (processor) => {
        if (processor.options.byDayOfMonth === void 0)
            return null;
        if (processor.reverse)
            return new RevByDayOfMonthRule(processor);
        return new ByDayOfMonthRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.byDayOfMonth !== void 0) {
            if (options2.frequency === "WEEKLY") {
                throw new RuleOptionError('when "frequency" is "WEEKLY", "byDayOfMonth" cannot be present');
            }
            if (!ruleOptionFilled(options2.byDayOfMonth)) {
                throw new RuleOptionError('"byDayOfMonth" expects a non-empty array');
            }
            if (options2.byDayOfMonth.some((num2) => num2 === 0 || num2 < -31 || num2 > 31)) {
                throw new RuleOptionError('"byDayOfMonth" values must be `num !== 0 && num <= 31 && num >= -31`');
            }
            norm.byDayOfMonth = options2.byDayOfMonth.slice();
        }
        else if (!(ruleOptionFilled(options2.byDayOfWeek) || ruleOptionFilled(options2.byDayOfYear)) && ["YEARLY", "MONTHLY"].includes(options2.frequency)) {
            norm.byDayOfMonth = [norm.start.get("day")];
        }
    },
    deps: () => [
        FrequencyRuleModule,
        ByDayOfMonthRuleModule,
        ByHourOfDayRuleModule,
        ByMinuteOfHourRuleModule,
        BySecondOfMinuteRuleModule,
        ByMillisecondOfSecondRuleModule
    ]
};
function getNthWeekdayOfYear(date, weekday, nth) {
    let base = date.set("month", 1).set("day", 1);
    if (nth < 0) {
        base = base.add(1, "year");
    }
    base = getNextWeekday(base, weekday);
    return nth < 0 ? base.add(nth, "week") : base.add(nth - 1, "week");
}
function getPreviousWeekday(date, weekday) {
    const diff2 = getDifferenceBetweenWeekdays(date.get("weekday"), weekday);
    return date.subtract(diff2 === 0 ? 0 : 7 - diff2, "day");
}
class RevByDayOfWeekRule extends RevRecurrenceRuleBase {
    run(date) {
        if (this.options.frequency === "YEARLY") {
            return this.options.byMonthOfYear === void 0 ? this.expandYearly(date) : this.expandMonthly(date);
        }
        else if (this.options.frequency === "MONTHLY") {
            return this.expandMonthly(date);
        }
        return this.expand(date);
    }
    expandYearly(date) {
        let next = getPrevWeekdaysOfYear(date, this.options.byDayOfWeek)[0];
        let index = 0;
        let base = date;
        while (!next && index < 28) {
            index++;
            base = base.granularity("year").subtract(1, "millisecond");
            next = getPrevWeekdaysOfYear(base, this.options.byDayOfWeek)[0];
        }
        if (!next) {
            throw new RecurrenceRuleError("The byDayOfWeek rule appears to contain an impossible combination");
        }
        return this.result(date, next);
    }
    expandMonthly(date) {
        let next = getPrevWeekdaysOfMonth(date, this.options.byDayOfWeek)[0];
        let index = 0;
        let base = date;
        while (!next && index < 50) {
            index++;
            base = base.granularity("month").subtract(1, "millisecond");
            next = getPrevWeekdaysOfMonth(base, this.options.byDayOfWeek)[0];
        }
        if (!next) {
            throw new RecurrenceRuleError("The byDayOfWeek rule appears to contain an impossible combination");
        }
        return this.result(date, next);
    }
    expand(date) {
        const next = this.options.byDayOfWeek.map((weekday) => getPreviousWeekday(date, weekday)).sort(dateTimeSortComparer).pop();
        return this.result(date, next);
    }
    result(date, next) {
        if (next.isEqual(date)) {
            return this.validateDate(new ValidDateTime(date));
        }
        return this.validateDate(new InvalidDateTime(next.endGranularity("day")));
    }
}
function getPrevWeekdaysOfYear(date, byDayOfWeek) {
    const normalizedNthWeekdaysOfYear = byDayOfWeek.filter((entry) => Array.isArray(entry)).map((entry) => getNthWeekdayOfYear(date, ...entry));
    const normalizedNextWeekdays = byDayOfWeek.filter((entry) => typeof entry === "string").map((weekday) => getPreviousWeekday(date, weekday)).filter((entry) => entry.get("year") === date.get("year"));
    return uniqDateTimes([...normalizedNthWeekdaysOfYear, ...normalizedNextWeekdays]).filter((entry) => entry.isBeforeOrEqual(date)).sort(dateTimeSortComparer).reverse();
}
function getPrevWeekdaysOfMonth(date, byDayOfWeek) {
    const normalizedNthWeekdaysOfMonth = byDayOfWeek.filter((entry) => Array.isArray(entry)).map((entry) => getNthWeekdayOfMonth(date, ...entry));
    const normalizedNextWeekdays = byDayOfWeek.filter((entry) => typeof entry === "string").map((weekday) => getPreviousWeekday(date, weekday)).filter((entry) => entry.get("year") === date.get("year") && entry.get("month") === date.get("month"));
    return uniqDateTimes([...normalizedNthWeekdaysOfMonth, ...normalizedNextWeekdays]).filter((entry) => entry.isBeforeOrEqual(date)).sort(dateTimeSortComparer).reverse();
}
class ByDayOfWeekRule extends RecurrenceRuleBase {
    run(date) {
        if (this.options.frequency === "YEARLY") {
            return this.options.byMonthOfYear === void 0 ? this.expandYearly(date) : this.expandMonthly(date);
        }
        else if (this.options.frequency === "MONTHLY") {
            return this.expandMonthly(date);
        }
        return this.expand(date);
    }
    expandYearly(date) {
        let next = getNextWeekdaysOfYear(date, this.options.byDayOfWeek)[0];
        let index = 0;
        let base = date;
        while (!next && index < 28) {
            index++;
            base = base.granularity("year").add(1, "year");
            next = getNextWeekdaysOfYear(base, this.options.byDayOfWeek)[0];
        }
        if (!next) {
            throw new RecurrenceRuleError("The byDayOfWeek rule appears to contain an impossible combination");
        }
        return this.result(date, next);
    }
    expandMonthly(date) {
        let next = getNextWeekdaysOfMonth(date, this.options.byDayOfWeek)[0];
        let index = 0;
        let base = date;
        while (!next && index < 50) {
            index++;
            base = base.granularity("month").add(1, "month");
            next = getNextWeekdaysOfMonth(base, this.options.byDayOfWeek)[0];
        }
        if (!next) {
            throw new RecurrenceRuleError("The byDayOfWeek rule appears to contain an impossible combination");
        }
        return this.result(date, next);
    }
    expand(date) {
        const next = this.options.byDayOfWeek.map((weekday) => getNextWeekday(date, weekday)).sort(dateTimeSortComparer)[0];
        return this.result(date, next);
    }
    result(date, next) {
        if (next.isEqual(date)) {
            return this.validateDate(new ValidDateTime(date));
        }
        return this.validateDate(new InvalidDateTime(next.granularity("day")));
    }
}
function getNextWeekdaysOfYear(date, byDayOfWeek) {
    const normalizedNthWeekdaysOfYear = byDayOfWeek.filter((entry) => Array.isArray(entry)).map((entry) => getNthWeekdayOfYear(date, ...entry));
    const normalizedNextWeekdays = byDayOfWeek.filter((entry) => typeof entry === "string").map((weekday) => getNextWeekday(date, weekday)).filter((entry) => entry.get("year") === date.get("year"));
    return uniqDateTimes([...normalizedNthWeekdaysOfYear, ...normalizedNextWeekdays]).filter((entry) => entry.isAfterOrEqual(date)).sort(dateTimeSortComparer);
}
function getNextWeekdaysOfMonth(date, byDayOfWeek) {
    const normalizedNthWeekdaysOfMonth = byDayOfWeek.filter((entry) => Array.isArray(entry)).map((entry) => getNthWeekdayOfMonth(date, ...entry));
    const normalizedNextWeekdays = byDayOfWeek.filter((entry) => typeof entry === "string").map((weekday) => getNextWeekday(date, weekday)).filter((entry) => entry.get("year") === date.get("year") && entry.get("month") === date.get("month"));
    return uniqDateTimes([...normalizedNthWeekdaysOfMonth, ...normalizedNextWeekdays]).filter((entry) => entry.isAfterOrEqual(date)).sort(dateTimeSortComparer);
}
const ByDayOfWeekRuleModule = {
    name: "ByDayOfWeek",
    get: (processor) => {
        if (processor.options.byDayOfWeek === void 0)
            return null;
        if (processor.reverse)
            return new RevByDayOfWeekRule(processor);
        return new ByDayOfWeekRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.byDayOfWeek !== void 0) {
            if (!ruleOptionFilled(options2.byDayOfWeek)) {
                throw new RuleOptionError('"byDayOfWeek" expects a non-empty array');
            }
            const invalidWeeday = options2.byDayOfWeek.find((day) => Array.isArray(day) ? !DateAdapter$1.WEEKDAYS.includes(day[0]) : !DateAdapter$1.WEEKDAYS.includes(day));
            if (invalidWeeday) {
                throw new RuleOptionError(`"byDayOfWeek" expects weedays in the form ${JSON.stringify(DateAdapter$1.WEEKDAYS)} but "${invalidWeeday}" was provided`);
            }
            if (!["YEARLY", "MONTHLY"].includes(options2.frequency) && options2.byDayOfWeek.some((weekday) => Array.isArray(weekday))) {
                throw new RuleOptionError('"byDayOfWeek" can only include a numeric value (i.e. `[string, number]`) when the "frequency" is either "MONTHLY" or "YEARLY"');
            }
            if (options2.frequency === "MONTHLY" && options2.byDayOfWeek.some((weekday) => Array.isArray(weekday) && (weekday[1] < -31 || weekday[1] === 0 || weekday[1] > 31))) {
                throw new RuleOptionError('when "frequency" is "MONTHLY", each "byDayOfWeek" can optionally only have a numeric value >= -31 and <= 31 and !== 0');
            }
            if (options2.frequency === "YEARLY" && options2.byDayOfWeek.some((weekday) => Array.isArray(weekday) && (weekday[1] < -366 || weekday[1] === 0 || weekday[1] > 366))) {
                throw new RuleOptionError('when "frequency" is "YEARLY", each "byDayOfWeek" can optionally only have a numeric value >= -366 and <= 366 and !== 0');
            }
            norm.byDayOfWeek = options2.byDayOfWeek;
        }
        else if (!ruleOptionFilled(options2.byDayOfMonth) && options2.frequency === "WEEKLY") {
            norm.byDayOfWeek = [norm.start.get("weekday")];
        }
    },
    deps: () => [
        FrequencyRuleModule,
        ByDayOfWeekRuleModule,
        ByHourOfDayRuleModule,
        ByMinuteOfHourRuleModule,
        BySecondOfMinuteRuleModule,
        ByMillisecondOfSecondRuleModule
    ]
};
class RevByMonthOfYearRule extends RevRecurrenceRuleBase {
    constructor() {
        super(...arguments);
        this.option = this.processor.options.byMonthOfYear.slice().reverse();
    }
    run(date) {
        const currentMonth2 = date.get("month");
        for (const month of this.option) {
            if (currentMonth2 < month)
                continue;
            if (currentMonth2 === month) {
                return this.validateDate(new ValidDateTime(date));
            }
            return this.validateDate(new InvalidDateTime(date.endGranularity("year").set("month", month)));
        }
        return this.validateDate(new InvalidDateTime(date.endGranularity("year").subtract(1, "year").set("month", this.option[0])));
    }
}
class ByMonthOfYearRule extends RecurrenceRuleBase {
    run(date) {
        const currentMonth2 = date.get("month");
        for (const month of this.options.byMonthOfYear) {
            if (currentMonth2 > month)
                continue;
            if (currentMonth2 === month) {
                return this.validateDate(new ValidDateTime(date));
            }
            return this.validateDate(new InvalidDateTime(date.granularity("year").set("month", month)));
        }
        return this.validateDate(new InvalidDateTime(date.granularity("year").add(1, "year").set("month", this.options.byMonthOfYear[0])));
    }
}
const ByMonthOfYearRuleModule = {
    name: "ByMonthOfYear",
    get: (processor) => {
        if (processor.options.byMonthOfYear === void 0)
            return null;
        if (processor.reverse) {
            return new RevByMonthOfYearRule(processor);
        }
        return new ByMonthOfYearRule(processor);
    },
    normalizeOptions: (options2, norm) => {
        if (options2.byMonthOfYear !== void 0) {
            if (!ruleOptionFilled(options2.byMonthOfYear)) {
                throw new RuleOptionError('"byMonthOfYear" expects a non-empty array');
            }
            if (options2.byMonthOfYear.some((num2) => num2 < 1 || num2 > 12)) {
                throw new RuleOptionError('"byMonthOfYear" values must be `num >= 1 && num >= 12`');
            }
            norm.byMonthOfYear = options2.byMonthOfYear.slice();
            norm.byMonthOfYear.sort(numberSortComparer);
        }
        else if (!(ruleOptionFilled(options2.byDayOfMonth) || ruleOptionFilled(options2.byDayOfWeek) || ruleOptionFilled(options2.byDayOfYear)) && options2.frequency === "YEARLY") {
            norm.byMonthOfYear = [norm.start.get("month")];
        }
    },
    deps: () => [
        FrequencyRuleModule,
        ByMonthOfYearRuleModule,
        ByDayOfMonthRuleModule,
        ByHourOfDayRuleModule,
        ByMinuteOfHourRuleModule,
        BySecondOfMinuteRuleModule,
        ByMillisecondOfSecondRuleModule
    ]
};
const ICAL_RULES = [
    FrequencyRuleModule,
    ByMonthOfYearRuleModule,
    ByDayOfMonthRuleModule,
    ByDayOfWeekRuleModule,
    ByHourOfDayRuleModule,
    ByMinuteOfHourRuleModule,
    BySecondOfMinuteRuleModule,
    ByMillisecondOfSecondRuleModule
];
class StandardDateAdapter extends DateAdapterBase$1 {
    constructor(date, options2 = {}) {
        super(void 0, options2);
        if (!["UTC", null, void 0].includes(options2.timezone)) {
            throw new InvalidDateAdapterError$1(`StandardDateAdapter only supports "UTC" and local time zones but "${options2.timezone}" was provided.`);
        }
        this._date = new Date(date);
        this.timezone = options2.timezone !== void 0 ? options2.timezone : null;
        if (options2.metadata) {
            Object.assign(this.metadata, options2.metadata);
        }
        this.assertIsValid();
    }
    static isDate(object) {
        return Object.prototype.toString.call(object) === "[object Date]";
    }
    static fromDate(date, options2) {
        return new StandardDateAdapter(date, options2);
    }
    static fromJSON(json) {
        const args = [
            json.year,
            json.month - 1,
            json.day,
            json.hour,
            json.minute,
            json.second,
            json.millisecond
        ];
        let date;
        switch (json.timezone) {
            case "UTC": {
                date = new StandardDateAdapter(new Date(Date.UTC(...args)), {
                    timezone: "UTC",
                    duration: json.duration
                });
                break;
            }
            case null: {
                date = new StandardDateAdapter(new Date(...args), {
                    timezone: null,
                    duration: json.duration
                });
                break;
            }
            default:
                throw new InvalidDateAdapterError$1(`The \`StandardDateAdapter\` only supports datetimes in UTC or LOCAL (null) time. You provided a JSON object with timezone "${json.timezone}".`);
        }
        if (json.metadata) {
            Object.assign(date.metadata, json.metadata);
        }
        return date;
    }
    static fromDateTime(datetime) {
        const date = StandardDateAdapter.fromJSON(datetime.toJSON());
        date.generators.push(...datetime.generators);
        if (datetime.metadata) {
            Object.assign(date.metadata, datetime.metadata);
        }
        return date;
    }
    get date() {
        return new Date(this._date);
    }
    get end() {
        if (!this.duration)
            return;
        if (this._end)
            return this._end;
        this._end = StandardDateAdapter.fromDateTime(this.toDateTime().add(this.duration, "millisecond")).date;
        return this._end;
    }
    set(prop, value) {
        if (prop === "timezone") {
            if (this.timezone === value)
                return this;
            else {
                return new StandardDateAdapter(this._date, {
                    timezone: value,
                    duration: this.duration,
                    generators: this.generators
                });
            }
        }
        else if (prop === "duration") {
            if (this.duration === value)
                return this;
            else {
                return new StandardDateAdapter(this._date, {
                    timezone: this.timezone,
                    duration: value,
                    generators: this.generators
                });
            }
        }
        throw new ArgumentError(`Unknown prop "${prop}" for StandardDateAdapter#set()`);
    }
    valueOf() {
        return this._date.valueOf();
    }
    toJSON() {
        let json;
        if (this.timezone === "UTC") {
            json = {
                timezone: this.timezone,
                year: this._date.getUTCFullYear(),
                month: this._date.getUTCMonth() + 1,
                day: this._date.getUTCDate(),
                hour: this._date.getUTCHours(),
                minute: this._date.getUTCMinutes(),
                second: this._date.getUTCSeconds(),
                millisecond: this._date.getUTCMilliseconds()
            };
        }
        else {
            json = {
                timezone: this.timezone,
                year: this._date.getFullYear(),
                month: this._date.getMonth() + 1,
                day: this._date.getDate(),
                hour: this._date.getHours(),
                minute: this._date.getMinutes(),
                second: this._date.getSeconds(),
                millisecond: this._date.getMilliseconds()
            };
        }
        if (this.duration) {
            json.duration = this.duration;
        }
        return json;
    }
    assertIsValid() {
        if (!StandardDateAdapter.isDate(this._date) || isNaN(this._date.valueOf())) {
            throw new InvalidDateAdapterError$1("StandardDateAdapter has invalid date.");
        }
        else if (![null, "UTC"].includes(this.timezone)) {
            throw new InvalidDateAdapterError$1(`StandardDateAdapter only supports local (null) and UTC timezones but "${this.timezone}" was specified.`);
        }
        else if (this.duration && this.duration <= 0) {
            throw new InvalidDateAdapterError$1("If provided, duration must be greater than 0.");
        }
        return true;
    }
}
StandardDateAdapter.hasTimezoneSupport = false;
DateAdapterBase$1.adapter = StandardDateAdapter;
Rule$1.recurrenceRules = ICAL_RULES;
class RSchedule extends Schedule {
}
function registerHandlebarsHelpers() {
    const regexTest = /^\/(.*)\/([gimuy]*)$/;
    function mathHelper(fn) {
        return (a, ...b) => {
            return b.map(Number).reduce(fn, Number(a));
        };
    }
    function regexHelper(mapRegex, mapNonRegex, apply2) {
        return (value, regex2, replace) => {
            if (value == null) {
                return null;
            }
            if (typeof regex2 !== "string" || typeof replace !== "string") {
                return "";
            }
            let regexp2;
            const match2 = regexTest.exec(regex2);
            if (match2) {
                regexp2 = mapRegex(match2[1], match2[2]);
            }
            else {
                regexp2 = mapNonRegex(regex2);
            }
            return apply2(String(value), regexp2, replace);
        };
    }
    const helpers = {
        regex: regexHelper((regex2, flags) => new RegExp(regex2, flags), (value) => new RegExp(value), (value, regex2, replace) => value.replace(regex2, replace)),
        replace: regexHelper((regex2, flags) => new RegExp(regex2, flags), (value) => value, (value, regex2, replace) => value.replace(regex2, replace)),
        replaceAll: regexHelper((regex2, flags) => new RegExp(regex2, flags), (value) => value, (value, regex2, replace) => value.replaceAll(regex2, replace)),
        add: mathHelper((a, b) => a + b),
        sub: mathHelper((a, b) => a - b),
        div: mathHelper((a, b) => a / b),
        mul: mathHelper((a, b) => a * b),
        mod: mathHelper((a, b) => a % b),
        floor: (a) => Math.floor(Number(a)),
        ceil: (a) => Math.ceil(Number(a)),
        round: (a) => Math.round(Number(a)),
        abs: (a) => Math.abs(Number(a)),
        min: mathHelper((a, b) => Math.min(a, b)),
        max: mathHelper((a, b) => Math.max(a, b)),
        fixed: (a, digits) => Number(a).toFixed(Number(digits)),
        day: (date) => date && format(date, "d"),
        month: (date) => date && format(date, "M"),
        year: (date) => date && format(date, "yyyy"),
        format: (date, f2) => date && f2 && format(date, f2),
        addDays: (date, days) => {
            if (!date || !days)
                return date;
            return format(addDays(date, days), "yyyy-MM-dd");
        },
        subDays: (date, days) => {
            if (!date || !days)
                return date;
            return format(subDays(date, days), "yyyy-MM-dd");
        },
        addMonths: (date, months) => {
            if (!date || !months)
                return date;
            return format(addMonths$1(parseDate$1(date), months), "yyyy-MM-dd");
        },
        subMonths: (date, months) => {
            if (!date || !months)
                return date;
            return format(subMonths$1(parseDate$1(date), months), "yyyy-MM-dd");
        },
        addWeeks: (date, weeks) => {
            if (!date || !weeks)
                return date;
            return format(addWeeks$1(parseDate$1(date), weeks), "yyyy-MM-dd");
        },
        subWeeks: (date, weeks) => {
            if (!date || !weeks)
                return date;
            return format(subWeeks$1(parseDate$1(date), weeks), "yyyy-MM-dd");
        },
        addYears: (date, years) => {
            if (!date || !years)
                return date;
            return format(addYears$1(parseDate$1(date), years), "yyyy-MM-dd");
        },
        subYears: (date, years) => {
            if (!date || !years)
                return date;
            return format(subYears(parseDate$1(date), years), "yyyy-MM-dd");
        },
        setDay: (date, day) => {
            if (!date)
                return date;
            const actualDay = Number(format(date, "d"));
            return format(addDays(date, day - actualDay), "yyyy-MM-dd");
        },
        debug: (value) => {
            logger.log(value);
        },
        concat: (...args) => args.join("")
    };
    for (const [name, fn] of Object.entries(helpers)) {
        handlebarsExports.registerHelper(name, (...args) => {
            return fn(...args.slice(0, -1));
        });
    }
}
registerHandlebarsHelpers();
function assert(test, type2, msg) {
    if (!test) {
        throw new RuleError(type2, msg);
    }
}
function parseRecurDate(desc) {
    try {
        const rules = recurConfigToRSchedule(desc);
        return {
            type: "recur",
            schedule: new RSchedule({
                rrules: rules,
                data: {
                    skipWeekend: desc.skipWeekend,
                    weekendSolve: desc.weekendSolveMode
                }
            })
        };
    }
    catch (e) {
        throw new RuleError("parse-recur-date", e.message);
    }
}
function parseDateString(str) {
    if (typeof str !== "string") {
        return null;
    }
    else if (str.length === 10) {
        if (!isValid(parseISO(str))) {
            return null;
        }
        return { type: "date", date: str };
    }
    else if (str.length === 7) {
        if (!isValid(parseISO(str + "-01"))) {
            return null;
        }
        return { type: "month", date: str };
    }
    else if (str.length === 4) {
        if (!isValid(parseISO(str + "-01-01"))) {
            return null;
        }
        return { type: "year", date: str };
    }
    return null;
}
function parseBetweenAmount(between) {
    const { num1, num2 } = between;
    if (typeof num1 !== "number" || typeof num2 !== "number") {
        return null;
    }
    return { type: "between", num1, num2 };
}
const CONDITION_TYPES = {
    date: {
        ops: ["is", "isapprox", "gt", "gte", "lt", "lte"],
        nullable: false,
        parse(op, value, fieldName) {
            const parsed = typeof value === "string" ? parseDateString(value) : value.frequency != null ? parseRecurDate(value) : null;
            assert(parsed, "date-format", `Invalid date format (field: ${fieldName})`);
            if (op === "isapprox") {
                assert(parsed.type === "date" || parsed.type === "recur", "date-format", `Invalid date value for isapprox (field: ${fieldName})`);
            }
            else if (op === "gt" || op === "gte" || op === "lt" || op === "lte") {
                assert(parsed.type === "date", "date-format", `Invalid date value for ${op} (field: ${fieldName})`);
            }
            return parsed;
        }
    },
    id: {
        ops: [
            "is",
            "contains",
            "matches",
            "oneOf",
            "isNot",
            "doesNotContain",
            "notOneOf",
            "and",
            "onBudget",
            "offBudget"
        ],
        nullable: true,
        parse(op, value, fieldName) {
            if (op === "oneOf" || op === "notOneOf" || op === "and") {
                assert(Array.isArray(value), "no-empty-array", `oneOf must have an array value (field: ${fieldName})`);
                return value;
            }
            return value;
        }
    },
    string: {
        ops: [
            "is",
            "contains",
            "matches",
            "oneOf",
            "isNot",
            "doesNotContain",
            "notOneOf",
            "hasTags"
        ],
        nullable: true,
        parse(op, value, fieldName) {
            if (op === "oneOf" || op === "notOneOf") {
                assert(Array.isArray(value), "no-empty-array", `oneOf must have an array value (field: ${fieldName}): ${JSON.stringify(value)}`);
                return value.filter(Boolean).map((val2) => val2.toLowerCase());
            }
            assert(typeof value === "string", "not-string", `Invalid string value (field: ${fieldName})`);
            if (op === "contains" || op === "matches" || op === "doesNotContain" || op === "hasTags") {
                assert(value.length > 0, "no-empty-string", `${op} must have non-empty string (field: ${fieldName})`);
            }
            if (op === "hasTags") {
                return value;
            }
            return value.toLowerCase();
        }
    },
    number: {
        ops: ["is", "isapprox", "isbetween", "gt", "gte", "lt", "lte"],
        nullable: false,
        parse(op, value, fieldName) {
            const parsed = typeof value === "number" ? { type: "literal", value } : parseBetweenAmount(value);
            assert(parsed != null, "not-number", `Value must be a number or between amount: ${JSON.stringify(value)} (field: ${fieldName})`);
            if (op === "isbetween") {
                assert(parsed.type === "between", "number-format", `Invalid between value for ${op} (field: ${fieldName})`);
            }
            else {
                assert(parsed.type === "literal", "number-format", `Invalid number value for ${op} (field: ${fieldName})`);
            }
            return parsed;
        }
    },
    boolean: {
        ops: ["is"],
        nullable: false,
        parse(op, value, fieldName) {
            assert(typeof value === "boolean", "not-boolean", `Value must be a boolean: ${value} (field: ${fieldName})`);
            return value;
        }
    }
};
class Condition {
    constructor(op, field, value, options2) {
        const typeName = FIELD_TYPES.get(field);
        assert(typeName, "internal", "Invalid condition field: " + field);
        const type2 = CONDITION_TYPES[typeName];
        assert(type2, "internal", `Invalid condition type: ${typeName} (field: ${field})`);
        assert(isValidOp(field, op), "internal", `Invalid condition operator: ${op} (type: ${typeName}, field: ${field})`);
        if (type2.nullable !== true) {
            assert(value != null, "no-null", `Field cannot be empty: ${field}`);
        }
        if (typeName === "string" && type2.nullable !== true) {
            assert(value !== "", "no-null", `Field cannot be empty: ${field}`);
        }
        this.rawValue = value;
        this.unparsedValue = value;
        this.op = op;
        this.field = field;
        this.value = type2.parse ? type2.parse(op, value, field) : value;
        this.options = options2;
        this.type = typeName;
    }
    eval(object) {
        let fieldValue = object[this.field];
        const type2 = this.type;
        if (type2 === "string") {
            fieldValue ??= "";
        }
        if (fieldValue === void 0) {
            return false;
        }
        if (typeof fieldValue === "string") {
            fieldValue = fieldValue.toLowerCase();
        }
        if (type2 === "number" && this.options) {
            if (this.options.outflow) {
                if (fieldValue > 0) {
                    return false;
                }
                fieldValue = -fieldValue;
            }
            else if (this.options.inflow) {
                if (fieldValue < 0) {
                    return false;
                }
            }
        }
        const extractValue = (v) => type2 === "number" ? v.value : v;
        switch (this.op) {
            case "isapprox":
            case "is":
                if (type2 === "date") {
                    if (fieldValue == null) {
                        return false;
                    }
                    if (this.value.type === "recur") {
                        const { schedule } = this.value;
                        if (this.op === "isapprox") {
                            const fieldDate = parseDate$1(fieldValue);
                            return schedule.occursBetween(subDays$1(fieldDate, 2), addDays$1(fieldDate, 2));
                        }
                        else {
                            return schedule.occursOn({ date: parseDate$1(fieldValue) });
                        }
                    }
                    else {
                        const { date } = this.value;
                        if (this.op === "isapprox") {
                            const fullDate = parseDate$1(date);
                            const high = addDays(fullDate, 2);
                            const low = subDays(fullDate, 2);
                            return fieldValue >= low && fieldValue <= high;
                        }
                        else {
                            switch (this.value.type) {
                                case "date":
                                    return fieldValue === date;
                                case "month":
                                    return monthFromDate(fieldValue) === date;
                                case "year":
                                    return yearFromDate(fieldValue) === date;
                            }
                        }
                    }
                }
                else if (type2 === "number") {
                    const number2 = this.value.value;
                    if (this.op === "isapprox") {
                        const threshold = getApproxNumberThreshold(number2);
                        return fieldValue >= number2 - threshold && fieldValue <= number2 + threshold;
                    }
                    return fieldValue === number2;
                }
                return fieldValue === this.value;
            case "isNot":
                return fieldValue !== this.value;
            case "isbetween": {
                const [low, high] = sortNumbers(this.value.num1, this.value.num2);
                return fieldValue >= low && fieldValue <= high;
            }
            case "contains":
                if (fieldValue === null) {
                    return false;
                }
                return String(fieldValue).indexOf(this.value) !== -1;
            case "doesNotContain":
                if (fieldValue === null) {
                    return false;
                }
                return String(fieldValue).indexOf(this.value) === -1;
            case "oneOf":
                if (fieldValue === null) {
                    return false;
                }
                return this.value.indexOf(fieldValue) !== -1;
            case "hasTags":
                if (fieldValue === null) {
                    return false;
                }
                return String(fieldValue).indexOf(this.value) !== -1;
            case "notOneOf":
                if (fieldValue === null) {
                    return false;
                }
                return this.value.indexOf(fieldValue) === -1;
            case "gt":
                if (fieldValue === null) {
                    return false;
                }
                else if (type2 === "date") {
                    return isAfter(fieldValue, this.value.date);
                }
                return fieldValue > extractValue(this.value);
            case "gte":
                if (fieldValue === null) {
                    return false;
                }
                else if (type2 === "date") {
                    return fieldValue === this.value.date || isAfter(fieldValue, this.value.date);
                }
                return fieldValue >= extractValue(this.value);
            case "lt":
                if (fieldValue === null) {
                    return false;
                }
                else if (type2 === "date") {
                    return isBefore(fieldValue, this.value.date);
                }
                return fieldValue < extractValue(this.value);
            case "lte":
                if (fieldValue === null) {
                    return false;
                }
                else if (type2 === "date") {
                    return fieldValue === this.value.date || isBefore(fieldValue, this.value.date);
                }
                return fieldValue <= extractValue(this.value);
            case "matches":
                if (fieldValue === null) {
                    return false;
                }
                try {
                    return new RegExp(this.value).test(fieldValue);
                }
                catch (e) {
                    logger.log("invalid regexp in matches condition", e);
                    return false;
                }
            case "onBudget":
                if (!object._account) {
                    return false;
                }
                return object._account.offbudget === 0;
            case "offBudget":
                if (!object._account) {
                    return false;
                }
                return object._account.offbudget === 1;
        }
        return false;
    }
    getValue() {
        return this.value;
    }
    serialize() {
        return {
            op: this.op,
            field: this.field,
            value: this.unparsedValue,
            type: this.type,
            ...this.options ? { options: this.options } : null
        };
    }
}
const ACTION_OPS = [
    "set",
    "set-split-amount",
    "link-schedule",
    "prepend-notes",
    "append-notes"
];
class Action {
    constructor(op, field, value, options2) {
        assert(ACTION_OPS.includes(op), "internal", `Invalid action operation: ${op}`);
        if (op === "set") {
            const typeName = FIELD_TYPES.get(field);
            assert(typeName, "internal", `Invalid field for action: ${field}`);
            this.field = field;
            this.type = typeName;
            if (options2?.template) {
                this.handlebarsTemplate = handlebarsExports.compile(options2.template, {
                    noEscape: true
                });
                try {
                    this.handlebarsTemplate({});
                }
                catch (e) {
                    logger.debug(e);
                    assert(false, "invalid-template", `Invalid Handlebars template`);
                }
            }
        }
        else if (op === "set-split-amount") {
            this.field = null;
            this.type = "number";
        }
        else if (op === "link-schedule") {
            this.field = null;
            this.type = "id";
        }
        else if (op === "prepend-notes" || op === "append-notes") {
            this.field = "notes";
            this.type = "id";
        }
        if (field === "account") {
            assert(value, "no-null", `Field cannot be empty: ${field}`);
        }
        this.op = op;
        this.rawValue = value;
        this.value = value;
        this.options = options2;
    }
    exec(object) {
        switch (this.op) {
            case "set":
                if (this.handlebarsTemplate) {
                    object[this.field] = this.handlebarsTemplate({
                        ...object,
                        today: currentDay()
                    });
                    switch (this.type) {
                        case "number":
                            object[this.field] = parseFloat(object[this.field]);
                            break;
                        case "date":
                            const parsed = parseDate$1(object[this.field]);
                            if (parsed && isValid(parsed)) {
                                object[this.field] = format(parsed, "yyyy-MM-dd");
                            }
                            else {
                                logger.error(`rules: invalid date produced by template for field ${this.field}:`, object[this.field]);
                                object[this.field] = "9999-12-31";
                            }
                            break;
                        case "boolean":
                            object[this.field] = object[this.field] === "true";
                            break;
                    }
                }
                else {
                    object[this.field] = this.value;
                }
                if (this.field === "payee_name") {
                    object["payee"] = "new";
                }
                break;
            case "set-split-amount":
                switch (this.options.method) {
                    case "fixed-amount":
                        object.amount = this.value;
                        break;
                }
                break;
            case "link-schedule":
                object.schedule = this.value;
                break;
            case "prepend-notes":
                object[this.field] = object[this.field] ? this.value + object[this.field] : this.value;
                break;
            case "append-notes":
                object[this.field] = object[this.field] ? object[this.field] + this.value : this.value;
                break;
        }
    }
    serialize() {
        return {
            op: this.op,
            field: this.field,
            value: this.value,
            type: this.type,
            ...this.options ? { options: this.options } : null
        };
    }
}
function execNonSplitActions(actions, transaction2) {
    const update2 = transaction2;
    actions.forEach((action) => action.exec(update2));
    return update2;
}
function getSplitRemainder(transactions) {
    const { error } = recalculateSplit(groupTransaction(transactions));
    return error ? error.difference : 0;
}
function execSplitActions(actions, transaction2) {
    const splitAmountActions = actions.filter((action) => action.op === "set-split-amount");
    const { data } = splitTransaction(ungroupTransaction(transaction2), transaction2.id);
    let newTransactions = data;
    actions.forEach((action) => {
        const splitTransactionIndex = (action.options?.splitIndex ?? 0) + 1;
        if (splitTransactionIndex >= newTransactions.length) {
            const { data: data2 } = addSplitTransaction(newTransactions, transaction2.id);
            newTransactions = data2;
        }
        action.exec(newTransactions[splitTransactionIndex]);
    });
    const remainingAfterFixedAmounts = getSplitRemainder(newTransactions);
    splitAmountActions.filter((action) => action.options.method === "fixed-percent").forEach((action) => {
        const splitTransactionIndex = (action.options?.splitIndex ?? 0) + 1;
        const percent = action.value / 100;
        const amount = Math.round(remainingAfterFixedAmounts * percent);
        newTransactions[splitTransactionIndex].amount = amount;
    });
    const remainderActions = splitAmountActions.filter((action) => action.options.method === "remainder");
    const remainingAfterFixedPercents = getSplitRemainder(newTransactions);
    if (remainderActions.length !== 0) {
        const amountPerRemainderSplit = Math.round(remainingAfterFixedPercents / remainderActions.length);
        let lastNonFixedTransactionIndex = -1;
        remainderActions.forEach((action) => {
            const splitTransactionIndex = (action.options?.splitIndex ?? 0) + 1;
            newTransactions[splitTransactionIndex].amount = amountPerRemainderSplit;
            lastNonFixedTransactionIndex = Math.max(lastNonFixedTransactionIndex, splitTransactionIndex);
        });
        newTransactions[lastNonFixedTransactionIndex].amount += getSplitRemainder(newTransactions);
    }
    newTransactions.splice(1, 1);
    return recalculateSplit(groupTransaction(newTransactions));
}
function execActions(actions, transaction2) {
    const parentActions = actions.filter((action) => !action.options?.splitIndex);
    const childActions = actions.filter((action) => action.options?.splitIndex);
    const totalSplitCount = actions.reduce((prev, cur) => Math.max(prev, cur.options?.splitIndex ?? 0), 0) + 1;
    const nonSplitResult = execNonSplitActions(parentActions, transaction2);
    if (totalSplitCount === 1) {
        return nonSplitResult;
    }
    if (nonSplitResult.is_child) {
        return nonSplitResult;
    }
    return execSplitActions(childActions, nonSplitResult);
}
class Rule2 {
    constructor({ id: id2, stage, conditionsOp, conditions, actions }) {
        this.id = id2;
        this.stage = stage ?? null;
        this.conditionsOp = conditionsOp;
        this.conditions = conditions.map((c) => new Condition(c.op, c.field, c.value, c.options));
        this.actions = actions.map((a) => new Action(a.op, a.field, a.value, a.options));
    }
    evalConditions(object) {
        if (this.conditions.length === 0) {
            return false;
        }
        const method = this.conditionsOp === "or" ? "some" : "every";
        return this.conditions[method]((condition) => {
            return condition.eval(object);
        });
    }
    execActions(object) {
        const result = execActions(this.actions, {
            ...object
        });
        const changes = Object.keys(result).reduce((prev, cur) => {
            if (result[cur] !== object[cur]) {
                prev[cur] = result[cur];
            }
            return prev;
        }, {});
        return changes;
    }
    exec(object) {
        if (this.evalConditions(object)) {
            return this.execActions(object);
        }
        return null;
    }
    // Apply is similar to exec but applies the changes for you
    apply(object) {
        const changes = this.exec(object);
        return Object.assign({}, object, changes);
    }
    getId() {
        return this.id;
    }
    serialize() {
        return {
            id: this.id,
            stage: this.stage,
            conditionsOp: this.conditionsOp,
            conditions: this.conditions.map((c) => c.serialize()),
            actions: this.actions.map((a) => a.serialize())
        };
    }
}
class RuleIndexer {
    constructor({ field, method }) {
        this.field = field;
        this.method = method;
        this.rules = /* @__PURE__ */ new Map();
    }
    getIndex(key) {
        if (!this.rules.has(key)) {
            this.rules.set(key, /* @__PURE__ */ new Set());
        }
        return this.rules.get(key);
    }
    getIndexForValue(value) {
        return this.getIndex(this.getKey(value) || "*");
    }
    getKey(value) {
        if (typeof value === "string" && value !== "") {
            if (this.method === "firstchar") {
                return value[0].toLowerCase();
            }
            return value.toLowerCase();
        }
        return null;
    }
    getIndexes(rule) {
        const cond = rule.conditions.find((cond2) => cond2.field === this.field);
        const indexes = [];
        if (cond && (cond.op === "oneOf" || cond.op === "is" || cond.op === "isNot" || cond.op === "notOneOf")) {
            if (cond.op === "oneOf" || cond.op === "notOneOf") {
                cond.value.forEach((val2) => indexes.push(this.getIndexForValue(val2)));
            }
            else {
                indexes.push(this.getIndexForValue(cond.value));
            }
        }
        else {
            indexes.push(this.getIndex("*"));
        }
        return indexes;
    }
    index(rule) {
        const indexes = this.getIndexes(rule);
        indexes.forEach((index) => {
            index.add(rule);
        });
    }
    remove(rule) {
        const indexes = this.getIndexes(rule);
        indexes.forEach((index) => {
            index.delete(rule);
        });
    }
    getApplicableRules(object) {
        let indexedRules;
        if (this.field in object) {
            const key = this.getKey(object[this.field]);
            if (key) {
                indexedRules = this.rules.get(key);
            }
        }
        return fastSetMerge(indexedRules || /* @__PURE__ */ new Set(), this.rules.get("*") || /* @__PURE__ */ new Set());
    }
}
const OP_SCORES = {
    is: 10,
    isNot: 10,
    oneOf: 9,
    notOneOf: 9,
    isapprox: 5,
    isbetween: 5,
    gt: 1,
    gte: 1,
    lt: 1,
    lte: 1,
    contains: 0,
    doesNotContain: 0,
    matches: 0,
    hasTags: 0,
    onBudget: 0,
    offBudget: 0
};
function computeScore(rule) {
    const initialScore = rule.conditions.reduce((score, condition) => {
        if (OP_SCORES[condition.op] == null) {
            logger.log(`Found invalid operation while ranking: ${condition.op}`);
            return 0;
        }
        return score + OP_SCORES[condition.op];
    }, 0);
    if (rule.conditions.every((cond) => cond.op === "is" || cond.op === "isNot" || cond.op === "isapprox" || cond.op === "oneOf" || cond.op === "notOneOf")) {
        return initialScore * 2;
    }
    return initialScore;
}
function _rankRules(rules) {
    const scores = /* @__PURE__ */ new Map();
    rules.forEach((rule) => {
        scores.set(rule, computeScore(rule));
    });
    return [...rules].sort((r1, r2) => {
        const score1 = scores.get(r1);
        const score2 = scores.get(r2);
        if (score1 < score2) {
            return -1;
        }
        else if (score1 > score2) {
            return 1;
        }
        else {
            const id1 = r1.getId();
            const id2 = r2.getId();
            return id1 < id2 ? -1 : id1 > id2 ? 1 : 0;
        }
    });
}
function rankRules(rules) {
    let pre = [];
    let normal = [];
    let post2 = [];
    for (const rule of rules) {
        switch (rule.stage) {
            case "pre":
                pre.push(rule);
                break;
            case "post":
                post2.push(rule);
                break;
            default:
                normal.push(rule);
        }
    }
    pre = _rankRules(pre);
    normal = _rankRules(normal);
    post2 = _rankRules(post2);
    return pre.concat(normal).concat(post2);
}
function migrateIds(rule, mappings) {
    for (let ci = 0; ci < rule.conditions.length; ci++) {
        const cond = rule.conditions[ci];
        if (cond.type === "id") {
            switch (cond.op) {
                case "is":
                    cond.value = mappings.get(cond.rawValue) || cond.rawValue;
                    cond.unparsedValue = cond.value;
                    break;
                case "isNot":
                    cond.value = mappings.get(cond.rawValue) || cond.rawValue;
                    cond.unparsedValue = cond.value;
                    break;
                case "oneOf":
                    cond.value = cond.rawValue.map((v) => mappings.get(v) || v);
                    cond.unparsedValue = [...cond.value];
                    break;
                case "notOneOf":
                    cond.value = cond.rawValue.map((v) => mappings.get(v) || v);
                    cond.unparsedValue = [...cond.value];
                    break;
            }
        }
    }
    for (let ai = 0; ai < rule.actions.length; ai++) {
        const action = rule.actions[ai];
        if (action.type === "id") {
            if (action.op === "set") {
                action.value = mappings.get(action.rawValue) || action.rawValue;
            }
        }
    }
}
function iterateIds(rules, fieldName, func) {
    let i;
    ruleiter: for (i = 0; i < rules.length; i++) {
        const rule = rules[i];
        for (let ci = 0; ci < rule.conditions.length; ci++) {
            const cond = rule.conditions[ci];
            if (cond.type === "id" && cond.field === fieldName) {
                switch (cond.op) {
                    case "is":
                        if (func(rule, cond.value)) {
                            continue ruleiter;
                        }
                        break;
                    case "isNot":
                        if (func(rule, cond.value)) {
                            continue ruleiter;
                        }
                        break;
                    case "oneOf":
                        for (let vi2 = 0; vi2 < cond.value.length; vi2++) {
                            if (func(rule, cond.value[vi2])) {
                                continue ruleiter;
                            }
                        }
                        break;
                    case "notOneOf":
                        for (let vi2 = 0; vi2 < cond.value.length; vi2++) {
                            if (func(rule, cond.value[vi2])) {
                                continue ruleiter;
                            }
                        }
                        break;
                }
            }
        }
        for (let ai = 0; ai < rule.actions.length; ai++) {
            const action = rule.actions[ai];
            if (action.type === "id" && action.field === fieldName) {
                if (action.op === "set") {
                    if (func(rule, action.value)) {
                        break;
                    }
                }
            }
        }
    }
}
let allRules;
let unlistenSync;
let firstcharIndexer;
let payeeIndexer;
function resetState() {
    allRules = /* @__PURE__ */ new Map();
    firstcharIndexer = new RuleIndexer({
        field: "imported_payee",
        method: "firstchar"
    });
    payeeIndexer = new RuleIndexer({ field: "payee" });
}
function invert(obj) {
    return Object.fromEntries(Object.entries(obj).map((entry) => {
        return [entry[1], entry[0]];
    }));
}
const internalFields = schemaConfig.views.transactions.fields;
const publicFields = invert(schemaConfig.views.transactions.fields);
function fromInternalField(obj) {
    return {
        ...obj,
        field: publicFields[obj.field] || obj.field
    };
}
function toInternalField(obj) {
    return {
        ...obj,
        field: internalFields[obj.field] || obj.field
    };
}
function parseArray(str) {
    let value;
    try {
        value = typeof str === "string" ? JSON.parse(str) : str;
    }
    catch (e) {
        throw new RuleError("internal", "Cannot parse rule json");
    }
    if (!Array.isArray(value)) {
        throw new RuleError("internal", "Rule json must be an array");
    }
    return value;
}
function parseConditionsOrActions(str) {
    return str ? parseArray(str).map((item) => fromInternalField(item)) : [];
}
function serializeConditionsOrActions(arr) {
    return JSON.stringify(arr.map((item) => toInternalField(item)));
}
const ruleModel = {
    validate(rule, { update: update2 } = {}) {
        requiredFields("rules", rule, ["conditions", "actions"], update2);
        if (!update2 || "stage" in rule) {
            if (rule.stage !== "pre" && rule.stage !== "post" && rule.stage !== null) {
                throw new Error("Invalid rule stage: " + rule.stage);
            }
        }
        if (!update2 || "conditionsOp" in rule) {
            if (!["and", "or"].includes(rule.conditionsOp)) {
                throw new Error("Invalid rule conditionsOp: " + rule.conditionsOp);
            }
        }
        return rule;
    },
    toJS(row) {
        const { conditions, conditions_op, actions, ...fields } = row;
        return {
            ...fields,
            conditionsOp: conditions_op,
            conditions: parseConditionsOrActions(conditions),
            actions: parseConditionsOrActions(actions)
        };
    },
    fromJS(rule) {
        const { conditions, conditionsOp, actions, ...row } = rule;
        if (conditionsOp) {
            row.conditions_op = conditionsOp;
        }
        if (Array.isArray(conditions)) {
            row.conditions = serializeConditionsOrActions(conditions);
        }
        if (Array.isArray(actions)) {
            row.actions = serializeConditionsOrActions(actions);
        }
        return row;
    }
};
function makeRule(data) {
    let rule;
    try {
        rule = new Rule2(ruleModel.toJS(data));
    }
    catch (e) {
        logger.warn("Invalid rule", e);
        if (e instanceof RuleError) {
            return null;
        }
        throw e;
    }
    migrateIds(rule, getMappings());
    return rule;
}
async function loadRules() {
    resetState();
    const rules = await all(`
    SELECT * FROM rules
      WHERE conditions IS NOT NULL AND actions IS NOT NULL AND tombstone = 0
  `);
    for (let i = 0; i < rules.length; i++) {
        const desc = rules[i];
        if (desc.stage === "cleanup" || desc.stage === "modify") {
            desc.stage = "pre";
        }
        const rule = makeRule(desc);
        if (rule) {
            allRules.set(rule.id, rule);
            firstcharIndexer.index(rule);
            payeeIndexer.index(rule);
        }
    }
    if (unlistenSync) {
        unlistenSync();
    }
    unlistenSync = addSyncListener(onApplySync$1);
}
function getRules$1() {
    return [...allRules.values()];
}
async function insertRule(rule) {
    rule = ruleModel.validate(rule);
    return insertWithUUID("rules", ruleModel.fromJS(rule));
}
async function updateRule$1(rule) {
    rule = ruleModel.validate(rule, { update: true });
    return update("rules", ruleModel.fromJS(rule));
}
async function deleteRule$1(id2) {
    const schedule = await first("SELECT id FROM schedules WHERE rule = ?", [id2]);
    if (schedule) {
        return false;
    }
    await delete_("rules", id2);
    return true;
}
function onApplySync$1(oldValues, newValues) {
    newValues.forEach((items, table) => {
        if (table === "rules") {
            items.forEach((newValue) => {
                const oldRule = allRules.get(newValue.id);
                if (newValue.tombstone === 1) {
                    const rule = allRules.get(newValue.id);
                    if (rule) {
                        allRules.delete(rule.getId());
                        firstcharIndexer.remove(rule);
                        payeeIndexer.remove(rule);
                    }
                }
                else {
                    const rule = makeRule(newValue);
                    if (rule) {
                        if (oldRule) {
                            firstcharIndexer.remove(oldRule);
                            payeeIndexer.remove(oldRule);
                        }
                        allRules.set(newValue.id, rule);
                        firstcharIndexer.index(rule);
                        payeeIndexer.index(rule);
                    }
                }
            });
        }
    });
    const tables = [...newValues.keys()];
    if (tables.find((table) => table.indexOf("mapping") !== -1)) {
        getRules$1().forEach((rule) => {
            migrateIds(rule, getMappings());
        });
    }
}
async function getRuleIdFromScheduleId(scheduleId) {
    const row = await first("SELECT rule FROM schedules WHERE id = ?", [scheduleId]);
    return row?.rule || null;
}
async function getAllRuleIdsFromSchedules(excluding) {
    const rows = await all("SELECT rule FROM schedules");
    const ruleIds = rows.map((r) => r.rule).filter((rule) => !!rule).filter((ruleId) => ruleId !== excluding);
    return ruleIds;
}
async function runRules$1(trans, accounts = null) {
    let accountsMap = null;
    if (accounts === null) {
        accountsMap = new Map((await getAccounts$2()).map((account) => [account.id, account]));
    }
    else {
        accountsMap = accounts;
    }
    let finalTrans = await prepareTransactionForRules({ ...trans }, accountsMap);
    let scheduleRuleID = "";
    if (trans.schedule != null) {
        const ruleId = await getRuleIdFromScheduleId(trans.schedule);
        if (ruleId != null) {
            scheduleRuleID = ruleId;
        }
    }
    const RuleIdsLinkedToSchedules = await getAllRuleIdsFromSchedules(scheduleRuleID);
    const rules = rankRules(fastSetMerge(firstcharIndexer.getApplicableRules(trans), payeeIndexer.getApplicableRules(trans)));
    for (let i = 0; i < rules.length; i++) {
        if (scheduleRuleID !== "") {
            if (rules[i].id === scheduleRuleID) {
                finalTrans = rules[i].apply(finalTrans);
            }
            else if (RuleIdsLinkedToSchedules.includes(rules[i].id)) {
                continue;
            }
            else {
                finalTrans = rules[i].apply(finalTrans);
            }
        }
        else {
            finalTrans = rules[i].apply(finalTrans);
        }
    }
    return await finalizeTransactionForRules(finalTrans);
}
function conditionSpecialCases(cond) {
    if (!cond) {
        return cond;
    }
    if (cond.op === "is" && cond.field === "category" && cond.value === null) {
        return new Condition("and", cond.field, [
            cond,
            new Condition("is", "transfer", false, null),
            new Condition("is", "parent", false, null)
        ], {});
    }
    else if (cond.op === "isNot" && cond.field === "category" && cond.value === null) {
        return new Condition("and", cond.field, [cond, new Condition("is", "parent", false, null)], {});
    }
    return cond;
}
function conditionsToAQL(conditions, { recurDateBounds = 100, applySpecialCases = true } = {}) {
    const errors2 = [];
    conditions = conditions.map((cond) => {
        if (cond instanceof Condition) {
            return cond;
        }
        try {
            return new Condition(cond.op, cond.field, cond.value, cond.options);
        }
        catch (e) {
            errors2.push(e.type || "internal");
            logger.log("conditionsToAQL: invalid condition: " + e.message);
            return null;
        }
    }).map((cond) => applySpecialCases ? conditionSpecialCases(cond) : cond).filter(Boolean);
    const mapConditionToActualQL = (cond) => {
        const { type: type2, options: options2 } = cond;
        let { field, op, value } = cond;
        const getValue = (value2) => {
            if (type2 === "number") {
                return value2.value;
            }
            return value2;
        };
        if (field === "transfer" && op === "is") {
            field = "transfer_id";
            if (value) {
                op = "isNot";
                value = null;
            }
            else {
                value = null;
            }
        }
        else if (field === "parent" && op === "is") {
            field = "is_parent";
            if (value) {
                op = "true";
            }
            else {
                op = "false";
            }
        }
        const apply2 = (field2, aqlOp, value2) => {
            if (type2 === "number") {
                if (options2) {
                    if (options2.outflow) {
                        return {
                            $and: [
                                { amount: { $lt: 0 } },
                                { [field2]: { $transform: "$neg", [aqlOp]: value2 } }
                            ]
                        };
                    }
                    else if (options2.inflow) {
                        return {
                            $and: [{ amount: { $gt: 0 } }, { [field2]: { [aqlOp]: value2 } }]
                        };
                    }
                }
                return { amount: { [aqlOp]: value2 } };
            }
            else if (type2 === "string") {
                return {
                    [field2]: {
                        $transform: op !== "hasTags" ? "$lower" : void 0,
                        [aqlOp]: value2
                    }
                };
            }
            else if (type2 === "date") {
                return { [field2]: { [aqlOp]: value2.date } };
            }
            return { [field2]: { [aqlOp]: value2 } };
        };
        switch (op) {
            case "isapprox":
            case "is":
                if (type2 === "date") {
                    if (value.type === "recur") {
                        const dates = value.schedule.occurrences({ take: recurDateBounds }).toArray().map((d) => dayFromDate(d.date));
                        return {
                            $or: dates.map((d) => {
                                if (op === "isapprox") {
                                    return {
                                        $and: [
                                            { date: { $gte: subDays(d, 2) } },
                                            { date: { $lte: addDays(d, 2) } }
                                        ]
                                    };
                                }
                                return { date: d };
                            })
                        };
                    }
                    else {
                        if (op === "isapprox") {
                            const fullDate = parseDate$1(value.date);
                            const high2 = addDays(fullDate, 2);
                            const low2 = subDays(fullDate, 2);
                            return {
                                $and: [{ date: { $gte: low2 } }, { date: { $lte: high2 } }]
                            };
                        }
                        else {
                            switch (value.type) {
                                case "date":
                                    return { date: value.date };
                                case "month": {
                                    const low2 = value.date + "-00";
                                    const high2 = value.date + "-99";
                                    return {
                                        $and: [{ date: { $gte: low2 } }, { date: { $lte: high2 } }]
                                    };
                                }
                                case "year": {
                                    const low2 = value.date + "-00-00";
                                    const high2 = value.date + "-99-99";
                                    return {
                                        $and: [{ date: { $gte: low2 } }, { date: { $lte: high2 } }]
                                    };
                                }
                            }
                        }
                    }
                }
                else if (type2 === "number") {
                    const number2 = value.value;
                    if (op === "isapprox") {
                        const threshold = getApproxNumberThreshold(number2);
                        return {
                            $and: [
                                apply2(field, "$gte", number2 - threshold),
                                apply2(field, "$lte", number2 + threshold)
                            ]
                        };
                    }
                    return apply2(field, "$eq", number2);
                }
                else if (type2 === "string") {
                    if (value === "") {
                        return {
                            $or: [apply2(field, "$eq", null), apply2(field, "$eq", "")]
                        };
                    }
                }
                return apply2(field, "$eq", value);
            case "isNot":
                return apply2(field, "$ne", value);
            case "isbetween":
                const [low, high] = sortNumbers(value.num1, value.num2);
                return {
                    [field]: [{ $gte: low }, { $lte: high }]
                };
            case "contains":
                return apply2(type2 === "id" ? field + ".name" : field, "$like", "%" + value + "%");
            case "matches":
                return apply2(type2 === "id" ? field + ".name" : field, "$regexp", value);
            case "doesNotContain":
                return apply2(type2 === "id" ? field + ".name" : field, "$notlike", "%" + value + "%");
            case "oneOf":
                const values = value;
                if (values.length === 0) {
                    return { id: null };
                }
                return { $or: values.map((v) => apply2(field, "$eq", v)) };
            case "hasTags":
                const tagValues = [];
                for (const [_, tag] of value.matchAll(/(?<!#)(#[^#\s]+)/g)) {
                    if (!tagValues.find((t2) => t2.tag === tag)) {
                        tagValues.push(tag);
                    }
                }
                return {
                    $and: tagValues.map((v) => {
                        const regex2 = new RegExp(`(?<!#)${v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}([\\s#]|$)`);
                        return apply2(field, "$regexp", regex2.source);
                    })
                };
            case "notOneOf":
                const notValues = value;
                if (notValues.length === 0) {
                    return { id: null };
                }
                return { $and: notValues.map((v) => apply2(field, "$ne", v)) };
            case "gt":
                return apply2(field, "$gt", getValue(value));
            case "gte":
                return apply2(field, "$gte", getValue(value));
            case "lt":
                return apply2(field, "$lt", getValue(value));
            case "lte":
                return apply2(field, "$lte", getValue(value));
            case "true":
                return apply2(field, "$eq", true);
            case "false":
                return apply2(field, "$eq", false);
            case "and":
                return {
                    $and: getValue(value).map((subExpr) => mapConditionToActualQL(subExpr))
                };
            case "onBudget":
                return { "account.offbudget": false };
            case "offBudget":
                return { "account.offbudget": true };
            default:
                throw new Error("Unhandled operator: " + op);
        }
    };
    const filters = conditions.map(mapConditionToActualQL);
    return { filters, errors: errors2 };
}
async function applyActions(transactions, actions) {
    const parsedActions = actions.map((action) => {
        if (action instanceof Action) {
            return action;
        }
        try {
            if (action.op === "set-split-amount") {
                return new Action(action.op, null, action.value, action.options);
            }
            else if (action.op === "link-schedule") {
                return new Action(action.op, null, action.value, null);
            }
            else if (action.op === "prepend-notes" || action.op === "append-notes") {
                return new Action(action.op, null, action.value, null);
            }
            return new Action(action.op, action.field, action.value, action.options);
        }
        catch (e) {
            logger.log("Action error", e);
            return null;
        }
    }).filter(Boolean);
    if (parsedActions.length !== actions.length) {
        return null;
    }
    const accounts = await getAccounts$2();
    const accountsMap = new Map(accounts.map((account) => [account.id, account]));
    const transactionsForRules = await Promise.all(transactions.map((transactions2) => prepareTransactionForRules(transactions2, accountsMap)));
    const updated = transactionsForRules.flatMap((trans) => {
        return ungroupTransaction(execActions(parsedActions, trans));
    });
    const finalized = [];
    for (const trans of updated) {
        finalized.push(await finalizeTransactionForRules(trans));
    }
    return batchUpdateTransactions({ updated: finalized });
}
function getRulesForPayee(payeeId) {
    const rules = /* @__PURE__ */ new Set();
    iterateIds(getRules$1(), "payee", (rule, id2) => {
        if (id2 === payeeId) {
            rules.add(rule);
        }
    });
    return rankRules([...rules]);
}
function* getIsSetterRules(stage, condField, actionField, { condValue, actionValue }) {
    const rules = getRules$1();
    for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        if (rule.stage === stage && rule.actions.length === 1 && rule.actions[0].op === "set" && rule.actions[0].field === actionField && (actionValue === void 0 || rule.actions[0].value === actionValue) && rule.conditions.length === 1 && (rule.conditions[0].op === "is" || rule.conditions[0].op === "isNot") && rule.conditions[0].field === condField && (condValue === void 0 || rule.conditions[0].value === condValue)) {
            yield rule.serialize();
        }
    }
    return null;
}
function* getOneOfSetterRules(stage, condField, actionField, { condValue, actionValue }) {
    const rules = getRules$1();
    for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        if (rule.stage === stage && rule.actions.length === 1 && rule.actions[0].op === "set" && rule.actions[0].field === actionField && (actionValue == null || rule.actions[0].value === actionValue) && rule.conditions.length === 1 && (rule.conditions[0].op === "oneOf" || rule.conditions[0].op === "oneOf") && rule.conditions[0].field === condField && (condValue == null || rule.conditions[0].value.indexOf(condValue) !== -1)) {
            yield rule.serialize();
        }
    }
    return null;
}
async function updatePayeeRenameRule(fromNames, to) {
    const renameRule = getOneOfSetterRules("pre", "imported_payee", "payee", {
        actionValue: to
    }).next().value;
    if (renameRule) {
        const condition = renameRule.conditions[0];
        const newValue = [
            ...fastSetMerge(new Set(condition.value), new Set(fromNames.filter((name) => name !== "")))
        ];
        const rule = {
            ...renameRule,
            conditions: [{ ...condition, value: newValue }]
        };
        await updateRule$1(rule);
        return renameRule.id;
    }
    else {
        const rule = new Rule2({
            stage: "pre",
            conditionsOp: "and",
            conditions: [{ op: "oneOf", field: "imported_payee", value: fromNames }],
            actions: [{ op: "set", field: "payee", value: to }]
        });
        return insertRule(rule.serialize());
    }
}
function getProbableCategory(transactions) {
    const scores = /* @__PURE__ */ new Map();
    transactions.forEach((trans) => {
        if (trans.category) {
            scores.set(trans.category, (scores.get(trans.category) || 0) + 1);
        }
    });
    const winner = transactions.reduce((winner2, trans) => {
        const score = scores.get(trans.category);
        if (!winner2 || score > winner2.score) {
            return { score, category: trans.category };
        }
        return winner2;
    }, null);
    return winner.score >= 3 ? winner.category : null;
}
async function updateCategoryRules(transactions) {
    if (transactions.length === 0) {
        return;
    }
    const payeeIds = new Set(transactions.map((trans) => trans.payee));
    const transIds = new Set(transactions.map((trans) => trans.id));
    let oldestDate = null;
    for (let i = 0; i < transactions.length; i++) {
        if (oldestDate === null || transactions[i].date < oldestDate) {
            oldestDate = transactions[i].date;
        }
    }
    oldestDate = subDays(oldestDate, 180);
    const register = await all(`SELECT t.* FROM v_transactions t
     LEFT JOIN accounts a ON a.id = t.account
     LEFT JOIN payees p ON p.id = t.payee
     WHERE date >= ? AND date <= ? AND is_parent = 0 AND a.closed = 0 AND p.learn_categories = 1
     ORDER BY date DESC`, [toDateRepr(oldestDate), toDateRepr(addDays(currentDay(), 180))]);
    const allTransactions = partitionByField(register, "payee");
    const categoriesToSet = /* @__PURE__ */ new Map();
    for (const payeeId of payeeIds) {
        if (payeeId) {
            const latestTrans = (allTransactions.get(payeeId) || []).slice(0, 5);
            if (latestTrans.find((trans) => transIds.has(trans.id))) {
                const category = getProbableCategory(latestTrans);
                if (category) {
                    categoriesToSet.set(payeeId, category);
                }
            }
        }
    }
    await batchMessages(async () => {
        for (const [payeeId, category] of categoriesToSet.entries()) {
            const ruleSetters = [
                ...getIsSetterRules(null, "payee", "category", {
                    condValue: payeeId
                })
            ];
            if (ruleSetters.length > 0) {
                for (const rule of ruleSetters) {
                    const action = rule.actions[0];
                    if (action.value !== category) {
                        await updateRule$1({
                            ...rule,
                            actions: [{ ...action, value: category }]
                        });
                    }
                }
            }
            else {
                const newRule = new Rule2({
                    stage: null,
                    conditionsOp: "and",
                    conditions: [{ op: "is", field: "payee", value: payeeId }],
                    actions: [{ op: "set", field: "category", value: category }]
                });
                await insertRule(newRule.serialize());
            }
        }
    });
}
async function prepareTransactionForRules(trans, accounts = null) {
    const r = { ...trans };
    if (trans.payee) {
        const payee = await getPayee$1(trans.payee);
        if (payee) {
            r.payee_name = payee.name;
        }
    }
    if (trans.account) {
        if (accounts !== null && accounts.has(trans.account)) {
            r._account = accounts.get(trans.account);
        }
        else {
            r._account = await getAccount(trans.account);
        }
    }
    return r;
}
async function finalizeTransactionForRules(trans) {
    if ("payee_name" in trans) {
        if (trans.payee === "new") {
            if (trans.payee_name) {
                let payeeId = (await getPayeeByName(trans.payee_name))?.id;
                payeeId ??= await insertPayee({
                    name: trans.payee_name
                });
                trans.payee = payeeId;
            }
            else {
                trans.payee = null;
            }
        }
        delete trans.payee_name;
    }
    return trans;
}
async function getPayee(acct) {
    return first("SELECT * FROM payees WHERE transfer_acct = ?", [
        acct
    ]);
}
async function getTransferredAccount(transaction2) {
    if (transaction2.payee) {
        const result = await first("SELECT transfer_acct FROM v_payees WHERE id = ?", [transaction2.payee]);
        return result?.transfer_acct || null;
    }
    return null;
}
async function clearCategory(transaction2, transferAcct) {
    const { offbudget: fromOffBudget } = await first("SELECT offbudget FROM accounts WHERE id = ?", [transaction2.account]);
    const { offbudget: toOffBudget } = await first("SELECT offbudget FROM accounts WHERE id = ?", [transferAcct]);
    if (fromOffBudget === toOffBudget) {
        await updateTransaction$2({ id: transaction2.id, category: null });
        if (transaction2.transfer_id) {
            await updateTransaction$2({
                id: transaction2.transfer_id,
                category: null
            });
        }
        return true;
    }
    return false;
}
async function addTransfer(transaction2, transferredAccount) {
    if (transaction2.is_parent) {
        return null;
    }
    const { id: fromPayee } = await first("SELECT id FROM payees WHERE transfer_acct = ?", [transaction2.account]);
    const transferTransaction = {
        account: transferredAccount,
        amount: -transaction2.amount,
        payee: fromPayee,
        date: transaction2.date,
        transfer_id: transaction2.id,
        notes: transaction2.notes || null,
        schedule: transaction2.schedule,
        cleared: false
    };
    const { notes, cleared } = await runRules$1(transferTransaction);
    const id2 = await insertTransaction({
        ...transferTransaction,
        notes,
        cleared
    });
    await updateTransaction$2({ id: transaction2.id, transfer_id: id2 });
    const categoryCleared = await clearCategory(transaction2, transferredAccount);
    return {
        id: transaction2.id,
        transfer_id: id2,
        ...categoryCleared ? { category: null } : {}
    };
}
async function removeTransfer(transaction2) {
    const transferTrans = await getTransaction(transaction2.transfer_id);
    if (transferTrans) {
        if (transferTrans.is_child) {
            await updateTransaction$2({
                id: transaction2.transfer_id,
                transfer_id: null,
                payee: null
            });
        }
        else {
            await deleteTransaction$2({ id: transaction2.transfer_id });
        }
    }
    await updateTransaction$2({ id: transaction2.id, transfer_id: null });
    return { id: transaction2.id, transfer_id: null };
}
async function updateTransfer(transaction2, transferredAccount) {
    const payee = await getPayee(transaction2.account);
    await updateTransaction$2({
        id: transaction2.transfer_id,
        account: transferredAccount,
        // Make sure to update the payee on the other side in case the
        // user moved this transaction into another account
        payee: payee.id,
        date: transaction2.date,
        notes: transaction2.notes,
        amount: -transaction2.amount,
        schedule: transaction2.schedule
    });
    const categoryCleared = await clearCategory(transaction2, transferredAccount);
    if (categoryCleared) {
        return { id: transaction2.id, category: null };
    }
}
async function onInsert(transaction2) {
    const transferredAccount = await getTransferredAccount(transaction2);
    if (transferredAccount) {
        return addTransfer(transaction2, transferredAccount);
    }
}
async function onDelete(transaction2) {
    if (transaction2.transfer_id) {
        await removeTransfer(transaction2);
    }
}
async function onUpdate(transaction2) {
    const transferredAccount = await getTransferredAccount(transaction2);
    if (transaction2.is_parent) {
        return removeTransfer(transaction2);
    }
    if (transferredAccount && !transaction2.transfer_id) {
        return addTransfer(transaction2, transferredAccount);
    }
    if (!transferredAccount && transaction2.transfer_id) {
        return removeTransfer(transaction2);
    }
    if (transferredAccount && transaction2.transfer_id) {
        return updateTransfer(transaction2, transferredAccount);
    }
}
async function idsWithChildren(ids) {
    const whereIds = whereIn(ids, "parent_id");
    const rows = await all(`SELECT id FROM v_transactions_internal WHERE ${whereIds}`);
    const set = new Set(ids);
    for (const row of rows) {
        set.add(row.id);
    }
    return [...set];
}
async function getTransactionsByIds(ids) {
    return incrFetch((query, params) => selectWithSchema("transactions", query, params), ids, 
    // eslint-disable-next-line actual/typography
    (id2) => `id = '${id2}'`, (where) => `SELECT * FROM v_transactions_internal WHERE ${where}`);
}
async function batchUpdateTransactions({ added, deleted, updated, learnCategories = false, detectOrphanPayees = true, runTransfers = true }) {
    let addedIds = [];
    const updatedIds = updated ? updated.map((u) => u.id) : [];
    const deletedIds = deleted ? await idsWithChildren(deleted.map((d) => d.id)) : [];
    const oldPayees = /* @__PURE__ */ new Set();
    const accounts = await all("SELECT * FROM accounts WHERE tombstone = 0");
    if (updated) {
        const descUpdatedIds = updated.filter((update2) => update2.payee).map((update2) => update2.id);
        const transactions = await getTransactionsByIds(descUpdatedIds);
        for (let i = 0; i < transactions.length; i++) {
            oldPayees.add(transactions[i].payee);
        }
    }
    await batchMessages(async () => {
        if (added) {
            addedIds = await Promise.all(added.map(async (t2) => {
                const account = accounts.find((acct) => acct.id === t2.account);
                if (t2.is_parent || account.offbudget === 1) {
                    t2.category = null;
                }
                return insertTransaction(t2);
            }));
        }
        if (deleted) {
            await Promise.all(
            // It's important to use `deletedIds` and not `deleted` here
            // because we've expanded it to include children above. The
            // inconsistency of the delete APIs is annoying and should
            // be fixed (it should only take an id)
            deletedIds.map(async (id2) => {
                await deleteTransaction$2({ id: id2 });
            }));
        }
        if (updated) {
            await Promise.all(updated.map(async (t2) => {
                if (t2.account) {
                    const account = accounts.find((acct) => acct.id === t2.account);
                    if (t2.is_parent || account.offbudget === 1) {
                        t2.category = null;
                    }
                }
                await updateTransaction$2(t2);
            }));
        }
    });
    const allAdded = await getTransactionsByIds(addedIds);
    const allUpdated = await getTransactionsByIds(updatedIds);
    const allDeleted = await getTransactionsByIds(deletedIds);
    const resultAdded = allAdded;
    const resultUpdated = allUpdated;
    let transfersUpdated;
    if (runTransfers) {
        await batchMessages(async () => {
            await Promise.all(allAdded.map((t2) => onInsert(t2)));
            transfersUpdated = (await Promise.all(allUpdated.map((t2) => onUpdate(t2)))).filter(Boolean);
            await Promise.all(allDeleted.map((t2) => onDelete(t2)));
        });
    }
    if (learnCategories) {
        const ids = /* @__PURE__ */ new Set([
            ...added ? added.filter((add2) => add2.category).map((add2) => add2.id) : [],
            ...updated ? updated.filter((update2) => update2.category).map((update2) => update2.id) : []
        ]);
        await updateCategoryRules(allAdded.concat(allUpdated).filter((trans) => ids.has(trans.id)));
    }
    if (detectOrphanPayees) {
        if (updated) {
            const newPayeeIds = updated.map((u) => u.payee).filter(Boolean);
            if (newPayeeIds.length > 0) {
                const allOrphaned = new Set(await getOrphanedPayees$1());
                [...oldPayees].filter((id2) => allOrphaned.has(id2));
            }
        }
    }
    return {
        added: resultAdded,
        updated: runTransfers ? transfersUpdated : resultUpdated,
        deleted: allDeleted
    };
}
const mappingsFromString = (str) => {
    try {
        const parsed = JSON.parse(str);
        if (typeof parsed !== "object" || parsed === null) {
            throw new Error("Invalid mapping format");
        }
        return new Map(Object.entries(parsed).map(([key, value]) => [
            key,
            new Map(Object.entries(value))
        ]));
    }
    catch (e) {
        const message2 = e instanceof Error ? e.message : e;
        throw new Error(`Failed to parse mapping: ${message2}`);
    }
};
const defaultMappings = /* @__PURE__ */ new Map([
    [
        "payment",
        /* @__PURE__ */ new Map([
            ["date", "date"],
            ["payee", "payeeName"],
            ["notes", "notes"]
        ])
    ],
    [
        "deposit",
        /* @__PURE__ */ new Map([
            ["date", "date"],
            ["payee", "payeeName"],
            ["notes", "notes"]
        ])
    ]
]);
const conjunctions = [
    "for",
    //
    "and",
    "nor",
    "but",
    "or",
    "yet",
    "so"
];
const articles = [
    "a",
    //
    "an",
    "the"
];
const prepositions = [
    "aboard",
    "about",
    "above",
    "across",
    "after",
    "against",
    "along",
    "amid",
    "among",
    "anti",
    "around",
    "as",
    "at",
    "before",
    "behind",
    "below",
    "beneath",
    "beside",
    "besides",
    "between",
    "beyond",
    "but",
    "by",
    "concerning",
    "considering",
    "despite",
    "down",
    "during",
    "except",
    "excepting",
    "excluding",
    "following",
    "for",
    "from",
    "in",
    "inside",
    "into",
    "like",
    "minus",
    "near",
    "of",
    "off",
    "on",
    "onto",
    "opposite",
    "over",
    "past",
    "per",
    "plus",
    "regarding",
    "round",
    "save",
    "since",
    "than",
    "through",
    "to",
    "toward",
    "towards",
    "under",
    "underneath",
    "unlike",
    "until",
    "up",
    "upon",
    "versus",
    "via",
    "with",
    "within",
    "without"
];
const lowerCaseSet = /* @__PURE__ */ new Set([
    ...conjunctions,
    ...articles,
    ...prepositions
]);
const specials = [
    "CLI",
    "API",
    "HTTP",
    "HTTPS",
    "JSX",
    "DNS",
    "URL",
    "CI",
    "CDN",
    "GitHub",
    "CSS",
    "JS",
    "JavaScript",
    "TypeScript",
    "HTML",
    "WordPress",
    "JavaScript",
    "Next.js",
    "Node.js"
];
const character = "[0-9A-Za-z---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]";
const regex = new RegExp(`(?:(?:(\\s?(?:^|[.\\(\\)!?;:"-])\\s*)(${character}))|(${character}))(${character}*[']*${character}*)`, "g");
const convertToRegExp = (specials2) => specials2.map((s) => [new RegExp(`\\b${s}\\b`, "gi"), s]);
function parseMatch(match2) {
    const firstCharacter = match2[0];
    if (/\s/.test(firstCharacter)) {
        return match2.substr(1);
    }
    if (/[()]/.test(firstCharacter)) {
        return null;
    }
    return match2;
}
function title(str, options2 = { special: void 0 }) {
    str = str.toLowerCase().replace(regex, (m, lead = "", forced, lower, rest) => {
        const parsedMatch = parseMatch(m);
        if (!parsedMatch) {
            return m;
        }
        if (!forced) {
            const fullLower = lower + rest;
            if (lowerCaseSet.has(fullLower)) {
                return parsedMatch;
            }
        }
        return lead + (lower || forced).toUpperCase() + rest;
    });
    const customSpecials = options2.special || [];
    const replace = [...specials, ...customSpecials];
    const replaceRegExp = convertToRegExp(replace);
    replaceRegExp.forEach(([pattern, s]) => {
        str = str.replace(pattern, s);
    });
    return str;
}
function BankSyncError2(type2, code, details) {
    return { type: "BankSyncError", category: type2, code, details };
}
function makeSplitTransaction(trans, subtransactions) {
    const { subtransactions: sub, ...parent } = recalculateSplit({
        ...trans,
        is_parent: true,
        subtransactions: subtransactions.map((transaction2, idx) => makeChild(trans, {
            ...transaction2,
            sort_order: 0 - idx
        }))
    });
    return [parent, ...sub];
}
async function updateAccountBalance(id2, balance) {
    await runQuery("UPDATE accounts SET balance_current = ? WHERE id = ?", [
        balance,
        id2
    ]);
}
async function getAccountOldestTransaction(id2) {
    return (await aqlQuery(q("transactions").filter({
        account: id2,
        date: { $lte: currentDay() }
    }).select("date").orderBy("date").limit(1))).data?.[0];
}
async function getAccountSyncStartDate(id2) {
    const dates = [subDays(currentDay(), 90)];
    const oldestTransaction = await getAccountOldestTransaction(id2);
    if (oldestTransaction)
        dates.push(oldestTransaction.date);
    return dayFromDate(max$1(dates.map((d) => parseDate$1(d))));
}
async function downloadGoCardlessTransactions(userId, userKey, acctId, bankId, since, includeBalance = true) {
    const userToken = await getItem("user-token");
    if (!userToken)
        return;
    logger.log("Pulling transactions from GoCardless");
    const res = await post(getServer().GOCARDLESS_SERVER + "/transactions", {
        userId,
        key: userKey,
        requisitionId: bankId,
        accountId: acctId,
        startDate: since,
        includeBalance
    }, {
        "X-ACTUAL-TOKEN": userToken
    });
    if (res.error_code) {
        const errorDetails = {
            rateLimitHeaders: res.rateLimitHeaders
        };
        throw BankSyncError2(res.error_type, res.error_code, errorDetails);
    }
    if (includeBalance) {
        const { transactions: { all: all2 }, balances, startingBalance } = res;
        logger.log("Response:", res);
        return {
            transactions: all2,
            accountBalance: balances,
            startingBalance
        };
    }
    else {
        logger.log("Response:", res);
        return {
            transactions: res.transactions.all
        };
    }
}
async function downloadSimpleFinTransactions(acctId, since) {
    const userToken = await getItem("user-token");
    if (!userToken)
        return;
    const batchSync = Array.isArray(acctId);
    logger.log("Pulling transactions from SimpleFin");
    let res;
    try {
        res = await post(getServer().SIMPLEFIN_SERVER + "/transactions", {
            accountId: acctId,
            startDate: since
        }, {
            "X-ACTUAL-TOKEN": userToken
        }, 
        // 5 minute timeout for batch sync, one minute for individual accounts
        Array.isArray(acctId) ? 3e5 : 6e4);
    }
    catch (error) {
        logger.error("Suspected timeout during bank sync:", error);
        throw BankSyncError2("TIMED_OUT", "TIMED_OUT");
    }
    if (Object.keys(res).length === 0) {
        throw BankSyncError2("NO_DATA", "NO_DATA");
    }
    if (res.error_code) {
        throw BankSyncError2(res.error_type, res.error_code);
    }
    let retVal = {};
    if (batchSync) {
        for (const [accountId, data] of Object.entries(res)) {
            if (accountId === "errors")
                continue;
            const error = res?.errors?.[accountId]?.[0];
            retVal[accountId] = {
                transactions: data?.transactions?.all,
                accountBalance: data?.balances,
                startingBalance: data?.startingBalance
            };
            if (error) {
                retVal[accountId].error_type = error.error_type;
                retVal[accountId].error_code = error.error_code;
            }
        }
    }
    else {
        const singleRes = res;
        retVal = {
            transactions: singleRes.transactions.all,
            accountBalance: singleRes.balances,
            startingBalance: singleRes.startingBalance
        };
    }
    logger.log("Response:", retVal);
    return retVal;
}
async function downloadPluggyAiTransactions(acctId, since) {
    const userToken = await getItem("user-token");
    if (!userToken)
        return;
    logger.log("Pulling transactions from Pluggy.ai");
    const res = await post(getServer().PLUGGYAI_SERVER + "/transactions", {
        accountId: acctId,
        startDate: since
    }, {
        "X-ACTUAL-TOKEN": userToken
    }, 6e4);
    if (res.error_code) {
        throw BankSyncError2(res.error_type, res.error_code);
    }
    else if ("error" in res) {
        throw BankSyncError2("Connection", res.error);
    }
    let retVal = {};
    const singleRes = res;
    retVal = {
        transactions: singleRes.transactions.all,
        accountBalance: singleRes.balances,
        startingBalance: singleRes.startingBalance
    };
    logger.log("Response:", retVal);
    return retVal;
}
async function resolvePayee(trans, payeeName, payeesToCreate) {
    if (trans.payee == null && payeeName) {
        let payee = payeesToCreate.get(payeeName.toLowerCase());
        payee = payee || await getPayeeByName(payeeName);
        if (payee != null) {
            return payee.id;
        }
        else {
            const newPayee = { id: v4(), name: payeeName };
            payeesToCreate.set(payeeName.toLowerCase(), newPayee);
            return newPayee.id;
        }
    }
    return trans.payee;
}
async function normalizeTransactions(transactions, acctId, { rawPayeeName = false } = {}) {
    const payeesToCreate = /* @__PURE__ */ new Map();
    const normalized = [];
    for (let trans of transactions) {
        if (trans.date == null) {
            throw new Error("`date` is required when adding a transaction");
        }
        const { payee_name: originalPayeeName, subtransactions, ...rest } = trans;
        trans = rest;
        let payee_name = originalPayeeName;
        if (payee_name) {
            const trimmed = payee_name.trim();
            if (trimmed === "") {
                payee_name = null;
            }
            else {
                payee_name = rawPayeeName ? trimmed : title(trimmed);
            }
        }
        trans.imported_payee = trans.imported_payee || payee_name;
        if (trans.imported_payee) {
            trans.imported_payee = trans.imported_payee.trim();
        }
        trans.account = acctId;
        trans.payee = await resolvePayee(trans, payee_name, payeesToCreate);
        trans.category = trans.category ?? null;
        normalized.push({
            payee_name,
            subtransactions: subtransactions ? subtransactions.map((t2) => ({ ...t2, account: acctId })) : null,
            trans
        });
    }
    return { normalized, payeesToCreate };
}
async function normalizeBankSyncTransactions(transactions, acctId) {
    const payeesToCreate = /* @__PURE__ */ new Map();
    const [customMappingsRaw, importPending, importNotes] = await Promise.all([
        aqlQuery(q("preferences").filter({ id: `custom-sync-mappings-${acctId}` }).select("value")).then((data) => data?.data?.[0]?.value),
        aqlQuery(q("preferences").filter({ id: `sync-import-pending-${acctId}` }).select("value")).then((data) => String(data?.data?.[0]?.value ?? "true") === "true"),
        aqlQuery(q("preferences").filter({ id: `sync-import-notes-${acctId}` }).select("value")).then((data) => String(data?.data?.[0]?.value ?? "true") === "true")
    ]);
    const mappings = customMappingsRaw ? mappingsFromString(customMappingsRaw) : defaultMappings;
    const normalized = [];
    for (const trans of transactions) {
        trans.cleared = Boolean(trans.booked);
        if (!importPending && !trans.cleared)
            continue;
        if (!trans.amount) {
            trans.amount = trans.transactionAmount.amount;
        }
        const mapping = mappings.get(trans.amount <= 0 ? "payment" : "deposit");
        const date = trans[mapping.get("date")] ?? trans.date;
        const payeeName = trans[mapping.get("payee")] ?? trans.payeeName;
        const notes = trans[mapping.get("notes")];
        if (date == null) {
            throw new Error("`date` is required when adding a transaction");
        }
        if (payeeName == null) {
            throw new Error("`payeeName` is required when adding a transaction");
        }
        trans.imported_payee = trans.imported_payee || payeeName;
        if (trans.imported_payee) {
            trans.imported_payee = trans.imported_payee.trim();
        }
        let imported_id = trans.transactionId;
        if (trans.cleared && !trans.transactionId && trans.internalTransactionId) {
            imported_id = `${trans.account}-${trans.internalTransactionId}`;
        }
        trans.account = acctId;
        trans.payee = await resolvePayee(trans, payeeName, payeesToCreate);
        normalized.push({
            payee_name: payeeName,
            trans: {
                amount: amountToInteger$1(trans.amount),
                payee: trans.payee,
                account: trans.account,
                date,
                notes: importNotes && notes ? notes.trim().replace(/#/g, "##") : null,
                category: trans.category ?? null,
                imported_id,
                imported_payee: trans.imported_payee,
                cleared: trans.cleared,
                raw_synced_data: JSON.stringify(trans)
            }
        });
    }
    return { normalized, payeesToCreate };
}
async function createNewPayees(payeesToCreate, addsAndUpdates) {
    const usedPayeeIds = new Set(addsAndUpdates.map((t2) => t2.payee));
    await batchMessages(async () => {
        for (const payee of payeesToCreate.values()) {
            if (usedPayeeIds.has(payee.id)) {
                await insertPayee(payee);
            }
        }
    });
}
async function reconcileTransactions(acctId, transactions, isBankSyncAccount = false, strictIdChecking = true, isPreview = false, defaultCleared = true) {
    logger.log("Performing transaction reconciliation");
    const updated = [];
    const added = [];
    const updatedPreview = [];
    const existingPayeeMap = /* @__PURE__ */ new Map();
    const { payeesToCreate, transactionsStep1, transactionsStep2, transactionsStep3 } = await matchTransactions(acctId, transactions, isBankSyncAccount, strictIdChecking);
    for (const { trans, subtransactions, match: match2 } of transactionsStep3) {
        if (match2 && !trans.forceAddTransaction) {
            if (match2.reconciled) {
                updatedPreview.push({ transaction: trans, ignored: true });
                continue;
            }
            const existing = {
                ...match2,
                cleared: match2.cleared === 1,
                date: fromDateRepr(match2.date)
            };
            const updates = {
                imported_id: trans.imported_id || null,
                payee: existing.payee || trans.payee || null,
                category: existing.category || trans.category || null,
                imported_payee: trans.imported_payee || null,
                notes: existing.notes || trans.notes || null,
                cleared: trans.cleared ?? existing.cleared,
                raw_synced_data: existing.raw_synced_data ?? trans.raw_synced_data ?? null
            };
            const fieldsToMarkUpdated = Object.keys(updates).filter((k) => {
                if (!existing.raw_synced_data && !trans.raw_synced_data) {
                    return k !== "raw_synced_data";
                }
                return true;
            });
            if (hasFieldsChanged(existing, updates, fieldsToMarkUpdated)) {
                updated.push({ id: existing.id, ...updates });
                if (!existingPayeeMap.has(existing.payee)) {
                    const payee = await getPayee$1(existing.payee);
                    existingPayeeMap.set(existing.payee, payee?.name);
                }
                existing.payee_name = existingPayeeMap.get(existing.payee);
                existing.amount = integerToAmount(existing.amount);
                updatedPreview.push({ transaction: trans, existing });
            }
            else {
                updatedPreview.push({ transaction: trans, ignored: true });
            }
            if (existing.is_parent && existing.cleared !== updates.cleared) {
                const children2 = await all("SELECT id FROM v_transactions WHERE parent_id = ?", [existing.id]);
                for (const child of children2) {
                    updated.push({ id: child.id, cleared: updates.cleared });
                }
            }
        }
        else {
            const { forceAddTransaction, ...newTrans } = trans;
            const finalTransaction = {
                ...newTrans,
                id: v4(),
                category: trans.category || null,
                cleared: trans.cleared ?? defaultCleared
            };
            if (subtransactions && subtransactions.length > 0) {
                added.push(...makeSplitTransaction(finalTransaction, subtransactions));
            }
            else {
                added.push(finalTransaction);
            }
        }
    }
    const now = Date.now();
    added.forEach((t2, index) => {
        t2.sort_order ??= now - index;
    });
    if (!isPreview) {
        await createNewPayees(payeesToCreate, [...added, ...updated]);
        await batchUpdateTransactions({ added, updated });
    }
    logger.log("Debug data for the operations:", {
        transactionsStep1,
        transactionsStep2,
        transactionsStep3,
        added,
        updated,
        updatedPreview
    });
    return {
        added: added.map((trans) => trans.id),
        updated: updated.map((trans) => trans.id),
        updatedPreview
    };
}
async function matchTransactions(acctId, transactions, isBankSyncAccount = false, strictIdChecking = true) {
    logger.log("Performing transaction reconciliation matching");
    const reimportDeleted = await aqlQuery(q("preferences").filter({ id: `sync-reimport-deleted-${acctId}` }).select("value")).then((data) => String(data?.data?.[0]?.value ?? "true") === "true");
    const hasMatched = /* @__PURE__ */ new Set();
    const transactionNormalization = isBankSyncAccount ? normalizeBankSyncTransactions : normalizeTransactions;
    const { normalized, payeesToCreate } = await transactionNormalization(transactions, acctId);
    const accounts = await getAccounts$2();
    const accountsMap = new Map(accounts.map((account) => [account.id, account]));
    const transactionsStep1 = [];
    for (const { payee_name, trans: originalTrans, subtransactions } of normalized) {
        const trans = await runRules$1(originalTrans, accountsMap);
        let match2 = null;
        let fuzzyDataset = null;
        if (trans.imported_id) {
            const table = reimportDeleted ? "v_transactions" : "v_transactions_internal";
            match2 = await first(`SELECT * FROM ${table} WHERE imported_id = ? AND account = ?`, [trans.imported_id, acctId]);
            if (match2) {
                hasMatched.add(match2.id);
            }
        }
        if (!match2) {
            const sevenDaysBefore = toDateRepr(subDays(trans.date, 7));
            const sevenDaysAfter = toDateRepr(addDays(trans.date, 7));
            if (strictIdChecking) {
                fuzzyDataset = await all(`SELECT id, is_parent, date, imported_id, payee, imported_payee, category, notes, reconciled, cleared, amount
          FROM v_transactions
          WHERE
            -- If both ids are set, and we didn't match earlier then skip dedup
            (imported_id IS NULL OR ? IS NULL)
            AND date >= ? AND date <= ? AND amount = ?
            AND account = ?`, [
                    trans.imported_id || null,
                    sevenDaysBefore,
                    sevenDaysAfter,
                    trans.amount || 0,
                    acctId
                ]);
            }
            else {
                fuzzyDataset = await all(`SELECT id, is_parent, date, imported_id, payee, imported_payee, category, notes, reconciled, cleared, amount
          FROM v_transactions
          WHERE date >= ? AND date <= ? AND amount = ? AND account = ?`, [sevenDaysBefore, sevenDaysAfter, trans.amount || 0, acctId]);
            }
            fuzzyDataset = fuzzyDataset.sort((a, b) => {
                const aDistance = Math.abs(differenceInMilliseconds(parseISO(trans.date), parseISO(fromDateRepr(a.date))));
                const bDistance = Math.abs(differenceInMilliseconds(parseISO(trans.date), parseISO(fromDateRepr(b.date))));
                return aDistance > bDistance ? 1 : -1;
            });
        }
        transactionsStep1.push({
            payee_name,
            trans,
            subtransactions: trans.subtransactions || subtransactions,
            match: match2,
            fuzzyDataset
        });
    }
    const transactionsStep2 = transactionsStep1.map((data) => {
        if (!data.match && data.fuzzyDataset) {
            const match2 = data.fuzzyDataset.find((row) => !hasMatched.has(row.id) && data.trans.payee === row.payee);
            if (match2) {
                hasMatched.add(match2.id);
                return { ...data, match: match2 };
            }
        }
        return data;
    });
    const transactionsStep3 = transactionsStep2.map((data) => {
        if (!data.match && data.fuzzyDataset) {
            const match2 = data.fuzzyDataset.find((row) => !hasMatched.has(row.id));
            if (match2) {
                hasMatched.add(match2.id);
                return { ...data, match: match2 };
            }
        }
        return data;
    });
    return {
        payeesToCreate,
        transactionsStep1,
        transactionsStep2,
        transactionsStep3
    };
}
async function addTransactions$1(acctId, transactions, { runTransfers = true, learnCategories = false } = {}) {
    const added = [];
    const { normalized, payeesToCreate } = await normalizeTransactions(transactions, acctId, { rawPayeeName: true });
    const accounts = await getAccounts$2();
    const accountsMap = new Map(accounts.map((account) => [account.id, account]));
    for (const { trans: originalTrans, subtransactions } of normalized) {
        const trans = await runRules$1(originalTrans, accountsMap);
        const finalTransaction = {
            id: v4(),
            ...trans,
            account: acctId,
            cleared: trans.cleared != null ? trans.cleared : true
        };
        const updatedSubtransactions = finalTransaction.subtransactions || subtransactions;
        if (updatedSubtransactions && updatedSubtransactions.length > 0) {
            added.push(...makeSplitTransaction(finalTransaction, updatedSubtransactions));
        }
        else {
            added.push(finalTransaction);
        }
    }
    await createNewPayees(payeesToCreate, added);
    let newTransactions;
    if (runTransfers || learnCategories) {
        const res = await batchUpdateTransactions({
            added,
            learnCategories,
            runTransfers
        });
        newTransactions = res.added.map((t2) => t2.id);
    }
    else {
        await batchMessages(async () => {
            newTransactions = await Promise.all(added.map(async (trans) => insertTransaction(trans)));
        });
    }
    return newTransactions;
}
async function processBankSyncDownload(download2, id2, acctRow, initialSync = false) {
    const useStrictIdChecking = !acctRow.account_sync_source;
    const importTransactions2 = await aqlQuery(q("preferences").filter({ id: `sync-import-transactions-${id2}` }).select("value")).then((data) => String(data?.data?.[0]?.value ?? "true") === "true");
    const { transactions: originalTransactions, startingBalance: currentBalance } = download2;
    if (initialSync) {
        const { transactions: transactions2 } = download2;
        let balanceToUse = currentBalance;
        if (acctRow.account_sync_source === "simpleFin") {
            const previousBalance = transactions2.reduce((total, trans) => {
                return total - parseInt(trans.transactionAmount.amount.replace(".", ""));
            }, currentBalance);
            balanceToUse = previousBalance;
        }
        if (acctRow.account_sync_source === "pluggyai") {
            const currentBalance2 = download2.startingBalance;
            const previousBalance = transactions2.reduce((total, trans) => total - trans.transactionAmount.amount * 100, currentBalance2);
            balanceToUse = Math.round(previousBalance);
        }
        const oldestTransaction = transactions2[transactions2.length - 1];
        const oldestDate = transactions2.length > 0 ? oldestTransaction.date : currentDay();
        const payee = await getStartingBalancePayee();
        return runMutator(async () => {
            const initialId = await insertTransaction({
                account: id2,
                amount: balanceToUse,
                category: acctRow.offbudget === 0 ? payee.category : null,
                payee: payee.id,
                date: oldestDate,
                cleared: true,
                starting_balance_flag: true
            });
            const result = await reconcileTransactions(id2, transactions2, true, useStrictIdChecking);
            return {
                ...result,
                added: [initialId, ...result.added]
            };
        });
    }
    const transactions = originalTransactions.map((trans) => ({
        ...trans,
        account: id2
    }));
    return runMutator(async () => {
        const result = await reconcileTransactions(id2, importTransactions2 ? transactions : [], true, useStrictIdChecking);
        if (currentBalance != null) {
            await updateAccountBalance(id2, currentBalance);
        }
        return result;
    });
}
async function syncAccount(userId, userKey, id2, acctId, bankId) {
    const acctRow = await select("accounts", id2);
    const syncStartDate = await getAccountSyncStartDate(id2);
    const oldestTransaction = await getAccountOldestTransaction(id2);
    const newAccount = oldestTransaction == null;
    let download2;
    if (acctRow.account_sync_source === "simpleFin") {
        download2 = await downloadSimpleFinTransactions(acctId, syncStartDate);
    }
    else if (acctRow.account_sync_source === "pluggyai") {
        download2 = await downloadPluggyAiTransactions(acctId, syncStartDate);
    }
    else if (acctRow.account_sync_source === "goCardless") {
        download2 = await downloadGoCardlessTransactions(userId, userKey, acctId, bankId, syncStartDate, newAccount);
    }
    else {
        throw new Error(`Unrecognized bank-sync provider: ${acctRow.account_sync_source}`);
    }
    return processBankSyncDownload(download2, id2, acctRow, newAccount);
}
async function simpleFinBatchSync$1(accounts) {
    const startDates = await Promise.all(accounts.map(async (a) => getAccountSyncStartDate(a.id)));
    const res = await downloadSimpleFinTransactions(accounts.map((a) => a.account_id), startDates);
    const promises = [];
    for (let i = 0; i < accounts.length; i++) {
        const account = accounts[i];
        const download2 = res[account.account_id];
        const acctRow = await select("accounts", account.id);
        const oldestTransaction = await getAccountOldestTransaction(account.id);
        const newAccount = oldestTransaction == null;
        if (download2.error_code) {
            promises.push(Promise.resolve({
                accountId: account.id,
                res: download2
            }));
            continue;
        }
        promises.push(processBankSyncDownload(download2, account.id, acctRow, newAccount).then((res2) => ({
            accountId: account.id,
            res: res2
        })));
    }
    return await Promise.all(promises);
}
async function updateAccount({ id: id2, name, last_reconciled }) {
    await update("accounts", {
        id: id2,
        name,
        ...last_reconciled && { last_reconciled }
    });
    return {};
}
async function getAccounts$1() {
    return getAccounts$2();
}
async function getAccountBalance({ id: id2, cutoff }) {
    const result = await first("SELECT sum(amount) as balance FROM transactions WHERE acct = ? AND isParent = 0 AND tombstone = 0 AND date <= ?", [id2, toDateRepr(dayFromDate(cutoff))]);
    return result?.balance ? result.balance : 0;
}
async function getAccountProperties({ id: id2 }) {
    const balanceResult = await first("SELECT sum(amount) as balance FROM transactions WHERE acct = ? AND isParent = 0 AND tombstone = 0", [id2]);
    const countResult = await first("SELECT count(id) as count FROM transactions WHERE acct = ? AND tombstone = 0", [id2]);
    return {
        balance: balanceResult?.balance || 0,
        numTransactions: countResult?.count || 0
    };
}
async function linkGoCardlessAccount({ requisitionId, account, upgradingId, offBudget = false }) {
    let id2;
    const bank = await findOrCreateBank(account.institution, requisitionId);
    if (upgradingId) {
        const accRow = await first("SELECT * FROM accounts WHERE id = ?", [upgradingId]);
        if (!accRow) {
            throw new Error(`Account with ID ${upgradingId} not found.`);
        }
        id2 = accRow.id;
        await update("accounts", {
            id: id2,
            account_id: account.account_id,
            bank: bank.id,
            account_sync_source: "goCardless"
        });
    }
    else {
        id2 = v4();
        await insertWithUUID("accounts", {
            id: id2,
            account_id: account.account_id,
            mask: account.mask,
            name: account.name,
            official_name: account.official_name,
            bank: bank.id,
            offbudget: offBudget ? 1 : 0,
            account_sync_source: "goCardless"
        });
        await insertPayee({
            name: "",
            transfer_acct: id2
        });
    }
    await syncAccount(void 0, void 0, id2, account.account_id, bank.bank_id);
    return "ok";
}
async function linkSimpleFinAccount({ externalAccount, upgradingId, offBudget = false }) {
    let id2;
    const institution = {
        name: externalAccount.institution ?? t("Unknown")
    };
    const bank = await findOrCreateBank(institution, externalAccount.orgDomain ?? externalAccount.orgId);
    if (upgradingId) {
        const accRow = await first("SELECT * FROM accounts WHERE id = ?", [upgradingId]);
        if (!accRow) {
            throw new Error(`Account with ID ${upgradingId} not found.`);
        }
        id2 = accRow.id;
        await update("accounts", {
            id: id2,
            account_id: externalAccount.account_id,
            bank: bank.id,
            account_sync_source: "simpleFin"
        });
    }
    else {
        id2 = v4();
        await insertWithUUID("accounts", {
            id: id2,
            account_id: externalAccount.account_id,
            name: externalAccount.name,
            official_name: externalAccount.name,
            bank: bank.id,
            offbudget: offBudget ? 1 : 0,
            account_sync_source: "simpleFin"
        });
        await insertPayee({
            name: "",
            transfer_acct: id2
        });
    }
    await syncAccount(void 0, void 0, id2, externalAccount.account_id, bank.bank_id);
    await send$1();
    return "ok";
}
async function linkPluggyAiAccount({ externalAccount, upgradingId, offBudget = false }) {
    let id2;
    const institution = {
        name: externalAccount.institution ?? t("Unknown")
    };
    const bank = await findOrCreateBank(institution, externalAccount.orgDomain ?? externalAccount.orgId);
    if (upgradingId) {
        const accRow = await first("SELECT * FROM accounts WHERE id = ?", [upgradingId]);
        if (!accRow) {
            throw new Error(`Account with ID ${upgradingId} not found.`);
        }
        id2 = accRow.id;
        await update("accounts", {
            id: id2,
            account_id: externalAccount.account_id,
            bank: bank.id,
            account_sync_source: "pluggyai"
        });
    }
    else {
        id2 = v4();
        await insertWithUUID("accounts", {
            id: id2,
            account_id: externalAccount.account_id,
            name: externalAccount.name,
            official_name: externalAccount.name,
            bank: bank.id,
            offbudget: offBudget ? 1 : 0,
            account_sync_source: "pluggyai"
        });
        await insertPayee({
            name: "",
            transfer_acct: id2
        });
    }
    await syncAccount(void 0, void 0, id2, externalAccount.account_id, bank.bank_id);
    await send$1();
    return "ok";
}
async function createAccount$1({ name, balance = 0, offBudget = false, closed = false }) {
    const id2 = await insertAccount({
        name,
        offbudget: offBudget ? 1 : 0,
        closed: closed ? 1 : 0
    });
    await insertPayee({
        name: "",
        transfer_acct: id2
    });
    if (balance != null && balance !== 0) {
        const payee = await getStartingBalancePayee();
        await insertTransaction({
            account: id2,
            amount: amountToInteger$1(balance),
            category: offBudget ? null : payee.category,
            payee: payee.id,
            date: currentDay(),
            cleared: true,
            starting_balance_flag: true
        });
    }
    return id2;
}
async function closeAccount({ id: id2, transferAccountId, categoryId, forced = false }) {
    await unlinkAccount({ id: id2 });
    return withUndo(async () => {
        const account = await first("SELECT * FROM accounts WHERE id = ? AND tombstone = 0", [id2]);
        if (!account || account.closed === 1) {
            return;
        }
        const { balance, numTransactions } = await getAccountProperties({ id: id2 });
        if (numTransactions === 0) {
            await deleteAccount({ id: id2 });
        }
        else if (forced) {
            const rows = await runQuery("SELECT id, transfer_id FROM v_transactions WHERE account = ?", [id2], true);
            const transferPayee = await first("SELECT id FROM payees WHERE transfer_acct = ?", [id2]);
            if (!transferPayee) {
                throw new Error(`Transfer payee with account ID ${id2} not found.`);
            }
            await batchMessages(async () => {
                rows.forEach((row) => {
                    if (row.transfer_id) {
                        updateTransaction$2({
                            id: row.transfer_id,
                            payee: null,
                            transfer_id: null
                        });
                    }
                    deleteTransaction$2({ id: row.id });
                });
                deleteAccount({ id: id2 });
                deleteTransferPayee({ id: transferPayee.id });
            });
        }
        else {
            if (balance !== 0 && transferAccountId == null) {
                throw APIError("balance is non-zero: transferAccountId is required");
            }
            if (id2 === transferAccountId) {
                throw APIError("transfer account can not be the account being closed");
            }
            await update("accounts", { id: id2, closed: 1 });
            if (balance !== 0 && transferAccountId) {
                const transferPayee = await first("SELECT id FROM payees WHERE transfer_acct = ?", [transferAccountId]);
                if (!transferPayee) {
                    throw new Error(`Transfer payee with account ID ${transferAccountId} not found.`);
                }
                await app$j.handlers["transaction-add"]({
                    id: v4(),
                    payee: transferPayee.id,
                    amount: -balance,
                    account: id2,
                    date: currentDay(),
                    notes: "Closing account",
                    category: categoryId
                });
            }
        }
    });
}
async function reopenAccount({ id: id2 }) {
    await update("accounts", { id: id2, closed: 0 });
}
async function moveAccount({ id: id2, targetId }) {
    await moveAccount$1(id2, targetId);
}
async function setSecret({ name, value }) {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    try {
        return await post(serverConfig.BASE_SERVER + "/secret", {
            name,
            value
        }, {
            "X-ACTUAL-TOKEN": userToken
        });
    }
    catch (error) {
        return {
            error: "failed",
            reason: error instanceof PostError ? error.reason : void 0
        };
    }
}
async function checkSecret(name) {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    try {
        return await get$2(serverConfig.BASE_SERVER + "/secret/" + name, {
            "X-ACTUAL-TOKEN": userToken
        });
    }
    catch (error) {
        logger.error(error);
        return { error: "failed" };
    }
}
let stopPolling = false;
async function pollGoCardlessWebToken({ requisitionId }) {
    const userToken = await getItem("user-token");
    if (!userToken)
        return { error: "unknown" };
    const startTime = Date.now();
    stopPolling = false;
    async function getData(cb) {
        if (stopPolling) {
            return;
        }
        if (Date.now() - startTime >= 1e3 * 60 * 10) {
            cb({ status: "timeout" });
            return;
        }
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("Failed to get server config.");
        }
        const data = await post(serverConfig.GOCARDLESS_SERVER + "/get-accounts", {
            requisitionId
        }, {
            "X-ACTUAL-TOKEN": userToken
        });
        if (data) {
            if (data.error_code) {
                logger.error("Failed linking gocardless account:", data);
                cb({ status: "unknown", message: data.error_type });
            }
            else {
                cb({ status: "success", data });
            }
        }
        else {
            setTimeout(() => getData(cb), 3e3);
        }
    }
    return new Promise((resolve) => {
        getData((data) => {
            if (data.status === "success") {
                resolve({ data: data.data });
                return;
            }
            if (data.status === "timeout") {
                resolve({ error: data.status });
                return;
            }
            resolve({
                error: data.status,
                message: data.message
            });
        });
    });
}
async function stopGoCardlessWebTokenPolling() {
    stopPolling = true;
    return "ok";
}
async function goCardlessStatus() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    return post(serverConfig.GOCARDLESS_SERVER + "/status", {}, {
        "X-ACTUAL-TOKEN": userToken
    });
}
async function simpleFinStatus() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    return post(serverConfig.SIMPLEFIN_SERVER + "/status", {}, {
        "X-ACTUAL-TOKEN": userToken
    });
}
async function pluggyAiStatus() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    return post(serverConfig.PLUGGYAI_SERVER + "/status", {}, {
        "X-ACTUAL-TOKEN": userToken
    });
}
async function simpleFinAccounts() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    try {
        return await post(serverConfig.SIMPLEFIN_SERVER + "/accounts", {}, {
            "X-ACTUAL-TOKEN": userToken
        }, 6e4);
    }
    catch (error) {
        return { error_code: "TIMED_OUT" };
    }
}
async function pluggyAiAccounts() {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    try {
        return await post(serverConfig.PLUGGYAI_SERVER + "/accounts", {}, {
            "X-ACTUAL-TOKEN": userToken
        }, 6e4);
    }
    catch (error) {
        return { error_code: "TIMED_OUT" };
    }
}
async function getGoCardlessBanks(country) {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    return post(serverConfig.GOCARDLESS_SERVER + "/get-banks", { country, showDemo: isNonProductionEnvironment() }, {
        "X-ACTUAL-TOKEN": userToken
    });
}
async function createGoCardlessWebToken({ institutionId, accessValidForDays }) {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "unauthorized" };
    }
    const serverConfig = getServer();
    if (!serverConfig) {
        throw new Error("Failed to get server config.");
    }
    try {
        return await post(serverConfig.GOCARDLESS_SERVER + "/create-web-token", {
            institutionId,
            accessValidForDays
        }, {
            "X-ACTUAL-TOKEN": userToken
        });
    }
    catch (error) {
        logger.error(error);
        return { error: "failed" };
    }
}
async function handleSyncResponse(res, acct) {
    const { added, updated } = res;
    const newTransactions = [];
    const matchedTransactions = [];
    const updatedAccounts = [];
    newTransactions.push(...added);
    matchedTransactions.push(...updated);
    if (added.length > 0) {
        updatedAccounts.push(acct.id);
    }
    const ts = ( /* @__PURE__ */new Date()).getTime().toString();
    await update("accounts", { id: acct.id, last_sync: ts });
    return {
        newTransactions,
        matchedTransactions,
        updatedAccounts
    };
}
function handleSyncError(err, acct) {
    if (err instanceof BankSyncError$1 || err?.type === "BankSyncError") {
        const error = err;
        const syncError = {
            type: "SyncError",
            accountId: acct.id,
            message: "Failed syncing account " + acct.name + ".",
            category: error.category,
            code: error.code
        };
        if (error.category === "RATE_LIMIT_EXCEEDED") {
            return {
                ...syncError,
                message: `Failed syncing account ${acct.name}. Rate limit exceeded. Please try again later.`
            };
        }
        return syncError;
    }
    if (err instanceof PostError && err.reason !== "internal") {
        return {
            accountId: acct.id,
            message: err.reason ? err.reason : `Account ${acct.name} is not linked properly. Please link it again.`
        };
    }
    return {
        accountId: acct.id,
        message: "There was an internal error. Please get in touch https://actualbudget.org/contact for support.",
        internal: err.stack
    };
}
async function accountsBankSync({ ids = [] }) {
    const { "user-id": userId, "user-key": userKey } = await multiGet(["user-id", "user-key"]);
    const accounts = await runQuery(`
    SELECT a.*, b.bank_id as bankId
    FROM accounts a
    LEFT JOIN banks b ON a.bank = b.id
    WHERE a.tombstone = 0 AND a.closed = 0
      ${ids.length ? `AND a.id IN (${ids.map(() => "?").join(", ")})` : ""}
    ORDER BY a.offbudget, a.sort_order
  `, ids, true);
    const errors2 = [];
    const newTransactions = [];
    const matchedTransactions = [];
    const updatedAccounts = [];
    for (const acct of accounts) {
        if (acct.bankId && acct.account_id) {
            try {
                logger.group("Bank Sync operation for account:", acct.name);
                const syncResponse = await syncAccount(userId, userKey, acct.id, acct.account_id, acct.bankId);
                const syncResponseData = await handleSyncResponse(syncResponse, acct);
                newTransactions.push(...syncResponseData.newTransactions);
                matchedTransactions.push(...syncResponseData.matchedTransactions);
                updatedAccounts.push(...syncResponseData.updatedAccounts);
            }
            catch (err) {
                const error = err;
                errors2.push(handleSyncError(error, acct));
                captureException({
                    ...error,
                    message: "Failed syncing account " + acct.name + "."
                });
            }
            finally {
                logger.groupEnd();
            }
        }
    }
    if (updatedAccounts.length > 0)
        ;
    return { errors: errors2, newTransactions, matchedTransactions, updatedAccounts };
}
async function simpleFinBatchSync({ ids = [] }) {
    const accounts = await runQuery(`SELECT a.*, b.bank_id as bankId FROM accounts a
         LEFT JOIN banks b ON a.bank = b.id
         WHERE
          a.tombstone = 0
          AND a.closed = 0
          AND a.account_sync_source = 'simpleFin'
          ${ids.length ? `AND a.id IN (${ids.map(() => "?").join(", ")})` : ""}
         ORDER BY a.offbudget, a.sort_order`, ids.length ? ids : [], true);
    const retVal = [];
    logger.group("Bank Sync operation for all SimpleFin accounts");
    try {
        const syncResponses = await simpleFinBatchSync$1(accounts.map((a) => ({
            id: a.id,
            account_id: a.account_id || null
        })));
        for (const syncResponse of syncResponses) {
            const account = accounts.find((a) => a.id === syncResponse.accountId);
            if (!account) {
                logger.error(`Invalid account ID found in response: ${syncResponse.accountId}. Proceeding to the next account...`);
                continue;
            }
            const errors2 = [];
            const newTransactions = [];
            const matchedTransactions = [];
            const updatedAccounts = [];
            if (syncResponse.res.error_code) {
                errors2.push(handleSyncError({
                    type: "BankSyncError",
                    reason: "Failed syncing account " + account.name + ".",
                    category: syncResponse.res.error_type,
                    code: syncResponse.res.error_code
                }, account));
            }
            else {
                const syncResponseData = await handleSyncResponse(syncResponse.res, account);
                newTransactions.push(...syncResponseData.newTransactions);
                matchedTransactions.push(...syncResponseData.matchedTransactions);
                updatedAccounts.push(...syncResponseData.updatedAccounts);
            }
            retVal.push({
                accountId: syncResponse.accountId,
                res: { errors: errors2, newTransactions, matchedTransactions, updatedAccounts }
            });
        }
    }
    catch (err) {
        const errors2 = [];
        for (const account of accounts) {
            retVal.push({
                accountId: account.id,
                res: {
                    errors: errors2,
                    newTransactions: [],
                    matchedTransactions: [],
                    updatedAccounts: []
                }
            });
            const error = err;
            errors2.push(handleSyncError(error, account));
        }
    }
    if (retVal.some((a) => a.res.updatedAccounts.length > 0))
        ;
    logger.groupEnd();
    return retVal;
}
async function importTransactions$2({ accountId, transactions, isPreview, opts }) {
    if (typeof accountId !== "string") {
        throw APIError("transactions-import: accountId must be an id");
    }
    try {
        const reconciled = await reconcileTransactions(accountId, transactions, false, true, isPreview, opts?.defaultCleared);
        return {
            errors: [],
            added: reconciled.added,
            updated: reconciled.updated,
            updatedPreview: reconciled.updatedPreview
        };
    }
    catch (err) {
        if (err instanceof TransactionError) {
            return {
                errors: [{ message: err.message }],
                added: [],
                updated: [],
                updatedPreview: []
            };
        }
        throw err;
    }
}
async function unlinkAccount({ id: id2 }) {
    const accRow = await first("SELECT * FROM accounts WHERE id = ?", [id2]);
    if (!accRow) {
        throw new Error(`Account with ID ${id2} not found.`);
    }
    const bankId = accRow.bank;
    if (!bankId) {
        return "ok";
    }
    const isGoCardless = accRow.account_sync_source === "goCardless";
    await updateAccount$1({
        id: id2,
        account_id: null,
        bank: null,
        balance_current: null,
        balance_available: null,
        balance_limit: null,
        account_sync_source: null
    });
    if (isGoCardless === false) {
        return;
    }
    const accountWithBankResult = await first("SELECT COUNT(*) as count FROM accounts WHERE bank = ?", [bankId]);
    const userToken = await getItem("user-token");
    if (!userToken) {
        return "ok";
    }
    if (!accountWithBankResult || accountWithBankResult.count === 0) {
        const bank = await first("SELECT bank_id FROM banks WHERE id = ?", [bankId]);
        if (!bank) {
            throw new Error(`Bank with ID ${bankId} not found.`);
        }
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("Failed to get server config.");
        }
        const requisitionId = bank.bank_id;
        try {
            await post(serverConfig.GOCARDLESS_SERVER + "/remove-account", {
                requisitionId
            }, {
                "X-ACTUAL-TOKEN": userToken
            });
        }
        catch (error) {
            logger.log({ error });
        }
    }
    return "ok";
}
const app$i = createApp();
app$i.method("account-update", mutator(undoable(updateAccount)));
app$i.method("accounts-get", getAccounts$1);
app$i.method("account-balance", getAccountBalance);
app$i.method("account-properties", getAccountProperties);
app$i.method("gocardless-accounts-link", linkGoCardlessAccount);
app$i.method("simplefin-accounts-link", linkSimpleFinAccount);
app$i.method("pluggyai-accounts-link", linkPluggyAiAccount);
app$i.method("account-create", mutator(undoable(createAccount$1)));
app$i.method("account-close", mutator(closeAccount));
app$i.method("account-reopen", mutator(undoable(reopenAccount)));
app$i.method("account-move", mutator(undoable(moveAccount)));
app$i.method("secret-set", setSecret);
app$i.method("secret-check", checkSecret);
app$i.method("gocardless-poll-web-token", pollGoCardlessWebToken);
app$i.method("gocardless-poll-web-token-stop", stopGoCardlessWebTokenPolling);
app$i.method("gocardless-status", goCardlessStatus);
app$i.method("simplefin-status", simpleFinStatus);
app$i.method("pluggyai-status", pluggyAiStatus);
app$i.method("simplefin-accounts", simpleFinAccounts);
app$i.method("pluggyai-accounts", pluggyAiAccounts);
app$i.method("gocardless-get-banks", getGoCardlessBanks);
app$i.method("gocardless-create-web-token", createGoCardlessWebToken);
app$i.method("accounts-bank-sync", accountsBankSync);
app$i.method("simplefin-batch-sync", simpleFinBatchSync);
app$i.method("transactions-import", mutator(undoable(importTransactions$2)));
app$i.method("account-unlink", mutator(unlinkAccount));
const app$h = createApp();
app$h.method("users-get", getUsers);
app$h.method("user-delete-all", deleteAllUsers);
app$h.method("user-add", addUser);
app$h.method("user-update", updateUser);
app$h.method("access-add", addAccess);
app$h.method("access-delete-all", deleteAllAccess);
app$h.method("access-get-available-users", accessGetAvailableUsers);
app$h.method("transfer-ownership", transferOwnership);
app$h.method("owner-created", ownerCreated);
async function getUsers() {
    const userToken = await getItem("user-token");
    if (userToken) {
        const res = await get$2(getServer().BASE_SERVER + "/admin/users/", {
            headers: {
                "X-ACTUAL-TOKEN": userToken
            }
        });
        if (res) {
            try {
                const list = JSON.parse(res);
                return list;
            }
            catch (err) {
                return { error: "Failed to parse response: " + err.message };
            }
        }
    }
    return null;
}
async function deleteAllUsers(ids) {
    const userToken = await getItem("user-token");
    if (userToken) {
        try {
            const res = await del(getServer().BASE_SERVER + "/admin/users", {
                ids
            }, {
                "X-ACTUAL-TOKEN": userToken
            });
            if (res) {
                return res;
            }
        }
        catch (err) {
            return { error: err.reason };
        }
    }
    return { someDeletionsFailed: true };
}
async function addUser(user) {
    const userToken = await getItem("user-token");
    if (userToken) {
        try {
            const res = await post(getServer().BASE_SERVER + "/admin/users/", user, {
                "X-ACTUAL-TOKEN": userToken
            });
            return res;
        }
        catch (err) {
            return { error: err.reason };
        }
    }
    return null;
}
async function updateUser(user) {
    const userToken = await getItem("user-token");
    if (userToken) {
        try {
            const res = await patch(getServer().BASE_SERVER + "/admin/users/", user, {
                "X-ACTUAL-TOKEN": userToken
            });
            return res;
        }
        catch (err) {
            return { error: err.reason };
        }
    }
    return null;
}
async function addAccess(access) {
    const userToken = await getItem("user-token");
    if (userToken) {
        try {
            await post(getServer().BASE_SERVER + "/admin/access/", access, {
                "X-ACTUAL-TOKEN": userToken
            });
            return {};
        }
        catch (err) {
            return { error: err.reason };
        }
    }
    return null;
}
async function deleteAllAccess({ fileId, ids }) {
    const userToken = await getItem("user-token");
    if (userToken) {
        try {
            const res = await del(getServer().BASE_SERVER + `/admin/access?fileId=${fileId}`, {
                token: userToken,
                ids
            });
            if (res) {
                return res;
            }
        }
        catch (err) {
            return { error: err.reason };
        }
    }
    return { someDeletionsFailed: true };
}
async function accessGetAvailableUsers(fileId) {
    const userToken = await getItem("user-token");
    if (userToken) {
        const res = await get$2(`${getServer().BASE_SERVER + "/admin/access/users"}?fileId=${fileId}`, {
            headers: {
                "X-ACTUAL-TOKEN": userToken
            }
        });
        if (res) {
            try {
                return JSON.parse(res);
            }
            catch (err) {
                return { error: "Failed to parse response: " + err.message };
            }
        }
    }
    return [];
}
async function transferOwnership({ fileId, newUserId }) {
    const userToken = await getItem("user-token");
    if (userToken) {
        try {
            await post(getServer().BASE_SERVER + "/admin/access/transfer-ownership/", { fileId, newUserId }, {
                "X-ACTUAL-TOKEN": userToken
            });
        }
        catch (err) {
            return { error: err.reason };
        }
    }
    return {};
}
async function ownerCreated() {
    const res = await get$2(getServer().BASE_SERVER + "/admin/owner-created/");
    if (res) {
        return JSON.parse(res);
    }
    return null;
}
function getDownloadError({ reason, meta, fileName }) {
    switch (reason) {
        case "network":
        case "download-failure":
            return t("Downloading the file failed. Check your network connection.");
        case "not-zip-file":
        case "invalid-zip-file":
        case "invalid-meta-file":
            return t("Downloaded file is invalid, sorry! Visit https://actualbudget.org/contact/ for support.");
        case "decrypt-failure":
            return "Unable to decrypt file " + (fileName || "(unknown)") + ". To change your key, first download this file with the proper password.";
        case "out-of-sync-migrations":
            return t("This budget cannot be loaded with this version of the app. Make sure the app is up-to-date.");
        default:
            const info = meta && typeof meta === "object" && "fileId" in meta && meta.fileId ? `, fileId: ${meta.fileId}` : "";
            return t("Something went wrong trying to download that file, sorry! Visit https://actualbudget.org/contact/ for support. reason: {{reason}}{{info}}", { reason, info });
    }
}
function getTestKeyError({ reason }) {
    switch (reason) {
        case "network":
            return t("Unable to connect to the server. We need to access the server to get some information about your keys.");
        case "old-key-style":
            return t("This file is encrypted with an old unsupported key style. Recreate the key on a device where the file is available, or use an older version of Actual to download it.");
        case "decrypt-failure":
            return t("Unable to decrypt file with this password. Please try again.");
        default:
            return t("Something went wrong trying to create a key, sorry! Visit https://actualbudget.org/contact/ for support.");
    }
}
function getSyncError(error, id2) {
    if (error === "out-of-sync-migrations" || error === "out-of-sync-data") {
        return t("This budget cannot be loaded with this version of the app.");
    }
    else if (error === "budget-not-found") {
        return t("Budget {{id}} not found. Check the ID of your budget in the Advanced section of the settings page.", { id: id2 });
    }
    else {
        return t("We had an unknown problem opening {{id}}.", { id: id2 });
    }
}
function getBankSyncError(error) {
    return error.message || t("We had an unknown problem syncing the account.");
}
const accountModel = {
    ...accountModel$1,
    toExternal(account) {
        return {
            id: account.id,
            name: account.name,
            offbudget: account.offbudget ? true : false,
            closed: account.closed ? true : false
        };
    },
    fromExternal(account) {
        const result = { ...account };
        if ("offbudget" in account) {
            result.offbudget = account.offbudget ? 1 : 0;
        }
        if ("closed" in account) {
            result.closed = account.closed ? 1 : 0;
        }
        return result;
    }
};
const categoryModel = {
    ...categoryModel$1,
    toExternal(category) {
        return {
            id: category.id,
            name: category.name,
            is_income: category.is_income ? true : false,
            hidden: category.hidden ? true : false,
            group_id: category.group
        };
    },
    fromExternal(category) {
        const { group_id, ...apiCategory } = category;
        const result = {
            ...apiCategory,
            group: group_id
        };
        return result;
    }
};
const categoryGroupModel = {
    ...categoryGroupModel$1,
    toExternal(group) {
        return {
            id: group.id,
            name: group.name,
            is_income: group.is_income ? true : false,
            hidden: group.hidden ? true : false,
            categories: group.categories?.map(categoryModel.toExternal) || []
        };
    },
    fromExternal(group) {
        const result = { ...group };
        if ("categories" in group) {
            result.categories = group.categories.map(categoryModel.fromExternal);
        }
        return result;
    }
};
const payeeModel = {
    ...payeeModel$1,
    toExternal(payee) {
        return {
            id: payee.id,
            name: payee.name,
            transfer_acct: payee.transfer_acct
        };
    },
    fromExternal(payee) {
        return payee;
    }
};
const remoteFileModel = {
    toExternal(file) {
        if (file.deleted) {
            return null;
        }
        return {
            cloudFileId: file.fileId,
            state: "remote",
            groupId: file.groupId,
            name: file.name,
            encryptKeyId: file.encryptKeyId,
            hasKey: file.hasKey,
            owner: file.owner,
            usersWithAccess: file.usersWithAccess
        };
    },
    fromExternal(file) {
        return { deleted: false, fileId: file.cloudFileId, ...file };
    }
};
const budgetModel = {
    toExternal(file) {
        return file;
    },
    fromExternal(file) {
        return file;
    }
};
const scheduleModel = {
    toExternal(schedule) {
        return {
            id: schedule.id,
            name: schedule.name,
            rule: schedule.rule,
            next_date: schedule.next_date,
            completed: schedule.completed,
            posts_transaction: schedule.posts_transaction,
            payee: schedule._payee,
            account: schedule._account,
            amount: schedule._amount,
            amountOp: schedule._amountOp,
            // e.g. 'isapprox', 'is', etc.
            date: schedule._date
        };
    },
    //just an update
    fromExternal(schedule) {
        const result = {
            id: schedule.id,
            name: schedule.name,
            rule: String(schedule.rule),
            next_date: String(schedule.next_date),
            completed: Boolean(schedule.completed),
            posts_transaction: schedule.posts_transaction,
            tombstone: false,
            _payee: String(schedule.payee),
            _account: String(schedule.account),
            _amount: schedule.amount,
            _amountOp: schedule.amountOp,
            // e.g. 'isapprox', 'is', etc.
            _date: schedule.date,
            _conditions: [
                { op: "is", field: "payee", value: String(schedule.payee) },
                { op: "is", field: "account", value: String(schedule.account) },
                { op: "isapprox", field: "date", value: schedule.date },
                { op: schedule.amountOp, field: "amount", value: schedule.amount }
            ],
            _actions: []
            // empty array, as you requested
        };
        return result;
    }
};
let IMPORT_MODE = false;
function withMutation(handler) {
    return (...args) => {
        return runMutator(async () => {
            const latestTimestamp = getClock().timestamp.toString();
            const result = await handler(...args);
            await all("SELECT DISTINCT dataset FROM messages_crdt WHERE timestamp > ?", [latestTimestamp]);
            return result;
        }, { undoDisabled: true });
    };
}
let handlers = {};
async function validateMonth(month) {
    if (!month.match(/^\d{4}-\d{2}$/)) {
        throw APIError("Invalid month format, use YYYY-MM: " + month);
    }
    if (!IMPORT_MODE) {
        const { start, end } = await handlers["get-budget-bounds"]();
        const range2 = range$1(start, end);
        if (!range2.includes(month)) {
            throw APIError("No budget exists for month: " + month);
        }
    }
}
async function validateExpenseCategory(debug, id2) {
    if (id2 == null) {
        throw APIError(`${debug}: category id is required`);
    }
    const row = await first("SELECT is_income FROM categories WHERE id = ?", [id2]);
    if (!row) {
        throw APIError(`${debug}: category ${id2} does not exist`);
    }
    if (row.is_income !== 0) {
        throw APIError(`${debug}: category ${id2} is not an expense category`);
    }
}
function checkFileOpen() {
    if (!(getPrefs() || {}).id) {
        throw APIError("No budget file is open");
    }
}
let batchPromise = null;
handlers["api/batch-budget-start"] = async function () {
    if (batchPromise) {
        throw APIError("Cannot start a batch process: batch already started");
    }
    if (IMPORT_MODE) {
        asyncTransaction(() => {
            return new Promise((resolve, reject) => {
                batchPromise = { resolve, reject };
            });
        });
    }
    else {
        batchMessages(() => {
            return new Promise((resolve, reject) => {
                batchPromise = { resolve, reject };
            });
        });
    }
};
handlers["api/batch-budget-end"] = async function () {
    if (!batchPromise) {
        throw APIError("Cannot end a batch process: no batch started");
    }
    batchPromise.resolve();
    batchPromise = null;
};
handlers["api/load-budget"] = async function ({ id: id2 }) {
    const { id: currentId } = getPrefs() || {};
    if (currentId !== id2) {
        const { error } = await handlers["load-budget"]({ id: id2 });
        if (!error)
            ;
        else {
            throw new Error(getSyncError(error, id2));
        }
    }
};
handlers["api/download-budget"] = async function ({ syncId, password }) {
    const { id: currentId } = getPrefs() || {};
    if (currentId) {
        await handlers["close-budget"]();
    }
    const budgets = await handlers["get-budgets"]();
    const localBudget = budgets.find((b) => b.groupId === syncId);
    let remoteBudget;
    if (!localBudget) {
        const files = await handlers["get-remote-files"]();
        if (!files) {
            throw new Error("Could not get remote files");
        }
        const file = files.find((f2) => f2.groupId === syncId);
        if (!file) {
            throw new Error(`Budget ${syncId} not found. Check the sync id of your budget in the Advanced section of the settings page.`);
        }
        remoteBudget = file;
    }
    const activeFile = remoteBudget ? remoteBudget : localBudget;
    if (activeFile.encryptKeyId) {
        if (!password) {
            throw new Error(`File ${activeFile.name} is encrypted. Please provide a password.`);
        }
        const result2 = await handlers["key-test"]({
            cloudFileId: remoteBudget ? remoteBudget.fileId : localBudget.cloudFileId,
            password
        });
        if (result2.error) {
            throw new Error(getTestKeyError(result2.error));
        }
    }
    if (localBudget) {
        await handlers["load-budget"]({ id: localBudget.id });
        const result2 = await handlers["sync-budget"]();
        if (result2.error) {
            throw new Error(getSyncError(result2.error, localBudget.id));
        }
        return;
    }
    const result = await handlers["download-budget"]({
        cloudFileId: remoteBudget.fileId
    });
    if (result.error) {
        logger.log("Full error details", result.error);
        throw new Error(getDownloadError(result.error));
    }
    await handlers["load-budget"]({ id: result.id });
};
handlers["api/get-budgets"] = async function () {
    const budgets = await handlers["get-budgets"]();
    const files = await handlers["get-remote-files"]() || [];
    return [
        ...budgets.map((file) => budgetModel.toExternal(file)),
        ...files.map((file) => remoteFileModel.toExternal(file)).filter((file) => file)
    ];
};
handlers["api/sync"] = async function () {
    const { id: id2 } = getPrefs();
    const result = await handlers["sync-budget"]();
    if (result.error) {
        throw new Error(getSyncError(result.error, id2));
    }
};
handlers["api/bank-sync"] = async function (args) {
    const batchSync = args?.accountId == null;
    const allErrors = [];
    if (!batchSync) {
        const { errors: errors22 } = await handlers["accounts-bank-sync"]({
            ids: [args.accountId]
        });
        allErrors.push(...errors22);
    }
    else {
        const accountsData = await handlers["accounts-get"]();
        const accountIdsToSync = accountsData.map((a) => a.id);
        const simpleFinAccounts2 = accountsData.filter((a) => a.account_sync_source === "simpleFin");
        const simpleFinAccountIds = simpleFinAccounts2.map((a) => a.id);
        if (simpleFinAccounts2.length > 1) {
            const res = await handlers["simplefin-batch-sync"]({
                ids: simpleFinAccountIds
            });
            res.forEach((a) => allErrors.push(...a.res.errors));
        }
        const { errors: errors22 } = await handlers["accounts-bank-sync"]({
            ids: accountIdsToSync.filter((a) => !simpleFinAccountIds.includes(a))
        });
        allErrors.push(...errors22);
    }
    const errors2 = allErrors.filter((e) => e != null);
    if (errors2.length > 0) {
        throw new Error(getBankSyncError(errors2[0]));
    }
};
handlers["api/start-import"] = async function ({ budgetName }) {
    await handlers["close-budget"]();
    await handlers["create-budget"]({ budgetName, avoidUpload: true });
    await runQuery("DELETE FROM categories WHERE is_income = 0");
    await runQuery("DELETE FROM category_groups WHERE is_income = 0");
    setSyncingMode("import");
    IMPORT_MODE = true;
};
handlers["api/finish-import"] = async function () {
    checkFileOpen();
    get$3().markCacheDirty();
    const { id: id2 } = getPrefs();
    await handlers["close-budget"]();
    await handlers["load-budget"]({ id: id2 });
    await handlers["get-budget-bounds"]();
    await waitOnSpreadsheet();
    await upload().catch(() => {
    });
    IMPORT_MODE = false;
};
handlers["api/abort-import"] = async function () {
    if (IMPORT_MODE) {
        checkFileOpen();
        const { id: id2 } = getPrefs();
        await handlers["close-budget"]();
        await handlers["delete-budget"]({ id: id2 });
    }
    IMPORT_MODE = false;
};
handlers["api/query"] = async function ({ query }) {
    checkFileOpen();
    return aqlQuery(query);
};
handlers["api/budget-months"] = async function () {
    checkFileOpen();
    const { start, end } = await handlers["get-budget-bounds"]();
    return range$1(start, end);
};
handlers["api/budget-month"] = async function ({ month }) {
    checkFileOpen();
    await validateMonth(month);
    const { data: groups } = await aqlQuery(q("category_groups").select("*"));
    const sheetName = sheetForMonth(month);
    function value(name) {
        const v = get$3().getCellValue(sheetName, name);
        return v === "" ? 0 : v;
    }
    return {
        month,
        incomeAvailable: value("available-funds"),
        lastMonthOverspent: value("last-month-overspent"),
        forNextMonth: value("buffered"),
        totalBudgeted: value("total-budgeted"),
        toBudget: value("to-budget"),
        fromLastMonth: value("from-last-month"),
        totalIncome: value("total-income"),
        totalSpent: value("total-spent"),
        totalBalance: value("total-leftover"),
        categoryGroups: groups.map((group) => {
            if (group.is_income) {
                return {
                    ...categoryGroupModel.toExternal(group),
                    received: value("total-income"),
                    categories: group.categories.map((cat) => ({
                        ...categoryModel.toExternal(cat),
                        received: value(`sum-amount-${cat.id}`)
                    }))
                };
            }
            return {
                ...categoryGroupModel.toExternal(group),
                budgeted: value(`group-budget-${group.id}`),
                spent: value(`group-sum-amount-${group.id}`),
                balance: value(`group-leftover-${group.id}`),
                categories: group.categories.map((cat) => ({
                    ...categoryModel.toExternal(cat),
                    budgeted: value(`budget-${cat.id}`),
                    spent: value(`sum-amount-${cat.id}`),
                    balance: value(`leftover-${cat.id}`),
                    carryover: value(`carryover-${cat.id}`)
                }))
            };
        })
    };
};
handlers["api/budget-set-amount"] = withMutation(async function ({ month, categoryId, amount }) {
    checkFileOpen();
    return handlers["budget/budget-amount"]({
        month,
        category: categoryId,
        amount
    });
});
handlers["api/budget-set-carryover"] = withMutation(async function ({ month, categoryId, flag }) {
    checkFileOpen();
    await validateMonth(month);
    await validateExpenseCategory("budget-set-carryover", categoryId);
    return handlers["budget/set-carryover"]({
        startMonth: month,
        category: categoryId,
        flag
    });
});
handlers["api/budget-hold-for-next-month"] = withMutation(async function ({ month, amount }) {
    checkFileOpen();
    await validateMonth(month);
    if (amount <= 0) {
        throw APIError("Amount to hold needs to be greater than 0");
    }
    return handlers["budget/hold-for-next-month"]({
        month,
        amount
    });
});
handlers["api/budget-reset-hold"] = withMutation(async function ({ month }) {
    checkFileOpen();
    await validateMonth(month);
    return handlers["budget/reset-hold"]({ month });
});
handlers["api/transactions-export"] = async function ({ transactions, categoryGroups, payees, accounts }) {
    checkFileOpen();
    return handlers["transactions-export"]({
        transactions,
        categoryGroups,
        payees,
        accounts
    });
};
handlers["api/transactions-import"] = withMutation(async function ({ accountId, transactions, isPreview = false, opts }) {
    checkFileOpen();
    return handlers["transactions-import"]({
        accountId,
        transactions,
        isPreview,
        opts
    });
});
handlers["api/transactions-add"] = withMutation(async function ({ accountId, transactions, runTransfers = false, learnCategories = false }) {
    checkFileOpen();
    await addTransactions$1(accountId, transactions, {
        runTransfers,
        learnCategories
    });
    return "ok";
});
handlers["api/transactions-get"] = async function ({ accountId, startDate, endDate }) {
    checkFileOpen();
    const { data } = await aqlQuery(q("transactions").filter({
        $and: [
            accountId && { account: accountId },
            startDate && { date: { $gte: startDate } },
            endDate && { date: { $lte: endDate } }
        ].filter(Boolean)
    }).select("*").options({ splits: "grouped" }));
    return data;
};
handlers["api/transaction-update"] = withMutation(async function ({ id: id2, fields }) {
    checkFileOpen();
    const { data } = await aqlQuery(q("transactions").filter({ id: id2 }).select("*").options({ splits: "grouped" }));
    const transactions = ungroupTransactions(data);
    if (transactions.length === 0) {
        return [];
    }
    const { diff: diff2 } = updateTransaction$1(transactions, { id: id2, ...fields });
    return handlers["transactions-batch-update"](diff2)["updated"];
});
handlers["api/transaction-delete"] = withMutation(async function ({ id: id2 }) {
    checkFileOpen();
    const { data } = await aqlQuery(q("transactions").filter({ id: id2 }).select("*").options({ splits: "grouped" }));
    const transactions = ungroupTransactions(data);
    if (transactions.length === 0) {
        return [];
    }
    const { diff: diff2 } = deleteTransaction$1(transactions, id2);
    return handlers["transactions-batch-update"](diff2)["deleted"];
});
handlers["api/accounts-get"] = async function () {
    checkFileOpen();
    const accounts = await getAccounts$2();
    return accounts.map((account) => accountModel.toExternal(account));
};
handlers["api/account-create"] = withMutation(async function ({ account, initialBalance = null }) {
    checkFileOpen();
    return handlers["account-create"]({
        name: account.name,
        offBudget: account.offbudget,
        closed: account.closed,
        // Current the API expects an amount but it really should expect
        // an integer
        balance: initialBalance != null ? integerToAmount(initialBalance) : null
    });
});
handlers["api/account-update"] = withMutation(async function ({ id: id2, fields }) {
    checkFileOpen();
    return updateAccount$1({ id: id2, ...accountModel.fromExternal(fields) });
});
handlers["api/account-close"] = withMutation(async function ({ id: id2, transferAccountId, transferCategoryId }) {
    checkFileOpen();
    return handlers["account-close"]({
        id: id2,
        transferAccountId,
        categoryId: transferCategoryId
    });
});
handlers["api/account-reopen"] = withMutation(async function ({ id: id2 }) {
    checkFileOpen();
    return handlers["account-reopen"]({ id: id2 });
});
handlers["api/account-delete"] = withMutation(async function ({ id: id2 }) {
    checkFileOpen();
    return handlers["account-close"]({ id: id2, forced: true });
});
handlers["api/account-balance"] = withMutation(async function ({ id: id2, cutoff = /* @__PURE__ */ new Date() }) {
    checkFileOpen();
    return handlers["account-balance"]({ id: id2, cutoff });
});
handlers["api/categories-get"] = async function ({ grouped } = {}) {
    checkFileOpen();
    const result = await handlers["get-categories"]();
    return grouped ? result.grouped.map(categoryGroupModel.toExternal) : result.list.map(categoryModel.toExternal);
};
handlers["api/category-groups-get"] = async function () {
    checkFileOpen();
    const groups = await handlers["get-category-groups"]();
    return groups.map(categoryGroupModel.toExternal);
};
handlers["api/category-group-create"] = withMutation(async function ({ group }) {
    checkFileOpen();
    return handlers["category-group-create"]({
        name: group.name,
        hidden: group.hidden
    });
});
handlers["api/category-group-update"] = withMutation(async function ({ id: id2, fields }) {
    checkFileOpen();
    return handlers["category-group-update"]({
        id: id2,
        ...categoryGroupModel.fromExternal(fields)
    });
});
handlers["api/category-group-delete"] = withMutation(async function ({ id: id2, transferCategoryId }) {
    checkFileOpen();
    return handlers["category-group-delete"]({
        id: id2,
        transferId: transferCategoryId
    });
});
handlers["api/category-create"] = withMutation(async function ({ category }) {
    checkFileOpen();
    return handlers["category-create"]({
        name: category.name,
        groupId: category.group_id,
        isIncome: category.is_income,
        hidden: category.hidden
    });
});
handlers["api/category-update"] = withMutation(async function ({ id: id2, fields }) {
    checkFileOpen();
    return handlers["category-update"]({
        id: id2,
        ...categoryModel.fromExternal(fields)
    });
});
handlers["api/category-delete"] = withMutation(async function ({ id: id2, transferCategoryId }) {
    checkFileOpen();
    return handlers["category-delete"]({
        id: id2,
        transferId: transferCategoryId
    });
});
handlers["api/common-payees-get"] = async function () {
    checkFileOpen();
    const payees = await handlers["common-payees-get"]();
    return payees.map(payeeModel.toExternal);
};
handlers["api/payees-get"] = async function () {
    checkFileOpen();
    const payees = await handlers["payees-get"]();
    return payees.map(payeeModel.toExternal);
};
handlers["api/payee-create"] = withMutation(async function ({ payee }) {
    checkFileOpen();
    return handlers["payee-create"]({ name: payee.name });
});
handlers["api/payee-update"] = withMutation(async function ({ id: id2, fields }) {
    checkFileOpen();
    return handlers["payees-batch-change"]({
        updated: [{ id: id2, ...payeeModel.fromExternal(fields) }]
    });
});
handlers["api/payee-delete"] = withMutation(async function ({ id: id2 }) {
    checkFileOpen();
    return handlers["payees-batch-change"]({ deleted: [{ id: id2 }] });
});
handlers["api/payees-merge"] = withMutation(async function ({ targetId, mergeIds }) {
    checkFileOpen();
    return handlers["payees-merge"]({ targetId, mergeIds });
});
handlers["api/rules-get"] = async function () {
    checkFileOpen();
    return handlers["rules-get"]();
};
handlers["api/payee-rules-get"] = async function ({ id: id2 }) {
    checkFileOpen();
    return handlers["payees-get-rules"]({ id: id2 });
};
handlers["api/rule-create"] = withMutation(async function ({ rule }) {
    checkFileOpen();
    const addedRule = await handlers["rule-add"](rule);
    if ("error" in addedRule) {
        throw APIError("Failed creating a new rule", addedRule.error);
    }
    return addedRule;
});
handlers["api/rule-update"] = withMutation(async function ({ rule }) {
    checkFileOpen();
    const updatedRule = await handlers["rule-update"](rule);
    if ("error" in updatedRule) {
        throw APIError("Failed updating the rule", updatedRule.error);
    }
    return updatedRule;
});
handlers["api/rule-delete"] = withMutation(async function (id2) {
    checkFileOpen();
    return handlers["rule-delete"](id2);
});
handlers["api/schedules-get"] = async function () {
    checkFileOpen();
    const { data } = await aqlQuery(q("schedules").select("*"));
    const schedules = data;
    return schedules.map((schedule) => scheduleModel.toExternal(schedule));
};
handlers["api/schedule-create"] = withMutation(async function (schedule) {
    checkFileOpen();
    const internalSchedule = scheduleModel.fromExternal(schedule);
    const partialSchedule = {
        name: internalSchedule.name,
        posts_transaction: internalSchedule.posts_transaction
    };
    return handlers["schedule/create"]({
        schedule: partialSchedule,
        conditions: internalSchedule._conditions
    });
});
handlers["api/schedule-update"] = withMutation(async function ({ id: id2, fields, resetNextDate }) {
    checkFileOpen();
    const { data } = await aqlQuery(q("schedules").filter({ id: id2 }).select("*"));
    if (!data || data.length === 0) {
        throw APIError(`Schedule ${id2} not found`);
    }
    const sched = data[0];
    let conditionsUpdated = false;
    const payeeIndex = sched._conditions.findIndex((c) => c.field === "payee");
    const accountIndex = sched._conditions.findIndex((c) => c.field === "account");
    const dateIndex = sched._conditions.findIndex((c) => c.field === "date");
    const amountIndex = sched._conditions.findIndex((c) => c.field === "amount");
    for (const key in fields) {
        const typedKey = key;
        const value = fields[typedKey];
        switch (typedKey) {
            case "name": {
                const newName = String(value);
                const { data: existing } = await aqlQuery(q("schedules").filter({ name: newName }).select("*"));
                if (!existing || existing.length === 0 || existing[0].id === sched.id) {
                    sched.name = newName;
                    conditionsUpdated = true;
                }
                else {
                    throw APIError(`There is already a schedule named: ${newName}`);
                }
                break;
            }
            case "next_date":
            case "completed": {
                throw APIError(`Field ${typedKey} is system-managed and not user-editable.`);
            }
            case "posts_transaction": {
                sched.posts_transaction = Boolean(value);
                conditionsUpdated = true;
                break;
            }
            case "payee": {
                if (payeeIndex !== -1) {
                    sched._conditions[payeeIndex].value = value;
                    conditionsUpdated = true;
                }
                else {
                    sched._conditions.push({
                        field: "payee",
                        op: "is",
                        value: String(value)
                    });
                    conditionsUpdated = true;
                }
                break;
            }
            case "account": {
                if (accountIndex !== -1) {
                    sched._conditions[accountIndex].value = value;
                    conditionsUpdated = true;
                }
                else {
                    sched._conditions.push({
                        field: "account",
                        op: "is",
                        value: String(value)
                    });
                    conditionsUpdated = true;
                }
                break;
            }
            case "amountOp": {
                if (amountIndex !== -1) {
                    let convertedOp;
                    switch (value) {
                        case "is":
                            convertedOp = "is";
                            break;
                        case "isapprox":
                            convertedOp = "isapprox";
                            break;
                        case "isbetween":
                            convertedOp = "isbetween";
                            break;
                        default:
                            throw APIError(`Invalid amount operator: ${value}. Expected: is, isapprox, or isbetween`);
                    }
                    sched._conditions[amountIndex].op = convertedOp;
                    conditionsUpdated = true;
                }
                else {
                    throw APIError(`Ammount can not be found. There is a bug here`);
                }
                break;
            }
            case "amount": {
                if (amountIndex !== -1) {
                    sched._conditions[amountIndex].value = value;
                    conditionsUpdated = true;
                }
                else {
                    throw APIError(`Ammount can not be found. There is a bug here`);
                }
                break;
            }
            case "date": {
                if (dateIndex !== -1) {
                    sched._conditions[dateIndex].value = value;
                    conditionsUpdated = true;
                }
                else {
                    throw APIError(`Date can not be found. Schedules can not be created without a date there is a bug here`);
                }
                break;
            }
            default: {
                throw APIError(`Unhandled field: ${typedKey}`);
            }
        }
    }
    if (conditionsUpdated) {
        return handlers["schedule/update"]({
            schedule: {
                id: sched.id,
                posts_transaction: sched.posts_transaction,
                name: sched.name
            },
            conditions: sched._conditions,
            resetNextDate
        });
    }
    else {
        return sched.id;
    }
});
handlers["api/schedule-delete"] = withMutation(async function (id2) {
    checkFileOpen();
    return handlers["schedule/delete"]({ id: id2 });
});
handlers["api/get-id-by-name"] = async function ({ type: type2, name }) {
    checkFileOpen();
    const allowedTypes = ["payees", "categories", "schedules", "accounts"];
    if (!allowedTypes.includes(type2)) {
        throw APIError("Provide a valid type");
    }
    const { data } = await aqlQuery(q(type2).filter({ name }).select("*"));
    if (!data || data.length === 0) {
        throw APIError(`Not found: ${type2} with name ${name}`);
    }
    return data[0].id;
};
handlers["api/get-server-version"] = async function () {
    checkFileOpen();
    return handlers["get-server-version"]();
};
function installAPI(serverHandlers) {
    const merged = Object.assign({}, serverHandlers, handlers);
    handlers = merged;
    return merged;
}
const app$g = createApp();
app$g.method("get-did-bootstrap", didBootstrap);
app$g.method("subscribe-needs-bootstrap", needsBootstrap);
app$g.method("subscribe-bootstrap", bootstrap);
app$g.method("subscribe-get-login-methods", getLoginMethods);
app$g.method("subscribe-get-user", getUser);
app$g.method("subscribe-change-password", changePassword);
app$g.method("subscribe-sign-in", signIn);
app$g.method("subscribe-sign-out", signOut);
app$g.method("subscribe-set-token", setToken);
app$g.method("enable-openid", enableOpenId);
app$g.method("get-openid-config", getOpenIdConfig);
app$g.method("enable-password", enablePassword);
async function didBootstrap() {
    return Boolean(await getItem("did-bootstrap"));
}
async function needsBootstrap({ url } = {}) {
    if (url && !isValidBaseURL(url)) {
        return { error: "get-server-failure" };
    }
    let serverConfig;
    try {
        serverConfig = getServer(url);
        if (!serverConfig) {
            return { bootstrapped: true, hasServer: false };
        }
    }
    catch (err) {
        return { error: "get-server-failure" };
    }
    let resText;
    try {
        resText = await get$2(serverConfig.SIGNUP_SERVER + "/needs-bootstrap");
    }
    catch (err) {
        return { error: "network-failure" };
    }
    let res;
    try {
        res = JSON.parse(resText);
    }
    catch (err) {
        return { error: "parse-failure" };
    }
    return {
        bootstrapped: res.data.bootstrapped,
        availableLoginMethods: res.data.availableLoginMethods || [
            { method: "password", active: true, displayName: "Password" }
        ],
        multiuser: res.data.multiuser || false,
        hasServer: true
    };
}
async function bootstrap(loginConfig) {
    try {
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        await post(serverConfig.SIGNUP_SERVER + "/bootstrap", loginConfig);
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
    return {};
}
async function getLoginMethods() {
    let res;
    try {
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        res = await fetch(serverConfig.SIGNUP_SERVER + "/login-methods").then((res2) => res2.json());
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
    if (res.methods) {
        return { methods: res.methods };
    }
    return { error: "internal" };
}
async function getUser() {
    const serverConfig = getServer();
    if (!serverConfig) {
        if (!await getItem("did-bootstrap")) {
            return null;
        }
        return { offline: false };
    }
    const userToken = await getItem("user-token");
    if (!userToken) {
        return null;
    }
    try {
        const res = await get$2(serverConfig.SIGNUP_SERVER + "/validate", {
            headers: {
                "X-ACTUAL-TOKEN": userToken
            }
        });
        let tokenExpired = false;
        const { status, reason, data: { userName = null, permission = "", userId = null, displayName = null, loginMethod = null } = {} } = JSON.parse(res) || {};
        if (status === "error") {
            if (reason === "unauthorized") {
                return null;
            }
            else if (reason === "token-expired") {
                tokenExpired = true;
            }
            else {
                return { offline: true };
            }
        }
        return {
            offline: false,
            userName,
            permission,
            userId,
            displayName,
            loginMethod,
            tokenExpired
        };
    }
    catch (e) {
        logger.log(e);
        return { offline: true };
    }
}
async function changePassword({ password }) {
    const userToken = await getItem("user-token");
    if (!userToken) {
        return { error: "not-logged-in" };
    }
    try {
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        await post(serverConfig.SIGNUP_SERVER + "/change-password", {
            token: userToken,
            password
        });
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
    return {};
}
async function signIn(loginInfo) {
    if (typeof loginInfo.loginMethod !== "string" || loginInfo.loginMethod == null) {
        loginInfo.loginMethod = "password";
    }
    let res;
    try {
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        res = await post(serverConfig.SIGNUP_SERVER + "/login", loginInfo);
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
    if (res.returnUrl) {
        return { redirectUrl: res.returnUrl };
    }
    if (!res.token) {
        throw new Error("login: User token not set");
    }
    await setItem("user-token", res.token);
    return {};
}
async function signOut() {
    unloadAllKeys();
    await multiRemove([
        "user-token",
        "encrypt-keys",
        "lastBudget",
        "readOnly"
    ]);
    return "ok";
}
async function setToken({ token }) {
    await setItem("user-token", token);
}
async function enableOpenId(openIdConfig) {
    try {
        const userToken = await getItem("user-token");
        if (!userToken) {
            return { error: "unauthorized" };
        }
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        await post(serverConfig.BASE_SERVER + "/openid/enable", openIdConfig, {
            "X-ACTUAL-TOKEN": userToken
        });
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
    return {};
}
async function getOpenIdConfig({ password }) {
    try {
        const userToken = await getItem("user-token");
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        const res = await post(serverConfig.BASE_SERVER + "/openid/config", { password }, {
            "X-ACTUAL-TOKEN": userToken
        });
        if (res) {
            return res;
        }
        return null;
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
}
async function enablePassword(passwordConfig) {
    try {
        const userToken = await getItem("user-token");
        if (!userToken) {
            return { error: "unauthorized" };
        }
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        await post(serverConfig.BASE_SERVER + "/openid/disable", passwordConfig, {
            "X-ACTUAL-TOKEN": userToken
        });
    }
    catch (err) {
        if (err instanceof PostError) {
            return {
                error: err.reason || "network-failure"
            };
        }
        throw err;
    }
    return {};
}
function peg$subclass$1(child, parent) {
    function C() {
        this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
}
function peg$SyntaxError$1(message2, expected, found, location) {
    var self2 = Error.call(this, message2);
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self2, peg$SyntaxError$1.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
}
peg$subclass$1(peg$SyntaxError$1, Error);
function peg$padEnd$1(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
        return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
peg$SyntaxError$1.prototype.format = function (sources) {
    var str = "Error: " + this.message;
    if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
            }
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
            var e = this.location.end;
            var filler = peg$padEnd$1("", offset_s.line.toString().length, " ");
            var line = src[s.line - 1];
            var last2 = s.line === e.line ? e.column : line.length + 1;
            var hatLen = last2 - s.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd$1("", s.column - 1, " ") + peg$padEnd$1("", hatLen, "^");
        }
        else {
            str += "\n at " + loc;
        }
    }
    return str;
};
peg$SyntaxError$1.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
            return '"' + literalEscape(expectation.text) + '"';
        },
        class: function (expectation) {
            var escapedParts = expectation.parts.map(function (part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function () {
            return "any character";
        },
        end: function () {
            return "end of input";
        },
        other: function (expectation) {
            return expectation.description;
        }
    };
    function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return "\\x" + hex(ch);
        });
    }
    function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return "\\x" + hex(ch);
        });
    }
    function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
            }
            descriptions.length = j;
        }
        switch (descriptions.length) {
            case 1:
                return descriptions[0];
            case 2:
                return descriptions[0] + " or " + descriptions[1];
            default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
    }
    function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function peg$parse$1(input, options2) {
    options2 = options2 !== void 0 ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { expr: peg$parseexpr };
    var peg$startRuleFunction = peg$parseexpr;
    var peg$c0 = "source";
    var peg$c1 = "sink";
    var peg$c2 = " ";
    var peg$c3 = " source";
    var peg$c4 = " sink";
    var peg$r0 = /^[0-9]/;
    var peg$e0 = peg$literalExpectation("source", false);
    var peg$e1 = peg$literalExpectation("sink", false);
    var peg$e2 = peg$otherExpectation("space");
    var peg$e3 = peg$literalExpectation(" ", false);
    var peg$e4 = peg$otherExpectation("digit");
    var peg$e5 = peg$classExpectation([["0", "9"]], false, false);
    var peg$e6 = peg$otherExpectation("weight");
    var peg$e7 = peg$otherExpectation("Name");
    var peg$e8 = peg$literalExpectation(" source", false);
    var peg$e9 = peg$anyExpectation();
    var peg$e10 = peg$literalExpectation(" sink", false);
    var peg$f0 = function () {
        return { group: null, type: "source" };
    };
    var peg$f1 = function (weight) {
        return { type: "sink", weight: +weight || 1, group: null };
    };
    var peg$f2 = function (group) {
        return { group: group || null, type: "source" };
    };
    var peg$f3 = function (group, weight) {
        return { type: "sink", weight: +weight || 1, group: group || null };
    };
    var peg$f4 = function (group) {
        return { group, type: null };
    };
    var peg$f5 = function (weight) {
        return +weight;
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
        if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$literalExpectation(text, ignoreCase) {
        return { type: "literal", text, ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
        return { type: "any" };
    }
    function peg$endExpectation() {
        return { type: "end" };
    }
    function peg$otherExpectation(description) {
        return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
            return details;
        }
        else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
                p--;
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                }
                else {
                    details.column++;
                }
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError$1(peg$SyntaxError$1.buildMessage(expected, found), expected, found, location);
    }
    function peg$parseexpr() {
        var s0, s1, s3, s5;
        s0 = peg$currPos;
        s1 = peg$parsesource();
        if (s1 !== peg$FAILED) {
            s1 = peg$f0();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesink();
            if (s1 !== peg$FAILED) {
                peg$parse_();
                s3 = peg$parseweight();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                s0 = peg$f1(s3);
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsesourcegroup();
                peg$parse_();
                s3 = peg$parsesource();
                if (s3 !== peg$FAILED) {
                    s0 = peg$f2(s1);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsesinkgroup();
                    peg$parse_();
                    s3 = peg$parsesink();
                    if (s3 !== peg$FAILED) {
                        peg$parse_();
                        s5 = peg$parseweight();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        s0 = peg$f3(s1, s5);
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsesourcegroup();
                        s1 = peg$f4(s1);
                        s0 = s1;
                    }
                }
            }
        }
        return s0;
    }
    function peg$parsesource() {
        var s0;
        if (input.substr(peg$currPos, 6) === peg$c0) {
            s0 = peg$c0;
            peg$currPos += 6;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e0);
            }
        }
        return s0;
    }
    function peg$parsesink() {
        var s0;
        if (input.substr(peg$currPos, 4) === peg$c1) {
            s0 = peg$c1;
            peg$currPos += 4;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e1);
            }
        }
        return s0;
    }
    function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c2;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e3);
            }
        }
        if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
                s0.push(s1);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s1 = peg$c2;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                    }
                }
            }
        }
        else {
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        return s0;
    }
    function peg$parsed() {
        var s0;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e5);
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        return s0;
    }
    function peg$parseweight() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parsed();
        if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsed();
            }
        }
        else {
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
        }
        else {
            s1 = s2;
        }
        if (s1 !== peg$FAILED) {
            s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e6);
            }
        }
        return s0;
    }
    function peg$parsesourcegroup() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 7) === peg$c3) {
            s4 = peg$c3;
            peg$currPos += 7;
        }
        else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e8);
            }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
            s3 = void 0;
        }
        else {
            peg$currPos = s3;
            s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e9);
                }
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 7) === peg$c3) {
                s4 = peg$c3;
                peg$currPos += 7;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e8);
                }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
                s3 = void 0;
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        s0 = input.substring(s0, peg$currPos);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
            peg$fail(peg$e7);
        }
        return s0;
    }
    function peg$parsesinkgroup() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 5) === peg$c4) {
            s4 = peg$c4;
            peg$currPos += 5;
        }
        else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e10);
            }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
            s3 = void 0;
        }
        else {
            peg$currPos = s3;
            s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e9);
                }
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 5) === peg$c4) {
                s4 = peg$c4;
                peg$currPos += 5;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e10);
                }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
                s3 = void 0;
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        s0 = input.substring(s0, peg$currPos);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
            peg$fail(peg$e7);
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
    }
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
function cleanupTemplate({ month }) {
    return processCleanup(month);
}
async function applyGroupCleanups(month, sourceGroups, sinkGroups, generalGroups) {
    const sheetName = sheetForMonth(month);
    const warnings = [];
    const db_month = parseInt(month.replace("-", ""));
    let groupLength = sourceGroups.length;
    while (groupLength > 0) {
        const groupName = sourceGroups[0].group;
        const tempSourceGroups = sourceGroups.filter((c) => c.group === groupName);
        const sinkGroup = sinkGroups.filter((c) => c.group === groupName);
        const generalGroup = generalGroups.filter((c) => c.group === groupName);
        let total_weight = 0;
        let available_amount = 0;
        if (sinkGroup.length > 0 || generalGroup.length > 0) {
            for (let ii = 0; ii < tempSourceGroups.length; ii++) {
                const balance = await getSheetValue(sheetName, `leftover-${tempSourceGroups[ii].category}`);
                const budgeted = await getSheetValue(sheetName, `budget-${tempSourceGroups[ii].category}`);
                await setBudget({
                    category: tempSourceGroups[ii].category,
                    month,
                    amount: budgeted - balance
                });
                available_amount += balance;
            }
            for (let ii = 0; ii < sinkGroup.length; ii++) {
                total_weight += sinkGroup[ii].weight;
            }
            for (let ii = 0; ii < generalGroup.length && available_amount > 0; ii++) {
                const balance = await getSheetValue(sheetName, `leftover-${generalGroup[ii].category}`);
                const budgeted = await getSheetValue(sheetName, `budget-${generalGroup[ii].category}`);
                const to_budget = budgeted + Math.abs(balance);
                const categoryId = generalGroup[ii].category;
                let carryover = await first(`SELECT carryover FROM zero_budgets WHERE month = ? and category = ?`, [db_month, categoryId]);
                if (carryover === null) {
                    carryover = { carryover: 0 };
                }
                if (
                // We have enough to fully cover the overspent.
                balance < 0 && Math.abs(balance) <= available_amount && !generalGroup[ii].category.is_income && carryover.carryover === 0) {
                    await setBudget({
                        category: generalGroup[ii].category,
                        month,
                        amount: to_budget
                    });
                    available_amount -= Math.abs(balance);
                }
                else if (
                // We can only cover this category partially.
                balance < 0 && !generalGroup[ii].category.is_income && carryover.carryover === 0 && Math.abs(balance) > available_amount) {
                    await setBudget({
                        category: generalGroup[ii].category,
                        month,
                        amount: budgeted + available_amount
                    });
                    available_amount = 0;
                }
            }
            for (let ii = 0; ii < sinkGroup.length && available_amount > 0; ii++) {
                const budgeted = await getSheetValue(sheetName, `budget-${sinkGroup[ii].category}`);
                const to_budget = budgeted + Math.round(sinkGroup[ii].weight / total_weight * available_amount);
                await setBudget({
                    category: sinkGroup[ii].category,
                    month,
                    amount: to_budget
                });
            }
        }
        else {
            warnings.push(groupName + " has no matching sink categories.");
        }
        sourceGroups = sourceGroups.filter((c) => c.group !== groupName);
        groupLength = sourceGroups.length;
    }
    return warnings;
}
async function processCleanup(month) {
    let num_sources = 0;
    let num_sinks = 0;
    let total_weight = 0;
    const errors2 = [];
    const warnings = [];
    const sinkCategory = [];
    const db_month = parseInt(month.replace("-", ""));
    const category_templates = await getCategoryTemplates();
    const categories = await all("SELECT * FROM v_categories WHERE tombstone = 0");
    const sheetName = sheetForMonth(month);
    const groupSource = [];
    const groupSink = [];
    const groupGeneral = [];
    for (let c = 0; c < categories.length; c++) {
        const category = categories[c];
        const template = category_templates[category.id];
        if (template) {
            if (template.filter((t2) => t2.type === "source" && t2.group !== null).length > 0) {
                groupSource.push({
                    category: category.id,
                    group: template.filter((t2) => t2.type === "source" && t2.group !== null)[0].group
                });
            }
            if (template.filter((t2) => t2.type === "sink" && t2.group !== null).length > 0) {
                groupSink.push({
                    category: category.id,
                    group: template.filter((t2) => t2.type === "sink" && t2.group !== null)[0].group,
                    weight: template.filter((t2) => t2.type === "sink" && t2.group !== null)[0].weight
                });
            }
            if (template.filter((t2) => t2.type === null && t2.group !== null).length > 0) {
                groupGeneral.push({ category: category.id, group: template[0].group });
            }
        }
    }
    const newWarnings = await applyGroupCleanups(month, groupSource, groupSink, groupGeneral);
    warnings.splice(1, 0, ...newWarnings);
    for (let c = 0; c < categories.length; c++) {
        const category = categories[c];
        const template = category_templates[category.id];
        if (template) {
            if (template.filter((t2) => t2.type === "source" && t2.group === null).length > 0) {
                const balance = await getSheetValue(sheetName, `leftover-${category.id}`);
                const budgeted = await getSheetValue(sheetName, `budget-${category.id}`);
                if (balance >= 0) {
                    await setBudget({
                        category: category.id,
                        month,
                        amount: budgeted - balance
                    });
                    await setGoal({
                        category: category.id,
                        month,
                        goal: budgeted - balance,
                        long_goal: 0
                    });
                    num_sources += 1;
                }
                else {
                    warnings.push(category.name + " does not have available funds.");
                }
                const carryover = await first(`SELECT carryover FROM zero_budgets WHERE month = ? and category = ?`, [db_month, category.id]);
                if (carryover !== null) {
                    if (carryover.carryover === 1)
                        ;
                }
            }
            if (template.filter((t2) => t2.type === "sink" && t2.group === null).length > 0) {
                sinkCategory.push({ cat: category, temp: template });
                num_sinks += 1;
                total_weight += template.filter((w) => w.type === "sink")[0].weight;
            }
        }
    }
    for (let c = 0; c < categories.length; c++) {
        const category = categories[c];
        const budgetAvailable2 = await getSheetValue(sheetName, `to-budget`);
        const balance = await getSheetValue(sheetName, `leftover-${category.id}`);
        const budgeted = await getSheetValue(sheetName, `budget-${category.id}`);
        const to_budget = budgeted + Math.abs(balance);
        const categoryId = category.id;
        let carryover = await first(`SELECT carryover FROM zero_budgets WHERE month = ? and category = ?`, [db_month, categoryId]);
        if (carryover === null) {
            carryover = { carryover: 0 };
        }
        if (balance < 0 && Math.abs(balance) <= budgetAvailable2 && !category.is_income && carryover.carryover === 0) {
            await setBudget({
                category: category.id,
                month,
                amount: to_budget
            });
        }
        else if (balance < 0 && !category.is_income && carryover.carryover === 0 && Math.abs(balance) > budgetAvailable2) {
            await setBudget({
                category: category.id,
                month,
                amount: budgeted + budgetAvailable2
            });
        }
    }
    const budgetAvailable = await getSheetValue(sheetName, `to-budget`);
    if (budgetAvailable < 0) {
        warnings.push("Global: No funds are available to reallocate.");
    }
    for (let c = 0; c < sinkCategory.length; c++) {
        const budgeted = await getSheetValue(sheetName, `budget-${sinkCategory[c].cat.id}`);
        const categoryId = sinkCategory[c].cat.id;
        const weight = sinkCategory[c].temp.filter((w) => w.type === "sink")[0].weight;
        let to_budget = budgeted + Math.round(weight / total_weight * budgetAvailable);
        if (c === sinkCategory.length - 1) {
            const currentBudgetAvailable = await getSheetValue(sheetName, `to-budget`);
            if (to_budget > currentBudgetAvailable) {
                to_budget = budgeted + currentBudgetAvailable;
            }
        }
        await setBudget({
            category: categoryId,
            month,
            amount: to_budget
        });
    }
    if (num_sources === 0) {
        if (errors2.length) {
            return {
                type: "error",
                sticky: true,
                message: "There were errors interpreting some templates:",
                pre: errors2.join("\n\n")
            };
        }
        else if (warnings.length) {
            return {
                type: "warning",
                message: "Global: Funds not available:",
                pre: warnings.join("\n\n")
            };
        }
        else {
            return {
                type: "message",
                message: "All categories were up to date."
            };
        }
    }
    else {
        const applied = `Successfully returned funds from ${num_sources} ${num_sources === 1 ? "source" : "sources"} and funded ${num_sinks} sinking ${num_sinks === 1 ? "fund" : "funds"}.`;
        if (errors2.length) {
            return {
                sticky: true,
                message: `${applied} There were errors interpreting some templates:`,
                pre: errors2.join("\n\n")
            };
        }
        else if (warnings.length) {
            return {
                type: "warning",
                message: "Global: Funds not available:",
                pre: warnings.join("\n\n")
            };
        }
        else if (budgetAvailable === 0) {
            return {
                type: "message",
                message: "All categories were up to date."
            };
        }
        else {
            return {
                type: "message",
                message: applied
            };
        }
    }
}
const TEMPLATE_PREFIX$1 = "#cleanup ";
async function getCategoryTemplates() {
    const templates = {};
    const notes = await all(`SELECT * FROM notes WHERE lower(note) like '%${TEMPLATE_PREFIX$1}%'`);
    for (let n = 0; n < notes.length; n++) {
        const lines = notes[n].note.split("\n");
        const template_lines = [];
        for (let l = 0; l < lines.length; l++) {
            const line = lines[l].trim();
            if (!line.toLowerCase().startsWith(TEMPLATE_PREFIX$1))
                continue;
            const expression = line.slice(TEMPLATE_PREFIX$1.length);
            try {
                const parsed = peg$parse$1(expression);
                template_lines.push(parsed);
            }
            catch (e) {
                template_lines.push({ type: "error", line, error: e });
            }
        }
        if (template_lines.length) {
            templates[notes[n].id] = template_lines;
        }
    }
    return templates;
}
var isArguments$1;
var hasRequiredIsArguments$2;
function requireIsArguments$2() {
    if (hasRequiredIsArguments$2)
        return isArguments$1;
    hasRequiredIsArguments$2 = 1;
    var toStr = Object.prototype.toString;
    isArguments$1 = function isArguments2(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
            isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
    };
    return isArguments$1;
}
var implementation$4;
var hasRequiredImplementation$4;
function requireImplementation$4() {
    if (hasRequiredImplementation$4)
        return implementation$4;
    hasRequiredImplementation$4 = 1;
    var keysShim;
    if (!Object.keys) {
        var has = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var isArgs = requireIsArguments$2();
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        var hasProtoEnumBug = isEnumerable.call(function () {
        }, "prototype");
        var dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ];
        var equalsConstructorPrototype = function (o) {
            var ctor = o.constructor;
            return ctor && ctor.prototype === o;
        };
        var excludedKeys = {
            $applicationCache: true,
            $console: true,
            $external: true,
            $frame: true,
            $frameElement: true,
            $frames: true,
            $innerHeight: true,
            $innerWidth: true,
            $onmozfullscreenchange: true,
            $onmozfullscreenerror: true,
            $outerHeight: true,
            $outerWidth: true,
            $pageXOffset: true,
            $pageYOffset: true,
            $parent: true,
            $scrollLeft: true,
            $scrollTop: true,
            $scrollX: true,
            $scrollY: true,
            $self: true,
            $webkitIndexedDB: true,
            $webkitStorageInfo: true,
            $window: true
        };
        var hasAutomationEqualityBug = function () {
            if (typeof window === "undefined") {
                return false;
            }
            for (var k in window) {
                try {
                    if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                        try {
                            equalsConstructorPrototype(window[k]);
                        }
                        catch (e) {
                            return true;
                        }
                    }
                }
                catch (e) {
                    return true;
                }
            }
            return false;
        }();
        var equalsConstructorPrototypeIfNotBuggy = function (o) {
            if (typeof window === "undefined" || !hasAutomationEqualityBug) {
                return equalsConstructorPrototype(o);
            }
            try {
                return equalsConstructorPrototype(o);
            }
            catch (e) {
                return false;
            }
        };
        keysShim = function keys2(object) {
            var isObject = object !== null && typeof object === "object";
            var isFunction = toStr.call(object) === "[object Function]";
            var isArguments2 = isArgs(object);
            var isString2 = isObject && toStr.call(object) === "[object String]";
            var theKeys = [];
            if (!isObject && !isFunction && !isArguments2) {
                throw new TypeError("Object.keys called on a non-object");
            }
            var skipProto = hasProtoEnumBug && isFunction;
            if (isString2 && object.length > 0 && !has.call(object, 0)) {
                for (var i = 0; i < object.length; ++i) {
                    theKeys.push(String(i));
                }
            }
            if (isArguments2 && object.length > 0) {
                for (var j = 0; j < object.length; ++j) {
                    theKeys.push(String(j));
                }
            }
            else {
                for (var name in object) {
                    if (!(skipProto && name === "prototype") && has.call(object, name)) {
                        theKeys.push(String(name));
                    }
                }
            }
            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var k = 0; k < dontEnums.length; ++k) {
                    if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                        theKeys.push(dontEnums[k]);
                    }
                }
            }
            return theKeys;
        };
    }
    implementation$4 = keysShim;
    return implementation$4;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
    if (hasRequiredObjectKeys)
        return objectKeys;
    hasRequiredObjectKeys = 1;
    var slice = Array.prototype.slice;
    var isArgs = requireIsArguments$2();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys2(o) {
        return origKeys(o);
    } : requireImplementation$4();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
            var keysWorksWithArguments = function () {
                var args = Object.keys(arguments);
                return args && args.length === arguments.length;
            }(1, 2);
            if (!keysWorksWithArguments) {
                Object.keys = function keys2(object) {
                    if (isArgs(object)) {
                        return originalKeys(slice.call(object));
                    }
                    return originalKeys(object);
                };
            }
        }
        else {
            Object.keys = keysShim;
        }
        return Object.keys || keysShim;
    };
    objectKeys = keysShim;
    return objectKeys;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty)
        return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
        try {
            $defineProperty({}, "a", { value: 1 });
        }
        catch (e) {
            $defineProperty = false;
        }
    }
    esDefineProperty = $defineProperty;
    return esDefineProperty;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
    if (hasRequiredSyntax)
        return syntax;
    hasRequiredSyntax = 1;
    syntax = SyntaxError;
    return syntax;
}
var type;
var hasRequiredType;
function requireType() {
    if (hasRequiredType)
        return type;
    hasRequiredType = 1;
    type = TypeError;
    return type;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
    if (hasRequiredGOPD)
        return gOPD;
    hasRequiredGOPD = 1;
    gOPD = Object.getOwnPropertyDescriptor;
    return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
    if (hasRequiredGopd)
        return gopd;
    hasRequiredGopd = 1;
    var $gOPD = /* @__PURE__ */ requireGOPD();
    if ($gOPD) {
        try {
            $gOPD([], "length");
        }
        catch (e) {
            $gOPD = null;
        }
    }
    gopd = $gOPD;
    return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
    if (hasRequiredDefineDataProperty)
        return defineDataProperty;
    hasRequiredDefineDataProperty = 1;
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var $SyntaxError = /* @__PURE__ */ requireSyntax();
    var $TypeError = /* @__PURE__ */ requireType();
    var gopd2 = /* @__PURE__ */ requireGopd();
    defineDataProperty = function defineDataProperty2(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
            throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
            throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
            throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
            throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
            throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
            throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd2 && gopd2(obj, property);
        if ($defineProperty) {
            $defineProperty(obj, property, {
                configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                value,
                writable: nonWritable === null && desc ? desc.writable : !nonWritable
            });
        }
        else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
            obj[property] = value;
        }
        else {
            throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
    };
    return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
    if (hasRequiredHasPropertyDescriptors)
        return hasPropertyDescriptors_1;
    hasRequiredHasPropertyDescriptors = 1;
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
            return null;
        }
        try {
            return $defineProperty([], "length", { value: 1 }).length !== 1;
        }
        catch (e) {
            return true;
        }
    };
    hasPropertyDescriptors_1 = hasPropertyDescriptors;
    return hasPropertyDescriptors_1;
}
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
    if (hasRequiredDefineProperties)
        return defineProperties_1;
    hasRequiredDefineProperties = 1;
    var keys2 = requireObjectKeys();
    var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty2 = /* @__PURE__ */ requireDefineDataProperty();
    var isFunction = function (fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
    var defineProperty = function (object, name, value, predicate) {
        if (name in object) {
            if (predicate === true) {
                if (object[name] === value) {
                    return;
                }
            }
            else if (!isFunction(predicate) || !predicate()) {
                return;
            }
        }
        if (supportsDescriptors) {
            defineDataProperty2(object, name, value, true);
        }
        else {
            defineDataProperty2(object, name, value);
        }
    };
    var defineProperties = function (object, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys2(map);
        if (hasSymbols2) {
            props = concat.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i = 0; i < props.length; i += 1) {
            defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
        }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    defineProperties_1 = defineProperties;
    return defineProperties_1;
}
var callBind = { exports: {} };
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
    if (hasRequiredEsObjectAtoms)
        return esObjectAtoms;
    hasRequiredEsObjectAtoms = 1;
    esObjectAtoms = Object;
    return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
    if (hasRequiredEsErrors)
        return esErrors;
    hasRequiredEsErrors = 1;
    esErrors = Error;
    return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
    if (hasRequired_eval)
        return _eval;
    hasRequired_eval = 1;
    _eval = EvalError;
    return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
    if (hasRequiredRange)
        return range;
    hasRequiredRange = 1;
    range = RangeError;
    return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
    if (hasRequiredRef)
        return ref;
    hasRequiredRef = 1;
    ref = ReferenceError;
    return ref;
}
var uri;
var hasRequiredUri;
function requireUri() {
    if (hasRequiredUri)
        return uri;
    hasRequiredUri = 1;
    uri = URIError;
    return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
    if (hasRequiredAbs)
        return abs;
    hasRequiredAbs = 1;
    abs = Math.abs;
    return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
    if (hasRequiredFloor)
        return floor;
    hasRequiredFloor = 1;
    floor = Math.floor;
    return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
    if (hasRequiredMax)
        return max;
    hasRequiredMax = 1;
    max = Math.max;
    return max;
}
var min;
var hasRequiredMin;
function requireMin() {
    if (hasRequiredMin)
        return min;
    hasRequiredMin = 1;
    min = Math.min;
    return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
    if (hasRequiredPow)
        return pow;
    hasRequiredPow = 1;
    pow = Math.pow;
    return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
    if (hasRequiredRound)
        return round;
    hasRequiredRound = 1;
    round = Math.round;
    return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
    if (hasRequired_isNaN)
        return _isNaN;
    hasRequired_isNaN = 1;
    _isNaN = Number.isNaN || function isNaN2(a) {
        return a !== a;
    };
    return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
    if (hasRequiredSign)
        return sign;
    hasRequiredSign = 1;
    var $isNaN = /* @__PURE__ */ require_isNaN();
    sign = function sign2(number2) {
        if ($isNaN(number2) || number2 === 0) {
            return number2;
        }
        return number2 < 0 ? -1 : 1;
    };
    return sign;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
    if (hasRequiredShams$1)
        return shams$1;
    hasRequiredShams$1 = 1;
    shams$1 = function hasSymbols2() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
            return false;
        }
        if (typeof Symbol.iterator === "symbol") {
            return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
            return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
            return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
            return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (var _ in obj) {
            return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
            return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
            return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
            return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
            var descriptor = (
            /** @type {PropertyDescriptor} */
            Object.getOwnPropertyDescriptor(obj, sym));
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                return false;
            }
        }
        return true;
    };
    return shams$1;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
    if (hasRequiredHasSymbols)
        return hasSymbols;
    hasRequiredHasSymbols = 1;
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = requireShams$1();
    hasSymbols = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
            return false;
        }
        if (typeof Symbol !== "function") {
            return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
            return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
            return false;
        }
        return hasSymbolSham();
    };
    return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
    if (hasRequiredReflect_getPrototypeOf)
        return Reflect_getPrototypeOf;
    hasRequiredReflect_getPrototypeOf = 1;
    Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
    return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
    if (hasRequiredObject_getPrototypeOf)
        return Object_getPrototypeOf;
    hasRequiredObject_getPrototypeOf = 1;
    var $Object = /* @__PURE__ */ requireEsObjectAtoms();
    Object_getPrototypeOf = $Object.getPrototypeOf || null;
    return Object_getPrototypeOf;
}
var implementation$3;
var hasRequiredImplementation$3;
function requireImplementation$3() {
    if (hasRequiredImplementation$3)
        return implementation$3;
    hasRequiredImplementation$3 = 1;
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max2 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
            arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
            arr[j + a.length] = b[j];
        }
        return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
            arr[j] = arrLike[i];
        }
        return arr;
    };
    var joiny = function (arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
            str += arr[i];
            if (i + 1 < arr.length) {
                str += joiner;
            }
        }
        return str;
    };
    implementation$3 = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(this, concatty(args, arguments));
                if (Object(result) === result) {
                    return result;
                }
                return this;
            }
            return target.apply(that, concatty(args, arguments));
        };
        var boundLength = max2(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
            var Empty = function Empty2() {
            };
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
    return implementation$3;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
    if (hasRequiredFunctionBind)
        return functionBind;
    hasRequiredFunctionBind = 1;
    var implementation2 = requireImplementation$3();
    functionBind = Function.prototype.bind || implementation2;
    return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
    if (hasRequiredFunctionCall)
        return functionCall;
    hasRequiredFunctionCall = 1;
    functionCall = Function.prototype.call;
    return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
    if (hasRequiredFunctionApply)
        return functionApply;
    hasRequiredFunctionApply = 1;
    functionApply = Function.prototype.apply;
    return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
    if (hasRequiredReflectApply)
        return reflectApply;
    hasRequiredReflectApply = 1;
    reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
    return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
    if (hasRequiredActualApply)
        return actualApply;
    hasRequiredActualApply = 1;
    var bind = requireFunctionBind();
    var $apply = requireFunctionApply();
    var $call = requireFunctionCall();
    var $reflectApply = requireReflectApply();
    actualApply = $reflectApply || bind.call($call, $apply);
    return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
    if (hasRequiredCallBindApplyHelpers)
        return callBindApplyHelpers;
    hasRequiredCallBindApplyHelpers = 1;
    var bind = requireFunctionBind();
    var $TypeError = /* @__PURE__ */ requireType();
    var $call = requireFunctionCall();
    var $actualApply = requireActualApply();
    callBindApplyHelpers = function callBindBasic(args) {
        if (args.length < 1 || typeof args[0] !== "function") {
            throw new $TypeError("a function is required");
        }
        return $actualApply(bind, $call, args);
    };
    return callBindApplyHelpers;
}
var get$1;
var hasRequiredGet;
function requireGet() {
    if (hasRequiredGet)
        return get$1;
    hasRequiredGet = 1;
    var callBind2 = requireCallBindApplyHelpers();
    var gOPD2 = /* @__PURE__ */ requireGopd();
    var hasProtoAccessor;
    try {
        hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
            [].__proto__ === Array.prototype;
    }
    catch (e) {
        if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
            throw e;
        }
    }
    var desc = !!hasProtoAccessor && gOPD2 && gOPD2(Object.prototype, 
    /** @type {keyof typeof Object.prototype} */
    "__proto__");
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    get$1 = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
    }) : false;
    return get$1;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
    if (hasRequiredGetProto)
        return getProto;
    hasRequiredGetProto = 1;
    var reflectGetProto = requireReflect_getPrototypeOf();
    var originalGetProto = requireObject_getPrototypeOf();
    var getDunderProto = /* @__PURE__ */ requireGet();
    getProto = reflectGetProto ? function getProto2(O) {
        return reflectGetProto(O);
    } : originalGetProto ? function getProto2(O) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
            throw new TypeError("getProto: not an object");
        }
        return originalGetProto(O);
    } : getDunderProto ? function getProto2(O) {
        return getDunderProto(O);
    } : null;
    return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
    if (hasRequiredHasown)
        return hasown;
    hasRequiredHasown = 1;
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = requireFunctionBind();
    hasown = bind.call(call, $hasOwn);
    return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
        return getIntrinsic;
    hasRequiredGetIntrinsic = 1;
    var undefined$1;
    var $Object = /* @__PURE__ */ requireEsObjectAtoms();
    var $Error = /* @__PURE__ */ requireEsErrors();
    var $EvalError = /* @__PURE__ */ require_eval();
    var $RangeError = /* @__PURE__ */ requireRange();
    var $ReferenceError = /* @__PURE__ */ requireRef();
    var $SyntaxError = /* @__PURE__ */ requireSyntax();
    var $TypeError = /* @__PURE__ */ requireType();
    var $URIError = /* @__PURE__ */ requireUri();
    var abs2 = /* @__PURE__ */ requireAbs();
    var floor2 = /* @__PURE__ */ requireFloor();
    var max2 = /* @__PURE__ */ requireMax();
    var min2 = /* @__PURE__ */ requireMin();
    var pow2 = /* @__PURE__ */ requirePow();
    var round2 = /* @__PURE__ */ requireRound();
    var sign2 = /* @__PURE__ */ requireSign();
    var $Function = Function;
    var getEvalledConstructor = function (expressionSyntax) {
        try {
            return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        }
        catch (e) {
        }
    };
    var $gOPD = /* @__PURE__ */ requireGopd();
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var throwTypeError = function () {
        throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function () {
        try {
            arguments.callee;
            return throwTypeError;
        }
        catch (calleeThrows) {
            try {
                return $gOPD(arguments, "callee").get;
            }
            catch (gOPDthrows) {
                return throwTypeError;
            }
        }
    }() : throwTypeError;
    var hasSymbols2 = requireHasSymbols()();
    var getProto2 = requireGetProto();
    var $ObjectGPO = requireObject_getPrototypeOf();
    var $ReflectGPO = requireReflect_getPrototypeOf();
    var $apply = requireFunctionApply();
    var $call = requireFunctionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
    var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2(( /* @__PURE__ */new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": $Object,
        "%Object.getOwnPropertyDescriptor%": $gOPD,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2(( /* @__PURE__ */new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
        "%Function.prototype.call%": $call,
        "%Function.prototype.apply%": $apply,
        "%Object.defineProperty%": $defineProperty,
        "%Object.getPrototypeOf%": $ObjectGPO,
        "%Math.abs%": abs2,
        "%Math.floor%": floor2,
        "%Math.max%": max2,
        "%Math.min%": min2,
        "%Math.pow%": pow2,
        "%Math.round%": round2,
        "%Math.sign%": sign2,
        "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto2) {
        try {
            null.error;
        }
        catch (e) {
            var errorProto = getProto2(getProto2(e));
            INTRINSICS["%Error.prototype%"] = errorProto;
        }
    }
    var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
            value = getEvalledConstructor("async function () {}");
        }
        else if (name === "%GeneratorFunction%") {
            value = getEvalledConstructor("function* () {}");
        }
        else if (name === "%AsyncGeneratorFunction%") {
            value = getEvalledConstructor("async function* () {}");
        }
        else if (name === "%AsyncGenerator%") {
            var fn = doEval2("%AsyncGeneratorFunction%");
            if (fn) {
                value = fn.prototype;
            }
        }
        else if (name === "%AsyncIteratorPrototype%") {
            var gen = doEval2("%AsyncGenerator%");
            if (gen && getProto2) {
                value = getProto2(gen.prototype);
            }
        }
        INTRINSICS[name] = value;
        return value;
    };
    var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = requireFunctionBind();
    var hasOwn = /* @__PURE__ */ requireHasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
        var first2 = $strSlice(string, 0, 1);
        var last2 = $strSlice(string, -1);
        if (first2 === "%" && last2 !== "%") {
            throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        }
        else if (last2 === "%" && first2 !== "%") {
            throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName2, function (match2, number2, quote, subString) {
            result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number2 || match2;
        });
        return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) {
                value = doEval(intrinsicName);
            }
            if (typeof value === "undefined" && !allowMissing) {
                throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
            }
            return {
                alias,
                name: intrinsicName,
                value
            };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    getIntrinsic = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
            throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
            throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
            throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath2(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
            var part = parts[i];
            var first2 = $strSlice(part, 0, 1);
            var last2 = $strSlice(part, -1);
            if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
                throw new $SyntaxError("property names with quotes must have matching quotes");
            }
            if (part === "constructor" || !isOwn) {
                skipFurtherCaching = true;
            }
            intrinsicBaseName += "." + part;
            intrinsicRealName = "%" + intrinsicBaseName + "%";
            if (hasOwn(INTRINSICS, intrinsicRealName)) {
                value = INTRINSICS[intrinsicRealName];
            }
            else if (value != null) {
                if (!(part in value)) {
                    if (!allowMissing) {
                        throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                    }
                    return void 0;
                }
                if ($gOPD && i + 1 >= parts.length) {
                    var desc = $gOPD(value, part);
                    isOwn = !!desc;
                    if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                        value = desc.get;
                    }
                    else {
                        value = value[part];
                    }
                }
                else {
                    isOwn = hasOwn(value, part);
                    value = value[part];
                }
                if (isOwn && !skipFurtherCaching) {
                    INTRINSICS[intrinsicRealName] = value;
                }
            }
        }
        return value;
    };
    return getIntrinsic;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
    if (hasRequiredSetFunctionLength)
        return setFunctionLength;
    hasRequiredSetFunctionLength = 1;
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var define = /* @__PURE__ */ requireDefineDataProperty();
    var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
    var gOPD2 = /* @__PURE__ */ requireGopd();
    var $TypeError = /* @__PURE__ */ requireType();
    var $floor = GetIntrinsic("%Math.floor%");
    setFunctionLength = function setFunctionLength2(fn, length) {
        if (typeof fn !== "function") {
            throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
            throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD2) {
            var desc = gOPD2(fn, "length");
            if (desc && !desc.configurable) {
                functionLengthIsConfigurable = false;
            }
            if (desc && !desc.writable) {
                functionLengthIsWritable = false;
            }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
            if (hasDescriptors) {
                define(
                /** @type {Parameters<define>[0]} */
                fn, "length", length, true, true);
            }
            else {
                define(
                /** @type {Parameters<define>[0]} */
                fn, "length", length);
            }
        }
        return fn;
    };
    return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
    if (hasRequiredApplyBind)
        return applyBind;
    hasRequiredApplyBind = 1;
    var bind = requireFunctionBind();
    var $apply = requireFunctionApply();
    var actualApply2 = requireActualApply();
    applyBind = function applyBind2() {
        return actualApply2(bind, $apply, arguments);
    };
    return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
    if (hasRequiredCallBind)
        return callBind.exports;
    hasRequiredCallBind = 1;
    (function (module2) {
        var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
        var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
        var callBindBasic = requireCallBindApplyHelpers();
        var applyBind2 = requireApplyBind();
        module2.exports = function callBind2(originalFunction) {
            var func = callBindBasic(arguments);
            var adjustedLength = originalFunction.length - (arguments.length - 1);
            return setFunctionLength2(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
        };
        if ($defineProperty) {
            $defineProperty(module2.exports, "apply", { value: applyBind2 });
        }
        else {
            module2.exports.apply = applyBind2;
        }
    })(callBind);
    return callBind.exports;
}
var callBound$1;
var hasRequiredCallBound$1;
function requireCallBound$1() {
    if (hasRequiredCallBound$1)
        return callBound$1;
    hasRequiredCallBound$1 = 1;
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var callBindBasic = requireCallBindApplyHelpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    callBound$1 = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing));
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
            return callBindBasic(
            /** @type {const} */
            [intrinsic]);
        }
        return intrinsic;
    };
    return callBound$1;
}
var implementation$2;
var hasRequiredImplementation$2;
function requireImplementation$2() {
    if (hasRequiredImplementation$2)
        return implementation$2;
    hasRequiredImplementation$2 = 1;
    var objectKeys2 = requireObjectKeys();
    var hasSymbols2 = requireShams$1()();
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $Object = /* @__PURE__ */ requireEsObjectAtoms();
    var $push = callBound2("Array.prototype.push");
    var $propIsEnumerable = callBound2("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols2 ? $Object.getOwnPropertySymbols : null;
    implementation$2 = function assign(target, source1) {
        if (target == null) {
            throw new TypeError("target must be an object");
        }
        var to = $Object(target);
        if (arguments.length === 1) {
            return to;
        }
        for (var s = 1; s < arguments.length; ++s) {
            var from = $Object(arguments[s]);
            var keys2 = objectKeys2(from);
            var getSymbols = hasSymbols2 && ($Object.getOwnPropertySymbols || originalGetSymbols);
            if (getSymbols) {
                var syms = getSymbols(from);
                for (var j = 0; j < syms.length; ++j) {
                    var key = syms[j];
                    if ($propIsEnumerable(from, key)) {
                        $push(keys2, key);
                    }
                }
            }
            for (var i = 0; i < keys2.length; ++i) {
                var nextKey = keys2[i];
                if ($propIsEnumerable(from, nextKey)) {
                    var propValue = from[nextKey];
                    to[nextKey] = propValue;
                }
            }
        }
        return to;
    };
    return implementation$2;
}
var polyfill$2;
var hasRequiredPolyfill$2;
function requirePolyfill$2() {
    if (hasRequiredPolyfill$2)
        return polyfill$2;
    hasRequiredPolyfill$2 = 1;
    var implementation2 = requireImplementation$2();
    var lacksProperEnumerationOrder = function () {
        if (!Object.assign) {
            return false;
        }
        var str = "abcdefghijklmnopqrst";
        var letters = str.split("");
        var map = {};
        for (var i = 0; i < letters.length; ++i) {
            map[letters[i]] = letters[i];
        }
        var obj = Object.assign({}, map);
        var actual = "";
        for (var k in obj) {
            actual += k;
        }
        return str !== actual;
    };
    var assignHasPendingExceptions = function () {
        if (!Object.assign || !Object.preventExtensions) {
            return false;
        }
        var thrower = Object.preventExtensions({ 1: 2 });
        try {
            Object.assign(thrower, "xy");
        }
        catch (e) {
            return thrower[1] === "y";
        }
        return false;
    };
    polyfill$2 = function getPolyfill() {
        if (!Object.assign) {
            return implementation2;
        }
        if (lacksProperEnumerationOrder()) {
            return implementation2;
        }
        if (assignHasPendingExceptions()) {
            return implementation2;
        }
        return Object.assign;
    };
    return polyfill$2;
}
var shim$2;
var hasRequiredShim$2;
function requireShim$2() {
    if (hasRequiredShim$2)
        return shim$2;
    hasRequiredShim$2 = 1;
    var define = requireDefineProperties();
    var getPolyfill = requirePolyfill$2();
    shim$2 = function shimAssign() {
        var polyfill2 = getPolyfill();
        define(Object, { assign: polyfill2 }, { assign: function () {
                return Object.assign !== polyfill2;
            } });
        return polyfill2;
    };
    return shim$2;
}
var object_assign;
var hasRequiredObject_assign;
function requireObject_assign() {
    if (hasRequiredObject_assign)
        return object_assign;
    hasRequiredObject_assign = 1;
    var defineProperties = requireDefineProperties();
    var callBind2 = requireCallBind();
    var implementation2 = requireImplementation$2();
    var getPolyfill = requirePolyfill$2();
    var shim2 = requireShim$2();
    var polyfill2 = callBind2.apply(getPolyfill());
    var bound = function assign(target, source1) {
        return polyfill2(Object, arguments);
    };
    defineProperties(bound, {
        getPolyfill,
        implementation: implementation2,
        shim: shim2
    });
    object_assign = bound;
    return object_assign;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
    if (hasRequiredCallBound)
        return callBound;
    hasRequiredCallBound = 1;
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var callBind2 = requireCallBind();
    var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
    callBound = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
            return callBind2(intrinsic);
        }
        return intrinsic;
    };
    return callBound;
}
var functionsHaveNames_1;
var hasRequiredFunctionsHaveNames;
function requireFunctionsHaveNames() {
    if (hasRequiredFunctionsHaveNames)
        return functionsHaveNames_1;
    hasRequiredFunctionsHaveNames = 1;
    var functionsHaveNames = function functionsHaveNames2() {
        return typeof function f2() {
        }.name === "string";
    };
    var gOPD2 = Object.getOwnPropertyDescriptor;
    if (gOPD2) {
        try {
            gOPD2([], "length");
        }
        catch (e) {
            gOPD2 = null;
        }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD2) {
            return false;
        }
        var desc = gOPD2(function () {
        }, "name");
        return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && function f2() {
        }.bind().name !== "";
    };
    functionsHaveNames_1 = functionsHaveNames;
    return functionsHaveNames_1;
}
var setFunctionName;
var hasRequiredSetFunctionName;
function requireSetFunctionName() {
    if (hasRequiredSetFunctionName)
        return setFunctionName;
    hasRequiredSetFunctionName = 1;
    var define = /* @__PURE__ */ requireDefineDataProperty();
    var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
    var functionsHaveConfigurableNames = requireFunctionsHaveNames().functionsHaveConfigurableNames();
    var $TypeError = /* @__PURE__ */ requireType();
    setFunctionName = function setFunctionName2(fn, name) {
        if (typeof fn !== "function") {
            throw new $TypeError("`fn` is not a function");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        if (!loose || functionsHaveConfigurableNames) {
            if (hasDescriptors) {
                define(
                /** @type {Parameters<define>[0]} */
                fn, "name", name, true, true);
            }
            else {
                define(
                /** @type {Parameters<define>[0]} */
                fn, "name", name);
            }
        }
        return fn;
    };
    return setFunctionName;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
    if (hasRequiredImplementation$1)
        return implementation$1;
    hasRequiredImplementation$1 = 1;
    var setFunctionName2 = requireSetFunctionName();
    var $TypeError = /* @__PURE__ */ requireType();
    var $Object = Object;
    implementation$1 = setFunctionName2(function flags() {
        if (this == null || this !== $Object(this)) {
            throw new $TypeError("RegExp.prototype.flags getter called on non-object");
        }
        var result = "";
        if (this.hasIndices) {
            result += "d";
        }
        if (this.global) {
            result += "g";
        }
        if (this.ignoreCase) {
            result += "i";
        }
        if (this.multiline) {
            result += "m";
        }
        if (this.dotAll) {
            result += "s";
        }
        if (this.unicode) {
            result += "u";
        }
        if (this.unicodeSets) {
            result += "v";
        }
        if (this.sticky) {
            result += "y";
        }
        return result;
    }, "get flags", true);
    return implementation$1;
}
var polyfill$1;
var hasRequiredPolyfill$1;
function requirePolyfill$1() {
    if (hasRequiredPolyfill$1)
        return polyfill$1;
    hasRequiredPolyfill$1 = 1;
    var implementation2 = requireImplementation$1();
    var supportsDescriptors = requireDefineProperties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    polyfill$1 = function getPolyfill() {
        if (supportsDescriptors && /a/mig.flags === "gim") {
            var descriptor = $gOPD(RegExp.prototype, "flags");
            if (descriptor && typeof descriptor.get === "function" && "dotAll" in RegExp.prototype && "hasIndices" in RegExp.prototype) {
                var calls = "";
                var o = {};
                Object.defineProperty(o, "hasIndices", {
                    get: function () {
                        calls += "d";
                    }
                });
                Object.defineProperty(o, "sticky", {
                    get: function () {
                        calls += "y";
                    }
                });
                descriptor.get.call(o);
                if (calls === "dy") {
                    return descriptor.get;
                }
            }
        }
        return implementation2;
    };
    return polyfill$1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
    if (hasRequiredShim$1)
        return shim$1;
    hasRequiredShim$1 = 1;
    var supportsDescriptors = requireDefineProperties().supportsDescriptors;
    var getPolyfill = requirePolyfill$1();
    var gOPD2 = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto2 = Object.getPrototypeOf;
    var regex2 = /a/;
    shim$1 = function shimFlags() {
        if (!supportsDescriptors || !getProto2) {
            throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill2 = getPolyfill();
        var proto2 = getProto2(regex2);
        var descriptor = gOPD2(proto2, "flags");
        if (!descriptor || descriptor.get !== polyfill2) {
            defineProperty(proto2, "flags", {
                configurable: true,
                enumerable: false,
                get: polyfill2
            });
        }
        return polyfill2;
    };
    return shim$1;
}
var regexp_prototype_flags;
var hasRequiredRegexp_prototype_flags;
function requireRegexp_prototype_flags() {
    if (hasRequiredRegexp_prototype_flags)
        return regexp_prototype_flags;
    hasRequiredRegexp_prototype_flags = 1;
    var define = requireDefineProperties();
    var callBind2 = requireCallBind();
    var implementation2 = requireImplementation$1();
    var getPolyfill = requirePolyfill$1();
    var shim2 = requireShim$1();
    var flagsBound = callBind2(getPolyfill());
    define(flagsBound, {
        getPolyfill,
        implementation: implementation2,
        shim: shim2
    });
    regexp_prototype_flags = flagsBound;
    return regexp_prototype_flags;
}
var node;
var hasRequiredNode;
function requireNode() {
    if (hasRequiredNode)
        return node;
    hasRequiredNode = 1;
    var $iterator = Symbol.iterator;
    node = function getIterator(iterable) {
        if (iterable != null && typeof iterable[$iterator] !== "undefined") {
            return iterable[$iterator]();
        }
    };
    return node;
}
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
    if (hasRequiredUtil_inspect)
        return util_inspect;
    hasRequiredUtil_inspect = 1;
    util_inspect = require$$0$1.inspect;
    return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
    if (hasRequiredObjectInspect)
        return objectInspect;
    hasRequiredObjectInspect = 1;
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (O) {
        return O.__proto__;
    } : null);
    function addNumericSeparator(num2, str) {
        if (num2 === Infinity || num2 === -Infinity || num2 !== num2 || num2 && num2 > -1e3 && num2 < 1e3 || $test.call(/e/, str)) {
            return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num2 === "number") {
            var int = num2 < 0 ? -$floor(-num2) : $floor(num2);
            if (int !== num2) {
                var intStr = String(int);
                var dec = $slice.call(str, intStr.length + 1);
                return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
            }
        }
        return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = /* @__PURE__ */ requireUtil_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
    var quotes = {
        __proto__: null,
        "double": '"',
        single: "'"
    };
    var quoteREs = {
        __proto__: null,
        "double": /(["\\])/g,
        single: /(['\\])/g
    };
    objectInspect = function inspect_(obj, options2, depth, seen) {
        var opts = options2 || {};
        if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
            throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
            throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
            throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }
        if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
            throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
            throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") {
            return "undefined";
        }
        if (obj === null) {
            return "null";
        }
        if (typeof obj === "boolean") {
            return obj ? "true" : "false";
        }
        if (typeof obj === "string") {
            return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
            if (obj === 0) {
                return Infinity / obj > 0 ? "0" : "-0";
            }
            var str = String(obj);
            return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
            var bigIntStr = String(obj) + "n";
            return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
            depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
            return isArray(obj) ? "[Array]" : "[Object]";
        }
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") {
            seen = [];
        }
        else if (indexOf(seen, obj) >= 0) {
            return "[Circular]";
        }
        function inspect(value, from, noIndent) {
            if (from) {
                seen = $arrSlice.call(seen);
                seen.push(from);
            }
            if (noIndent) {
                var newOpts = {
                    depth: opts.depth
                };
                if (has(opts, "quoteStyle")) {
                    newOpts.quoteStyle = opts.quoteStyle;
                }
                return inspect_(value, newOpts, depth + 1, seen);
            }
            return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function" && !isRegExp(obj)) {
            var name = nameOf(obj);
            var keys2 = arrObjKeys(obj, inspect);
            return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
        }
        if (isSymbol2(obj)) {
            var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
            return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement(obj)) {
            var s = "<" + $toLowerCase.call(String(obj.nodeName));
            var attrs = obj.attributes || [];
            for (var i = 0; i < attrs.length; i++) {
                s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
            }
            s += ">";
            if (obj.childNodes && obj.childNodes.length) {
                s += "...";
            }
            s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
            return s;
        }
        if (isArray(obj)) {
            if (obj.length === 0) {
                return "[]";
            }
            var xs = arrObjKeys(obj, inspect);
            if (indent && !singleLineValues(xs)) {
                return "[" + indentedJoin(xs, indent) + "]";
            }
            return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError2(obj)) {
            var parts = arrObjKeys(obj, inspect);
            if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
                return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
            }
            if (parts.length === 0) {
                return "[" + String(obj) + "]";
            }
            return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
            if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
                return utilInspect(obj, { depth: maxDepth - depth });
            }
            else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
                return obj.inspect();
            }
        }
        if (isMap2(obj)) {
            var mapParts = [];
            if (mapForEach) {
                mapForEach.call(obj, function (value, key) {
                    mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
                });
            }
            return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet2(obj)) {
            var setParts = [];
            if (setForEach) {
                setForEach.call(obj, function (value) {
                    setParts.push(inspect(value, obj));
                });
            }
            return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) {
            return weakCollectionOf("WeakMap");
        }
        if (isWeakSet(obj)) {
            return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
            return weakCollectionOf("WeakRef");
        }
        if (isNumber(obj)) {
            return markBoxed(inspect(Number(obj)));
        }
        if (isBigInt(obj)) {
            return markBoxed(inspect(bigIntValueOf.call(obj)));
        }
        if (isBoolean(obj)) {
            return markBoxed(booleanValueOf.call(obj));
        }
        if (isString2(obj)) {
            return markBoxed(inspect(String(obj)));
        }
        if (typeof window !== "undefined" && obj === window) {
            return "{ [object Window] }";
        }
        if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
            return "{ [object globalThis] }";
        }
        if (!isDate2(obj) && !isRegExp(obj)) {
            var ys = arrObjKeys(obj, inspect);
            var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
            var protoTag = obj instanceof Object ? "" : "null prototype";
            var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
            var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
            var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
            if (ys.length === 0) {
                return tag + "{}";
            }
            if (indent) {
                return tag + "{" + indentedJoin(ys, indent) + "}";
            }
            return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
        var style = opts.quoteStyle || defaultStyle;
        var quoteChar = quotes[style];
        return quoteChar + s + quoteChar;
    }
    function quote(s) {
        return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
        return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
        return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
        return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
        return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
        return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
        return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
        return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol2(obj) {
        if (hasShammedSymbols) {
            return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
            return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
            return false;
        }
        try {
            symToString.call(obj);
            return true;
        }
        catch (e) {
        }
        return false;
    }
    function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) {
            return false;
        }
        try {
            bigIntValueOf.call(obj);
            return true;
        }
        catch (e) {
        }
        return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function (key) {
        return key in this;
    };
    function has(obj, key) {
        return hasOwn.call(obj, key);
    }
    function toStr(obj) {
        return objectToString.call(obj);
    }
    function nameOf(f2) {
        if (f2.name) {
            return f2.name;
        }
        var m = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
        if (m) {
            return m[1];
        }
        return null;
    }
    function indexOf(xs, x) {
        if (xs.indexOf) {
            return xs.indexOf(x);
        }
        for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) {
                return i;
            }
        }
        return -1;
    }
    function isMap2(x) {
        if (!mapSize || !x || typeof x !== "object") {
            return false;
        }
        try {
            mapSize.call(x);
            try {
                setSize.call(x);
            }
            catch (s) {
                return true;
            }
            return x instanceof Map;
        }
        catch (e) {
        }
        return false;
    }
    function isWeakMap(x) {
        if (!weakMapHas || !x || typeof x !== "object") {
            return false;
        }
        try {
            weakMapHas.call(x, weakMapHas);
            try {
                weakSetHas.call(x, weakSetHas);
            }
            catch (s) {
                return true;
            }
            return x instanceof WeakMap;
        }
        catch (e) {
        }
        return false;
    }
    function isWeakRef(x) {
        if (!weakRefDeref || !x || typeof x !== "object") {
            return false;
        }
        try {
            weakRefDeref.call(x);
            return true;
        }
        catch (e) {
        }
        return false;
    }
    function isSet2(x) {
        if (!setSize || !x || typeof x !== "object") {
            return false;
        }
        try {
            setSize.call(x);
            try {
                mapSize.call(x);
            }
            catch (m) {
                return true;
            }
            return x instanceof Set;
        }
        catch (e) {
        }
        return false;
    }
    function isWeakSet(x) {
        if (!weakSetHas || !x || typeof x !== "object") {
            return false;
        }
        try {
            weakSetHas.call(x, weakSetHas);
            try {
                weakMapHas.call(x, weakMapHas);
            }
            catch (s) {
                return true;
            }
            return x instanceof WeakSet;
        }
        catch (e) {
        }
        return false;
    }
    function isElement(x) {
        if (!x || typeof x !== "object") {
            return false;
        }
        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
            return true;
        }
        return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
            var remaining = str.length - opts.maxStringLength;
            var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
            return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        var quoteRE = quoteREs[opts.quoteStyle || "single"];
        quoteRE.lastIndex = 0;
        var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
        var n = c.charCodeAt(0);
        var x = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[n];
        if (x) {
            return "\\" + x;
        }
        return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
        return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
        return type2 + " { ? }";
    }
    function collectionOf(type2, size2, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type2 + " (" + size2 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
        for (var i = 0; i < xs.length; i++) {
            if (indexOf(xs[i], "\n") >= 0) {
                return false;
            }
        }
        return true;
    }
    function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") {
            baseIndent = "	";
        }
        else if (typeof opts.indent === "number" && opts.indent > 0) {
            baseIndent = $join.call(Array(opts.indent + 1), " ");
        }
        else {
            return null;
        }
        return {
            base: baseIndent,
            prev: $join.call(Array(depth + 1), baseIndent)
        };
    }
    function indentedJoin(xs, indent) {
        if (xs.length === 0) {
            return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
        var isArr = isArray(obj);
        var xs = [];
        if (isArr) {
            xs.length = obj.length;
            for (var i = 0; i < obj.length; i++) {
                xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
            }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
            symMap = {};
            for (var k = 0; k < syms.length; k++) {
                symMap["$" + syms[k]] = syms[k];
            }
        }
        for (var key in obj) {
            if (!has(obj, key)) {
                continue;
            }
            if (isArr && String(Number(key)) === key && key < obj.length) {
                continue;
            }
            if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
                continue;
            }
            else if ($test.call(/[^\w$]/, key)) {
                xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
            }
            else {
                xs.push(key + ": " + inspect(obj[key], obj));
            }
        }
        if (typeof gOPS === "function") {
            for (var j = 0; j < syms.length; j++) {
                if (isEnumerable.call(obj, syms[j])) {
                    xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
                }
            }
        }
        return xs;
    }
    return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
    if (hasRequiredSideChannelList)
        return sideChannelList;
    hasRequiredSideChannelList = 1;
    var inspect = /* @__PURE__ */ requireObjectInspect();
    var $TypeError = /* @__PURE__ */ requireType();
    var listGetNode = function (list, key, isDelete) {
        var prev = list;
        var curr;
        for (; (curr = prev.next) != null; prev = curr) {
            if (curr.key === key) {
                prev.next = curr.next;
                if (!isDelete) {
                    curr.next = /** @type {NonNullable<typeof list.next>} */
                        list.next;
                    list.next = curr;
                }
                return curr;
            }
        }
    };
    var listGet = function (objects, key) {
        if (!objects) {
            return void 0;
        }
        var node2 = listGetNode(objects, key);
        return node2 && node2.value;
    };
    var listSet = function (objects, key, value) {
        var node2 = listGetNode(objects, key);
        if (node2) {
            node2.value = value;
        }
        else {
            objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
                {
                    // eslint-disable-line no-param-reassign, no-extra-parens
                    key,
                    next: objects.next,
                    value
                };
        }
    };
    var listHas = function (objects, key) {
        if (!objects) {
            return false;
        }
        return !!listGetNode(objects, key);
    };
    var listDelete = function (objects, key) {
        if (objects) {
            return listGetNode(objects, key, true);
        }
    };
    sideChannelList = function getSideChannelList() {
        var $o;
        var channel = {
            assert: function (key) {
                if (!channel.has(key)) {
                    throw new $TypeError("Side channel does not contain " + inspect(key));
                }
            },
            "delete": function (key) {
                var root = $o && $o.next;
                var deletedNode = listDelete($o, key);
                if (deletedNode && root && root === deletedNode) {
                    $o = void 0;
                }
                return !!deletedNode;
            },
            get: function (key) {
                return listGet($o, key);
            },
            has: function (key) {
                return listHas($o, key);
            },
            set: function (key, value) {
                if (!$o) {
                    $o = {
                        next: void 0
                    };
                }
                listSet(
                /** @type {NonNullable<typeof $o>} */
                $o, key, value);
            }
        };
        return channel;
    };
    return sideChannelList;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
    if (hasRequiredSideChannelMap)
        return sideChannelMap;
    hasRequiredSideChannelMap = 1;
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var inspect = /* @__PURE__ */ requireObjectInspect();
    var $TypeError = /* @__PURE__ */ requireType();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound2("Map.prototype.get", true);
    var $mapSet = callBound2("Map.prototype.set", true);
    var $mapHas = callBound2("Map.prototype.has", true);
    var $mapDelete = callBound2("Map.prototype.delete", true);
    var $mapSize = callBound2("Map.prototype.size", true);
    sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
        function getSideChannelMap() {
            var $m;
            var channel = {
                assert: function (key) {
                    if (!channel.has(key)) {
                        throw new $TypeError("Side channel does not contain " + inspect(key));
                    }
                },
                "delete": function (key) {
                    if ($m) {
                        var result = $mapDelete($m, key);
                        if ($mapSize($m) === 0) {
                            $m = void 0;
                        }
                        return result;
                    }
                    return false;
                },
                get: function (key) {
                    if ($m) {
                        return $mapGet($m, key);
                    }
                },
                has: function (key) {
                    if ($m) {
                        return $mapHas($m, key);
                    }
                    return false;
                },
                set: function (key, value) {
                    if (!$m) {
                        $m = new $Map();
                    }
                    $mapSet($m, key, value);
                }
            };
            return channel;
        };
    return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
    if (hasRequiredSideChannelWeakmap)
        return sideChannelWeakmap;
    hasRequiredSideChannelWeakmap = 1;
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var inspect = /* @__PURE__ */ requireObjectInspect();
    var getSideChannelMap = requireSideChannelMap();
    var $TypeError = /* @__PURE__ */ requireType();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound2("WeakMap.prototype.get", true);
    var $weakMapSet = callBound2("WeakMap.prototype.set", true);
    var $weakMapHas = callBound2("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
    sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
            assert: function (key) {
                if (!channel.has(key)) {
                    throw new $TypeError("Side channel does not contain " + inspect(key));
                }
            },
            "delete": function (key) {
                if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                    if ($wm) {
                        return $weakMapDelete($wm, key);
                    }
                }
                else if (getSideChannelMap) {
                    if ($m) {
                        return $m["delete"](key);
                    }
                }
                return false;
            },
            get: function (key) {
                if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                    if ($wm) {
                        return $weakMapGet($wm, key);
                    }
                }
                return $m && $m.get(key);
            },
            has: function (key) {
                if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                    if ($wm) {
                        return $weakMapHas($wm, key);
                    }
                }
                return !!$m && $m.has(key);
            },
            set: function (key, value) {
                if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                    if (!$wm) {
                        $wm = new $WeakMap();
                    }
                    $weakMapSet($wm, key, value);
                }
                else if (getSideChannelMap) {
                    if (!$m) {
                        $m = getSideChannelMap();
                    }
                    $m.set(key, value);
                }
            }
        };
        return channel;
    }) : getSideChannelMap;
    return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
    if (hasRequiredSideChannel)
        return sideChannel;
    hasRequiredSideChannel = 1;
    var $TypeError = /* @__PURE__ */ requireType();
    var inspect = /* @__PURE__ */ requireObjectInspect();
    var getSideChannelList = requireSideChannelList();
    var getSideChannelMap = requireSideChannelMap();
    var getSideChannelWeakMap = requireSideChannelWeakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    sideChannel = function getSideChannel() {
        var $channelData;
        var channel = {
            assert: function (key) {
                if (!channel.has(key)) {
                    throw new $TypeError("Side channel does not contain " + inspect(key));
                }
            },
            "delete": function (key) {
                return !!$channelData && $channelData["delete"](key);
            },
            get: function (key) {
                return $channelData && $channelData.get(key);
            },
            has: function (key) {
                return !!$channelData && $channelData.has(key);
            },
            set: function (key, value) {
                if (!$channelData) {
                    $channelData = makeChannel();
                }
                $channelData.set(key, value);
            }
        };
        return channel;
    };
    return sideChannel;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
    if (hasRequiredImplementation)
        return implementation;
    hasRequiredImplementation = 1;
    var numberIsNaN = function (value) {
        return value !== value;
    };
    implementation = function is2(a, b) {
        if (a === 0 && b === 0) {
            return 1 / a === 1 / b;
        }
        if (a === b) {
            return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
            return true;
        }
        return false;
    };
    return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
    if (hasRequiredPolyfill)
        return polyfill;
    hasRequiredPolyfill = 1;
    var implementation2 = requireImplementation();
    polyfill = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation2;
    };
    return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
    if (hasRequiredShim)
        return shim;
    hasRequiredShim = 1;
    var getPolyfill = requirePolyfill();
    var define = requireDefineProperties();
    shim = function shimObjectIs() {
        var polyfill2 = getPolyfill();
        define(Object, { is: polyfill2 }, {
            is: function testObjectIs() {
                return Object.is !== polyfill2;
            }
        });
        return polyfill2;
    };
    return shim;
}
var objectIs;
var hasRequiredObjectIs;
function requireObjectIs() {
    if (hasRequiredObjectIs)
        return objectIs;
    hasRequiredObjectIs = 1;
    var define = requireDefineProperties();
    var callBind2 = requireCallBind();
    var implementation2 = requireImplementation();
    var getPolyfill = requirePolyfill();
    var shim2 = requireShim();
    var polyfill2 = callBind2(getPolyfill(), Object);
    define(polyfill2, {
        getPolyfill,
        implementation: implementation2,
        shim: shim2
    });
    objectIs = polyfill2;
    return objectIs;
}
var shams;
var hasRequiredShams;
function requireShams() {
    if (hasRequiredShams)
        return shams;
    hasRequiredShams = 1;
    var hasSymbols2 = requireShams$1();
    shams = function hasToStringTagShams() {
        return hasSymbols2() && !!Symbol.toStringTag;
    };
    return shams;
}
var isArguments;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
    if (hasRequiredIsArguments$1)
        return isArguments;
    hasRequiredIsArguments$1 = 1;
    var hasToStringTag = requireShams()();
    var callBound2 = requireCallBound();
    var $toString = callBound2("Object.prototype.toString");
    var isStandardArguments = function isArguments2(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
            return false;
        }
        return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments2(value) {
        if (isStandardArguments(value)) {
            return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function () {
        return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    return isArguments;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
    if (hasRequiredIsarray)
        return isarray;
    hasRequiredIsarray = 1;
    var toString = {}.toString;
    isarray = Array.isArray || function (arr) {
        return toString.call(arr) == "[object Array]";
    };
    return isarray;
}
var isArrayBuffer;
var hasRequiredIsArrayBuffer;
function requireIsArrayBuffer() {
    if (hasRequiredIsArrayBuffer)
        return isArrayBuffer;
    hasRequiredIsArrayBuffer = 1;
    var callBind2 = requireCallBind();
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var $ArrayBuffer = GetIntrinsic("%ArrayBuffer%", true);
    var $byteLength = callBound2("ArrayBuffer.prototype.byteLength", true);
    var $toString = callBound2("Object.prototype.toString");
    var abSlice = !!$ArrayBuffer && !$byteLength && new $ArrayBuffer(0).slice;
    var $abSlice = !!abSlice && callBind2(abSlice);
    isArrayBuffer = $byteLength || $abSlice ? function isArrayBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
            return false;
        }
        try {
            if ($byteLength) {
                $byteLength(obj);
            }
            else {
                $abSlice(obj, 0);
            }
            return true;
        }
        catch (e) {
            return false;
        }
    } : $ArrayBuffer ? function isArrayBuffer2(obj) {
        return $toString(obj) === "[object ArrayBuffer]";
    } : function isArrayBuffer2(obj) {
        return false;
    };
    return isArrayBuffer;
}
var isDateObject;
var hasRequiredIsDateObject;
function requireIsDateObject() {
    if (hasRequiredIsDateObject)
        return isDateObject;
    hasRequiredIsDateObject = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var getDay2 = callBound2("Date.prototype.getDay");
    var tryDateObject = function tryDateGetDayCall(value) {
        try {
            getDay2(value);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    var toStr = callBound2("Object.prototype.toString");
    var dateClass = "[object Date]";
    var hasToStringTag = requireShams()();
    isDateObject = function isDateObject2(value) {
        if (typeof value !== "object" || value === null) {
            return false;
        }
        return hasToStringTag ? tryDateObject(value) : toStr(value) === dateClass;
    };
    return isDateObject;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
    if (hasRequiredIsRegex)
        return isRegex;
    hasRequiredIsRegex = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var hasToStringTag = requireShams()();
    var hasOwn = /* @__PURE__ */ requireHasown();
    var gOPD2 = /* @__PURE__ */ requireGopd();
    var fn;
    if (hasToStringTag) {
        var $exec = callBound2("RegExp.prototype.exec");
        var isRegexMarker = {};
        var throwRegexMarker = function () {
            throw isRegexMarker;
        };
        var badStringifier = {
            toString: throwRegexMarker,
            valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
            badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
        fn = function isRegex2(value) {
            if (!value || typeof value !== "object") {
                return false;
            }
            var descriptor = (
            /** @type {NonNullable<typeof gOPD>} */
            gOPD2(
            /** @type {{ lastIndex?: unknown }} */
            value, "lastIndex"));
            var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
            if (!hasLastIndexDataProperty) {
                return false;
            }
            try {
                $exec(value, 
                /** @type {string} */
                /** @type {unknown} */
                badStringifier);
            }
            catch (e) {
                return e === isRegexMarker;
            }
        };
    }
    else {
        var $toString = callBound2("Object.prototype.toString");
        var regexClass = "[object RegExp]";
        fn = function isRegex2(value) {
            if (!value || typeof value !== "object" && typeof value !== "function") {
                return false;
            }
            return $toString(value) === regexClass;
        };
    }
    isRegex = fn;
    return isRegex;
}
var isSharedArrayBuffer;
var hasRequiredIsSharedArrayBuffer;
function requireIsSharedArrayBuffer() {
    if (hasRequiredIsSharedArrayBuffer)
        return isSharedArrayBuffer;
    hasRequiredIsSharedArrayBuffer = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $byteLength = callBound2("SharedArrayBuffer.prototype.byteLength", true);
    isSharedArrayBuffer = $byteLength ? function isSharedArrayBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
            return false;
        }
        try {
            $byteLength(obj);
            return true;
        }
        catch (e) {
            return false;
        }
    } : function isSharedArrayBuffer2(_obj) {
        return false;
    };
    return isSharedArrayBuffer;
}
var isString;
var hasRequiredIsString;
function requireIsString() {
    if (hasRequiredIsString)
        return isString;
    hasRequiredIsString = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $strValueOf = callBound2("String.prototype.valueOf");
    var tryStringObject = function tryStringObject2(value) {
        try {
            $strValueOf(value);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    var $toString = callBound2("Object.prototype.toString");
    var strClass = "[object String]";
    var hasToStringTag = requireShams()();
    isString = function isString2(value) {
        if (typeof value === "string") {
            return true;
        }
        if (!value || typeof value !== "object") {
            return false;
        }
        return hasToStringTag ? tryStringObject(value) : $toString(value) === strClass;
    };
    return isString;
}
var isNumberObject;
var hasRequiredIsNumberObject;
function requireIsNumberObject() {
    if (hasRequiredIsNumberObject)
        return isNumberObject;
    hasRequiredIsNumberObject = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $numToStr = callBound2("Number.prototype.toString");
    var tryNumberObject = function tryNumberObject2(value) {
        try {
            $numToStr(value);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    var $toString = callBound2("Object.prototype.toString");
    var numClass = "[object Number]";
    var hasToStringTag = requireShams()();
    isNumberObject = function isNumberObject2(value) {
        if (typeof value === "number") {
            return true;
        }
        if (!value || typeof value !== "object") {
            return false;
        }
        return hasToStringTag ? tryNumberObject(value) : $toString(value) === numClass;
    };
    return isNumberObject;
}
var isBooleanObject;
var hasRequiredIsBooleanObject;
function requireIsBooleanObject() {
    if (hasRequiredIsBooleanObject)
        return isBooleanObject;
    hasRequiredIsBooleanObject = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $boolToStr = callBound2("Boolean.prototype.toString");
    var $toString = callBound2("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value) {
        try {
            $boolToStr(value);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag = requireShams()();
    isBooleanObject = function isBoolean(value) {
        if (typeof value === "boolean") {
            return true;
        }
        if (value === null || typeof value !== "object") {
            return false;
        }
        return hasToStringTag ? tryBooleanObject(value) : $toString(value) === boolClass;
    };
    return isBooleanObject;
}
var isSymbol$1 = { exports: {} };
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
    if (hasRequiredSafeRegexTest)
        return safeRegexTest;
    hasRequiredSafeRegexTest = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var isRegex2 = requireIsRegex();
    var $exec = callBound2("RegExp.prototype.exec");
    var $TypeError = /* @__PURE__ */ requireType();
    safeRegexTest = function regexTester(regex2) {
        if (!isRegex2(regex2)) {
            throw new $TypeError("`regex` must be a RegExp");
        }
        return function test(s) {
            return $exec(regex2, s) !== null;
        };
    };
    return safeRegexTest;
}
var hasRequiredIsSymbol;
function requireIsSymbol() {
    if (hasRequiredIsSymbol)
        return isSymbol$1.exports;
    hasRequiredIsSymbol = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $toString = callBound2("Object.prototype.toString");
    var hasSymbols2 = requireHasSymbols()();
    var safeRegexTest2 = /* @__PURE__ */ requireSafeRegexTest();
    if (hasSymbols2) {
        var $symToStr = callBound2("Symbol.prototype.toString");
        var isSymString = safeRegexTest2(/^Symbol\(.*\)$/);
        var isSymbolObject = function isRealSymbolObject(value) {
            if (typeof value.valueOf() !== "symbol") {
                return false;
            }
            return isSymString($symToStr(value));
        };
        isSymbol$1.exports = function isSymbol2(value) {
            if (typeof value === "symbol") {
                return true;
            }
            if (!value || typeof value !== "object" || $toString(value) !== "[object Symbol]") {
                return false;
            }
            try {
                return isSymbolObject(value);
            }
            catch (e) {
                return false;
            }
        };
    }
    else {
        isSymbol$1.exports = function isSymbol2(value) {
            return false;
        };
    }
    return isSymbol$1.exports;
}
var isBigint = { exports: {} };
var hasBigints;
var hasRequiredHasBigints;
function requireHasBigints() {
    if (hasRequiredHasBigints)
        return hasBigints;
    hasRequiredHasBigints = 1;
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    hasBigints = function hasNativeBigInts() {
        return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
    };
    return hasBigints;
}
var hasRequiredIsBigint;
function requireIsBigint() {
    if (hasRequiredIsBigint)
        return isBigint.exports;
    hasRequiredIsBigint = 1;
    var hasBigInts = requireHasBigints()();
    if (hasBigInts) {
        var bigIntValueOf = BigInt.prototype.valueOf;
        var tryBigInt = function tryBigIntObject(value) {
            try {
                bigIntValueOf.call(value);
                return true;
            }
            catch (e) {
            }
            return false;
        };
        isBigint.exports = function isBigInt(value) {
            if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
                return false;
            }
            if (typeof value === "bigint") {
                return true;
            }
            return tryBigInt(value);
        };
    }
    else {
        isBigint.exports = function isBigInt(value) {
            return false;
        };
    }
    return isBigint.exports;
}
var whichBoxedPrimitive;
var hasRequiredWhichBoxedPrimitive;
function requireWhichBoxedPrimitive() {
    if (hasRequiredWhichBoxedPrimitive)
        return whichBoxedPrimitive;
    hasRequiredWhichBoxedPrimitive = 1;
    var isString2 = requireIsString();
    var isNumber = requireIsNumberObject();
    var isBoolean = requireIsBooleanObject();
    var isSymbol2 = requireIsSymbol();
    var isBigInt = requireIsBigint();
    whichBoxedPrimitive = function whichBoxedPrimitive2(value) {
        if (value == null || typeof value !== "object" && typeof value !== "function") {
            return null;
        }
        if (isString2(value)) {
            return "String";
        }
        if (isNumber(value)) {
            return "Number";
        }
        if (isBoolean(value)) {
            return "Boolean";
        }
        if (isSymbol2(value)) {
            return "Symbol";
        }
        if (isBigInt(value)) {
            return "BigInt";
        }
    };
    return whichBoxedPrimitive;
}
var isMap;
var hasRequiredIsMap;
function requireIsMap() {
    if (hasRequiredIsMap)
        return isMap;
    hasRequiredIsMap = 1;
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
        exported = function isMap2(x) {
            return false;
        };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
        exported = function isMap2(x) {
            return false;
        };
    }
    isMap = exported || function isMap2(x) {
        if (!x || typeof x !== "object") {
            return false;
        }
        try {
            $mapHas.call(x);
            if ($setHas) {
                try {
                    $setHas.call(x);
                }
                catch (e) {
                    return true;
                }
            }
            return x instanceof $Map;
        }
        catch (e) {
        }
        return false;
    };
    return isMap;
}
var isSet;
var hasRequiredIsSet;
function requireIsSet() {
    if (hasRequiredIsSet)
        return isSet;
    hasRequiredIsSet = 1;
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
        exported = function isSet2(x) {
            return false;
        };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
        exported = function isSet2(x) {
            return false;
        };
    }
    isSet = exported || function isSet2(x) {
        if (!x || typeof x !== "object") {
            return false;
        }
        try {
            $setHas.call(x);
            if ($mapHas) {
                try {
                    $mapHas.call(x);
                }
                catch (e) {
                    return true;
                }
            }
            return x instanceof $Set;
        }
        catch (e) {
        }
        return false;
    };
    return isSet;
}
var isWeakmap;
var hasRequiredIsWeakmap;
function requireIsWeakmap() {
    if (hasRequiredIsWeakmap)
        return isWeakmap;
    hasRequiredIsWeakmap = 1;
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported;
    if (!$WeakMap) {
        exported = function isWeakMap(x) {
            return false;
        };
    }
    var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported && !$mapHas) {
        exported = function isWeakMap(x) {
            return false;
        };
    }
    isWeakmap = exported || function isWeakMap(x) {
        if (!x || typeof x !== "object") {
            return false;
        }
        try {
            $mapHas.call(x, $mapHas);
            if ($setHas) {
                try {
                    $setHas.call(x, $setHas);
                }
                catch (e) {
                    return true;
                }
            }
            return x instanceof $WeakMap;
        }
        catch (e) {
        }
        return false;
    };
    return isWeakmap;
}
var isWeakset = { exports: {} };
var hasRequiredIsWeakset;
function requireIsWeakset() {
    if (hasRequiredIsWeakset)
        return isWeakset.exports;
    hasRequiredIsWeakset = 1;
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var callBound2 = requireCallBound();
    var $WeakSet = GetIntrinsic("%WeakSet%", true);
    var $setHas = callBound2("WeakSet.prototype.has", true);
    if ($setHas) {
        var $mapHas = callBound2("WeakMap.prototype.has", true);
        isWeakset.exports = function isWeakSet(x) {
            if (!x || typeof x !== "object") {
                return false;
            }
            try {
                $setHas(x, $setHas);
                if ($mapHas) {
                    try {
                        $mapHas(x, $mapHas);
                    }
                    catch (e) {
                        return true;
                    }
                }
                return x instanceof $WeakSet;
            }
            catch (e) {
            }
            return false;
        };
    }
    else {
        isWeakset.exports = function isWeakSet(x) {
            return false;
        };
    }
    return isWeakset.exports;
}
var whichCollection;
var hasRequiredWhichCollection;
function requireWhichCollection() {
    if (hasRequiredWhichCollection)
        return whichCollection;
    hasRequiredWhichCollection = 1;
    var isMap2 = /* @__PURE__ */ requireIsMap();
    var isSet2 = /* @__PURE__ */ requireIsSet();
    var isWeakMap = requireIsWeakmap();
    var isWeakSet = /* @__PURE__ */ requireIsWeakset();
    whichCollection = function whichCollection2(value) {
        if (value && typeof value === "object") {
            if (isMap2(value)) {
                return "Map";
            }
            if (isSet2(value)) {
                return "Set";
            }
            if (isWeakMap(value)) {
                return "WeakMap";
            }
            if (isWeakSet(value)) {
                return "WeakSet";
            }
        }
        return false;
    };
    return whichCollection;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
    if (hasRequiredIsCallable)
        return isCallable;
    hasRequiredIsCallable = 1;
    var fnToStr = Function.prototype.toString;
    var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
        try {
            badArrayLike = Object.defineProperty({}, "length", {
                get: function () {
                    throw isCallableMarker;
                }
            });
            isCallableMarker = {};
            reflectApply2(function () {
                throw 42;
            }, null, badArrayLike);
        }
        catch (_) {
            if (_ !== isCallableMarker) {
                reflectApply2 = null;
            }
        }
    }
    else {
        reflectApply2 = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
        try {
            var fnStr = fnToStr.call(value);
            return constructorRegex.test(fnStr);
        }
        catch (e) {
            return false;
        }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
        try {
            if (isES6ClassFn(value)) {
                return false;
            }
            fnToStr.call(value);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
        return false;
    };
    if (typeof document === "object") {
        var all2 = document.all;
        if (toStr.call(all2) === toStr.call(document.all)) {
            isDDA = function isDocumentDotAll(value) {
                if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                    try {
                        var str = toStr.call(value);
                        return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
                    }
                    catch (e) {
                    }
                }
                return false;
            };
        }
    }
    isCallable = reflectApply2 ? function isCallable2(value) {
        if (isDDA(value)) {
            return true;
        }
        if (!value) {
            return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
            return false;
        }
        try {
            reflectApply2(value, null, badArrayLike);
        }
        catch (e) {
            if (e !== isCallableMarker) {
                return false;
            }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable2(value) {
        if (isDDA(value)) {
            return true;
        }
        if (!value) {
            return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
            return false;
        }
        if (hasToStringTag) {
            return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
            return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
            return false;
        }
        return tryFunctionObject(value);
    };
    return isCallable;
}
var forEach;
var hasRequiredForEach;
function requireForEach() {
    if (hasRequiredForEach)
        return forEach;
    hasRequiredForEach = 1;
    var isCallable2 = requireIsCallable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
            if (hasOwnProperty.call(array, i)) {
                if (receiver == null) {
                    iterator(array[i], i, array);
                }
                else {
                    iterator.call(receiver, array[i], i, array);
                }
            }
        }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
            if (receiver == null) {
                iterator(string.charAt(i), i, string);
            }
            else {
                iterator.call(receiver, string.charAt(i), i, string);
            }
        }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
            if (hasOwnProperty.call(object, k)) {
                if (receiver == null) {
                    iterator(object[k], k, object);
                }
                else {
                    iterator.call(receiver, object[k], k, object);
                }
            }
        }
    };
    function isArray(x) {
        return toStr.call(x) === "[object Array]";
    }
    forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable2(iterator)) {
            throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
            receiver = thisArg;
        }
        if (isArray(list)) {
            forEachArray(list, iterator, receiver);
        }
        else if (typeof list === "string") {
            forEachString(list, iterator, receiver);
        }
        else {
            forEachObject(list, iterator, receiver);
        }
    };
    return forEach;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
    if (hasRequiredPossibleTypedArrayNames)
        return possibleTypedArrayNames;
    hasRequiredPossibleTypedArrayNames = 1;
    possibleTypedArrayNames = [
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array"
    ];
    return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
    if (hasRequiredAvailableTypedArrays)
        return availableTypedArrays;
    hasRequiredAvailableTypedArrays = 1;
    var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    availableTypedArrays = function availableTypedArrays2() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
            if (typeof g[possibleNames[i]] === "function") {
                out[out.length] = possibleNames[i];
            }
        }
        return out;
    };
    return availableTypedArrays;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
    if (hasRequiredWhichTypedArray)
        return whichTypedArray;
    hasRequiredWhichTypedArray = 1;
    var forEach2 = requireForEach();
    var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
    var callBind2 = requireCallBind();
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var gOPD2 = /* @__PURE__ */ requireGopd();
    var getProto2 = requireGetProto();
    var $toString = callBound2("Object.prototype.toString");
    var hasToStringTag = requireShams()();
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays = availableTypedArrays2();
    var $slice = callBound2("String.prototype.slice");
    var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
            if (array[i] === value) {
                return i;
            }
        }
        return -1;
    };
    var cache2 = { __proto__: null };
    if (hasToStringTag && gOPD2 && getProto2) {
        forEach2(typedArrays, function (typedArray) {
            var arr = new g[typedArray]();
            if (Symbol.toStringTag in arr && getProto2) {
                var proto2 = getProto2(arr);
                var descriptor = gOPD2(proto2, Symbol.toStringTag);
                if (!descriptor && proto2) {
                    var superProto = getProto2(proto2);
                    descriptor = gOPD2(superProto, Symbol.toStringTag);
                }
                cache2["$" + typedArray] = callBind2(descriptor.get);
            }
        });
    }
    else {
        forEach2(typedArrays, function (typedArray) {
            var arr = new g[typedArray]();
            var fn = arr.slice || arr.set;
            if (fn) {
                cache2[
                /** @type {`$${import('.').TypedArrayName}`} */
                "$" + typedArray] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
                    // @ts-expect-error TODO FIXME
                    callBind2(fn);
            }
        });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache2, 
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function (getter, typedArray) {
            if (!found) {
                try {
                    if ("$" + getter(value) === typedArray) {
                        found = /** @type {import('.').TypedArrayName} */
                            $slice(typedArray, 1);
                    }
                }
                catch (e) {
                }
            }
        });
        return found;
    };
    var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache2, 
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function (getter, name) {
            if (!found) {
                try {
                    getter(value);
                    found = /** @type {import('.').TypedArrayName} */
                        $slice(name, 1);
                }
                catch (e) {
                }
            }
        });
        return found;
    };
    whichTypedArray = function whichTypedArray2(value) {
        if (!value || typeof value !== "object") {
            return false;
        }
        if (!hasToStringTag) {
            var tag = $slice($toString(value), 8, -1);
            if ($indexOf(typedArrays, tag) > -1) {
                return tag;
            }
            if (tag !== "Object") {
                return false;
            }
            return trySlices(value);
        }
        if (!gOPD2) {
            return null;
        }
        return tryTypedArrays(value);
    };
    return whichTypedArray;
}
var arrayBufferByteLength;
var hasRequiredArrayBufferByteLength;
function requireArrayBufferByteLength() {
    if (hasRequiredArrayBufferByteLength)
        return arrayBufferByteLength;
    hasRequiredArrayBufferByteLength = 1;
    var callBound2 = /* @__PURE__ */ requireCallBound$1();
    var $byteLength = callBound2("ArrayBuffer.prototype.byteLength", true);
    var isArrayBuffer2 = /* @__PURE__ */ requireIsArrayBuffer();
    arrayBufferByteLength = function byteLength(ab) {
        if (!isArrayBuffer2(ab)) {
            return NaN;
        }
        return $byteLength ? $byteLength(ab) : ab.byteLength;
    };
    return arrayBufferByteLength;
}
var deepEqual$1;
var hasRequiredDeepEqual;
function requireDeepEqual() {
    if (hasRequiredDeepEqual)
        return deepEqual$1;
    hasRequiredDeepEqual = 1;
    var assign = requireObject_assign();
    var callBound2 = requireCallBound();
    var flags = requireRegexp_prototype_flags();
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var getIterator = requireNode();
    var getSideChannel = requireSideChannel();
    var is2 = requireObjectIs();
    var isArguments2 = requireIsArguments$1();
    var isArray = requireIsarray();
    var isArrayBuffer2 = /* @__PURE__ */ requireIsArrayBuffer();
    var isDate2 = /* @__PURE__ */ requireIsDateObject();
    var isRegex2 = requireIsRegex();
    var isSharedArrayBuffer2 = /* @__PURE__ */ requireIsSharedArrayBuffer();
    var objectKeys2 = requireObjectKeys();
    var whichBoxedPrimitive2 = requireWhichBoxedPrimitive();
    var whichCollection2 = /* @__PURE__ */ requireWhichCollection();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var byteLength = /* @__PURE__ */ requireArrayBufferByteLength();
    var sabByteLength = callBound2("SharedArrayBuffer.prototype.byteLength", true);
    var $getTime = callBound2("Date.prototype.getTime");
    var gPO = Object.getPrototypeOf;
    var $objToString = callBound2("Object.prototype.toString");
    var $Set = GetIntrinsic("%Set%", true);
    var $mapHas = callBound2("Map.prototype.has", true);
    var $mapGet = callBound2("Map.prototype.get", true);
    var $mapSize = callBound2("Map.prototype.size", true);
    var $setAdd = callBound2("Set.prototype.add", true);
    var $setDelete = callBound2("Set.prototype.delete", true);
    var $setHas = callBound2("Set.prototype.has", true);
    var $setSize = callBound2("Set.prototype.size", true);
    function setHasEqualElement(set, val1, opts, channel) {
        var i = getIterator(set);
        var result;
        while ((result = i.next()) && !result.done) {
            if (internalDeepEqual(val1, result.value, opts, channel)) {
                $setDelete(set, result.value);
                return true;
            }
        }
        return false;
    }
    function findLooseMatchingPrimitives(prim) {
        if (typeof prim === "undefined") {
            return null;
        }
        if (typeof prim === "object") {
            return void 0;
        }
        if (typeof prim === "symbol") {
            return false;
        }
        if (typeof prim === "string" || typeof prim === "number") {
            return +prim === +prim;
        }
        return true;
    }
    function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
            return altValue;
        }
        var curB = $mapGet(b, altValue);
        var looseOpts = assign({}, opts, { strict: false });
        if (typeof curB === "undefined" && !$mapHas(b, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
            return false;
        }
        return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
    }
    function setMightHaveLoosePrim(a, b, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
            return altValue;
        }
        return $setHas(b, altValue) && !$setHas(a, altValue);
    }
    function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
        var i = getIterator(set);
        var result;
        var key2;
        while ((result = i.next()) && !result.done) {
            key2 = result.value;
            if (
            // eslint-disable-next-line no-use-before-define
            internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)) {
                $setDelete(set, key2);
                return true;
            }
        }
        return false;
    }
    function internalDeepEqual(actual, expected, options2, channel) {
        var opts = options2 || {};
        if (opts.strict ? is2(actual, expected) : actual === expected) {
            return true;
        }
        var actualBoxed = whichBoxedPrimitive2(actual);
        var expectedBoxed = whichBoxedPrimitive2(expected);
        if (actualBoxed !== expectedBoxed) {
            return false;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
            return opts.strict ? is2(actual, expected) : actual == expected;
        }
        var hasActual = channel.has(actual);
        var hasExpected = channel.has(expected);
        var sentinel;
        if (hasActual && hasExpected) {
            if (channel.get(actual) === channel.get(expected)) {
                return true;
            }
        }
        else {
            sentinel = {};
        }
        if (!hasActual) {
            channel.set(actual, sentinel);
        }
        if (!hasExpected) {
            channel.set(expected, sentinel);
        }
        return objEquiv(actual, expected, opts, channel);
    }
    function isBuffer2(x) {
        if (!x || typeof x !== "object" || typeof x.length !== "number") {
            return false;
        }
        if (typeof x.copy !== "function" || typeof x.slice !== "function") {
            return false;
        }
        if (x.length > 0 && typeof x[0] !== "number") {
            return false;
        }
        return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
    }
    function setEquiv(a, b, opts, channel) {
        if ($setSize(a) !== $setSize(b)) {
            return false;
        }
        var iA = getIterator(a);
        var iB = getIterator(b);
        var resultA;
        var resultB;
        var set;
        while ((resultA = iA.next()) && !resultA.done) {
            if (resultA.value && typeof resultA.value === "object") {
                if (!set) {
                    set = new $Set();
                }
                $setAdd(set, resultA.value);
            }
            else if (!$setHas(b, resultA.value)) {
                if (opts.strict) {
                    return false;
                }
                if (!setMightHaveLoosePrim(a, b, resultA.value)) {
                    return false;
                }
                if (!set) {
                    set = new $Set();
                }
                $setAdd(set, resultA.value);
            }
        }
        if (set) {
            while ((resultB = iB.next()) && !resultB.done) {
                if (resultB.value && typeof resultB.value === "object") {
                    if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
                        return false;
                    }
                }
                else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
                    return false;
                }
            }
            return $setSize(set) === 0;
        }
        return true;
    }
    function mapEquiv(a, b, opts, channel) {
        if ($mapSize(a) !== $mapSize(b)) {
            return false;
        }
        var iA = getIterator(a);
        var iB = getIterator(b);
        var resultA;
        var resultB;
        var set;
        var key;
        var item1;
        var item2;
        while ((resultA = iA.next()) && !resultA.done) {
            key = resultA.value[0];
            item1 = resultA.value[1];
            if (key && typeof key === "object") {
                if (!set) {
                    set = new $Set();
                }
                $setAdd(set, key);
            }
            else {
                item2 = $mapGet(b, key);
                if (typeof item2 === "undefined" && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
                    if (opts.strict) {
                        return false;
                    }
                    if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
                        return false;
                    }
                    if (!set) {
                        set = new $Set();
                    }
                    $setAdd(set, key);
                }
            }
        }
        if (set) {
            while ((resultB = iB.next()) && !resultB.done) {
                key = resultB.value[0];
                item2 = resultB.value[1];
                if (key && typeof key === "object") {
                    if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
                        return false;
                    }
                }
                else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel)) && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)) {
                    return false;
                }
            }
            return $setSize(set) === 0;
        }
        return true;
    }
    function objEquiv(a, b, opts, channel) {
        var i, key;
        if (typeof a !== typeof b) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if ($objToString(a) !== $objToString(b)) {
            return false;
        }
        if (isArguments2(a) !== isArguments2(b)) {
            return false;
        }
        var aIsArray = isArray(a);
        var bIsArray = isArray(b);
        if (aIsArray !== bIsArray) {
            return false;
        }
        var aIsError = a instanceof Error;
        var bIsError = b instanceof Error;
        if (aIsError !== bIsError) {
            return false;
        }
        if (aIsError || bIsError) {
            if (a.name !== b.name || a.message !== b.message) {
                return false;
            }
        }
        var aIsRegex = isRegex2(a);
        var bIsRegex = isRegex2(b);
        if (aIsRegex !== bIsRegex) {
            return false;
        }
        if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {
            return false;
        }
        var aIsDate = isDate2(a);
        var bIsDate = isDate2(b);
        if (aIsDate !== bIsDate) {
            return false;
        }
        if (aIsDate || bIsDate) {
            if ($getTime(a) !== $getTime(b)) {
                return false;
            }
        }
        if (opts.strict && gPO && gPO(a) !== gPO(b)) {
            return false;
        }
        var aWhich = whichTypedArray2(a);
        var bWhich = whichTypedArray2(b);
        if (aWhich !== bWhich) {
            return false;
        }
        if (aWhich || bWhich) {
            if (a.length !== b.length) {
                return false;
            }
            for (i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        var aIsBuffer = isBuffer2(a);
        var bIsBuffer = isBuffer2(b);
        if (aIsBuffer !== bIsBuffer) {
            return false;
        }
        if (aIsBuffer || bIsBuffer) {
            if (a.length !== b.length) {
                return false;
            }
            for (i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        var aIsArrayBuffer = isArrayBuffer2(a);
        var bIsArrayBuffer = isArrayBuffer2(b);
        if (aIsArrayBuffer !== bIsArrayBuffer) {
            return false;
        }
        if (aIsArrayBuffer || bIsArrayBuffer) {
            if (byteLength(a) !== byteLength(b)) {
                return false;
            }
            return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
        }
        var aIsSAB = isSharedArrayBuffer2(a);
        var bIsSAB = isSharedArrayBuffer2(b);
        if (aIsSAB !== bIsSAB) {
            return false;
        }
        if (aIsSAB || bIsSAB) {
            if (sabByteLength(a) !== sabByteLength(b)) {
                return false;
            }
            return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
        }
        if (typeof a !== typeof b) {
            return false;
        }
        var ka2 = objectKeys2(a);
        var kb = objectKeys2(b);
        if (ka2.length !== kb.length) {
            return false;
        }
        ka2.sort();
        kb.sort();
        for (i = ka2.length - 1; i >= 0; i--) {
            if (ka2[i] != kb[i]) {
                return false;
            }
        }
        for (i = ka2.length - 1; i >= 0; i--) {
            key = ka2[i];
            if (!internalDeepEqual(a[key], b[key], opts, channel)) {
                return false;
            }
        }
        var aCollection = whichCollection2(a);
        var bCollection = whichCollection2(b);
        if (aCollection !== bCollection) {
            return false;
        }
        if (aCollection === "Set" || bCollection === "Set") {
            return setEquiv(a, b, opts, channel);
        }
        if (aCollection === "Map") {
            return mapEquiv(a, b, opts, channel);
        }
        return true;
    }
    deepEqual$1 = function deepEqual2(a, b, opts) {
        return internalDeepEqual(a, b, opts, getSideChannel());
    };
    return deepEqual$1;
}
var deepEqualExports = requireDeepEqual();
const deepEqual = /* @__PURE__ */ getDefaultExportFromCjs(deepEqualExports);
function takeDates(config2) {
    const schedule = new RSchedule({ rrules: recurConfigToRSchedule(config2) });
    return schedule.occurrences({ take: 3 }).toArray().map((d2) => d2.date);
}
async function getTransactions(date, account) {
    const { data } = await aqlQuery(q("transactions").filter({
        account,
        schedule: null,
        // Don't match transfers
        "payee.transfer_acct": null,
        $and: [
            { date: { $gte: subDays$1(date, 2) } },
            { date: { $lte: addDays$1(date, 2) } }
        ]
    }).select("*").options({ splits: "none" }));
    return data;
}
function getRank(day1, day2) {
    const dayDiff = Math.abs(differenceInDays(parseDate$1(day1), parseDate$1(day2)));
    return 1 / (dayDiff + 1);
}
function matchSchedules(allOccurs, config2) {
    allOccurs = [...allOccurs].reverse();
    const baseOccur = allOccurs[0];
    const occurs = allOccurs.slice(1);
    const schedules = [];
    for (const trans of baseOccur.transactions) {
        const threshold = getApproxNumberThreshold(trans.amount);
        const payee = trans.payee;
        const found = occurs.map((occur) => {
            let matched = occur.transactions.find((t2) => t2.amount >= trans.amount - threshold && t2.amount <= trans.amount + threshold);
            matched = matched && matched.payee === payee ? matched : null;
            if (matched) {
                return { trans: matched, rank: getRank(occur.date, matched.date) };
            }
            return null;
        });
        if (found.indexOf(null) !== -1) {
            continue;
        }
        const rank = found.reduce((total, match2) => total + match2.rank, getRank(baseOccur.date, trans.date));
        const exactAmount = found.reduce((exact, match2) => exact && match2.trans.amount === trans.amount, true);
        schedules.push({
            rank,
            amount: trans.amount,
            account: trans.account,
            payee: trans.payee,
            date: config2,
            // Exact dates rank as 1, so all of them matches exactly it
            // would equal the number of `allOccurs`
            exactDate: rank === allOccurs.length,
            exactAmount
        });
    }
    return schedules;
}
async function schedulesForPattern(baseStart, numDays, baseConfig, accountId) {
    let schedules = [];
    for (let i = 0; i < numDays; i++) {
        const start = addDays$1(baseStart, i);
        let config2;
        if (typeof baseConfig === "function") {
            config2 = baseConfig(start);
            if (config2 === false) {
                continue;
            }
        }
        else {
            config2 = { ...baseConfig, start };
        }
        config2.start = dayFromDate(config2.start);
        const data = [];
        const dates = takeDates(config2);
        for (const date of dates) {
            data.push({
                date: dayFromDate(date),
                transactions: await getTransactions(date, accountId)
            });
        }
        schedules = schedules.concat(matchSchedules(data, config2));
    }
    return schedules;
}
async function weekly(startDate, accountId) {
    return schedulesForPattern(subWeeks$1(parseDate$1(startDate), 4), 7 * 2, { frequency: "weekly" }, accountId);
}
async function every2weeks(startDate, accountId) {
    return schedulesForPattern(
    // 6 weeks would cover 3 instances, but we also scan an addition
    // week back
    subWeeks$1(parseDate$1(startDate), 7), 7 * 2, { frequency: "weekly", interval: 2 }, accountId);
}
async function monthly(startDate, accountId) {
    return schedulesForPattern(subMonths$1(parseDate$1(startDate), 4), 31 * 2, (start) => {
        if (getDate(start) > 28) {
            return false;
        }
        return { start, frequency: "monthly" };
    }, accountId);
}
async function monthlyLastDay(startDate, accountId) {
    const s1 = await schedulesForPattern(subMonths$1(parseDate$1(startDate), 3), 1, { frequency: "monthly", patterns: [{ type: "day", value: -1 }] }, accountId);
    const s2 = await schedulesForPattern(subMonths$1(parseDate$1(startDate), 4), 1, { frequency: "monthly", patterns: [{ type: "day", value: -1 }] }, accountId);
    return s1.concat(s2);
}
async function monthly1stor3rd(startDate, accountId) {
    return schedulesForPattern(subWeeks$1(parseDate$1(startDate), 8), 14, (start) => {
        const day = format$1(/* @__PURE__ */ new Date(), "iiii");
        const dayValue = day.slice(0, 2).toUpperCase();
        return {
            start,
            frequency: "monthly",
            patterns: [
                { type: dayValue, value: 1 },
                { type: dayValue, value: 3 }
            ]
        };
    }, accountId);
}
async function monthly2ndor4th(startDate, accountId) {
    return schedulesForPattern(subMonths$1(parseDate$1(startDate), 8), 14, (start) => {
        const day = format$1(/* @__PURE__ */ new Date(), "iiii");
        const dayValue = day.slice(0, 2).toUpperCase();
        return {
            start,
            frequency: "monthly",
            patterns: [
                { type: dayValue, value: 2 },
                { type: dayValue, value: 4 }
            ]
        };
    }, accountId);
}
async function findStartDate(schedule) {
    const conditions = schedule._conditions;
    const dateCond = conditions.find((c) => c.field === "date");
    let currentConfig = dateCond.value;
    while (1) {
        const prevConfig = currentConfig;
        currentConfig = { ...prevConfig };
        switch (currentConfig.frequency) {
            case "weekly":
                currentConfig.start = dayFromDate(subWeeks$1(parseDate$1(currentConfig.start), currentConfig.interval || 1));
                break;
            case "monthly":
                currentConfig.start = dayFromDate(subMonths$1(parseDate$1(currentConfig.start), currentConfig.interval || 1));
                break;
            case "yearly":
                currentConfig.start = dayFromDate(subYears(parseDate$1(currentConfig.start), currentConfig.interval || 1));
                break;
            default:
                throw new Error("findStartDate: invalid frequency");
        }
        const newConditions = conditions.map((c) => c.field === "date" ? { ...c, value: currentConfig } : c);
        const { filters, errors: errors2 } = conditionsToAQL(newConditions, {
            recurDateBounds: 1
        });
        if (errors2.length > 0) {
            currentConfig = null;
            break;
        }
        const { data } = await aqlQuery(q("transactions").filter({ $and: filters }).select("*"));
        if (data.length === 0) {
            currentConfig = prevConfig;
            break;
        }
    }
    if (currentConfig) {
        return {
            ...schedule,
            date: currentConfig,
            _conditions: conditions.map((c) => c.field === "date" ? { ...c, value: currentConfig } : c)
        };
    }
    return schedule;
}
async function findSchedules() {
    const { data: accounts } = await aqlQuery(q("accounts").filter({ closed: false }).select("*"));
    let allSchedules = [];
    for (const account of accounts) {
        const latestTrans = await first("SELECT date FROM v_transactions WHERE account = ? AND parent_id IS NULL ORDER BY date DESC LIMIT 1", [account.id]);
        if (latestTrans) {
            const latestDate = fromDateRepr(latestTrans.date);
            allSchedules = allSchedules.concat(await weekly(latestDate, account.id), await every2weeks(latestDate, account.id), await monthly(latestDate, account.id), await monthlyLastDay(latestDate, account.id), await monthly1stor3rd(latestDate, account.id), await monthly2ndor4th(latestDate, account.id));
        }
    }
    const schedules = [...groupBy(allSchedules, "payee").entries()].map(([, schedules2]) => {
        schedules2.sort((s1, s2) => s2.rank - s1.rank);
        const winner = schedules2[0];
        return {
            id: v4(),
            account: winner.account,
            payee: winner.payee,
            date: winner.date,
            amount: winner.amount,
            _conditions: [
                { op: "is", field: "account", value: winner.account },
                { op: "is", field: "payee", value: winner.payee },
                {
                    op: winner.exactDate ? "is" : "isapprox",
                    field: "date",
                    value: winner.date
                },
                {
                    op: winner.exactAmount ? "is" : "isapprox",
                    field: "amount",
                    value: winner.amount
                }
            ]
        };
    });
    const finalized = [];
    for (const schedule of schedules) {
        finalized.push(await findStartDate(schedule));
    }
    return finalized;
}
function zip(arr1, arr2) {
    const result = [];
    for (let i = 0; i < arr1.length; i++) {
        result.push([arr1[i], arr2[i]]);
    }
    return result;
}
function updateConditions(conditions, newConditions) {
    const scheduleConds = extractScheduleConds(conditions);
    const newScheduleConds = extractScheduleConds(newConditions);
    const replacements = zip(Object.values(scheduleConds), Object.values(newScheduleConds));
    const updated = conditions.map((cond) => {
        const r = replacements.find((r2) => cond === r2[0]);
        return r && r[1] ? r[1] : cond;
    });
    const added = replacements.filter((x) => x[0] == null && x[1] != null).map((x) => x[1]);
    return updated.concat(added);
}
async function getRuleForSchedule(id2) {
    if (id2 == null) {
        throw new Error("Schedule not attached to a rule");
    }
    const { data: ruleId } = await aqlQuery(q("schedules").filter({ id: id2 }).calculate("rule"));
    return getRules$1().find((rule) => rule.id === ruleId);
}
async function fixRuleForSchedule(id2) {
    const { data: ruleId } = await aqlQuery(q("schedules").filter({ id: id2 }).calculate("rule"));
    if (ruleId) {
        await delete_("rules", ruleId);
    }
    const newId = await insertRule({
        stage: null,
        conditionsOp: "and",
        conditions: [
            { op: "isapprox", field: "date", value: currentDay() },
            { op: "isapprox", field: "amount", value: 0 }
        ],
        actions: [{ op: "link-schedule", value: id2 }]
    });
    await updateWithSchema("schedules", { id: id2, rule: newId });
    return getRules$1().find((rule) => rule.id === newId);
}
async function setNextDate({ id: id2, start, conditions, reset }) {
    if (conditions == null) {
        const rule = await getRuleForSchedule(id2);
        if (rule == null) {
            throw new Error("No rule found for schedule");
        }
        conditions = rule.serialize().conditions;
    }
    const { date: dateCond } = extractScheduleConds(conditions);
    const { data: nextDate } = await aqlQuery(q("schedules").filter({ id: id2 }).calculate("next_date"));
    if (dateCond) {
        const newNextDate = getNextDate(dateCond, start ? start(nextDate) : /* @__PURE__ */ new Date());
        if (newNextDate !== nextDate) {
            const nd = await first("SELECT id, base_next_date_ts FROM schedules_next_date WHERE schedule_id = ?", [id2]);
            await update("schedules_next_date", reset ? {
                id: nd.id,
                base_next_date: toDateRepr(newNextDate),
                base_next_date_ts: Date.now()
            } : {
                id: nd.id,
                local_next_date: toDateRepr(newNextDate),
                local_next_date_ts: nd.base_next_date_ts
            });
        }
    }
}
async function checkIfScheduleExists(name, scheduleId) {
    const idForName = await first("SELECT id from schedules WHERE tombstone = 0 AND name = ?", [name]);
    if (idForName == null) {
        return false;
    }
    if (scheduleId) {
        return idForName["id"] !== scheduleId;
    }
    return true;
}
async function createSchedule({ schedule = null, conditions = [] } = {}) {
    const scheduleId = schedule?.id || v4();
    const { date: dateCond } = extractScheduleConds(conditions);
    if (dateCond == null) {
        throw new Error("A date condition is required to create a schedule");
    }
    if (dateCond.value == null) {
        throw new Error("Date is required");
    }
    const nextDate = getNextDate(dateCond);
    const nextDateRepr = nextDate ? toDateRepr(nextDate) : null;
    if (schedule) {
        if (schedule.name) {
            if (await checkIfScheduleExists(schedule.name, scheduleId)) {
                throw new Error("Cannot create schedules with the same name");
            }
        }
        else {
            schedule.name = null;
        }
    }
    const ruleId = await insertRule({
        stage: null,
        conditionsOp: "and",
        conditions,
        actions: [{ op: "link-schedule", value: scheduleId }]
    });
    const now = Date.now();
    await insertWithUUID("schedules_next_date", {
        schedule_id: scheduleId,
        local_next_date: nextDateRepr,
        local_next_date_ts: now,
        base_next_date: nextDateRepr,
        base_next_date_ts: now
    });
    await insertWithSchema("schedules", {
        ...schedule,
        id: scheduleId,
        rule: ruleId
    });
    return scheduleId;
}
async function updateSchedule({ schedule, conditions, resetNextDate }) {
    if (schedule.rule) {
        throw new Error("You cannot change the rule of a schedule");
    }
    let rule;
    if (conditions) {
        const { date: dateCond } = extractScheduleConds(conditions);
        if (dateCond && dateCond.value == null) {
            throw new Error("Date is required");
        }
        rule = await getRuleForSchedule(schedule.id);
        if (rule == null) {
            rule = await fixRuleForSchedule(schedule.id);
        }
    }
    await batchMessages(async () => {
        if (conditions) {
            const oldConditions = rule.serialize().conditions;
            const newConditions = updateConditions(oldConditions, conditions);
            await updateRule$1({ id: rule.id, conditions: newConditions });
            const stripType = ({ type: type2, ...fields }) => fields;
            if (resetNextDate || !deepEqual(oldConditions.find((c) => c.field === "account"), oldConditions.find((c) => c.field === "account")) || !deepEqual(stripType(oldConditions.find((c) => c.field === "date") || {}), stripType(newConditions.find((c) => c.field === "date") || {}))) {
                await setNextDate({
                    id: schedule.id,
                    conditions: newConditions,
                    reset: true
                });
            }
        }
        else if (resetNextDate) {
            await setNextDate({ id: schedule.id, reset: true });
        }
        await updateWithSchema("schedules", schedule);
    });
    return schedule.id;
}
async function deleteSchedule({ id: id2 }) {
    const { data: ruleId } = await aqlQuery(q("schedules").filter({ id: id2 }).calculate("rule"));
    await batchMessages(async () => {
        await delete_("rules", ruleId);
        await delete_("schedules", id2);
    });
}
async function skipNextDate({ id: id2 }) {
    return setNextDate({
        id: id2,
        start: (nextDate) => {
            return addDays$1(parseDate$1(nextDate), 1);
        }
    });
}
function discoverSchedules() {
    return findSchedules();
}
async function getUpcomingDates({ config: config2, count }) {
    const rules = recurConfigToRSchedule(config2);
    try {
        const schedule = new RSchedule({ rrules: rules });
        return schedule.occurrences({ start: startOfDay(/* @__PURE__ */ new Date()), take: count }).toArray().map((date) => config2.skipWeekend ? getDateWithSkippedWeekend(date.date, config2.weekendSolveMode) : date.date).map((date) => dayFromDate(date));
    }
    catch (err) {
        throw err;
    }
}
function onRuleUpdate(rule) {
    const { actions, conditions } = rule instanceof Rule2 ? rule.serialize() : ruleModel.toJS(rule);
    if (actions && actions.find((a) => a.op === "link-schedule")) {
        const scheduleId = actions.find((a) => a.op === "link-schedule").value;
        if (scheduleId) {
            const conds = extractScheduleConds(conditions);
            const payeeIdx = conditions.findIndex((c) => c === conds.payee);
            const accountIdx = conditions.findIndex((c) => c === conds.account);
            const amountIdx = conditions.findIndex((c) => c === conds.amount);
            const dateIdx = conditions.findIndex((c) => c === conds.date);
            runQuery("INSERT OR REPLACE INTO schedules_json_paths (schedule_id, payee, account, amount, date) VALUES (?, ?, ?, ?, ?)", [
                scheduleId,
                payeeIdx === -1 ? null : `$[${payeeIdx}]`,
                accountIdx === -1 ? null : `$[${accountIdx}]`,
                amountIdx === -1 ? null : `$[${amountIdx}]`,
                dateIdx === -1 ? null : `$[${dateIdx}]`
            ]);
        }
    }
}
function trackJSONPaths() {
    transaction(() => {
        getRules$1().forEach((rule) => {
            onRuleUpdate(rule);
        });
    });
    return addSyncListener(onApplySync);
}
function onApplySync(oldValues, newValues) {
    newValues.forEach((items, table) => {
        if (table === "rules") {
            items.forEach((newValue) => {
                onRuleUpdate(newValue);
            });
        }
    });
}
async function postTransactionForSchedule({ id: id2, today }) {
    const { data } = await aqlQuery(q("schedules").filter({ id: id2 }).select("*"));
    const schedule = data[0];
    if (schedule == null || schedule._account == null) {
        return;
    }
    const transaction2 = {
        payee: schedule._payee,
        account: schedule._account,
        amount: getScheduledAmount(schedule._amount),
        date: today ? currentDay() : schedule.next_date,
        schedule: schedule.id,
        cleared: false
    };
    if (transaction2.account) {
        await addTransactions$1(transaction2.account, [transaction2]);
    }
}
async function advanceSchedulesService(syncSuccess) {
    const { data: schedules } = await aqlQuery(q("schedules").filter({ completed: false, "_account.closed": false }).select("*"));
    const { data: hasTransData } = await aqlQuery(getHasTransactionsQuery(schedules));
    const hasTrans = new Set(hasTransData.filter(Boolean).map((row) => row.schedule));
    const failedToPost = [];
    const { data: upcomingLength } = await aqlQuery(q("preferences").filter({ id: "upcomingScheduledTransactionLength" }).select("value"));
    for (const schedule of schedules) {
        const status = getStatus(schedule.next_date, schedule.completed, hasTrans.has(schedule.id), upcomingLength[0]?.value ?? "7");
        if (status === "paid") {
            if (schedule._date) {
                if (schedule._date.frequency) {
                    try {
                        await setNextDate({ id: schedule.id });
                    }
                    catch (err) {
                    }
                }
                else {
                    if (schedule._date < currentDay()) {
                        await updateSchedule({
                            schedule: { id: schedule.id, completed: true }
                        });
                    }
                }
            }
        }
        else if ((status === "due" || status === "missed") && schedule.posts_transaction && schedule._account) {
            if (syncSuccess) {
                await postTransactionForSchedule({ id: schedule.id });
            }
            else {
                failedToPost.push(schedule._payee);
            }
        }
    }
}
const app$f = createApp();
app$f.method("schedule/create", mutator(undoable(createSchedule)));
app$f.method("schedule/update", mutator(undoable(updateSchedule)));
app$f.method("schedule/delete", mutator(undoable(deleteSchedule)));
app$f.method("schedule/skip-next-date", mutator(undoable(skipNextDate)));
app$f.method("schedule/post-transaction", mutator(undoable(postTransactionForSchedule)));
app$f.method("schedule/force-run-service", mutator(() => advanceSchedulesService(true)));
app$f.method("schedule/discover", discoverSchedules);
app$f.method("schedule/get-upcoming-dates", getUpcomingDates);
app$f.service(trackJSONPaths);
app$f.events.on("sync", ({ type: type2 }) => {
    const completeEvent = type2 === "success" || type2 === "error" || type2 === "unauthorized";
    if (completeEvent && getPrefs()) {
        if (!getDatabase()) {
            logger.info("database is not available, skipping schedule service");
            return;
        }
        const { lastScheduleRun } = getPrefs();
        if (lastScheduleRun !== currentDay()) {
            runMutator(() => advanceSchedulesService(type2 === "success"));
            savePrefs({ lastScheduleRun: currentDay() });
        }
    }
});
async function createScheduleList(templates, current_month, category) {
    const t2 = [];
    const errors2 = [];
    for (const template of templates) {
        const { id: sid, completed } = await first("SELECT id, completed FROM schedules WHERE TRIM(name) = ? AND tombstone = 0", [template.name]);
        const rule = await getRuleForSchedule(sid);
        const conditions = rule.serialize().conditions;
        const { date: dateConditions, amount: amountCondition } = extractScheduleConds(conditions);
        let scheduleAmount = amountCondition.op === "isbetween" ? Math.round(amountCondition.value.num1 + amountCondition.value.num2) / 2 : amountCondition.value;
        if (template.adjustment) {
            const adjustmentFactor = 1 + template.adjustment / 100;
            scheduleAmount = Math.round(scheduleAmount * adjustmentFactor);
        }
        const { amount: postRuleAmount, subtransactions } = rule.execActions({
            amount: scheduleAmount,
            category: category.id,
            subtransactions: []
        });
        const categorySubtransactions = subtransactions?.filter((t22) => t22.category === category.id);
        const sign2 = category.is_income ? 1 : -1;
        const target = sign2 * (categorySubtransactions?.length ? categorySubtransactions.reduce((acc, t22) => acc + t22.amount, 0) : postRuleAmount ?? scheduleAmount);
        const next_date_string = getNextDate(dateConditions, _parse(current_month));
        const target_interval = dateConditions.value.interval ? dateConditions.value.interval : 1;
        const target_frequency = dateConditions.value.frequency;
        const isRepeating = Object(dateConditions.value) === dateConditions.value && "frequency" in dateConditions.value;
        const num_months = differenceInCalendarMonths(next_date_string, current_month);
        if (num_months < 0) {
            errors2.push(`Schedule ${template.name} is in the Past.`);
        }
        else {
            t2.push({
                target,
                next_date_string,
                target_interval,
                target_frequency,
                num_months,
                completed,
                //started,
                full: template.full === null ? false : template.full,
                repeat: isRepeating,
                name: template.name
            });
            if (!completed) {
                if (isRepeating) {
                    let monthlyTarget = 0;
                    const nextMonth2 = addMonths(current_month, t2[t2.length - 1].num_months + 1);
                    let nextBaseDate = getNextDate(dateConditions, _parse(current_month), true);
                    let nextDate = dateConditions.value.skipWeekend ? dayFromDate(getDateWithSkippedWeekend(_parse(nextBaseDate), dateConditions.value.weekendSolveMode)) : nextBaseDate;
                    while (nextDate < nextMonth2) {
                        monthlyTarget += -target;
                        const currentDate2 = nextBaseDate;
                        const oneDayLater = addDays(nextBaseDate, 1);
                        nextBaseDate = getNextDate(dateConditions, _parse(oneDayLater), true);
                        nextDate = dateConditions.value.skipWeekend ? dayFromDate(getDateWithSkippedWeekend(_parse(nextBaseDate), dateConditions.value.weekendSolveMode)) : nextBaseDate;
                        const diffDays = differenceInCalendarDays(nextBaseDate, currentDate2);
                        if (!diffDays) {
                            break;
                        }
                    }
                    t2[t2.length - 1].target = -monthlyTarget;
                }
            }
            else {
                errors2.push(`Schedule ${template.name} is not active during the month in question.`);
            }
        }
    }
    return { t: t2.filter((c) => c.completed === 0), errors: errors2 };
}
function getPayMonthOfTotal(t2) {
    let total = 0;
    const schedules = t2.filter((c) => c.num_months === 0);
    for (const schedule of schedules) {
        total += schedule.target;
    }
    return total;
}
async function getSinkingContributionTotal(t2, remainder, last_month_balance) {
    let total = 0;
    for (const [index, schedule] of t2.entries()) {
        remainder = index === 0 ? schedule.target - last_month_balance : schedule.target - remainder;
        let tg = 0;
        if (remainder >= 0) {
            tg = remainder;
            remainder = 0;
        }
        else {
            tg = 0;
            remainder = Math.abs(remainder);
        }
        total += tg / (schedule.num_months + 1);
    }
    return total;
}
function getSinkingBaseContributionTotal(t2) {
    let total = 0;
    for (const schedule of t2) {
        let monthlyAmount = 0;
        let prevDate;
        let intervalMonths;
        switch (schedule.target_frequency) {
            case "yearly":
                monthlyAmount = schedule.target / schedule.target_interval / 12;
                break;
            case "monthly":
                monthlyAmount = schedule.target / schedule.target_interval;
                break;
            case "weekly":
                prevDate = subWeeks(schedule.next_date_string, schedule.target_interval);
                intervalMonths = differenceInCalendarMonths(schedule.next_date_string, prevDate);
                if (intervalMonths === 0)
                    intervalMonths = 1;
                monthlyAmount = schedule.target / intervalMonths;
                break;
            case "daily":
                prevDate = subDays(schedule.next_date_string, schedule.target_interval);
                intervalMonths = differenceInCalendarMonths(schedule.next_date_string, prevDate);
                if (intervalMonths === 0)
                    intervalMonths = 1;
                monthlyAmount = schedule.target / intervalMonths;
                break;
        }
        total += monthlyAmount;
    }
    return total;
}
function getSinkingTotal(t2) {
    let total = 0;
    for (const schedule of t2) {
        total += schedule.target;
    }
    return total;
}
async function runSchedule(template_lines, current_month, balance, remainder, last_month_balance, to_budget, errors2, category) {
    const scheduleTemplates = template_lines.filter((t22) => t22.type === "schedule");
    const t2 = await createScheduleList(scheduleTemplates, current_month, category);
    errors2 = errors2.concat(t2.errors);
    const isPayMonthOf = (c) => c.full || c.target_frequency === "monthly" && c.target_interval === 1 && c.num_months === 0 || c.target_frequency === "weekly" && c.target_interval <= 4 || c.target_frequency === "daily" && c.target_interval <= 31 || isReflectBudget();
    const t_payMonthOf = t2.t.filter(isPayMonthOf);
    const t_sinking = t2.t.filter((c) => !isPayMonthOf(c)).sort((a, b) => a.next_date_string.localeCompare(b.next_date_string));
    const totalPayMonthOf = getPayMonthOfTotal(t_payMonthOf);
    const totalSinking = getSinkingTotal(t_sinking);
    const totalSinkingBaseContribution = getSinkingBaseContributionTotal(t_sinking);
    if (balance >= totalSinking + totalPayMonthOf) {
        to_budget += Math.round(totalPayMonthOf + totalSinkingBaseContribution);
    }
    else {
        const totalSinkingContribution = await getSinkingContributionTotal(t_sinking, remainder, last_month_balance);
        if (t_sinking.length === 0) {
            to_budget += Math.round(totalPayMonthOf + totalSinkingContribution) - last_month_balance;
        }
        else {
            to_budget += Math.round(totalPayMonthOf + totalSinkingContribution);
        }
    }
    return { to_budget, errors: errors2, remainder };
}
function peg$subclass(child, parent) {
    function C() {
        this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
}
function peg$SyntaxError(message2, expected, found, location) {
    var self2 = Error.call(this, message2);
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
}
peg$subclass(peg$SyntaxError, Error);
function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
        return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
peg$SyntaxError.prototype.format = function (sources) {
    var str = "Error: " + this.message;
    if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
            }
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line = src[s.line - 1];
            var last2 = s.line === e.line ? e.column : line.length + 1;
            var hatLen = last2 - s.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
        }
        else {
            str += "\n at " + loc;
        }
    }
    return str;
};
peg$SyntaxError.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
            return '"' + literalEscape(expectation.text) + '"';
        },
        class: function (expectation) {
            var escapedParts = expectation.parts.map(function (part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function () {
            return "any character";
        },
        end: function () {
            return "end of input";
        },
        other: function (expectation) {
            return expectation.description;
        }
    };
    function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return "\\x" + hex(ch);
        });
    }
    function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return "\\x" + hex(ch);
        });
    }
    function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
            }
            descriptions.length = j;
        }
        switch (descriptions.length) {
            case 1:
                return descriptions[0];
            case 2:
                return descriptions[0] + " or " + descriptions[1];
            default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
    }
    function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function peg$parse(input, options2) {
    options2 = options2 !== void 0 ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { expr: peg$parseexpr };
    var peg$startRuleFunction = peg$parseexpr;
    var peg$c0 = "average";
    var peg$c1 = "months";
    var peg$c2 = "copy from";
    var peg$c3 = "months ago";
    var peg$c4 = "[";
    var peg$c5 = "]";
    var peg$c6 = "increase";
    var peg$c7 = "decrease";
    var peg$c8 = "month";
    var peg$c9 = "year";
    var peg$c10 = "years";
    var peg$c11 = "per week starting";
    var peg$c12 = "per day";
    var peg$c13 = "previous";
    var peg$c14 = "day";
    var peg$c15 = "days";
    var peg$c16 = "spend";
    var peg$c17 = "from";
    var peg$c18 = "week";
    var peg$c19 = "weeks";
    var peg$c20 = "by";
    var peg$c21 = "of";
    var peg$c22 = "repeat";
    var peg$c23 = "every";
    var peg$c24 = "starting";
    var peg$c25 = "up";
    var peg$c26 = "to";
    var peg$c27 = "hold";
    var peg$c28 = "schedule";
    var peg$c29 = "full";
    var peg$c30 = "-";
    var peg$c31 = "remainder";
    var peg$c32 = "#template";
    var peg$c33 = "#goal";
    var peg$c34 = ".";
    var peg$c35 = "%";
    var peg$r0 = /^[ \t]/;
    var peg$r1 = /^[0-9]/;
    var peg$r2 = /^[1-9]/;
    var peg$r3 = /^[^ \t\r\n]/;
    var peg$r4 = /^[^\r\n]/;
    var peg$r5 = /^[^\r\n\t]/;
    var peg$e0 = peg$literalExpectation("average", true);
    var peg$e1 = peg$literalExpectation("months", true);
    var peg$e2 = peg$literalExpectation("copy from", true);
    var peg$e3 = peg$literalExpectation("months ago", true);
    var peg$e4 = peg$literalExpectation("[", false);
    var peg$e5 = peg$literalExpectation("]", false);
    var peg$e6 = peg$literalExpectation("increase", true);
    var peg$e7 = peg$literalExpectation("decrease", true);
    var peg$e8 = peg$otherExpectation("repeat interval");
    var peg$e9 = peg$literalExpectation("month", true);
    var peg$e10 = peg$literalExpectation("year", true);
    var peg$e11 = peg$literalExpectation("years", true);
    var peg$e12 = peg$literalExpectation("per week starting", true);
    var peg$e13 = peg$literalExpectation("per day", true);
    var peg$e14 = peg$literalExpectation("previous", true);
    var peg$e15 = peg$literalExpectation("day", true);
    var peg$e16 = peg$literalExpectation("days", true);
    var peg$e17 = peg$literalExpectation("spend", true);
    var peg$e18 = peg$literalExpectation("from", true);
    var peg$e19 = peg$literalExpectation("week", true);
    var peg$e20 = peg$literalExpectation("weeks", true);
    var peg$e21 = peg$literalExpectation("by", true);
    var peg$e22 = peg$literalExpectation("of", true);
    var peg$e23 = peg$literalExpectation("repeat", true);
    var peg$e24 = peg$literalExpectation("every", true);
    var peg$e25 = peg$literalExpectation("starting", true);
    var peg$e26 = peg$literalExpectation("up", true);
    var peg$e27 = peg$literalExpectation("to", true);
    var peg$e28 = peg$literalExpectation("hold", true);
    var peg$e29 = peg$literalExpectation("schedule", true);
    var peg$e30 = peg$literalExpectation("full", true);
    var peg$e31 = peg$literalExpectation("-", true);
    var peg$e32 = peg$literalExpectation("remainder", true);
    var peg$e33 = peg$literalExpectation("#template", false);
    var peg$e34 = peg$literalExpectation("#goal", true);
    var peg$e35 = peg$otherExpectation("whitespace");
    var peg$e36 = peg$classExpectation([" ", "	"], false, false);
    var peg$e38 = peg$otherExpectation("digit");
    var peg$e39 = peg$classExpectation([["0", "9"]], false, false);
    var peg$e40 = peg$otherExpectation("number");
    var peg$e41 = peg$classExpectation([["1", "9"]], false, false);
    var peg$e42 = peg$otherExpectation("amount");
    var peg$e43 = peg$literalExpectation("-", false);
    var peg$e44 = peg$literalExpectation(".", false);
    var peg$e45 = peg$otherExpectation("percentage");
    var peg$e46 = peg$literalExpectation("%", false);
    var peg$e47 = peg$otherExpectation("year");
    var peg$e48 = peg$otherExpectation("month");
    var peg$e49 = peg$otherExpectation("day");
    var peg$e50 = peg$otherExpectation("currency symbol");
    var peg$e51 = peg$anyExpectation();
    var peg$e52 = peg$classExpectation([" ", "	", "\r", "\n"], true, false);
    var peg$e53 = peg$classExpectation(["\r", "\n"], true, false);
    var peg$e54 = peg$otherExpectation("Name");
    var peg$e55 = peg$classExpectation(["\r", "\n", "	"], true, false);
    var peg$f0 = function (template, percentOf, category) {
        return { type: "percentage", percent: +percentOf.percent, previous: percentOf.prev, category, priority: template.priority, directive: template.directive };
    };
    var peg$f1 = function (template, amount, period, starting, limit) {
        return { type: "periodic", amount, period, starting, limit, priority: template.priority, directive: template.directive };
    };
    var peg$f2 = function (template, amount, month, from, repeat) {
        return {
            type: from ? "spend" : "by",
            amount,
            month,
            ...repeat ? repeat[3] : {},
            from,
            priority: template.priority,
            directive: template.directive
        };
    };
    var peg$f3 = function (template, monthly2, limit) {
        return { type: "simple", monthly: monthly2, limit, priority: template.priority, directive: template.directive };
    };
    var peg$f4 = function (template, limit) {
        return { type: "simple", monthly: null, limit, priority: template.priority, directive: template.directive };
    };
    var peg$f5 = function (template, schedule, full, name, modifiers) {
        return { type: "schedule", name: name.trim(), priority: template.priority, directive: template.directive, full, adjustment: modifiers?.adjustment };
    };
    var peg$f6 = function (template, remainder, limit) {
        return { type: "remainder", priority: null, directive: template.directive, weight: remainder, limit };
    };
    var peg$f7 = function (template, amount) {
        return { type: "average", numMonths: +amount, priority: template.priority, directive: template.directive };
    };
    var peg$f8 = function (template, lookBack, limit) {
        return { type: "copy", priority: template.priority, directive: template.directive, lookBack: +lookBack, limit };
    };
    var peg$f9 = function (goal, amount) {
        return { type: "goal", amount, priority: null, directive: goal };
    };
    var peg$f10 = function (modifier) {
        return modifier;
    };
    var peg$f11 = function (op, value) {
        const multiplier = op.toLowerCase() === "increase" ? 1 : -1;
        return { adjustment: multiplier * +value };
    };
    var peg$f12 = function () {
        return { annual: false };
    };
    var peg$f13 = function (months) {
        return { annual: false, repeat: +months };
    };
    var peg$f14 = function () {
        return { annual: true };
    };
    var peg$f15 = function (years) {
        return { annual: true, repeat: +years };
    };
    var peg$f16 = function (amount, start, hold) {
        return { amount, hold, period: "weekly", start };
    };
    var peg$f17 = function (amount, hold) {
        return { amount, hold, period: "daily", start: null };
    };
    var peg$f18 = function (amount, hold) {
        return { amount, hold, period: "monthly", start: null };
    };
    var peg$f19 = function (percent) {
        return { percent, prev: true };
    };
    var peg$f20 = function (percent) {
        return { percent, prev: false };
    };
    var peg$f21 = function () {
        return { period: "day", amount: 1 };
    };
    var peg$f22 = function (n) {
        return { period: "day", amount: +n };
    };
    var peg$f23 = function () {
        return { period: "week", amount: 1 };
    };
    var peg$f24 = function (n) {
        return { period: "week", amount: +n };
    };
    var peg$f25 = function (n) {
        return { period: "month", amount: +n };
    };
    var peg$f26 = function () {
        return { period: "year", amount: 1 };
    };
    var peg$f27 = function (n) {
        return { period: "year", amount: +n };
    };
    var peg$f28 = function (month) {
        return month;
    };
    var peg$f29 = function () {
        return true;
    };
    var peg$f30 = function () {
        return text();
    };
    var peg$f31 = function () {
        return true;
    };
    var peg$f32 = function (number2) {
        return number2;
    };
    var peg$f33 = function (weight) {
        return +weight || 1;
    };
    var peg$f34 = function (priority) {
        return { priority: +priority, directive: "template" };
    };
    var peg$f35 = function () {
        return "goal";
    };
    var peg$f36 = function () {
        return text();
    };
    var peg$f38 = function (amount) {
        return +amount;
    };
    var peg$f39 = function (percent) {
        return percent;
    };
    var peg$f40 = function (symbol) {
        return new RegExp("\\p{Sc}", "u").test(symbol);
    };
    var peg$f41 = function () {
        return text().trim();
    };
    var peg$f42 = function () {
        return text();
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
        if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
        return { type: "any" };
    }
    function peg$endExpectation() {
        return { type: "end" };
    }
    function peg$otherExpectation(description) {
        return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
            return details;
        }
        else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
                p--;
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                }
                else {
                    details.column++;
                }
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parseexpr() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$parsetemplate();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            s3 = peg$parsepercentOf();
            if (s3 !== peg$FAILED) {
                s4 = peg$parsename();
                if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f0(s1, s3, s4);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetemplate();
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                s3 = peg$parseamount();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    s5 = peg$parserepeatEvery();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        s7 = peg$parseperiodCount();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parse_();
                            s9 = peg$parsestarting();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parse_();
                                s11 = peg$parsedate();
                                if (s11 !== peg$FAILED) {
                                    s12 = peg$parselimit();
                                    if (s12 === peg$FAILED) {
                                        s12 = null;
                                    }
                                    peg$savedPos = s0;
                                    s0 = peg$f1(s1, s3, s7, s11, s12);
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsetemplate();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    s3 = peg$parseamount();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        s5 = peg$parseby();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            s7 = peg$parsemonth();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsespendFrom();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                s9 = peg$currPos;
                                s10 = peg$parse_();
                                s11 = peg$parserepeatEvery();
                                if (s11 !== peg$FAILED) {
                                    s12 = peg$parse_();
                                    s13 = peg$parserepeat();
                                    if (s13 !== peg$FAILED) {
                                        s10 = [s10, s11, s12, s13];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                if (s9 === peg$FAILED) {
                                    s9 = null;
                                }
                                peg$savedPos = s0;
                                s0 = peg$f2(s1, s3, s7, s8, s9);
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsetemplate();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        s3 = peg$parseamount();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parselimit();
                            if (s4 === peg$FAILED) {
                                s4 = null;
                            }
                            peg$savedPos = s0;
                            s0 = peg$f3(s1, s3, s4);
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsetemplate();
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            s3 = peg$parselimit();
                            if (s3 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f4(s1, s3);
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsetemplate();
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                s3 = peg$parseschedule();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parse_();
                                    s5 = peg$parsefull();
                                    if (s5 === peg$FAILED) {
                                        s5 = null;
                                    }
                                    s6 = peg$parserawScheduleName();
                                    if (s6 !== peg$FAILED) {
                                        s7 = peg$parsemodifiers();
                                        if (s7 === peg$FAILED) {
                                            s7 = null;
                                        }
                                        peg$savedPos = s0;
                                        s0 = peg$f5(s1, s3, s5, s6, s7);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parsetemplate();
                                if (s1 !== peg$FAILED) {
                                    s2 = peg$parse_();
                                    s3 = peg$parseremainder();
                                    if (s3 !== peg$FAILED) {
                                        s4 = peg$parselimit();
                                        if (s4 === peg$FAILED) {
                                            s4 = null;
                                        }
                                        peg$savedPos = s0;
                                        s0 = peg$f6(s1, s3, s4);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parsetemplate();
                                    if (s1 !== peg$FAILED) {
                                        s2 = peg$parse_();
                                        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c0) {
                                            s3 = input.substr(peg$currPos, 7);
                                            peg$currPos += 7;
                                        }
                                        else {
                                            s3 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$e0);
                                            }
                                        }
                                        if (s3 !== peg$FAILED) {
                                            s4 = peg$parse_();
                                            s5 = peg$parsepositive();
                                            if (s5 !== peg$FAILED) {
                                                s6 = peg$parse_();
                                                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c1) {
                                                    s7 = input.substr(peg$currPos, 6);
                                                    peg$currPos += 6;
                                                }
                                                else {
                                                    s7 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$e1);
                                                    }
                                                }
                                                if (s7 === peg$FAILED) {
                                                    s7 = null;
                                                }
                                                peg$savedPos = s0;
                                                s0 = peg$f7(s1, s5);
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parsetemplate();
                                        if (s1 !== peg$FAILED) {
                                            s2 = peg$parse_();
                                            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c2) {
                                                s3 = input.substr(peg$currPos, 9);
                                                peg$currPos += 9;
                                            }
                                            else {
                                                s3 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$e2);
                                                }
                                            }
                                            if (s3 !== peg$FAILED) {
                                                s4 = peg$parse_();
                                                s5 = peg$parsepositive();
                                                if (s5 !== peg$FAILED) {
                                                    s6 = peg$parse_();
                                                    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c3) {
                                                        s7 = input.substr(peg$currPos, 10);
                                                        peg$currPos += 10;
                                                    }
                                                    else {
                                                        s7 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$e3);
                                                        }
                                                    }
                                                    if (s7 !== peg$FAILED) {
                                                        s8 = peg$parselimit();
                                                        if (s8 === peg$FAILED) {
                                                            s8 = null;
                                                        }
                                                        peg$savedPos = s0;
                                                        s0 = peg$f8(s1, s5, s8);
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            s1 = peg$parsegoal();
                                            if (s1 !== peg$FAILED) {
                                                s2 = peg$parseamount();
                                                if (s2 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s0 = peg$f9(s1, s2);
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parsemodifiers() {
        var s0, s2, s3, s4;
        s0 = peg$currPos;
        peg$parse_();
        if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c4;
            peg$currPos++;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsemodifier();
            if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                    s4 = peg$c5;
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e5);
                    }
                }
                if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f10(s3);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsemodifier() {
        var s0, s1, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c6) {
            s1 = input.substr(peg$currPos, 8);
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e6);
            }
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c7) {
                s1 = input.substr(peg$currPos, 8);
                peg$currPos += 8;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parsepercent();
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11(s1, s3);
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parserepeat() {
        var s0, s1, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c8) {
            s1 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e9);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f12();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsepositive();
            if (s1 !== peg$FAILED) {
                peg$parse_();
                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c1) {
                    s3 = input.substr(peg$currPos, 6);
                    peg$currPos += 6;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e1);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f13(s1);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c9) {
                    s1 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e10);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f14();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsepositive();
                    if (s1 !== peg$FAILED) {
                        peg$parse_();
                        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c10) {
                            s3 = input.substr(peg$currPos, 5);
                            peg$currPos += 5;
                        }
                        else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e11);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f15(s1);
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e8);
            }
        }
        return s0;
    }
    function peg$parselimit() {
        var s0, s2, s4, s6, s8, s10;
        s0 = peg$currPos;
        peg$parse_();
        s2 = peg$parseupTo();
        if (s2 !== peg$FAILED) {
            peg$parse_();
            s4 = peg$parseamount();
            if (s4 !== peg$FAILED) {
                peg$parse_();
                if (input.substr(peg$currPos, 17).toLowerCase() === peg$c11) {
                    s6 = input.substr(peg$currPos, 17);
                    peg$currPos += 17;
                }
                else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e12);
                    }
                }
                if (s6 !== peg$FAILED) {
                    peg$parse_();
                    s8 = peg$parsedate();
                    if (s8 !== peg$FAILED) {
                        peg$parse_();
                        s10 = peg$parsehold();
                        if (s10 === peg$FAILED) {
                            s10 = null;
                        }
                        peg$savedPos = s0;
                        s0 = peg$f16(s4, s8, s10);
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            peg$parse_();
            s2 = peg$parseupTo();
            if (s2 !== peg$FAILED) {
                peg$parse_();
                s4 = peg$parseamount();
                if (s4 !== peg$FAILED) {
                    peg$parse_();
                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c12) {
                        s6 = input.substr(peg$currPos, 7);
                        peg$currPos += 7;
                    }
                    else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e13);
                        }
                    }
                    if (s6 !== peg$FAILED) {
                        peg$parse_();
                        s8 = peg$parsehold();
                        if (s8 === peg$FAILED) {
                            s8 = null;
                        }
                        peg$savedPos = s0;
                        s0 = peg$f17(s4, s8);
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                peg$parse_();
                s2 = peg$parseupTo();
                if (s2 !== peg$FAILED) {
                    peg$parse_();
                    s4 = peg$parseamount();
                    if (s4 !== peg$FAILED) {
                        peg$parse_();
                        s6 = peg$parsehold();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        peg$savedPos = s0;
                        s0 = peg$f18(s4, s6);
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        return s0;
    }
    function peg$parsepercentOf() {
        var s0, s1, s3, s5;
        s0 = peg$currPos;
        s1 = peg$parsepercent();
        if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parseof();
            if (s3 !== peg$FAILED) {
                peg$parse_();
                if (input.substr(peg$currPos, 8).toLowerCase() === peg$c13) {
                    s5 = input.substr(peg$currPos, 8);
                    peg$currPos += 8;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e14);
                    }
                }
                if (s5 !== peg$FAILED) {
                    peg$parse_();
                    peg$savedPos = s0;
                    s0 = peg$f19(s1);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsepercent();
            if (s1 !== peg$FAILED) {
                peg$parse_();
                s3 = peg$parseof();
                if (s3 !== peg$FAILED) {
                    peg$parse_();
                    peg$savedPos = s0;
                    s0 = peg$f20(s1);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseperiodCount() {
        var s0, s1, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c14) {
            s1 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e15);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f21();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsenumber();
            if (s1 !== peg$FAILED) {
                peg$parse_();
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c15) {
                    s3 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e16);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$parse_();
                    peg$savedPos = s0;
                    s0 = peg$f22(s1);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseweek();
                if (s1 !== peg$FAILED) {
                    peg$parse_();
                    peg$savedPos = s0;
                    s0 = peg$f23();
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsenumber();
                    if (s1 !== peg$FAILED) {
                        peg$parse_();
                        s3 = peg$parseweeks();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f24(s1);
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsenumber();
                        if (s1 !== peg$FAILED) {
                            peg$parse_();
                            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c1) {
                                s3 = input.substr(peg$currPos, 6);
                                peg$currPos += 6;
                            }
                            else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e1);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$parse_();
                                peg$savedPos = s0;
                                s0 = peg$f25(s1);
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c9) {
                                s1 = input.substr(peg$currPos, 4);
                                peg$currPos += 4;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e10);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$parse_();
                                peg$savedPos = s0;
                                s0 = peg$f26();
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parsenumber();
                                if (s1 !== peg$FAILED) {
                                    peg$parse_();
                                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c10) {
                                        s3 = input.substr(peg$currPos, 5);
                                        peg$currPos += 5;
                                    }
                                    else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$e11);
                                        }
                                    }
                                    if (s3 !== peg$FAILED) {
                                        peg$parse_();
                                        peg$savedPos = s0;
                                        s0 = peg$f27(s1);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parsespendFrom() {
        var s0, s2, s4, s6;
        s0 = peg$currPos;
        peg$parse_();
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c16) {
            s2 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e17);
            }
        }
        if (s2 !== peg$FAILED) {
            peg$parse_();
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c17) {
                s4 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e18);
                }
            }
            if (s4 !== peg$FAILED) {
                peg$parse_();
                s6 = peg$parsemonth();
                if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f28(s6);
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseweek() {
        var s0;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c18) {
            s0 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e19);
            }
        }
        return s0;
    }
    function peg$parseweeks() {
        var s0;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c19) {
            s0 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e20);
            }
        }
        return s0;
    }
    function peg$parseby() {
        var s0;
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c20) {
            s0 = input.substr(peg$currPos, 2);
            peg$currPos += 2;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e21);
            }
        }
        return s0;
    }
    function peg$parseof() {
        var s0;
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c21) {
            s0 = input.substr(peg$currPos, 2);
            peg$currPos += 2;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e22);
            }
        }
        return s0;
    }
    function peg$parserepeatEvery() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c22) {
            s1 = input.substr(peg$currPos, 6);
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e23);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c23) {
                s3 = input.substr(peg$currPos, 5);
                peg$currPos += 5;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e24);
                }
            }
            if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsestarting() {
        var s0;
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c24) {
            s0 = input.substr(peg$currPos, 8);
            peg$currPos += 8;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e25);
            }
        }
        return s0;
    }
    function peg$parseupTo() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c25) {
            s1 = input.substr(peg$currPos, 2);
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e26);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (input.substr(peg$currPos, 2).toLowerCase() === peg$c26) {
                s3 = input.substr(peg$currPos, 2);
                peg$currPos += 2;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e27);
                }
            }
            if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsehold() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
            s1 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e28);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f29();
        }
        s0 = s1;
        return s0;
    }
    function peg$parseschedule() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c28) {
            s1 = input.substr(peg$currPos, 8);
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e29);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f30();
        }
        s0 = s1;
        return s0;
    }
    function peg$parsefull() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c29) {
            s1 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e30);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f31();
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsepriority() {
        var s0, s1, s2;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 1).toLowerCase() === peg$c30) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e31);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f32(s2);
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseremainder() {
        var s0, s1, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c31) {
            s1 = input.substr(peg$currPos, 9);
            peg$currPos += 9;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e32);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parsepositive();
            if (s3 === peg$FAILED) {
                s3 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f33(s3);
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsetemplate() {
        var s0, s1, s2;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c32) {
            s1 = peg$c32;
            peg$currPos += 9;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e33);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsepriority();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f34(s2);
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsegoal() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c33) {
            s1 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e34);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f35();
        }
        s0 = s1;
        return s0;
    }
    function peg$parse_() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e36);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r0.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                }
            }
        }
        peg$savedPos = s0;
        s1 = peg$f36();
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
            peg$fail(peg$e35);
        }
        return s0;
    }
    function peg$parsed() {
        var s0;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e39);
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
                peg$fail(peg$e38);
            }
        }
        return s0;
    }
    function peg$parsenumber() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsed();
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsed();
            }
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e40);
            }
        }
        return s0;
    }
    function peg$parsepositive() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (peg$r2.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e41);
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e39);
                }
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e39);
                    }
                }
            }
            s2 = [s2, s3];
            s1 = s2;
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        return s0;
    }
    function peg$parseamount() {
        var s0, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        peg$parsecurrencySymbol();
        peg$parse_();
        s3 = peg$currPos;
        s4 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
            s5 = peg$c30;
            peg$currPos++;
        }
        else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e43);
            }
        }
        if (s5 === peg$FAILED) {
            s5 = null;
        }
        s6 = [];
        s7 = peg$parsed();
        if (s7 !== peg$FAILED) {
            while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsed();
            }
        }
        else {
            s6 = peg$FAILED;
        }
        if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
                s8 = peg$c34;
                peg$currPos++;
            }
            else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e44);
                }
            }
            if (s8 !== peg$FAILED) {
                s9 = peg$currPos;
                s10 = peg$parsed();
                if (s10 !== peg$FAILED) {
                    s11 = peg$parsed();
                    if (s11 === peg$FAILED) {
                        s11 = null;
                    }
                    s10 = [s10, s11];
                    s9 = s10;
                }
                else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                }
                if (s9 === peg$FAILED) {
                    s9 = null;
                }
                s8 = [s8, s9];
                s7 = s8;
            }
            else {
                peg$currPos = s7;
                s7 = peg$FAILED;
            }
            if (s7 === peg$FAILED) {
                s7 = null;
            }
            s5 = [s5, s6, s7];
            s4 = s5;
        }
        else {
            peg$currPos = s4;
            s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
            s3 = input.substring(s3, peg$currPos);
        }
        else {
            s3 = s4;
        }
        if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f38(s3);
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
                peg$fail(peg$e42);
            }
        }
        return s0;
    }
    function peg$parsepercent() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsed();
        if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsed();
            }
        }
        else {
            s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c34;
                peg$currPos++;
            }
            else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e44);
                }
            }
            if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parsed();
                if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parsed();
                    }
                }
                else {
                    s6 = peg$FAILED;
                }
                if (s6 === peg$FAILED) {
                    s6 = null;
                }
                s5 = [s5, s6];
                s4 = s5;
            }
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            s3 = [s3, s4];
            s2 = s3;
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
        }
        else {
            s1 = s2;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 37) {
                s3 = peg$c35;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e46);
                }
            }
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f39(s1);
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e45);
            }
        }
        return s0;
    }
    function peg$parseyear() {
        var s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsed();
        if (s2 !== peg$FAILED) {
            s3 = peg$parsed();
            if (s3 !== peg$FAILED) {
                s4 = peg$parsed();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsed();
                    if (s5 !== peg$FAILED) {
                        s2 = [s2, s3, s4, s5];
                        s1 = s2;
                    }
                    else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e47);
            }
        }
        return s0;
    }
    function peg$parsemonth() {
        var s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseyear();
        if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
                s3 = peg$c30;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e43);
                }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$parsed();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsed();
                    if (s5 !== peg$FAILED) {
                        s2 = [s2, s3, s4, s5];
                        s1 = s2;
                    }
                    else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e48);
            }
        }
        return s0;
    }
    function peg$parseday() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsed();
        if (s2 !== peg$FAILED) {
            s3 = peg$parsed();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e49);
            }
        }
        return s0;
    }
    function peg$parsedate() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsemonth();
        if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
                s3 = peg$c30;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e43);
                }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$parseday();
                if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        return s0;
    }
    function peg$parsecurrencySymbol() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e51);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s2 = peg$f40(s1);
            if (s2) {
                s2 = void 0;
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e50);
            }
        }
        return s0;
    }
    function peg$parserawScheduleName() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s5 = peg$c4;
            peg$currPos++;
        }
        else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        if (s5 !== peg$FAILED) {
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c6) {
                s6 = input.substr(peg$currPos, 8);
                peg$currPos += 8;
            }
            else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e6);
                }
            }
            if (s6 === peg$FAILED) {
                if (input.substr(peg$currPos, 8).toLowerCase() === peg$c7) {
                    s6 = input.substr(peg$currPos, 8);
                    peg$currPos += 8;
                }
                else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e7);
                    }
                }
            }
            if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
            }
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s4;
            s4 = peg$FAILED;
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
            s3 = void 0;
        }
        else {
            peg$currPos = s3;
            s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
            if (peg$r3.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e52);
                }
            }
            if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 91) {
                    s10 = peg$c4;
                    peg$currPos++;
                }
                else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e4);
                    }
                }
                if (s10 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c6) {
                        s11 = input.substr(peg$currPos, 8);
                        peg$currPos += 8;
                    }
                    else {
                        s11 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e6);
                        }
                    }
                    if (s11 === peg$FAILED) {
                        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c7) {
                            s11 = input.substr(peg$currPos, 8);
                            peg$currPos += 8;
                        }
                        else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e7);
                            }
                        }
                    }
                    if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                    }
                    else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                    s7 = void 0;
                }
                else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                    if (peg$r4.test(input.charAt(peg$currPos))) {
                        s8 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e53);
                        }
                    }
                    if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$currPos;
                    s7 = peg$currPos;
                    peg$silentFails++;
                    s8 = peg$currPos;
                    s9 = peg$parse_();
                    if (input.charCodeAt(peg$currPos) === 91) {
                        s10 = peg$c4;
                        peg$currPos++;
                    }
                    else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e4);
                        }
                    }
                    if (s10 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c6) {
                            s11 = input.substr(peg$currPos, 8);
                            peg$currPos += 8;
                        }
                        else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e6);
                            }
                        }
                        if (s11 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c7) {
                                s11 = input.substr(peg$currPos, 8);
                                peg$currPos += 8;
                            }
                            else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e7);
                                }
                            }
                        }
                        if (s11 !== peg$FAILED) {
                            s9 = [s9, s10, s11];
                            s8 = s9;
                        }
                        else {
                            peg$currPos = s8;
                            s8 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s8 === peg$FAILED) {
                        s7 = void 0;
                    }
                    else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                    }
                    if (s7 !== peg$FAILED) {
                        if (peg$r4.test(input.charAt(peg$currPos))) {
                            s8 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e53);
                            }
                        }
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                }
                s3 = [s3, s4, s5];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
        }
        else {
            s1 = s2;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f41();
        }
        s0 = s1;
        return s0;
    }
    function peg$parsename() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        if (peg$r5.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e55);
            }
        }
        if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$r5.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e55);
                    }
                }
            }
        }
        else {
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
        }
        else {
            s1 = s2;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f42();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e54);
            }
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
    }
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
const TEMPLATE_PREFIX = "#template";
const GOAL_PREFIX = "#goal";
async function storeNoteTemplates() {
    const categoriesWithTemplates = await getCategoriesWithTemplates();
    await storeTemplates({ categoriesWithTemplates, source: "notes" });
    await resetCategoryGoalDefsWithNoTemplates();
}
async function checkTemplateNotes() {
    const categoryWithTemplates = await getCategoriesWithTemplates();
    const schedules = await getActiveSchedules();
    const scheduleNames = schedules.map(({ name }) => name);
    const errors2 = [];
    categoryWithTemplates.forEach(({ name, templates }) => {
        templates.forEach((template) => {
            if (template.type === "error") {
                if (template.error && template.error.includes("adjustment")) {
                    errors2.push(`${name}: ${template.line}
Error: ${template.error}`);
                }
                else {
                    errors2.push(`${name}: ${template.line}`);
                }
            }
            else if (template.type === "schedule" && !scheduleNames.includes(template.name)) {
                errors2.push(`${name}: Schedule ${template.name} does not exist`);
            }
        });
    });
    if (errors2.length) {
        return {
            sticky: true,
            message: "There were errors interpreting some templates:",
            pre: errors2.join("\n\n")
        };
    }
    return {
        type: "message",
        message: "All templates passed! "
    };
}
async function getCategoriesWithTemplates() {
    const templatesForCategory = [];
    const templateNotes = await getCategoriesWithTemplateNotes();
    templateNotes.forEach(({ id: id2, name, note }) => {
        if (!note) {
            return;
        }
        const parsedTemplates = [];
        note.split("\n").forEach((line) => {
            const trimmedLine = line.substring(line.indexOf("#")).trim();
            if (!trimmedLine.startsWith(TEMPLATE_PREFIX) && !trimmedLine.startsWith(GOAL_PREFIX)) {
                return;
            }
            try {
                const parsedTemplate = peg$parse(trimmedLine);
                if (parsedTemplate.type === "schedule" && parsedTemplate.adjustment !== void 0) {
                    if (parsedTemplate.adjustment <= -100 || parsedTemplate.adjustment > 1e3) {
                        throw new Error(`Invalid adjustment percentage (${parsedTemplate.adjustment}%). Must be between -100% and 1000%`);
                    }
                }
                parsedTemplates.push(parsedTemplate);
            }
            catch (e) {
                parsedTemplates.push({
                    type: "error",
                    directive: "error",
                    line,
                    error: e.message
                });
            }
        });
        if (!parsedTemplates.length) {
            return;
        }
        templatesForCategory.push({
            id: id2,
            name,
            templates: parsedTemplates
        });
    });
    return templatesForCategory;
}
async function unparse(templates) {
    return templates.flatMap((template) => {
        if (template.type === "error") {
            return [];
        }
        if (template.type === "goal") {
            return `${GOAL_PREFIX} ${template.amount}`;
        }
        const prefix = template.priority ? `${TEMPLATE_PREFIX}-${template.priority}` : TEMPLATE_PREFIX;
        switch (template.type) {
            case "simple": {
                let result = prefix;
                if (template.monthly != null) {
                    result += ` ${template.monthly}`;
                }
                if (template.limit) {
                    result += ` ${limitToString(template.limit)}`;
                }
                return result.trim();
            }
            case "schedule": {
                let result = `${prefix} schedule`;
                if (template.full) {
                    result += " full";
                }
                result += ` ${template.name}`;
                if (template.adjustment !== void 0) {
                    const adj = template.adjustment;
                    const op = adj >= 0 ? "increase" : "decrease";
                    const val2 = Math.abs(adj);
                    result += ` [${op} ${val2}%]`;
                }
                return result;
            }
            case "percentage": {
                const prev = template.previous ? "previous " : "";
                return `${prefix} ${trimTrailingZeros(template.percent)}% of ${prev}${template.category}`.trim();
            }
            case "periodic": {
                const periodPart = periodToString(template.period);
                let result = `${prefix} ${template.amount} repeat every ${periodPart} starting ${template.starting}`;
                if (template.limit) {
                    result += ` ${limitToString(template.limit)}`;
                }
                return result;
            }
            case "by":
            case "spend": {
                let result = `${prefix} ${template.amount} by ${template.month}`;
                if (template.type === "spend" && template.from) {
                    result += ` spend from ${template.from}`;
                }
                if (template.annual !== void 0) {
                    const repeatInfo = repeatToString(template.annual, template.repeat);
                    if (repeatInfo) {
                        result += ` repeat every ${repeatInfo}`;
                    }
                }
                return result;
            }
            case "remainder": {
                let result = `${prefix} remainder`;
                if (template.weight !== void 0 && template.weight !== 1) {
                    result += ` ${template.weight}`;
                }
                if (template.limit) {
                    result += ` ${limitToString(template.limit)}`;
                }
                return result;
            }
            case "average": {
                return `${prefix} average ${template.numMonths} months`;
            }
            case "copy": {
                const result = `${prefix} copy from ${template.lookBack} months ago`;
                return result;
            }
            default:
                return [];
        }
    }).join("\n");
}
function limitToString(limit) {
    switch (limit.period) {
        case "weekly": {
            const base = `up to ${limit.amount} per week starting ${limit.start}`;
            return limit.hold ? `${base} hold` : base;
        }
        case "daily": {
            const base = `up to ${limit.amount} per day`;
            return limit.hold ? `${base} hold` : base;
        }
        case "monthly":
        default: {
            const base = `up to ${limit.amount}`;
            return limit.hold ? `${base} hold` : base;
        }
    }
}
function periodToString(p) {
    const { period, amount } = p;
    if (amount === 1) {
        return period;
    }
    return `${amount} ${period}s`;
}
function repeatToString(annual, repeat) {
    if (annual === void 0)
        return null;
    if (annual) {
        if (!repeat || repeat === 1)
            return "year";
        return `${repeat} years`;
    }
    if (!repeat || repeat === 1)
        return "month";
    return `${repeat} months`;
}
function trimTrailingZeros(n) {
    const s = n.toString();
    if (!s.includes("."))
        return s;
    return s.replace(/\.0+$/, "").replace(/(\.[0-9]*[1-9])0+$/, "$1");
}
async function resetCategoryGoalDefsWithNoTemplates() {
    await run(`
      UPDATE categories
      SET goal_def = NULL
      WHERE id NOT IN (SELECT n.id
                       FROM notes n
                       WHERE lower(note) LIKE '%${TEMPLATE_PREFIX}%'
                          OR lower(note) LIKE '%${GOAL_PREFIX}%')
        AND COALESCE(JSON_EXTRACT(template_settings, '$.source'), 'notes') <> 'ui'
    `);
}
async function getCategoriesWithTemplateNotes() {
    return await all(`
      SELECT c.id AS id, c.name as name, n.note AS note
      FROM notes n
             JOIN categories c ON n.id = c.id
      WHERE c.id = n.id
        AND c.tombstone = 0
        AND COALESCE(JSON_EXTRACT(c.template_settings, '$.source'), 'notes') <> 'ui'
        AND (lower(note) LIKE '%${TEMPLATE_PREFIX}%'
        OR lower(note) LIKE '%${GOAL_PREFIX}%')
    `);
}
async function getActiveSchedules() {
    return await all("SELECT id, rule, active, completed, posts_transaction, tombstone, name from schedules WHERE name NOT NULL AND tombstone = 0");
}
class CategoryTemplateContext {
    /*----------------------------------------------------------------------------
     * Using This Class:
     * 1. instantiate via `await categoryTemplate.init(templates, categoryID, month)`;
     *    templates: all templates for this category (including templates and goals)
     *    categoryID: the ID of the category that this Class will be for
     *    month: the month string of the month for templates being applied
     * 2. gather needed data for external use.  ex: remainder weights, priorities, limitExcess
     * 3. run each priority level that is needed via runTemplatesForPriority
     * 4. run the remainder templates via runRemainder()
     * 5. finish processing by running getValues() and saving values for batch processing.
     * Alternate:
     * If the situation calls for it you can run all templates in a catagory in one go using the
     * method runAll which will run all templates and goals for reference, and can optionally be saved
     */
    //-----------------------------------------------------------------------------
    // Class interface
    // set up the class and check all templates
    static async init(templates, category, month, budgeted) {
        const lastMonthSheet = sheetForMonth(subMonths(month, 1));
        const lastMonthBalance = await getSheetValue(lastMonthSheet, `leftover-${category.id}`);
        const carryover = await getSheetBoolean(lastMonthSheet, `carryover-${category.id}`);
        let fromLastMonth;
        if (lastMonthBalance < 0 && !carryover) {
            fromLastMonth = 0;
        }
        else if (category.is_income) {
            fromLastMonth = 0;
        }
        else {
            fromLastMonth = lastMonthBalance;
        }
        await CategoryTemplateContext.checkByAndScheduleAndSpend(templates, month);
        await CategoryTemplateContext.checkPercentage(templates);
        const hideDecimal = await aqlQuery(q("preferences").filter({ id: "hideFraction" }).select("*"));
        return new CategoryTemplateContext(templates, category, month, fromLastMonth, budgeted, hideDecimal.data.length > 0 ? hideDecimal.data[0].value === "true" : false);
    }
    isGoalOnly() {
        return this.templates.length === 0 && this.remainder.length === 0 && this.goals.length > 0;
    }
    getPriorities() {
        return Array.from(this.priorities);
    }
    hasRemainder() {
        return this.remainderWeight > 0 && !this.limitMet;
    }
    getRemainderWeight() {
        return this.remainderWeight;
    }
    getLimitExcess() {
        return this.limitExcess;
    }
    // what is the full requested amount this month
    async runAll(available) {
        let toBudget = 0;
        const prioritiesSorted = new Int32Array([...this.getPriorities()].sort());
        for (let i = 0; i < prioritiesSorted.length; i++) {
            const p = prioritiesSorted[i];
            toBudget += await this.runTemplatesForPriority(p, available, available);
        }
        return toBudget;
    }
    // run all templates in a given priority level
    // return: amount budgeted in this priority level
    async runTemplatesForPriority(priority, budgetAvail, availStart) {
        if (!this.priorities.has(priority))
            return 0;
        if (this.limitMet)
            return 0;
        const t2 = this.templates.filter((t22) => t22.directive === "template" && t22.priority === priority);
        let available = budgetAvail || 0;
        let toBudget = 0;
        let byFlag = false;
        let remainder = 0;
        let scheduleFlag = false;
        for (const template of t2) {
            let newBudget = 0;
            switch (template.type) {
                case "simple": {
                    newBudget = CategoryTemplateContext.runSimple(template, this.limitAmount);
                    break;
                }
                case "copy": {
                    newBudget = await CategoryTemplateContext.runCopy(template, this);
                    break;
                }
                case "periodic": {
                    newBudget = CategoryTemplateContext.runPeriodic(template, this);
                    break;
                }
                case "spend": {
                    newBudget = await CategoryTemplateContext.runSpend(template, this);
                    break;
                }
                case "percentage": {
                    newBudget = await CategoryTemplateContext.runPercentage(template, availStart, this);
                    break;
                }
                case "by": {
                    if (!byFlag) {
                        newBudget = CategoryTemplateContext.runBy(this);
                    }
                    else {
                        newBudget = 0;
                    }
                    byFlag = true;
                    break;
                }
                case "schedule": {
                    if (!scheduleFlag) {
                        const budgeted = this.fromLastMonth + toBudget;
                        const ret = await runSchedule(t2, this.month, budgeted, remainder, this.fromLastMonth, toBudget, [], this.category);
                        newBudget = ret.to_budget - toBudget;
                        remainder = ret.remainder;
                        scheduleFlag = true;
                    }
                    break;
                }
                case "average": {
                    newBudget = await CategoryTemplateContext.runAverage(template, this);
                    break;
                }
            }
            available = available - newBudget;
            toBudget += newBudget;
        }
        if (this.limitCheck) {
            if (toBudget + this.toBudgetAmount + this.fromLastMonth >= this.limitAmount) {
                const orig = toBudget;
                toBudget = this.limitAmount - this.toBudgetAmount - this.fromLastMonth;
                this.limitMet = true;
                available = available + orig - toBudget;
            }
        }
        if (this.hideDecimal)
            toBudget = this.removeFraction(toBudget);
        if (priority > 0 && available < 0 && !this.category.is_income) {
            this.fullAmount += toBudget;
            toBudget = Math.max(0, toBudget + available);
            this.toBudgetAmount += toBudget;
        }
        else {
            this.fullAmount += toBudget;
            this.toBudgetAmount += toBudget;
        }
        return this.category.is_income ? -toBudget : toBudget;
    }
    runRemainder(budgetAvail, perWeight) {
        if (this.remainder.length === 0)
            return 0;
        let toBudget = Math.round(this.remainderWeight * perWeight);
        let smallest = 1;
        if (this.hideDecimal) {
            toBudget = this.removeFraction(toBudget);
            smallest = 100;
        }
        if (toBudget > budgetAvail || budgetAvail - toBudget <= smallest) {
            toBudget = budgetAvail;
        }
        if (this.limitCheck) {
            if (toBudget + this.toBudgetAmount + this.fromLastMonth >= this.limitAmount) {
                toBudget = this.limitAmount - this.toBudgetAmount - this.fromLastMonth;
                this.limitMet = true;
            }
        }
        this.toBudgetAmount += toBudget;
        return toBudget;
    }
    getValues() {
        this.runGoal();
        return {
            budgeted: this.toBudgetAmount,
            goal: this.goalAmount,
            longGoal: this.isLongGoal
        };
    }
    constructor(templates, category, month, fromLastMonth, budgeted, hideDecimal = false) {
        this.templates = [];
        this.remainder = [];
        this.goals = [];
        this.priorities = new Set();
        this.hideDecimal = false;
        this.remainderWeight = 0;
        this.toBudgetAmount = 0;
        // amount that will be budgeted by the templates
        this.fullAmount = null;
        // the full requested amount, start null for remainder only cats
        this.isLongGoal = null;
        //defaulting the goals to null so templates can be unset
        this.goalAmount = null;
        this.fromLastMonth = 0;
        // leftover from last month
        this.limitMet = false;
        this.limitExcess = 0;
        this.limitAmount = 0;
        this.limitCheck = false;
        this.limitHold = false;
        this.previouslyBudgeted = 0;
        this.category = category;
        this.month = month;
        this.fromLastMonth = fromLastMonth;
        this.previouslyBudgeted = budgeted;
        this.hideDecimal = hideDecimal;
        if (templates) {
            templates.forEach((t2) => {
                if (t2.directive === "template" && t2.type !== "remainder" && t2.type !== "limit") {
                    this.templates.push(t2);
                    if (t2.priority !== null)
                        this.priorities.add(t2.priority);
                }
                else if (t2.directive === "template" && t2.type === "remainder") {
                    this.remainder.push(t2);
                    this.remainderWeight += t2.weight;
                }
                else if (t2.directive === "goal" && t2.type === "goal") {
                    this.goals.push(t2);
                }
            });
        }
        this.checkLimit(templates);
        this.checkSpend();
        this.checkGoal();
    }
    runGoal() {
        if (this.goals.length > 0) {
            if (this.isGoalOnly())
                this.toBudgetAmount = this.previouslyBudgeted;
            this.isLongGoal = true;
            this.goalAmount = amountToInteger$1(this.goals[0].amount);
            return;
        }
        this.goalAmount = this.fullAmount;
    }
    //-----------------------------------------------------------------------------
    //  Template Validation
    static async checkByAndScheduleAndSpend(templates, month) {
        if (templates.filter((t2) => t2.type === "schedule" || t2.type === "by").length === 0) {
            return;
        }
        const scheduleNames = (await getActiveSchedules()).map(({ name }) => name.trim());
        templates.filter((t2) => t2.type === "schedule").forEach((t2) => {
            if (!scheduleNames.includes(t2.name.trim())) {
                throw new Error(`Schedule ${t2.name.trim()} does not exist`);
            }
        });
        const lowestPriority = Math.min(...templates.filter((t2) => t2.type === "schedule" || t2.type === "by").map((t2) => t2.priority));
        templates.filter((t2) => t2.type === "schedule" || t2.type === "by").forEach((t2) => {
            if (t2.priority !== lowestPriority) {
                throw new Error(`Schedule and By templates must be the same priority level. Fix by setting all Schedule and By templates to priority level ${lowestPriority}`);
            }
        });
        templates.filter((t2) => t2.type === "by" || t2.type === "spend").forEach((t2) => {
            const range2 = differenceInCalendarMonths(`${t2.month}`, month);
            if (range2 < 0 && !(t2.repeat || t2.annual)) {
                throw new Error(`Target month has passed, remove or update the target month`);
            }
        });
    }
    static async checkPercentage(templates) {
        const pt2 = templates.filter((t2) => t2.type === "percentage");
        if (pt2.length === 0)
            return;
        const reqCategories = pt2.map((t2) => t2.category.toLowerCase());
        const availCategories = await getCategories$3();
        const availNames = availCategories.filter((c) => c.is_income).map((c) => c.name.toLocaleLowerCase());
        reqCategories.forEach((n) => {
            if (n === "available funds" || n === "all income")
                ;
            else if (!availNames.includes(n)) {
                throw new Error(`Category "${n}" is not found in available income categories`);
            }
        });
    }
    checkLimit(templates) {
        for (const template of templates.filter((t2) => t2.type === "simple" || t2.type === "periodic" || t2.type === "limit" || t2.type === "remainder")) {
            let limitDef;
            if (template.type === "limit") {
                limitDef = template;
            }
            else {
                if (template.limit) {
                    limitDef = template.limit;
                }
                else {
                    continue;
                }
            }
            if (this.limitCheck) {
                throw new Error("Only one `up to` allowed per category");
            }
            if (limitDef.period === "daily") {
                const numDays = differenceInCalendarDays(addMonths(this.month, 1), this.month);
                this.limitAmount += amountToInteger$1(limitDef.amount) * numDays;
            }
            else if (limitDef.period === "weekly") {
                const nextMonth$1 = nextMonth(this.month);
                let week2 = limitDef.start;
                const baseLimit = amountToInteger$1(limitDef.amount);
                while (week2 < nextMonth$1) {
                    if (week2 >= this.month) {
                        this.limitAmount += baseLimit;
                    }
                    week2 = addWeeks(week2, 1);
                }
            }
            else if (limitDef.period === "monthly") {
                this.limitAmount = amountToInteger$1(limitDef.amount);
            }
            else {
                throw new Error("Invalid limit period. Check template syntax");
            }
            this.limitCheck = true;
            this.limitHold = limitDef.hold ? true : false;
            if (this.fromLastMonth >= this.limitAmount) {
                this.limitMet = true;
                if (this.limitHold) {
                    this.limitExcess = 0;
                    this.toBudgetAmount = 0;
                    this.fullAmount = 0;
                }
                else {
                    this.limitExcess = this.fromLastMonth - this.limitAmount;
                    this.toBudgetAmount = -this.limitExcess;
                    this.fullAmount = -this.limitExcess;
                }
            }
        }
    }
    checkSpend() {
        const st = this.templates.filter((t2) => t2.type === "spend");
        if (st.length > 1) {
            throw new Error("Only one spend template is allowed per category");
        }
    }
    checkGoal() {
        if (this.goals.length > 1) {
            throw new Error(`Only one #goal is allowed per category`);
        }
    }
    removeFraction(amount) {
        return amountToInteger$1(Math.round(integerToAmount(amount)));
    }
    //-----------------------------------------------------------------------------
    //  Processor Functions
    static runSimple(template, limit) {
        if (template.monthly != null) {
            return amountToInteger$1(template.monthly);
        }
        else {
            return limit;
        }
    }
    static async runCopy(template, templateContext) {
        const sheetName = sheetForMonth(subMonths(templateContext.month, template.lookBack));
        return await getSheetValue(sheetName, `budget-${templateContext.category.id}`);
    }
    static runPeriodic(template, templateContext) {
        let toBudget = 0;
        const amount = amountToInteger$1(template.amount);
        const period = template.period.period;
        const numPeriods = template.period.amount;
        let date = template.starting;
        let dateShiftFunction;
        switch (period) {
            case "day":
                dateShiftFunction = addDays;
                break;
            case "week":
                dateShiftFunction = addWeeks;
                break;
            case "month":
                dateShiftFunction = addMonths;
                break;
            case "year":
                dateShiftFunction = (date2, numPeriods2) => addMonths(date2, numPeriods2 * 12);
                break;
        }
        while (templateContext.month > date) {
            date = dateShiftFunction(date, numPeriods);
        }
        if (differenceInCalendarMonths(templateContext.month, date) < 0) {
            return 0;
        }
        const nextMonth2 = addMonths(templateContext.month, 1);
        while (date < nextMonth2) {
            toBudget += amount;
            date = dateShiftFunction(date, numPeriods);
        }
        return toBudget;
    }
    static async runSpend(template, templateContext) {
        let fromMonth = `${template.from}`;
        let toMonth = `${template.month}`;
        let alreadyBudgeted = templateContext.fromLastMonth;
        let firstMonth = true;
        const repeat = template.annual ? (template.repeat || 1) * 12 : template.repeat;
        let m = differenceInCalendarMonths(toMonth, templateContext.month);
        if (repeat && m < 0) {
            while (m < 0) {
                toMonth = addMonths(toMonth, repeat);
                fromMonth = addMonths(fromMonth, repeat);
                m = differenceInCalendarMonths(toMonth, templateContext.month);
            }
        }
        for (let m2 = fromMonth; differenceInCalendarMonths(templateContext.month, m2) > 0; m2 = addMonths(m2, 1)) {
            const sheetName = sheetForMonth(m2);
            if (firstMonth) {
                const spent = await getSheetValue(sheetName, `sum-amount-${templateContext.category.id}`);
                const balance = await getSheetValue(sheetName, `leftover-${templateContext.category.id}`);
                alreadyBudgeted = balance - spent;
                firstMonth = false;
            }
            else {
                alreadyBudgeted += await getSheetValue(sheetName, `budget-${templateContext.category.id}`);
            }
        }
        const numMonths = differenceInCalendarMonths(toMonth, templateContext.month);
        const target = amountToInteger$1(template.amount);
        if (numMonths < 0) {
            return 0;
        }
        else {
            return Math.round((target - alreadyBudgeted) / (numMonths + 1));
        }
    }
    static async runPercentage(template, availableFunds, templateContext) {
        const percent = template.percent;
        const cat = template.category.toLowerCase();
        const prev = template.previous;
        let sheetName;
        let monthlyIncome = 1;
        if (prev) {
            sheetName = sheetForMonth(subMonths(templateContext.month, 1));
        }
        else {
            sheetName = sheetForMonth(templateContext.month);
        }
        if (cat === "all income") {
            monthlyIncome = await getSheetValue(sheetName, `total-income`);
        }
        else if (cat === "available funds") {
            monthlyIncome = availableFunds;
        }
        else {
            const incomeCat = (await getCategories$3()).find((c) => c.is_income && c.name.toLowerCase() === cat);
            monthlyIncome = await getSheetValue(sheetName, `sum-amount-${incomeCat.id}`);
        }
        return Math.max(0, Math.round(monthlyIncome * (percent / 100)));
    }
    static async runAverage(template, templateContext) {
        let sum = 0;
        for (let i = 1; i <= template.numMonths; i++) {
            const sheetName = sheetForMonth(subMonths(templateContext.month, i));
            sum += await getSheetValue(sheetName, `sum-amount-${templateContext.category.id}`);
        }
        return -Math.round(sum / template.numMonths);
    }
    static runBy(templateContext) {
        const byTemplates = templateContext.templates.filter((t2) => t2.type === "by");
        const savedInfo = [];
        let totalNeeded = 0;
        let shortNumMonths;
        for (let i = 0; i < byTemplates.length; i++) {
            const template = byTemplates[i];
            let targetMonth = `${template.month}`;
            const period = template.annual ? (template.repeat || 1) * 12 : template.repeat != null ? template.repeat : null;
            let numMonths = differenceInCalendarMonths(targetMonth, templateContext.month);
            while (numMonths < 0 && period) {
                targetMonth = addMonths(targetMonth, period);
                numMonths = differenceInCalendarMonths(targetMonth, templateContext.month);
            }
            savedInfo.push({ numMonths, period });
            if (numMonths < shortNumMonths || shortNumMonths === void 0) {
                shortNumMonths = numMonths;
            }
        }
        for (let i = 0; i < byTemplates.length; i++) {
            const template = byTemplates[i];
            const numMonths = savedInfo[i].numMonths;
            const period = savedInfo[i].period;
            let amount;
            if (numMonths > shortNumMonths && period) {
                amount = Math.round(amountToInteger$1(template.amount) / period * (period - numMonths + shortNumMonths));
            }
            else if (numMonths > shortNumMonths) {
                amount = Math.round(amountToInteger$1(template.amount) / (numMonths + 1) * (shortNumMonths + 1));
            }
            else {
                amount = amountToInteger$1(template.amount);
            }
            totalNeeded += amount;
        }
        return Math.round((totalNeeded - templateContext.fromLastMonth) / (shortNumMonths + 1));
    }
}
async function storeTemplates({ categoriesWithTemplates, source }) {
    await batchMessages(async () => {
        for (const { id: id2, templates } of categoriesWithTemplates) {
            const goalDefs = JSON.stringify(templates);
            await updateWithSchema("categories", {
                id: id2,
                goal_def: goalDefs,
                template_settings: { source }
            });
        }
    });
}
async function applyTemplate({ month }) {
    await storeNoteTemplates();
    const categoryTemplates = await getTemplates();
    const ret = await processTemplate(month, false, categoryTemplates);
    return ret;
}
async function overwriteTemplate({ month }) {
    await storeNoteTemplates();
    const categoryTemplates = await getTemplates();
    const ret = await processTemplate(month, true, categoryTemplates);
    return ret;
}
async function applyMultipleCategoryTemplates({ month, categoryIds }) {
    const { data: categoryData } = await aqlQuery(q("categories").filter({ id: { $oneof: categoryIds } }).select("*"));
    await storeNoteTemplates();
    const categoryTemplates = await getTemplates((c) => categoryIds.includes(c.id));
    const ret = await processTemplate(month, true, categoryTemplates, categoryData);
    return ret;
}
async function applySingleCategoryTemplate({ month, category }) {
    const { data: categoryData } = await aqlQuery(q("categories").filter({ id: category }).select("*"));
    await storeNoteTemplates();
    const categoryTemplates = await getTemplates((c) => c.id === category);
    const ret = await processTemplate(month, true, categoryTemplates, categoryData);
    return ret;
}
function runCheckTemplates() {
    return checkTemplateNotes();
}
async function getCategories$2() {
    const { data: categoryGroups } = await aqlQuery(q("category_groups").filter({ hidden: false }).select("*"));
    return categoryGroups.flatMap((g) => g.categories || []).filter((c) => !c.hidden);
}
async function getTemplates(filter = () => true) {
    const { data: categoriesWithGoalDef } = await aqlQuery(q("categories").filter({ goal_def: { $ne: null } }).select("*"));
    const categoryTemplates = {};
    for (const categoryWithGoalDef of categoriesWithGoalDef.filter(filter)) {
        categoryTemplates[categoryWithGoalDef.id] = JSON.parse(categoryWithGoalDef.goal_def);
    }
    return categoryTemplates;
}
async function getTemplatesForCategory(categoryId) {
    return getTemplates((c) => c.id === categoryId);
}
async function setBudgets(month, templateBudget) {
    await batchMessages(async () => {
        templateBudget.forEach((element) => {
            setBudget({
                category: element.category,
                month,
                amount: element.budgeted
            });
        });
    });
}
async function setGoals(month, templateGoal) {
    await batchMessages(async () => {
        templateGoal.forEach((element) => {
            setGoal({
                month,
                category: element.category,
                goal: element.goal,
                long_goal: element.longGoal
            });
        });
    });
}
async function processTemplate(month, force, categoryTemplates, categories = []) {
    const isReflect = isReflectBudget();
    if (!categories.length) {
        categories = (await getCategories$2()).filter((c) => isReflect || !c.is_income);
    }
    const templateContexts = [];
    let availBudget = await getSheetValue(sheetForMonth(month), `to-budget`);
    const prioritiesSet = /* @__PURE__ */ new Set();
    const errors2 = [];
    const budgetList = [];
    const goalList = [];
    for (const category of categories) {
        const { id: id2 } = category;
        const sheetName = sheetForMonth(month);
        const templates = categoryTemplates[id2];
        const budgeted = await getSheetValue(sheetName, `budget-${id2}`);
        const existingGoal = await getSheetValue(sheetName, `goal-${id2}`);
        if ((budgeted === 0 || force) && templates) {
            try {
                const templateContext = await CategoryTemplateContext.init(templates, category, month, budgeted);
                if (!templateContext.isGoalOnly()) {
                    availBudget += budgeted;
                }
                availBudget += templateContext.getLimitExcess();
                templateContext.getPriorities().forEach((p) => prioritiesSet.add(p));
                templateContexts.push(templateContext);
            }
            catch (e) {
                errors2.push(`${category.name}: ${e.message}`);
            }
        }
        else if (existingGoal !== null && !templates) {
            goalList.push({
                category: id2,
                goal: null,
                longGoal: null
            });
        }
    }
    if (templateContexts.length === 0 && errors2.length === 0) {
        if (goalList.length > 0) {
            setGoals(month, goalList);
        }
        return {
            type: "message",
            message: "Everything is up to date"
        };
    }
    if (errors2.length > 0) {
        return {
            sticky: true,
            message: "There were errors interpreting some templates:",
            pre: errors2.join(`

`)
        };
    }
    const priorities = new Int32Array([...prioritiesSet]).sort();
    for (const priority of priorities) {
        const availStart = availBudget;
        for (const templateContext of templateContexts) {
            const budget = await templateContext.runTemplatesForPriority(priority, availBudget, availStart);
            availBudget -= budget;
        }
    }
    let remainderContexts = templateContexts.filter((c) => c.hasRemainder());
    while (availBudget > 0 && remainderContexts.length > 0) {
        let remainderWeight = 0;
        remainderContexts.forEach((context) => remainderWeight += context.getRemainderWeight());
        const perWeight = availBudget / remainderWeight;
        remainderContexts.forEach((context) => {
            availBudget -= context.runRemainder(availBudget, perWeight);
        });
        remainderContexts = templateContexts.filter((c) => c.hasRemainder());
    }
    templateContexts.forEach((context) => {
        const values = context.getValues();
        budgetList.push({
            category: context.category.id,
            budgeted: values.budgeted
        });
        goalList.push({
            category: context.category.id,
            goal: values.goal,
            longGoal: values.longGoal ? 1 : null
        });
    });
    await setBudgets(month, budgetList);
    await setGoals(month, goalList);
    return {
        type: "message",
        message: `Successfully applied templates to ${templateContexts.length} categories`
    };
}
const app$e = createApp();
app$e.method("budget/budget-amount", mutator(undoable(setBudget)));
app$e.method("budget/copy-previous-month", mutator(undoable(copyPreviousMonth)));
app$e.method("budget/copy-single-month", mutator(undoable(copySinglePreviousMonth)));
app$e.method("budget/set-zero", mutator(undoable(setZero)));
app$e.method("budget/set-3month-avg", mutator(undoable(set3MonthAvg)));
app$e.method("budget/set-6month-avg", mutator(undoable(set6MonthAvg)));
app$e.method("budget/set-12month-avg", mutator(undoable(set12MonthAvg)));
app$e.method("budget/set-n-month-avg", mutator(undoable(setNMonthAvg)));
app$e.method("budget/check-templates", mutator(undoable(runCheckTemplates)));
app$e.method("budget/apply-goal-template", mutator(undoable(applyTemplate)));
app$e.method("budget/apply-multiple-templates", mutator(undoable(applyMultipleCategoryTemplates)));
app$e.method("budget/overwrite-goal-template", mutator(undoable(overwriteTemplate)));
app$e.method("budget/apply-single-template", mutator(undoable(applySingleCategoryTemplate)));
app$e.method("budget/cleanup-goal-template", mutator(undoable(cleanupTemplate)));
app$e.method("budget/hold-for-next-month", mutator(undoable(holdForNextMonth)));
app$e.method("budget/reset-hold", mutator(undoable(resetHold)));
app$e.method("budget/cover-overspending", mutator(undoable(coverOverspending)));
app$e.method("budget/transfer-available", mutator(undoable(transferAvailable)));
app$e.method("budget/cover-overbudgeted", mutator(undoable(coverOverbudgeted)));
app$e.method("budget/transfer-category", mutator(undoable(transferCategory)));
app$e.method("budget/set-carryover", mutator(undoable(setCategoryCarryover)));
app$e.method("budget/reset-income-carryover", mutator(undoable(resetIncomeCarryover)));
app$e.method("get-categories", getCategories$1);
app$e.method("get-budget-bounds", getBudgetBounds);
app$e.method("envelope-budget-month", envelopeBudgetMonth);
app$e.method("tracking-budget-month", trackingBudgetMonth);
app$e.method("category-create", mutator(undoable(createCategory$1)));
app$e.method("category-update", mutator(undoable(updateCategory)));
app$e.method("category-move", mutator(undoable(moveCategory)));
app$e.method("category-delete", mutator(undoable(deleteCategory)));
app$e.method("get-category-groups", getCategoryGroups);
app$e.method("category-group-create", mutator(undoable(createCategoryGroup$1)));
app$e.method("category-group-update", mutator(undoable(updateCategoryGroup)));
app$e.method("category-group-move", mutator(undoable(moveCategoryGroup)));
app$e.method("category-group-delete", mutator(undoable(deleteCategoryGroup)));
app$e.method("must-category-transfer", isCategoryTransferRequired);
app$e.method("budget/get-category-automations", getTemplatesForCategory);
app$e.method("budget/set-category-automations", mutator(undoable(storeTemplates)));
app$e.method("budget/store-note-templates", mutator(storeNoteTemplates));
app$e.method("budget/render-note-templates", unparse);
async function getCategories$1() {
    const categoryGroups = await getCategoryGroups();
    return {
        grouped: categoryGroups,
        list: categoryGroups.flatMap((g) => g.categories ?? [])
    };
}
async function getBudgetBounds() {
    return await createAllBudgets();
}
async function envelopeBudgetMonth({ month }) {
    const groups = await getCategoriesGrouped();
    const sheetName = sheetForMonth(month);
    function value(name) {
        const v = getCellValue(sheetName, name);
        return { value: v === "" ? 0 : v, name: resolveName(sheetName, name) };
    }
    let values = [
        value("available-funds"),
        value("last-month-overspent"),
        value("buffered"),
        value("total-budgeted"),
        value("to-budget"),
        value("from-last-month"),
        value("total-income"),
        value("total-spent"),
        value("total-leftover")
    ];
    for (const group of groups) {
        const categories = group.categories ?? [];
        if (group.is_income) {
            values.push(value("total-income"));
            for (const cat of categories) {
                values.push(value(`sum-amount-${cat.id}`));
            }
        }
        else {
            values = values.concat([
                value(`group-budget-${group.id}`),
                value(`group-sum-amount-${group.id}`),
                value(`group-leftover-${group.id}`)
            ]);
            for (const cat of categories) {
                values = values.concat([
                    value(`budget-${cat.id}`),
                    value(`sum-amount-${cat.id}`),
                    value(`leftover-${cat.id}`),
                    value(`carryover-${cat.id}`),
                    value(`goal-${cat.id}`),
                    value(`long-goal-${cat.id}`)
                ]);
            }
        }
    }
    return values;
}
async function trackingBudgetMonth({ month }) {
    const groups = await getCategoriesGrouped();
    const sheetName = sheetForMonth(month);
    function value(name) {
        const v = getCellValue(sheetName, name);
        return { value: v === "" ? 0 : v, name: resolveName(sheetName, name) };
    }
    let values = [
        value("total-budgeted"),
        value("total-budget-income"),
        value("total-saved"),
        value("total-income"),
        value("total-spent"),
        value("real-saved"),
        value("total-leftover")
    ];
    for (const group of groups) {
        values = values.concat([
            value(`group-budget-${group.id}`),
            value(`group-sum-amount-${group.id}`),
            value(`group-leftover-${group.id}`)
        ]);
        const categories = group.categories ?? [];
        for (const cat of categories) {
            values = values.concat([
                value(`budget-${cat.id}`),
                value(`sum-amount-${cat.id}`),
                value(`leftover-${cat.id}`),
                value(`goal-${cat.id}`),
                value(`long-goal-${cat.id}`)
            ]);
            if (!group.is_income) {
                values.push(value(`carryover-${cat.id}`));
            }
        }
    }
    return values;
}
async function createCategory$1({ name, groupId, isIncome, hidden }) {
    if (!groupId) {
        throw APIError("Creating a category: groupId is required");
    }
    return await insertCategory({
        name: name.trim(),
        cat_group: groupId,
        is_income: isIncome ? 1 : 0,
        hidden: hidden ? 1 : 0
    });
}
async function updateCategory(category) {
    try {
        await updateCategory$1(categoryModel$1.toDb({
            ...category,
            name: category.name.trim()
        }));
    }
    catch (e) {
        if (e instanceof Error && e.message.toLowerCase().includes("unique constraint")) {
            return { error: { type: "category-exists" } };
        }
        throw e;
    }
    return {};
}
async function moveCategory({ id: id2, groupId, targetId }) {
    await batchMessages(async () => {
        await moveCategory$1(id2, groupId, targetId);
    });
}
async function deleteCategory({ id: id2, transferId }) {
    let result = {};
    await batchMessages(async () => {
        const row = await first("SELECT is_income FROM categories WHERE id = ?", [id2]);
        if (!row) {
            result = { error: "no-categories" };
            return;
        }
        const transfer = transferId && await first("SELECT is_income FROM categories WHERE id = ?", [transferId]);
        if (!row || transferId && !transfer) {
            result = { error: "no-categories" };
            return;
        }
        else if (transferId && row && transfer && row.is_income !== transfer.is_income) {
            result = { error: "category-type" };
            return;
        }
        if (row.is_income === 0) {
            if (transferId) {
                await doTransfer([id2], transferId);
            }
        }
        await deleteCategory$1({ id: id2 }, transferId);
    });
    return result;
}
async function getCategoryGroups() {
    const { data: categoryGroups } = await aqlQuery(q("category_groups").select("*"));
    return categoryGroups;
}
async function createCategoryGroup$1({ name, isIncome, hidden }) {
    return await insertCategoryGroup({
        name,
        is_income: isIncome ? 1 : 0,
        hidden: hidden ? 1 : 0
    });
}
async function updateCategoryGroup(group) {
    await updateCategoryGroup$1(categoryGroupModel$1.toDb(group));
}
async function moveCategoryGroup({ id: id2, targetId }) {
    await batchMessages(async () => {
        await moveCategoryGroup$1(id2, targetId);
    });
}
async function deleteCategoryGroup({ id: id2, transferId }) {
    const groupCategories = await all("SELECT id FROM categories WHERE cat_group = ? AND tombstone = 0", [id2]);
    await batchMessages(async () => {
        if (transferId) {
            await doTransfer(groupCategories.map((c) => c.id), transferId);
        }
        await deleteCategoryGroup$1({ id: id2 }, transferId);
    });
}
async function isCategoryTransferRequired({ id: id2 }) {
    const res = await runQuery(`SELECT count(t.id) as count FROM transactions t
       LEFT JOIN category_mapping cm ON cm.id = t.category
       WHERE cm.transferId = ? AND t.tombstone = 0`, [id2], true);
    if (res[0].count !== 0) {
        return true;
    }
    return [...get$3().meta().createdMonths].some((month) => {
        const sheetName = sheetForMonth(month);
        const value = get$3().getCellValue(sheetName, "budget-" + id2);
        return value != null && value !== 0;
    });
}
const random = Math.random;
function pickRandom(list) {
    return list[Math.floor(random() * list.length) % list.length];
}
function number(start, end) {
    return start + (end - start) * random();
}
function integer(start, end) {
    return Math.round(number(start, end));
}
function findMin(items, field) {
    let item = items[0];
    for (let i = 0; i < items.length; i++) {
        if (items[i][field] < item[field]) {
            item = items[i];
        }
    }
    return item;
}
function getStartingBalanceCat(categories) {
    return categories.find((c) => c.name === "Starting Balances").id;
}
function extractCommonThings(payees, groups) {
    const incomePayee = payees.find((p) => p.name === "Deposit");
    const expensePayees = payees.filter((p) => p.name !== "Deposit" && p.name !== "Starting Balance");
    const expenseGroup = groups.find((g) => !g.is_income);
    const incomeGroup = groups.find((g) => g.is_income);
    const categories = expenseGroup.categories.filter((c) => [
        "Food",
        "Restaurants",
        "Entertainment",
        "Clothing",
        "General",
        "Gift",
        "Medical"
    ].indexOf(c.name) !== -1);
    return {
        incomePayee,
        expensePayees: expensePayees.filter((p) => !p.bill),
        incomeGroup,
        expenseCategories: categories,
        billCategories: groups.find((g) => g.name === "Bills").categories,
        billPayees: expensePayees.filter((p) => p.bill)
    };
}
async function fillPrimaryChecking(handlers2, account, payees, groups) {
    const { incomePayee, expensePayees, incomeGroup, expenseCategories, billCategories, billPayees } = extractCommonThings(payees, groups);
    const numTransactions = integer(100, 200);
    const transactions = [];
    for (let i = 0; i < numTransactions; i++) {
        let payee;
        if (random() < 0.09) {
            payee = incomePayee;
        }
        else {
            payee = pickRandom(expensePayees);
        }
        let category;
        if (payee.name === "Deposit") {
            category = incomeGroup.categories.find((c) => c.name === "Income");
        }
        else {
            category = pickRandom(expenseCategories);
        }
        let amount;
        if (payee.name === "Deposit") {
            amount = integer(5e4, 7e4);
        }
        else {
            amount = integer(0, random() < 0.05 ? -8e3 : -700);
        }
        const currentDate2 = subDays(currentDay(), Math.floor(i / 3));
        const transaction2 = {
            id: v4(),
            amount,
            payee: payee.id,
            account: account.id,
            date: currentDate2,
            category: category.id
        };
        transactions.push(transaction2);
        if (random() < 0.2) {
            const a = Math.round(transaction2.amount / 3);
            const pick = () => payee === incomePayee ? incomeGroup.categories.find((c) => c.name === "Income").id : pickRandom(expenseCategories).id;
            transaction2.subtransactions = [
                {
                    id: v4(),
                    date: currentDate2,
                    account: account.id,
                    amount: a,
                    category: pick()
                },
                {
                    id: v4(),
                    date: currentDate2,
                    account: account.id,
                    amount: a,
                    category: pick()
                },
                {
                    id: v4(),
                    date: currentDate2,
                    account: account.id,
                    amount: transaction2.amount - a * 2,
                    category: pick()
                }
            ];
        }
    }
    const earliestMonth = monthFromDate(transactions[transactions.length - 1].date);
    const months = rangeInclusive(earliestMonth, currentMonth());
    const currentDay$1 = currentDay();
    for (const month of months) {
        let date = addDays(month, 12);
        if (isBefore(date, currentDay$1)) {
            transactions.push({
                amount: -1e4,
                payee: billPayees.find((p) => p.name.toLowerCase().includes("power")).id,
                account: account.id,
                date,
                category: billCategories.find((c) => c.name === "Power").id
            });
        }
        date = addDays(month, 18);
        if (isBefore(date, currentDay$1)) {
            transactions.push({
                amount: -9e3,
                payee: billPayees.find((p) => p.name.toLowerCase().includes("water")).id,
                account: account.id,
                date,
                category: billCategories.find((c) => c.name === "Water").id
            });
        }
        date = addDays(month, 2);
        if (isBefore(date, currentDay$1)) {
            transactions.push({
                amount: -12e4,
                payee: billPayees.find((p) => p.name.toLowerCase().includes("housy")).id,
                account: account.id,
                date,
                category: billCategories.find((c) => c.name === "Mortgage").id
            });
        }
        date = addDays(month, 20);
        if (isBefore(date, currentDay$1)) {
            transactions.push({
                amount: -6e3,
                payee: billPayees.find((p) => p.name.toLowerCase().includes("internet")).id,
                account: account.id,
                date,
                category: billCategories.find((c) => c.name === "Internet").id
            });
        }
        date = addDays(month, 23);
        if (isBefore(date, currentDay$1)) {
            transactions.push({
                amount: -7500,
                payee: billPayees.find((p) => p.name.toLowerCase().includes("t-mobile")).id,
                account: account.id,
                date,
                category: billCategories.find((c) => c.name === "Cell").id
            });
        }
    }
    let earliestDate = null;
    transactions.forEach((t2) => {
        if (earliestDate == null || t2.date < earliestDate) {
            earliestDate = t2.date;
        }
    });
    transactions.unshift({
        amount: 1e5,
        payee: payees.find((p) => p.name === "Starting Balance").id,
        account: account.id,
        date: earliestDate,
        category: getStartingBalanceCat(incomeGroup.categories),
        starting_balance_flag: true
    });
    return addTransactions$1(account.id, transactions);
}
async function fillChecking(handlers2, account, payees, groups) {
    const { incomePayee, expensePayees, incomeGroup, expenseCategories } = extractCommonThings(payees, groups);
    const numTransactions = integer(20, 40);
    const transactions = [];
    for (let i = 0; i < numTransactions; i++) {
        let payee;
        if (random() < 0.04) {
            payee = incomePayee;
        }
        else {
            payee = pickRandom(expensePayees);
        }
        let category;
        if (payee.name === "Deposit") {
            category = incomeGroup.categories.find((c) => c.name === "Income");
        }
        else {
            category = pickRandom(expenseCategories);
        }
        const amount = payee.name === "Deposit" ? integer(5e4, 7e4) : integer(0, -1e4);
        transactions.push({
            amount,
            payee: payee.id,
            account: account.id,
            date: subDays(currentDay(), i * 2),
            category: category.id
        });
    }
    transactions.unshift({
        amount: integer(9e4, 12e4),
        payee: payees.find((p) => p.name === "Starting Balance").id,
        account: account.id,
        date: transactions[transactions.length - 1].date,
        category: getStartingBalanceCat(incomeGroup.categories),
        starting_balance_flag: true
    });
    await handlers2["transactions-batch-update"]({
        added: transactions,
        fastMode: true
    });
}
async function fillInvestment(handlers2, account, payees, groups) {
    const { incomePayee, incomeGroup } = extractCommonThings(payees, groups);
    const numTransactions = integer(10, 30);
    const transactions = [];
    for (let i = 0; i < numTransactions; i++) {
        const payee = incomePayee;
        const category = incomeGroup.categories.find((c) => c.name === "Income");
        const amount = integer(1e4, 2e4);
        transactions.push({
            amount,
            payee: payee.id,
            account: account.id,
            date: subDays(currentDay(), integer(10, 360)),
            category: category.id
        });
    }
    transactions.unshift({
        amount: integer(1e4, 2e4),
        payee: payees.find((p) => p.name === "Starting Balance").id,
        account: account.id,
        date: findMin(transactions, "date").date,
        category: getStartingBalanceCat(incomeGroup.categories),
        starting_balance_flag: true
    });
    await handlers2["transactions-batch-update"]({
        added: transactions,
        fastMode: true
    });
}
async function fillSavings(handlers2, account, payees, groups) {
    const { incomePayee, expensePayees, incomeGroup, expenseCategories } = extractCommonThings(payees, groups);
    const numTransactions = integer(15, 40);
    const transactions = [];
    for (let i = 0; i < numTransactions; i++) {
        let payee;
        if (random() < 0.3) {
            payee = incomePayee;
        }
        else {
            payee = pickRandom(expensePayees);
        }
        const category = payee === incomePayee ? incomeGroup.categories.find((c) => c.name === "Income") : pickRandom(expenseCategories);
        const amount = payee === incomePayee ? integer(1e4, 8e4) : integer(-1e4, -2e3);
        transactions.push({
            amount,
            payee: payee.id,
            account: account.id,
            date: subDays(currentDay(), i * 5),
            category: category.id
        });
    }
    transactions.unshift({
        amount: 3e4,
        payee: payees.find((p) => p.name === "Starting Balance").id,
        account: account.id,
        date: transactions[transactions.length - 1].date,
        category: getStartingBalanceCat(incomeGroup.categories),
        starting_balance_flag: true
    });
    await handlers2["transactions-batch-update"]({
        added: transactions,
        fastMode: true
    });
}
async function fillMortgage(handlers2, account, payees, groups) {
    const { incomePayee, incomeGroup } = extractCommonThings(payees, groups);
    const numTransactions = integer(7, 10);
    const amount = integer(1e5, 2e5);
    const category = incomeGroup.categories.find((c) => c.name === "Income");
    const transactions = [
        {
            amount: integer(-3e3, -3500) * 100 * 100,
            payee: payees.find((p) => p.name === "Starting Balance").id,
            account: account.id,
            date: subMonths(currentDay(), numTransactions) + "-02",
            category: getStartingBalanceCat(incomeGroup.categories),
            starting_balance_flag: true
        }
    ];
    for (let i = 0; i < numTransactions; i++) {
        const payee = incomePayee;
        transactions.push({
            amount,
            payee: payee.id,
            account: account.id,
            date: subMonths(currentDay(), i) + "-02",
            category: category.id,
            starting_balance_flag: true
        });
    }
    await handlers2["transactions-batch-update"]({
        added: transactions,
        fastMode: true
    });
}
async function fillOther(handlers2, account, payees, groups) {
    const { incomePayee, incomeGroup } = extractCommonThings(payees, groups);
    const numTransactions = integer(3, 6);
    const category = incomeGroup.categories.find((c) => c.name === "Income");
    const transactions = [
        {
            id: v4(),
            amount: integer(3250, 3700) * 100 * 100,
            payee: payees.find((p) => p.name === "Starting Balance").id,
            account: account.id,
            date: subMonths(currentDay(), numTransactions) + "-02",
            category: getStartingBalanceCat(incomeGroup.categories),
            starting_balance_flag: true
        }
    ];
    for (let i = 0; i < numTransactions; i++) {
        const payee = incomePayee;
        const amount = integer(4, 9) * 100 * 100;
        transactions.push({
            id: v4(),
            amount,
            payee: payee.id,
            account: account.id,
            date: subMonths(currentDay(), i) + "-02",
            category: category.id
        });
    }
    await handlers2["transactions-batch-update"]({
        added: transactions,
        fastMode: true
    });
}
async function createBudget$1(accounts, payees, groups) {
    const primaryAccount = accounts.find((a) => a.name = "Bank of America");
    const earliestDate = (await first(`SELECT t.date FROM v_transactions t LEFT JOIN accounts a ON t.account = a.id
       WHERE a.offbudget = 0 AND t.is_child = 0 ORDER BY date ASC LIMIT 1`)).date;
    const earliestPrimaryDate = (await first(`SELECT t.date FROM v_transactions t LEFT JOIN accounts a ON t.account = a.id
       WHERE a.id = ? AND a.offbudget = 0 AND t.is_child = 0 ORDER BY date ASC LIMIT 1`, [primaryAccount.id])).date;
    const start = monthFromDate(fromDateRepr(earliestDate));
    const end = currentMonth();
    const months = rangeInclusive(start, end);
    function category(name) {
        for (const group of groups) {
            const cat = group.categories.find((c) => c.name === name);
            if (cat) {
                return cat;
            }
        }
    }
    function setBudget$1(month, category2, amount) {
        return setBudget({ month, category: category2.id, amount });
    }
    function setBudgetIfSpent(month, cat) {
        const spent = getCellValue(sheetForMonth(month), `sum-amount-${cat.id}`);
        if (spent < 0) {
            setBudget$1(month, cat, -spent);
        }
    }
    await runMutator(() => batchMessages(async () => {
        for (const month of months) {
            if (month >= monthFromDate(fromDateRepr(earliestPrimaryDate))) {
                setBudget$1(month, category("Food"), 4e4);
                setBudget$1(month, category("Restaurants"), 3e4);
                setBudget$1(month, category("Entertainment"), 1e4);
                setBudget$1(month, category("Clothing"), 3e3);
                setBudget$1(month, category("General"), 5e4);
                setBudget$1(month, category("Gift"), 7500);
                setBudget$1(month, category("Medical"), 1e4);
                setBudget$1(month, category("Cell"), 7500);
                setBudget$1(month, category("Internet"), 6e3);
                setBudget$1(month, category("Mortgage"), 12e4);
                setBudget$1(month, category("Water"), 9e3);
                setBudget$1(month, category("Power"), 1e4);
            }
            else {
                setBudgetIfSpent(month, category("Food"));
                setBudgetIfSpent(month, category("Restaurants"));
                setBudgetIfSpent(month, category("Entertainment"));
                setBudgetIfSpent(month, category("Clothing"));
                setBudgetIfSpent(month, category("General"));
                setBudgetIfSpent(month, category("Gift"));
                setBudgetIfSpent(month, category("Medical"));
                setBudgetIfSpent(month, category("Cell"));
                setBudgetIfSpent(month, category("Internet"));
                setBudgetIfSpent(month, category("Mortgage"));
                setBudgetIfSpent(month, category("Water"));
                setBudgetIfSpent(month, category("Power"));
            }
        }
    }));
    await waitOnSpreadsheet();
    await runMutator(() => batchMessages(async () => {
        let prevSaved = 0;
        for (const month of months) {
            if (month >= monthFromDate(fromDateRepr(earliestPrimaryDate)) && month <= currentMonth()) {
                const sheetName2 = sheetForMonth(month);
                const toBudget2 = getCellValue(sheetName2, "to-budget");
                const available = toBudget2 - prevSaved;
                if (available - 403e3 > 0) {
                    setBudget$1(month, category("Savings"), available - 403e3);
                    setBuffer(month, 403e3);
                    prevSaved += available - 403e3;
                }
                else if (available > 0) {
                    setBuffer(month, available);
                }
            }
        }
    }));
    await waitOnSpreadsheet();
    const sheetName = sheetForMonth(currentMonth());
    const toBudget = getCellValue(sheetName, "to-budget");
    if (toBudget < 0) {
        await addTransactions$1(primaryAccount.id, [
            {
                amount: -toBudget,
                category: category("Income").id,
                date: currentMonth() + "-01"
            }
        ]);
    }
    await waitOnSpreadsheet();
}
async function createTestBudget(handlers2) {
    setSyncingMode("import");
    await execQuery("PRAGMA journal_mode = OFF");
    await runQuery("DELETE FROM categories;");
    await runQuery("DELETE FROM category_groups");
    const accounts = [
        { name: "Bank of America" },
        { name: "Ally Savings" },
        { name: "Capital One Checking" },
        { name: "HSBC" },
        { name: "Vanguard 401k", offBudget: true },
        { name: "Mortgage", offBudget: true },
        { name: "House Asset", offBudget: true },
        { name: "Roth IRA", offBudget: true }
    ];
    await runMutator(async () => {
        for (const account of accounts) {
            account.id = await handlers2["account-create"](account);
        }
    });
    const newPayees = [
        { name: "Starting Balance" },
        { name: "Kroger" },
        { name: "Publix" },
        { name: "Home Depot" },
        { name: "Movies" },
        { name: "Online store" },
        { name: "Deposit" },
        { name: "Dominion Power", bill: true },
        { name: "Extra Watery", bill: true },
        { name: "Housy House", bill: true },
        { name: "Fast Internet", bill: true },
        { name: "T-mobile", bill: true }
    ];
    const payees = [];
    await runMutator(() => batchMessages(async () => {
        for (const newPayee of newPayees) {
            const id2 = await handlers2["payee-create"]({ name: newPayee.name });
            payees.push({
                id: id2,
                name: newPayee.name,
                ...newPayee
            });
        }
    }));
    const newCategoryGroups = [
        {
            name: "Usual Expenses",
            categories: [
                { name: "Savings" },
                { name: "Medical" },
                { name: "Gift" },
                { name: "General" },
                { name: "Clothing" },
                { name: "Entertainment" },
                { name: "Restaurants" },
                { name: "Food" }
            ]
        },
        {
            name: "Bills",
            categories: [
                { name: "Power" },
                { name: "Water" },
                { name: "Mortgage" },
                { name: "Internet" },
                { name: "Cell" }
            ]
        },
        {
            name: "Income",
            is_income: true,
            categories: [
                { name: "Income", is_income: true },
                { name: "Misc", is_income: true },
                { name: "Starting Balances", is_income: true }
            ]
        }
    ];
    const categoryGroups = [];
    await runMutator(async () => {
        for (const group of newCategoryGroups) {
            const groupId = await handlers2["category-group-create"]({
                name: group.name,
                isIncome: group.is_income
            });
            categoryGroups.push({
                ...group,
                id: groupId,
                categories: []
            });
            for (const category of group.categories) {
                const categoryId = await handlers2["category-create"]({
                    ...category,
                    isIncome: category.is_income,
                    groupId
                });
                categoryGroups[categoryGroups.length - 1].categories.push({
                    ...category,
                    id: categoryId,
                    group: groupId
                });
            }
        }
    });
    const allGroups = (await runHandler(handlers2["get-categories"])).grouped;
    setSyncingMode("import");
    await runMutator(() => batchMessages(async () => {
        for (const account of accounts) {
            if (account.name === "Bank of America") {
                await fillPrimaryChecking(handlers2, account, payees, allGroups);
            }
            else if (account.name === "Capital One Checking" || account.name === "HSBC") {
                await fillChecking(handlers2, account, payees, allGroups);
            }
            else if (account.name === "Ally Savings") {
                await fillSavings(handlers2, account, payees, allGroups);
            }
            else if (account.name === "Vanguard 401k" || account.name === "Roth IRA") {
                await fillInvestment(handlers2, account, payees, allGroups);
            }
            else if (account.name === "Mortgage") {
                await fillMortgage(handlers2, account, payees, allGroups);
            }
            else if (account.name === "House Asset") {
                await fillOther(handlers2, account, payees, allGroups);
            }
            else {
                console.error("Unknown account name for test budget: ", account.name);
                await fillChecking(handlers2, account, payees, allGroups);
            }
        }
    }));
    setSyncingMode("import");
    const primaryAccount = accounts.find((a) => a.name = "Bank of America");
    const { data: primaryBalance } = await aqlQuery(q("transactions").filter({ account: primaryAccount.id }).calculate({ $sum: "$amount" }).serialize());
    if (primaryBalance < 0) {
        const { data: results } = await aqlQuery(q("transactions").filter({ account: primaryAccount.id, amount: { $gt: 0 } }).limit(1).select(["id", "amount"]).serialize());
        const lastDeposit = results[0];
        await runHandler(handlers2["transaction-update"], {
            ...lastDeposit,
            amount: lastDeposit.amount + -primaryBalance + integer(1e4, 2e4)
        });
    }
    setSyncingMode("disabled");
    await reloadSpreadsheet(db$1);
    await createAllBudgets();
    await waitOnSpreadsheet();
    await runMutator(() => batchMessages(async () => {
        const account = accounts.find((acc) => acc.name === "Bank of America");
        await runHandler(handlers2["schedule/create"], {
            schedule: {
                name: "Phone bills",
                posts_transaction: false
            },
            conditions: [
                {
                    op: "is",
                    field: "payee",
                    value: payees.find((item) => item.name === "Dominion Power").id
                },
                {
                    op: "is",
                    field: "account",
                    value: account.id
                },
                {
                    op: "is",
                    field: "date",
                    value: {
                        start: currentDay(),
                        frequency: "monthly",
                        patterns: [],
                        skipWeekend: false,
                        weekendSolveMode: "after"
                    }
                },
                { op: "isapprox", field: "amount", value: -12e3 }
            ]
        });
        await runHandler(handlers2["schedule/create"], {
            schedule: {
                name: "Internet bill",
                posts_transaction: false
            },
            conditions: [
                {
                    op: "is",
                    field: "payee",
                    value: payees.find((item) => item.name === "Fast Internet").id
                },
                {
                    op: "is",
                    field: "account",
                    value: account.id
                },
                {
                    op: "is",
                    field: "date",
                    value: subDays(currentDay(), 1)
                },
                { op: "isapprox", field: "amount", value: -14e3 }
            ]
        });
        await runHandler(handlers2["schedule/create"], {
            schedule: {
                name: "Wedding",
                posts_transaction: false
            },
            conditions: [
                {
                    op: "is",
                    field: "date",
                    value: {
                        start: subDays(currentDay(), 3),
                        frequency: "monthly",
                        patterns: [],
                        skipWeekend: false,
                        weekendSolveMode: "after"
                    }
                },
                { op: "is", field: "amount", value: -27e5 }
            ]
        });
        await runHandler(handlers2["schedule/create"], {
            schedule: {
                name: "Utilities",
                posts_transaction: false
            },
            conditions: [
                {
                    op: "is",
                    field: "account",
                    value: account.id
                },
                {
                    op: "is",
                    field: "date",
                    value: {
                        start: addDays(currentDay(), 1),
                        frequency: "monthly",
                        patterns: [],
                        skipWeekend: false,
                        weekendSolveMode: "after"
                    }
                },
                { op: "is", field: "amount", value: -19e4 }
            ]
        });
    }));
    await createBudget$1(accounts, payees, allGroups);
}
async function importActual(_filepath, buffer) {
    await exports.handlers["close-budget"]();
    let id2;
    try {
        ({ id: id2 } = await importBuffer({ cloudFileId: null, groupId: null }, buffer));
    }
    catch (e) {
        if (e.type === "FileDownloadError") {
            return { error: e.reason };
        }
        throw e;
    }
    const sqliteDb = await openDatabase$1(join$1(getBudgetDir(id2), "db.sqlite"));
    execQuery$2(sqliteDb, `
          DELETE FROM kvcache;
          DELETE FROM kvcache_key;
        `);
    closeDatabase$1(sqliteDb);
    await exports.handlers["load-budget"]({ id: id2 });
    await exports.handlers["get-budget-bounds"]();
    await waitOnSpreadsheet();
    await upload().catch(() => {
    });
}
function send(name, args) {
    return send$2(name, args);
}
async function batchBudgetUpdates(func) {
    await send("api/batch-budget-start");
    try {
        await func();
    }
    finally {
        await send("api/batch-budget-end");
    }
}
function setBudgetAmount(month, categoryId, value) {
    return send("api/budget-set-amount", { month, categoryId, amount: value });
}
function setBudgetCarryover(month, categoryId, flag) {
    return send("api/budget-set-carryover", { month, categoryId, flag });
}
function addTransactions(accountId, transactions, { learnCategories = false, runTransfers = false } = {}) {
    return send("api/transactions-add", {
        accountId,
        transactions,
        learnCategories,
        runTransfers
    });
}
function getAccounts() {
    return send("api/accounts-get");
}
function createAccount(account, initialBalance) {
    return send("api/account-create", { account, initialBalance });
}
function createCategoryGroup(group) {
    return send("api/category-group-create", { group });
}
function getCategories() {
    return send("api/categories-get", { grouped: false });
}
function createCategory(category) {
    return send("api/category-create", { category });
}
function getPayees$1() {
    return send("api/payees-get");
}
function createPayee$1(payee) {
    return send("api/payee-create", { payee });
}
function amountToInteger(n) {
    return Math.round(n * 100);
}
var slash;
var hasRequiredSlash;
function requireSlash() {
    if (hasRequiredSlash)
        return slash;
    hasRequiredSlash = 1;
    slash = (path2) => {
        const isExtendedLengthPath = /^\\\\\?\\/.test(path2);
        const hasNonAscii = /[^\u0000-\u0080]+/.test(path2);
        if (isExtendedLengthPath || hasNonAscii) {
            return path2;
        }
        return path2.replace(/\\/g, "/");
    };
    return slash;
}
var slashExports = requireSlash();
const normalizePathSep = /* @__PURE__ */ getDefaultExportFromCjs(slashExports);
async function importAccounts$1(data, entityIdMap) {
    const accounts = sortByKey(data.accounts, "sortableIndex");
    return Promise.all(accounts.map(async (account) => {
        if (!account.isTombstone) {
            const id2 = await createAccount({
                name: account.accountName,
                offbudget: account.onBudget ? false : true,
                closed: account.hidden ? true : false
            });
            entityIdMap.set(account.entityId, id2);
        }
    }));
}
async function importCategories$1(data, entityIdMap) {
    const masterCategories = sortByKey(data.masterCategories, "sortableIndex");
    await Promise.all(masterCategories.map(async (masterCategory) => {
        if (masterCategory.type === "OUTFLOW" && !masterCategory.isTombstone && masterCategory.subCategories && masterCategory.subCategories.some((cat) => !cat.isTombstone)) {
            const id2 = await createCategoryGroup({
                name: masterCategory.name,
                is_income: false
            });
            entityIdMap.set(masterCategory.entityId, id2);
            if (masterCategory.note) {
                send$2("notes-save", { id: id2, note: masterCategory.note });
            }
            if (masterCategory.subCategories) {
                const subCategories = sortByKey(masterCategory.subCategories, "sortableIndex");
                subCategories.reverse();
                for (const category of subCategories) {
                    if (!category.isTombstone) {
                        let categoryName = category.name;
                        if (masterCategory.name === "Hidden Categories") {
                            const categoryNameParts = categoryName.split(" ` ");
                            categoryNameParts.pop();
                            categoryName = categoryNameParts.join("/").trim();
                        }
                        const id22 = await createCategory({
                            name: categoryName,
                            group_id: entityIdMap.get(category.masterCategoryId)
                        });
                        entityIdMap.set(category.entityId, id22);
                        if (category.note) {
                            send$2("notes-save", { id: id22, note: category.note });
                        }
                    }
                }
            }
        }
    }));
}
async function importPayees$1(data, entityIdMap) {
    for (const payee of data.payees) {
        if (!payee.isTombstone) {
            const id2 = await createPayee$1({
                name: payee.name,
                category: entityIdMap.get(payee.autoFillCategoryId) || null,
                transfer_acct: entityIdMap.get(payee.targetAccountId) || null
            });
            entityIdMap.set(payee.entityId, id2);
        }
    }
}
async function importTransactions$1(data, entityIdMap) {
    const categories = await getCategories();
    const incomeCategoryId = categories.find((cat) => cat.name === "Income").id;
    const accounts = await getAccounts();
    const payees = await getPayees$1();
    function getCategory(id2) {
        if (id2 == null || id2 === "Category/__Split__") {
            return null;
        }
        else if (id2 === "Category/__ImmediateIncome__" || id2 === "Category/__DeferredIncome__") {
            return incomeCategoryId;
        }
        return entityIdMap.get(id2);
    }
    function isOffBudget(acctId) {
        const acct = accounts.find((acct2) => acct2.id === acctId);
        if (!acct) {
            throw new Error("Could not find account for transaction when importing");
        }
        return acct.offbudget;
    }
    for (const transaction2 of data.transactions) {
        entityIdMap.set(transaction2.entityId, v4());
        if (transaction2.subTransactions) {
            for (const subTransaction of transaction2.subTransactions) {
                entityIdMap.set(subTransaction.entityId, v4());
            }
        }
    }
    const transactionsGrouped = groupBy(data.transactions, "accountId");
    await Promise.all([...transactionsGrouped.keys()].map(async (accountId) => {
        const transactions = transactionsGrouped.get(accountId);
        const toImport = transactions.map((transaction2) => {
            if (transaction2.isTombstone) {
                return null;
            }
            const id2 = entityIdMap.get(transaction2.entityId);
            function transferProperties(t2) {
                const transferId = entityIdMap.get(t2.transferTransactionId) || null;
                let payee = null;
                let imported_payee = null;
                if (transferId) {
                    payee = payees.find((p) => p.transfer_acct === entityIdMap.get(t2.targetAccountId)).id;
                }
                else {
                    payee = entityIdMap.get(t2.payeeId);
                    imported_payee = data.payees.find((p) => p.entityId === t2.payeeId)?.name;
                }
                return {
                    transfer_id: transferId,
                    payee,
                    imported_payee
                };
            }
            const newTransaction = {
                id: id2,
                amount: amountToInteger(transaction2.amount),
                category: isOffBudget(entityIdMap.get(accountId)) ? null : getCategory(transaction2.categoryId),
                date: transaction2.date,
                notes: transaction2.memo || null,
                cleared: transaction2.cleared === "Cleared" || transaction2.cleared === "Reconciled",
                reconciled: transaction2.cleared === "Reconciled",
                ...transferProperties(transaction2),
                subtransactions: transaction2.subTransactions && transaction2.subTransactions.filter((st) => !st.isTombstone).map((t2) => {
                    return {
                        id: entityIdMap.get(t2.entityId),
                        amount: amountToInteger(t2.amount),
                        category: getCategory(t2.categoryId),
                        notes: t2.memo || null,
                        ...transferProperties(t2)
                    };
                })
            };
            return newTransaction;
        }).filter((x) => x);
        await addTransactions(entityIdMap.get(accountId), toImport, {
            learnCategories: true
        });
    }));
}
function fillInBudgets(data, categoryBudgets) {
    const budgets = [...categoryBudgets];
    data.masterCategories.forEach((masterCategory) => {
        if (masterCategory.subCategories) {
            masterCategory.subCategories.forEach((category) => {
                if (!budgets.find((b) => b.categoryId === category.entityId)) {
                    budgets.push({
                        budgeted: 0,
                        categoryId: category.entityId
                    });
                }
            });
        }
    });
    return budgets;
}
async function importBudgets$1(data, entityIdMap) {
    const budgets = sortByKey(data.monthlyBudgets, "month");
    await batchBudgetUpdates(async () => {
        for (const budget of budgets) {
            const filled = fillInBudgets(data, budget.monthlySubCategoryBudgets.filter((b) => !b.isTombstone));
            await Promise.all(filled.map(async (catBudget) => {
                const amount = amountToInteger(catBudget.budgeted);
                const catId = entityIdMap.get(catBudget.categoryId);
                const month = monthFromDate(budget.month);
                if (!catId) {
                    return;
                }
                await setBudgetAmount(month, catId, amount);
                if (catBudget.overspendingHandling === "AffectsBuffer") {
                    await setBudgetCarryover(month, catId, false);
                }
                else if (catBudget.overspendingHandling === "Confined") {
                    await setBudgetCarryover(month, catId, true);
                }
            }));
        }
    });
}
function estimateRecentness(str) {
    return str.split(",").reduce((total, version) => {
        const [_, number2] = version.split("-");
        return total + parseInt(number2);
    }, 0);
}
function findLatestDevice(zipped, entries) {
    let devices = entries.map((entry) => {
        const contents = zipped.readFile(entry).toString("utf8");
        let data;
        try {
            data = JSON.parse(contents);
        }
        catch (e) {
            return null;
        }
        if (data.hasFullKnowledge) {
            return {
                deviceGUID: data.deviceGUID,
                shortName: data.shortDeviceId,
                recentness: estimateRecentness(data.knowledge)
            };
        }
        return null;
    }).filter((x) => x);
    devices = sortByKey(devices, "recentness");
    return devices[devices.length - 1].deviceGUID;
}
async function doImport$1(data) {
    const entityIdMap = /* @__PURE__ */ new Map();
    logger.log("Importing Accounts...");
    await importAccounts$1(data, entityIdMap);
    logger.log("Importing Categories...");
    await importCategories$1(data, entityIdMap);
    logger.log("Importing Payees...");
    await importPayees$1(data, entityIdMap);
    logger.log("Importing Transactions...");
    await importTransactions$1(data, entityIdMap);
    logger.log("Importing Budgets...");
    await importBudgets$1(data, entityIdMap);
    logger.log("Setting up...");
}
function getBudgetName$1(filepath) {
    let unixFilepath = normalizePathSep(filepath);
    if (!/\.zip/.test(unixFilepath)) {
        return null;
    }
    unixFilepath = unixFilepath.replace(/\.zip$/, "").replace(/.ynab4$/, "");
    const m = unixFilepath.match(/([^/~]+)[^/]*$/);
    if (!m) {
        return null;
    }
    return m[1];
}
function getFile(entries, path2) {
    const files = entries.filter((e) => e.entryName === path2);
    if (files.length === 0) {
        throw new Error("Could not find file: " + path2);
    }
    if (files.length >= 2) {
        throw new Error("File name matches multiple files: " + path2);
    }
    return files[0];
}
function join(...paths) {
    return paths.slice(1).reduce((full, path2) => {
        return full + "/" + path2.replace(/^\//, "");
    }, paths[0].replace(/\/$/, ""));
}
function parseFile$2(buffer) {
    const zipped = new AdmZip(buffer);
    const entries = zipped.getEntries();
    let root = "";
    const dirMatch = entries[0].entryName.match(/([^/]*\.ynab4)/);
    if (dirMatch) {
        root = dirMatch[1] + "/";
    }
    const metaStr = zipped.readFile(getFile(entries, root + "Budget.ymeta"));
    const meta = JSON.parse(metaStr.toString("utf8"));
    const budgetPath = join(root, meta.relativeDataFolderName);
    const deviceFiles = entries.filter((e) => e.entryName.startsWith(join(budgetPath, "devices")));
    const deviceGUID = findLatestDevice(zipped, deviceFiles);
    const yfullPath = join(budgetPath, deviceGUID, "Budget.yfull");
    let contents;
    try {
        contents = zipped.readFile(getFile(entries, yfullPath)).toString("utf8");
    }
    catch (e) {
        logger.log(e);
        throw new Error("Error reading Budget.yfull file");
    }
    try {
        return JSON.parse(contents);
    }
    catch (e) {
        throw new Error("Error parsing Budget.yfull file");
    }
}
const YNAB4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    doImport: doImport$1,
    getBudgetName: getBudgetName$1,
    parseFile: parseFile$2
}, Symbol.toStringTag, { value: "Module" }));
function amountFromYnab(amount) {
    return Math.round(amount / 10);
}
function importAccounts(data, entityIdMap) {
    return Promise.all(data.accounts.map(async (account) => {
        if (!account.deleted) {
            const id2 = await createAccount({
                name: account.name,
                offbudget: account.on_budget ? false : true,
                closed: account.closed
            });
            entityIdMap.set(account.id, id2);
        }
    }));
}
async function importCategories(data, entityIdMap) {
    const categories = await getCategories();
    const incomeCatId = findIdByName(categories, "Income");
    const ynabIncomeCategories = ["To be Budgeted", "Inflow: Ready to Assign"];
    function checkSpecialCat(cat) {
        if (cat.category_group_id === findIdByName(data.category_groups, "Internal Master Category")) {
            if (ynabIncomeCategories.some((ynabIncomeCategory) => equalsIgnoreCase(cat.name, ynabIncomeCategory))) {
                return "income";
            }
            else {
                return "internal";
            }
        }
        else if (cat.category_group_id === findIdByName(data.category_groups, "Credit Card Payments")) {
            return "creditCard";
        }
        else if (cat.category_group_id === findIdByName(data.category_groups, "Income")) {
            return "income";
        }
    }
    for (const group of data.category_groups) {
        if (!group.deleted) {
            let groupId;
            if (!equalsIgnoreCase(group.name, "Internal Master Category") && !equalsIgnoreCase(group.name, "Credit Card Payments") && !equalsIgnoreCase(group.name, "Hidden Categories") && !equalsIgnoreCase(group.name, "Income")) {
                let run2 = true;
                const MAX_RETRY = 10;
                let count = 1;
                const origName = group.name;
                while (run2) {
                    try {
                        groupId = await createCategoryGroup({
                            name: group.name,
                            is_income: false,
                            hidden: group.hidden
                        });
                        entityIdMap.set(group.id, groupId);
                        if (group.note) {
                            send$2("notes-save", { id: groupId, note: group.note });
                        }
                        run2 = false;
                    }
                    catch (e) {
                        group.name = origName + "-" + count.toString();
                        count += 1;
                        if (count >= MAX_RETRY) {
                            run2 = false;
                            throw Error(e.message);
                        }
                    }
                }
            }
            if (equalsIgnoreCase(group.name, "Income")) {
                groupId = incomeCatId;
                entityIdMap.set(group.id, groupId);
            }
            const cats = data.categories.filter((cat) => cat.category_group_id === group.id);
            for (const cat of cats.reverse()) {
                if (!cat.deleted) {
                    switch (checkSpecialCat(cat)) {
                        case "income": {
                            const id2 = incomeCatId;
                            entityIdMap.set(cat.id, id2);
                            break;
                        }
                        case "creditCard":
                        // ignores it
                        case "internal":
                            break;
                        default: {
                            let run2 = true;
                            const MAX_RETRY = 10;
                            let count = 1;
                            const origName = cat.name;
                            while (run2) {
                                try {
                                    const id2 = await createCategory({
                                        name: cat.name,
                                        group_id: groupId,
                                        hidden: cat.hidden
                                    });
                                    entityIdMap.set(cat.id, id2);
                                    if (cat.note) {
                                        send$2("notes-save", { id: id2, note: cat.note });
                                    }
                                    run2 = false;
                                }
                                catch (e) {
                                    cat.name = origName + "-" + count.toString();
                                    count += 1;
                                    if (count >= MAX_RETRY) {
                                        run2 = false;
                                        throw Error(e.message);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
function importPayees(data, entityIdMap) {
    return Promise.all(data.payees.map(async (payee) => {
        if (!payee.deleted) {
            const id2 = await createPayee$1({
                name: payee.name
            });
            entityIdMap.set(payee.id, id2);
        }
    }));
}
async function importTransactions(data, entityIdMap) {
    const payees = await getPayees$1();
    const categories = await getCategories();
    const incomeCatId = findIdByName(categories, "Income");
    const startingBalanceCatId = findIdByName(categories, "Starting Balances");
    const startingPayeeYNAB = findIdByName(data.payees, "Starting Balance");
    const transactionsGrouped = groupBy(data.transactions, "account_id");
    const subtransactionsGrouped = groupBy(data.subtransactions, "transaction_id");
    const payeesByTransferAcct = payees.filter((payee) => payee?.transfer_acct).map((payee) => [payee.transfer_acct, payee]);
    const payeeTransferAcctHashMap = new Map(payeesByTransferAcct);
    const orphanTransferMap = /* @__PURE__ */ new Map();
    const orphanSubtransfer = [];
    const orphanSubtransferTrxId = [];
    const orphanSubtransferAcctIdByTrxIdMap = /* @__PURE__ */ new Map();
    const orphanSubtransferDateByTrxIdMap = /* @__PURE__ */ new Map();
    for (const transaction2 of data.subtransactions) {
        entityIdMap.set(transaction2.id, v4());
        if (transaction2.transfer_account_id) {
            orphanSubtransfer.push(transaction2);
            orphanSubtransferTrxId.push(transaction2.transaction_id);
        }
    }
    for (const transaction2 of data.transactions) {
        entityIdMap.set(transaction2.id, v4());
        if (transaction2.transfer_account_id && !transaction2.transfer_transaction_id) {
            const key = transaction2.account_id + "#" + transaction2.transfer_account_id;
            if (!orphanTransferMap.has(key)) {
                orphanTransferMap.set(key, [transaction2]);
            }
            else {
                orphanTransferMap.get(key).push(transaction2);
            }
        }
        if (orphanSubtransferTrxId.includes(transaction2.id)) {
            orphanSubtransferAcctIdByTrxIdMap.set(transaction2.id, transaction2.account_id);
            orphanSubtransferDateByTrxIdMap.set(transaction2.id, transaction2.date);
        }
    }
    const orphanSubtransferMap = orphanSubtransfer.reduce((map, subtransaction) => {
        const key = subtransaction.transfer_account_id + "#" + orphanSubtransferAcctIdByTrxIdMap.get(subtransaction.transaction_id);
        if (!map.has(key)) {
            map.set(key, [subtransaction]);
        }
        else {
            map.get(key).push(subtransaction);
        }
        return map;
    }, 
    /* @__PURE__ */ new Map());
    const orphanTransferComparator = (a, b) => {
        const date_a = "date" in a ? a.date : orphanSubtransferDateByTrxIdMap.get(a.transaction_id);
        const date_b = "date" in b ? b.date : orphanSubtransferDateByTrxIdMap.get(b.transaction_id);
        const amount_a = "date" in a ? a.amount : -a.amount;
        const amount_b = "date" in b ? b.amount : -b.amount;
        if (date_a > date_b)
            return 1;
        if (date_a < date_b)
            return -1;
        if (amount_a > amount_b)
            return 1;
        if (amount_a < amount_b)
            return -1;
        if (a.memo > b.memo)
            return 1;
        if (a.memo < b.memo)
            return -1;
        return 0;
    };
    const orphanTrxIdSubtrxIdMap = /* @__PURE__ */ new Map();
    orphanTransferMap.forEach((transactions, key) => {
        const subtransactions = orphanSubtransferMap.get(key);
        if (subtransactions) {
            transactions.sort(orphanTransferComparator);
            subtransactions.sort(orphanTransferComparator);
            let transactionIdx = 0;
            let subtransactionIdx = 0;
            do {
                switch (orphanTransferComparator(transactions[transactionIdx], subtransactions[subtransactionIdx])) {
                    case 0:
                        orphanTrxIdSubtrxIdMap.set(transactions[transactionIdx].id, entityIdMap.get(subtransactions[subtransactionIdx].id));
                        orphanTrxIdSubtrxIdMap.set(subtransactions[subtransactionIdx].id, entityIdMap.get(transactions[transactionIdx].id));
                        transactionIdx++;
                        subtransactionIdx++;
                        break;
                    case -1:
                        transactionIdx++;
                        break;
                    case 1:
                        subtransactionIdx++;
                        break;
                }
            } while (transactionIdx < transactions.length && subtransactionIdx < subtransactions.length);
        }
    });
    await Promise.all([...transactionsGrouped.keys()].map(async (accountId) => {
        const transactions = transactionsGrouped.get(accountId);
        const toImport = transactions.map((transaction2) => {
            if (transaction2.deleted) {
                return null;
            }
            const subtransactions = subtransactionsGrouped.get(transaction2.id);
            const newTransaction = {
                id: entityIdMap.get(transaction2.id),
                account: entityIdMap.get(transaction2.account_id),
                date: transaction2.date,
                amount: amountFromYnab(transaction2.amount),
                category: entityIdMap.get(transaction2.category_id) || null,
                cleared: ["cleared", "reconciled"].includes(transaction2.cleared),
                reconciled: transaction2.cleared === "reconciled",
                notes: transaction2.memo || null,
                imported_id: transaction2.import_id || null,
                transfer_id: entityIdMap.get(transaction2.transfer_transaction_id) || orphanTrxIdSubtrxIdMap.get(transaction2.id) || null,
                subtransactions: subtransactions ? subtransactions.map((subtrans) => {
                    return {
                        id: entityIdMap.get(subtrans.id),
                        amount: amountFromYnab(subtrans.amount),
                        category: entityIdMap.get(subtrans.category_id) || null,
                        notes: subtrans.memo,
                        transfer_id: orphanTrxIdSubtrxIdMap.get(subtrans.id) || null,
                        payee: null,
                        imported_payee: null
                    };
                }) : null,
                payee: null,
                imported_payee: null
            };
            const transactionPayeeUpdate = (trx, newTrx) => {
                if (trx.transfer_account_id) {
                    const mappedTransferAccountId = entityIdMap.get(trx.transfer_account_id);
                    newTrx.payee = payeeTransferAcctHashMap.get(mappedTransferAccountId)?.id;
                }
                else {
                    newTrx.payee = entityIdMap.get(trx.payee_id);
                    newTrx.imported_payee = data.payees.find((p) => !p.deleted && p.id === trx.payee_id)?.name;
                }
            };
            transactionPayeeUpdate(transaction2, newTransaction);
            if (newTransaction.subtransactions) {
                subtransactions.forEach((subtrans) => {
                    const newSubtransaction = newTransaction.subtransactions.find((newSubtrans) => newSubtrans.id === entityIdMap.get(subtrans.id));
                    transactionPayeeUpdate(subtrans, newSubtransaction);
                });
            }
            if (transaction2.payee_id === startingPayeeYNAB && entityIdMap.get(transaction2.category_id) === incomeCatId) {
                newTransaction.category = startingBalanceCatId;
                newTransaction.payee = null;
            }
            return newTransaction;
        }).filter((x) => x);
        await addTransactions(entityIdMap.get(accountId), toImport, {
            learnCategories: true
        });
    }));
}
async function importBudgets(data, entityIdMap) {
    const budgets = sortByKey(data.months, "month");
    const internalCatIdYnab = findIdByName(data.category_groups, "Internal Master Category");
    const creditcardCatIdYnab = findIdByName(data.category_groups, "Credit Card Payments");
    await batchBudgetUpdates(async () => {
        for (const budget of budgets) {
            const month = monthFromDate(budget.month);
            await Promise.all(budget.categories.map(async (catBudget) => {
                const catId = entityIdMap.get(catBudget.id);
                const amount = Math.round(catBudget.budgeted / 10);
                if (!catId || catBudget.category_group_id === internalCatIdYnab || catBudget.category_group_id === creditcardCatIdYnab) {
                    return;
                }
                await setBudgetAmount(month, catId, amount);
            }));
        }
    });
}
async function doImport(data) {
    const entityIdMap = /* @__PURE__ */ new Map();
    logger.log("Importing Accounts...");
    await importAccounts(data, entityIdMap);
    logger.log("Importing Categories...");
    await importCategories(data, entityIdMap);
    logger.log("Importing Payees...");
    await importPayees(data, entityIdMap);
    logger.log("Importing Transactions...");
    await importTransactions(data, entityIdMap);
    logger.log("Importing Budgets...");
    await importBudgets(data, entityIdMap);
    logger.log("Setting up...");
}
function parseFile$1(buffer) {
    let data = JSON.parse(buffer.toString());
    if (data.data) {
        data = data.data;
    }
    if (data.budget) {
        data = data.budget;
    }
    return data;
}
function getBudgetName(_filepath, data) {
    return data.budget_name || data.name;
}
function equalsIgnoreCase(stringa, stringb) {
    return stringa.localeCompare(stringb, void 0, {
        sensitivity: "base"
    }) === 0;
}
function findByNameIgnoreCase(categories, name) {
    return categories.find((cat) => equalsIgnoreCase(cat.name, name));
}
function findIdByName(categories, name) {
    return findByNameIgnoreCase(categories, name)?.id;
}
const YNAB5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    doImport,
    getBudgetName,
    parseFile: parseFile$1
}, Symbol.toStringTag, { value: "Module" }));
const importers = {
    ynab4: YNAB4,
    ynab5: YNAB5
};
async function handleBudgetImport(type2, filepath, buffer) {
    if (type2 === "actual") {
        return importActual(filepath, buffer);
    }
    const importer = importers[type2];
    try {
        let data;
        let budgetName;
        try {
            data = importer.parseFile(buffer);
            budgetName = importer.getBudgetName(filepath, data);
        }
        catch (e) {
            logger.error("failed to parse file", e);
        }
        if (!budgetName) {
            return { error: "not-" + type2 };
        }
        try {
            await exports.handlers["api/start-import"]({ budgetName });
        }
        catch (e) {
            logger.error("failed to start import", e);
            return { error: "unknown" };
        }
        await importer.doImport(data);
    }
    catch (e) {
        await exports.handlers["api/abort-import"]();
        logger.error("failed to run import", e);
        return { error: "unknown" };
    }
    await exports.handlers["api/finish-import"]();
}
function migrateParentIds(_oldValues, newValues) {
    newValues.forEach((items, table) => {
        if (table === "transactions") {
            const toApply = [];
            items.forEach((newValue) => {
                if (newValue.isChild === 1 && newValue.parent_id == null && newValue.id.includes("/")) {
                    const parentId = newValue.id.split("/")[0];
                    toApply.push({
                        dataset: "transactions",
                        row: newValue.id,
                        column: "parent_id",
                        value: parentId,
                        timestamp: Timestamp.send()
                    });
                }
            });
            if (toApply.length > 0) {
                applyMessages(toApply);
            }
        }
    });
}
let _unlisten = null;
function listen() {
    unlisten();
    _unlisten = addSyncListener(migrateParentIds);
}
function unlisten() {
    if (_unlisten) {
        _unlisten();
        _unlisten = null;
    }
}
var md5$1 = { exports: {} };
var crypt = { exports: {} };
var hasRequiredCrypt;
function requireCrypt() {
    if (hasRequiredCrypt)
        return crypt.exports;
    hasRequiredCrypt = 1;
    (function () {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
            // Bit-wise rotation left
            rotl: function (n, b) {
                return n << b | n >>> 32 - b;
            },
            // Bit-wise rotation right
            rotr: function (n, b) {
                return n << 32 - b | n >>> b;
            },
            // Swap big-endian to little-endian and vice versa
            endian: function (n) {
                if (n.constructor == Number) {
                    return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
                }
                for (var i = 0; i < n.length; i++)
                    n[i] = crypt$1.endian(n[i]);
                return n;
            },
            // Generate an array of any length of random bytes
            randomBytes: function (n) {
                for (var bytes = []; n > 0; n--)
                    bytes.push(Math.floor(Math.random() * 256));
                return bytes;
            },
            // Convert a byte array to big-endian 32-bit words
            bytesToWords: function (bytes) {
                for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                    words[b >>> 5] |= bytes[i] << 24 - b % 32;
                return words;
            },
            // Convert big-endian 32-bit words to a byte array
            wordsToBytes: function (words) {
                for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                    bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
                return bytes;
            },
            // Convert a byte array to a hex string
            bytesToHex: function (bytes) {
                for (var hex = [], i = 0; i < bytes.length; i++) {
                    hex.push((bytes[i] >>> 4).toString(16));
                    hex.push((bytes[i] & 15).toString(16));
                }
                return hex.join("");
            },
            // Convert a hex string to a byte array
            hexToBytes: function (hex) {
                for (var bytes = [], c = 0; c < hex.length; c += 2)
                    bytes.push(parseInt(hex.substr(c, 2), 16));
                return bytes;
            },
            // Convert a byte array to a base-64 string
            bytesToBase64: function (bytes) {
                for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                    var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                    for (var j = 0; j < 4; j++)
                        if (i * 8 + j * 6 <= bytes.length * 8)
                            base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                        else
                            base64.push("=");
                }
                return base64.join("");
            },
            // Convert a base-64 string to a byte array
            base64ToBytes: function (base64) {
                base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
                for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                    if (imod4 == 0)
                        continue;
                    bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
                }
                return bytes;
            }
        };
        crypt.exports = crypt$1;
    })();
    return crypt.exports;
}
var charenc_1;
var hasRequiredCharenc;
function requireCharenc() {
    if (hasRequiredCharenc)
        return charenc_1;
    hasRequiredCharenc = 1;
    var charenc = {
        // UTF-8 encoding
        utf8: {
            // Convert a string to a byte array
            stringToBytes: function (str) {
                return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
            },
            // Convert a byte array to a string
            bytesToString: function (bytes) {
                return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
            }
        },
        // Binary encoding
        bin: {
            // Convert a string to a byte array
            stringToBytes: function (str) {
                for (var bytes = [], i = 0; i < str.length; i++)
                    bytes.push(str.charCodeAt(i) & 255);
                return bytes;
            },
            // Convert a byte array to a string
            bytesToString: function (bytes) {
                for (var str = [], i = 0; i < bytes.length; i++)
                    str.push(String.fromCharCode(bytes[i]));
                return str.join("");
            }
        }
    };
    charenc_1 = charenc;
    return charenc_1;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer_1;
var hasRequiredIsBuffer$1;
function requireIsBuffer$1() {
    if (hasRequiredIsBuffer$1)
        return isBuffer_1;
    hasRequiredIsBuffer$1 = 1;
    isBuffer_1 = function (obj) {
        return obj != null && (isBuffer2(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer2(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer2(obj.slice(0, 0));
    }
    return isBuffer_1;
}
var hasRequiredMd5;
function requireMd5() {
    if (hasRequiredMd5)
        return md5$1.exports;
    hasRequiredMd5 = 1;
    (function () {
        var crypt2 = requireCrypt(), utf8 = requireCharenc().utf8, isBuffer2 = requireIsBuffer$1(), bin = requireCharenc().bin, md52 = function (message2, options2) {
            if (message2.constructor == String)
                if (options2 && options2.encoding === "binary")
                    message2 = bin.stringToBytes(message2);
                else
                    message2 = utf8.stringToBytes(message2);
            else if (isBuffer2(message2))
                message2 = Array.prototype.slice.call(message2, 0);
            else if (!Array.isArray(message2) && message2.constructor !== Uint8Array)
                message2 = message2.toString();
            var m = crypt2.bytesToWords(message2), l = message2.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
            for (var i = 0; i < m.length; i++) {
                m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
            }
            m[l >>> 5] |= 128 << l % 32;
            m[(l + 64 >>> 9 << 4) + 14] = l;
            var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
            for (var i = 0; i < m.length; i += 16) {
                var aa = a, bb = b, cc = c, dd = d;
                a = FF(a, b, c, d, m[i + 0], 7, -680876936);
                d = FF(d, a, b, c, m[i + 1], 12, -389564586);
                c = FF(c, d, a, b, m[i + 2], 17, 606105819);
                b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
                a = FF(a, b, c, d, m[i + 4], 7, -176418897);
                d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
                c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
                b = FF(b, c, d, a, m[i + 7], 22, -45705983);
                a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
                d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
                c = FF(c, d, a, b, m[i + 10], 17, -42063);
                b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
                a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
                d = FF(d, a, b, c, m[i + 13], 12, -40341101);
                c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
                b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
                a = GG(a, b, c, d, m[i + 1], 5, -165796510);
                d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
                c = GG(c, d, a, b, m[i + 11], 14, 643717713);
                b = GG(b, c, d, a, m[i + 0], 20, -373897302);
                a = GG(a, b, c, d, m[i + 5], 5, -701558691);
                d = GG(d, a, b, c, m[i + 10], 9, 38016083);
                c = GG(c, d, a, b, m[i + 15], 14, -660478335);
                b = GG(b, c, d, a, m[i + 4], 20, -405537848);
                a = GG(a, b, c, d, m[i + 9], 5, 568446438);
                d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
                c = GG(c, d, a, b, m[i + 3], 14, -187363961);
                b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
                a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
                d = GG(d, a, b, c, m[i + 2], 9, -51403784);
                c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
                b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
                a = HH(a, b, c, d, m[i + 5], 4, -378558);
                d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
                c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
                b = HH(b, c, d, a, m[i + 14], 23, -35309556);
                a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
                d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
                c = HH(c, d, a, b, m[i + 7], 16, -155497632);
                b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
                a = HH(a, b, c, d, m[i + 13], 4, 681279174);
                d = HH(d, a, b, c, m[i + 0], 11, -358537222);
                c = HH(c, d, a, b, m[i + 3], 16, -722521979);
                b = HH(b, c, d, a, m[i + 6], 23, 76029189);
                a = HH(a, b, c, d, m[i + 9], 4, -640364487);
                d = HH(d, a, b, c, m[i + 12], 11, -421815835);
                c = HH(c, d, a, b, m[i + 15], 16, 530742520);
                b = HH(b, c, d, a, m[i + 2], 23, -995338651);
                a = II(a, b, c, d, m[i + 0], 6, -198630844);
                d = II(d, a, b, c, m[i + 7], 10, 1126891415);
                c = II(c, d, a, b, m[i + 14], 15, -1416354905);
                b = II(b, c, d, a, m[i + 5], 21, -57434055);
                a = II(a, b, c, d, m[i + 12], 6, 1700485571);
                d = II(d, a, b, c, m[i + 3], 10, -1894986606);
                c = II(c, d, a, b, m[i + 10], 15, -1051523);
                b = II(b, c, d, a, m[i + 1], 21, -2054922799);
                a = II(a, b, c, d, m[i + 8], 6, 1873313359);
                d = II(d, a, b, c, m[i + 15], 10, -30611744);
                c = II(c, d, a, b, m[i + 6], 15, -1560198380);
                b = II(b, c, d, a, m[i + 13], 21, 1309151649);
                a = II(a, b, c, d, m[i + 4], 6, -145523070);
                d = II(d, a, b, c, m[i + 11], 10, -1120210379);
                c = II(c, d, a, b, m[i + 2], 15, 718787259);
                b = II(b, c, d, a, m[i + 9], 21, -343485551);
                a = a + aa >>> 0;
                b = b + bb >>> 0;
                c = c + cc >>> 0;
                d = d + dd >>> 0;
            }
            return crypt2.endian([a, b, c, d]);
        };
        md52._ff = function (a, b, c, d, x, s, t2) {
            var n = a + (b & c | ~b & d) + (x >>> 0) + t2;
            return (n << s | n >>> 32 - s) + b;
        };
        md52._gg = function (a, b, c, d, x, s, t2) {
            var n = a + (b & d | c & ~d) + (x >>> 0) + t2;
            return (n << s | n >>> 32 - s) + b;
        };
        md52._hh = function (a, b, c, d, x, s, t2) {
            var n = a + (b ^ c ^ d) + (x >>> 0) + t2;
            return (n << s | n >>> 32 - s) + b;
        };
        md52._ii = function (a, b, c, d, x, s, t2) {
            var n = a + (c ^ (b | ~d)) + (x >>> 0) + t2;
            return (n << s | n >>> 32 - s) + b;
        };
        md52._blocksize = 16;
        md52._digestsize = 16;
        md5$1.exports = function (message2, options2) {
            if (message2 === void 0 || message2 === null)
                throw new Error("Illegal argument " + message2);
            var digestbytes = crypt2.wordsToBytes(md52(message2, options2));
            return options2 && options2.asBytes ? digestbytes : options2 && options2.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
        };
    })();
    return md5$1.exports;
}
var md5Exports = requireMd5();
const md5 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
async function runMigration$3(db2) {
    function getValue(node2) {
        return node2.expr != null ? node2.expr : node2.cachedValue;
    }
    db2.execQuery(`
CREATE TABLE zero_budget_months
  (id TEXT PRIMARY KEY,
   buffered INTEGER DEFAULT 0);

CREATE TABLE zero_budgets
  (id TEXT PRIMARY KEY,
   month INTEGER,
   category TEXT,
   amount INTEGER DEFAULT 0,
   carryover INTEGER DEFAULT 0);

CREATE TABLE reflect_budgets
  (id TEXT PRIMARY KEY,
   month INTEGER,
   category TEXT,
   amount INTEGER DEFAULT 0,
   carryover INTEGER DEFAULT 0);

CREATE TABLE notes
  (id TEXT PRIMARY KEY,
   note TEXT);

CREATE TABLE kvcache (key TEXT PRIMARY KEY, value TEXT);
CREATE TABLE kvcache_key (id INTEGER PRIMARY KEY, key REAL);
`);
    const budget = db2.runQuery(`SELECT * FROM spreadsheet_cells WHERE name LIKE 'budget%!budget-%'`, [], true);
    db2.transaction(() => {
        budget.forEach((monthBudget) => {
            const match2 = monthBudget.name.match(/^(budget-report|budget)(\d+)!budget-(.+)$/);
            if (match2 == null) {
                console.log("Warning: invalid budget month name", monthBudget.name);
                return;
            }
            const type2 = match2[1];
            const month = match2[2].slice(0, 4) + "-" + match2[2].slice(4);
            const dbmonth = parseInt(match2[2]);
            const cat = match2[3];
            let amount = parseInt(getValue(monthBudget));
            if (isNaN(amount)) {
                amount = 0;
            }
            const sheetName = monthBudget.name.split("!")[0];
            const carryover = db2.runQuery("SELECT * FROM spreadsheet_cells WHERE name = ?", [`${sheetName}!carryover-${cat}`], true);
            const table = type2 === "budget-report" ? "reflect_budgets" : "zero_budgets";
            db2.runQuery(`INSERT INTO ${table} (id, month, category, amount, carryover) VALUES (?, ?, ?, ?, ?)`, [
                `${month}-${cat}`,
                dbmonth,
                cat,
                amount,
                carryover.length > 0 && getValue(carryover[0]) === "true" ? 1 : 0
            ]);
        });
    });
    const buffers = db2.runQuery(`SELECT * FROM spreadsheet_cells WHERE name LIKE 'budget%!buffered'`, [], true);
    db2.transaction(() => {
        buffers.forEach((buffer) => {
            const match2 = buffer.name.match(/^budget(\d+)!buffered$/);
            if (match2) {
                const month = match2[1].slice(0, 4) + "-" + match2[1].slice(4);
                let amount = parseInt(getValue(buffer));
                if (isNaN(amount)) {
                    amount = 0;
                }
                db2.runQuery(`INSERT INTO zero_budget_months (id, buffered) VALUES (?, ?)`, [month, amount]);
            }
        });
    });
    const notes = db2.runQuery(`SELECT * FROM spreadsheet_cells WHERE name LIKE 'notes!%'`, [], true);
    const parseNote = (str) => {
        try {
            const value = JSON.parse(str);
            return value && value !== "" ? value : null;
        }
        catch (e) {
            return null;
        }
    };
    db2.transaction(() => {
        notes.forEach((note) => {
            const parsed = parseNote(getValue(note));
            if (parsed) {
                const [, id2] = note.name.split("!");
                db2.runQuery(`INSERT INTO notes (id, note) VALUES (?, ?)`, [id2, parsed]);
            }
        });
    });
    db2.execQuery(`
    DROP TABLE spreadsheet_cells;
    ANALYZE;
    VACUUM;
  `);
}
async function runMigration$2(db2) {
    const categories = await db2.runQuery("SELECT id FROM categories WHERE tombstone = 0", [], true);
    const customReports = await db2.runQuery("SELECT id, selected_categories, conditions FROM custom_reports WHERE tombstone = 0 AND selected_categories IS NOT NULL", [], true);
    for (const report of customReports) {
        const conditions = report.conditions ? JSON.parse(report.conditions) : [];
        const selectedCategories = report.selected_categories ? JSON.parse(report.selected_categories) : [];
        const selectedCategoryIds = selectedCategories.map(({ id: id2 }) => id2);
        const areAllCategoriesSelected = !categories.find(({ id: id2 }) => !selectedCategoryIds.includes(id2));
        if (areAllCategoriesSelected) {
            continue;
        }
        if (conditions.find(({ field }) => field === "category")) {
            continue;
        }
        await db2.runQuery("UPDATE custom_reports SET conditions = ? WHERE id = ?", [
            JSON.stringify([
                ...conditions,
                {
                    field: "category",
                    op: "oneOf",
                    value: selectedCategoryIds,
                    type: "id"
                }
            ]),
            report.id
        ]);
    }
    await db2.runQuery("UPDATE custom_reports SET selected_categories = NULL WHERE tombstone = 0");
}
async function runMigration$1(db2) {
    db2.transaction(() => {
        db2.execQuery(`
      CREATE TABLE dashboard
        (id TEXT PRIMARY KEY,
         type TEXT,
         width INTEGER,
         height INTEGER,
         x INTEGER,
         y INTEGER,
         meta TEXT,
         tombstone INTEGER DEFAULT 0);

      INSERT INTO dashboard (id, type, width, height, x, y)
      VALUES
        ('${v4()}','net-worth-card', 8, 2, 0, 0),
        ('${v4()}', 'cash-flow-card', 4, 2, 8, 0),
        ('${v4()}', 'spending-card', 4, 2, 0, 2);
    `);
        const reports = db2.runQuery("SELECT id FROM custom_reports WHERE tombstone = 0 ORDER BY name COLLATE NOCASE ASC", [], true);
        reports.forEach((report, id2) => {
            db2.runQuery(`INSERT INTO dashboard (id, type, width, height, x, y, meta) VALUES (?, ?, ?, ?, ?, ?, ?)`, [
                v4(),
                "custom-report",
                4,
                2,
                id2 * 4 % 12,
                2 + Math.floor(id2 / 3) * 2,
                JSON.stringify({ id: report.id })
            ]);
        });
    });
}
const SYNCED_PREF_KEYS = [
    "firstDayOfWeekIdx",
    "dateFormat",
    "numberFormat",
    "hideFraction",
    "isPrivacyEnabled",
    /^show-extra-balances-/,
    /^hide-cleared-/,
    /^parse-date-/,
    /^csv-mappings-/,
    /^csv-delimiter-/,
    /^csv-has-header-/,
    /^ofx-fallback-missing-payee-/,
    /^flip-amount-/,
    "budgetType",
    /^flags\./
];
async function runMigration(db2, { fs: fs2, fileId }) {
    await db2.execQuery(`
    CREATE TABLE preferences
       (id TEXT PRIMARY KEY,
        value TEXT);
  `);
    try {
        const budgetDir = fs2.getBudgetDir(fileId);
        const fullpath = fs2.join(budgetDir, "metadata.json");
        const prefs2 = JSON.parse(await fs2.readFile(fullpath));
        if (typeof prefs2 !== "object") {
            return;
        }
        await Promise.all(Object.keys(prefs2).map(async (key) => {
            if (!SYNCED_PREF_KEYS.find((keyMatcher) => keyMatcher instanceof RegExp ? keyMatcher.test(key) : keyMatcher === key)) {
                return;
            }
            await db2.runQuery("INSERT INTO preferences (id, value) VALUES (?, ?)", [
                key,
                String(prefs2[key])
            ]);
        }));
    }
    catch (e) {
    }
}
let MIGRATIONS_DIR = migrationsPath;
const javascriptMigrations = {
    1632571489012: runMigration$3,
    1722717601e3: runMigration$2,
    1722804019e3: runMigration$1,
    1723665565e3: runMigration
};
function getMigrationId(name) {
    return parseInt(name.match(/^(\d)+/)[0]);
}
async function patchBadMigrations(db2) {
    const badFiltersMigration = 1685375406832;
    const newFiltersMigration = 1688749527273;
    const appliedIds = await getAppliedMigrations(db2);
    if (appliedIds.includes(badFiltersMigration)) {
        await runQuery$1(db2, "DELETE FROM __migrations__ WHERE id = ?", [
            badFiltersMigration
        ]);
        await runQuery$1(db2, "INSERT INTO __migrations__ (id) VALUES (?)", [
            newFiltersMigration
        ]);
    }
}
async function getAppliedMigrations(db2) {
    const rows = await runQuery$1(db2, "SELECT * FROM __migrations__ ORDER BY id ASC", [], true);
    return rows.map((row) => row.id);
}
async function getMigrationList(migrationsDir) {
    const files = await listDir(migrationsDir);
    return files.filter((name) => name.match(/(\.sql|\.js)$/)).sort((m1, m2) => {
        const id1 = getMigrationId(m1);
        const id2 = getMigrationId(m2);
        if (id1 < id2) {
            return -1;
        }
        else if (id1 > id2) {
            return 1;
        }
        return 0;
    });
}
function getPending(appliedIds, all2) {
    return all2.filter((name) => {
        const id2 = getMigrationId(name);
        return appliedIds.indexOf(id2) === -1;
    });
}
async function applyJavaScript(db2, id2) {
    const dbInterface = {
        runQuery: (query, params, fetchAll2) => runQuery$1(db2, query, params, fetchAll2),
        execQuery: (query) => execQuery$2(db2, query),
        transaction: (func) => transaction$1(db2, func)
    };
    if (javascriptMigrations[id2] == null) {
        throw new Error("Could not find JS migration code to run for " + id2);
    }
    const run2 = javascriptMigrations[id2];
    return run2(dbInterface, {
        fs,
        fileId: getPrefs()?.id
    });
}
async function applySql(db2, sql) {
    try {
        await execQuery$2(db2, sql);
    }
    catch (e) {
        logger.log("Error applying sql:", sql);
        throw e;
    }
}
async function applyMigration(db2, name, migrationsDir) {
    const code = await readFile(join$1(migrationsDir, name));
    if (name.match(/\.js$/)) {
        await applyJavaScript(db2, getMigrationId(name));
    }
    else {
        await applySql(db2, code);
    }
    await runQuery$1(db2, "INSERT INTO __migrations__ (id) VALUES (?)", [
        getMigrationId(name)
    ]);
}
function checkDatabaseValidity(appliedIds, available) {
    for (let i = 0; i < appliedIds.length; i++) {
        if (i >= available.length || appliedIds[i] !== getMigrationId(available[i])) {
            logger.error("Database is out of sync with migrations:", {
                appliedIds,
                available
            });
            throw new Error("out-of-sync-migrations");
        }
    }
}
async function migrate(db2) {
    await patchBadMigrations(db2);
    const appliedIds = await getAppliedMigrations(db2);
    const available = await getMigrationList(MIGRATIONS_DIR);
    checkDatabaseValidity(appliedIds, available);
    const pending = getPending(appliedIds, available);
    for (const migration of pending) {
        await applyMigration(db2, migration, MIGRATIONS_DIR);
    }
    return pending;
}
async function runMigrations() {
    await migrate(getDatabase());
}
async function updateViews() {
    const hashKey = "view-hash";
    const row = await first("SELECT value FROM __meta__ WHERE key = ?", [hashKey]);
    const { value: hash } = row || {};
    const views = makeViews(schema, schemaConfig);
    const currentHash = md5(views);
    if (hash !== currentHash) {
        await execQuery(views);
        await runQuery("INSERT OR REPLACE INTO __meta__ (key, value) VALUES (?, ?)", [hashKey, currentHash]);
    }
}
async function updateVersion() {
    await runMigrations();
    await updateViews();
}
async function uniqueBudgetName(initialName = "My Finances") {
    const budgets = await exports.handlers["get-budgets"]();
    let idx = 1;
    let newName = initialName;
    while (budgets.find((file) => file.name === newName)) {
        newName = `${initialName} ${idx}`;
        idx++;
    }
    return newName;
}
async function validateBudgetName(name) {
    const trimmedName = name.trim();
    const uniqueName = await uniqueBudgetName(trimmedName);
    let message2 = null;
    if (trimmedName === "")
        message2 = "Budget name cannot be blank";
    if (trimmedName.length > 100) {
        message2 = "Budget name is too long (max length 100)";
    }
    if (uniqueName !== trimmedName) {
        message2 = `${name} already exists, try ${uniqueName} instead`;
    }
    return message2 ? { valid: false, message: message2 } : { valid: true };
}
async function idFromBudgetName(name) {
    let id2 = name.replace(/( |[^A-Za-z0-9])/g, "-") + "-" + v4().slice(0, 7);
    let index = 0;
    let budgetDir = getBudgetDir(id2);
    while (await exists(budgetDir)) {
        index++;
        budgetDir = getBudgetDir(id2 + index.toString());
    }
    if (index > 0) {
        id2 = id2 + index.toString();
    }
    return id2;
}
const LATEST_BACKUP_FILENAME = "db.latest.sqlite";
let serviceInterval = null;
async function getBackups$1(id2) {
    const budgetDir = getBudgetDir(id2);
    const backupDir = join$1(budgetDir, "backups");
    let paths = [];
    if (await exists(backupDir)) {
        paths = await listDir(backupDir);
        paths = paths.filter((file) => file.match(/\.sqlite$/));
    }
    const backups = await Promise.all(paths.map(async (path2) => {
        const mtime = await getModifiedTime(join$1(backupDir, path2));
        return {
            id: path2,
            date: new Date(mtime)
        };
    }));
    backups.sort((b1, b2) => {
        if (b1.date < b2.date) {
            return 1;
        }
        else if (b1.date > b2.date) {
            return -1;
        }
        return 0;
    });
    return backups;
}
async function getLatestBackup(id2) {
    const budgetDir = getBudgetDir(id2);
    if (await exists(join$1(budgetDir, LATEST_BACKUP_FILENAME))) {
        return {
            id: LATEST_BACKUP_FILENAME,
            date: null,
            isLatest: true
        };
    }
    return null;
}
async function getAvailableBackups(id2) {
    const backups = await getBackups$1(id2);
    const latestBackup = await getLatestBackup(id2);
    if (latestBackup) {
        backups.unshift(latestBackup);
    }
    return backups.map((backup) => ({
        ...backup,
        date: backup.date ? format$1(backup.date, "yyyy-MM-dd H:mm") : null
    }));
}
async function updateBackups(backups) {
    const byDay = backups.reduce((groups, backup) => {
        const day = format$1(backup.date, "yyyy-MM-dd");
        groups[day] = groups[day] || [];
        groups[day].push(backup);
        return groups;
    }, {});
    const removed = [];
    for (const day of Object.keys(byDay)) {
        const dayBackups = byDay[day];
        const isToday = day === currentDay();
        for (const backup of dayBackups.slice(isToday ? 3 : 1)) {
            removed.push(backup.id);
        }
    }
    const currentBackups = backups.filter((backup) => !removed.includes(backup.id));
    return removed.concat(currentBackups.slice(10).map((backup) => backup.id));
}
async function makeBackup$1(id2) {
    const budgetDir = getBudgetDir(id2);
    if (await exists(join$1(budgetDir, LATEST_BACKUP_FILENAME))) {
        await removeFile$1(join$1(getBudgetDir(id2), LATEST_BACKUP_FILENAME));
    }
    const backupId = `${v4()}.sqlite`;
    const backupPath = join$1(budgetDir, "backups", backupId);
    if (!await exists(join$1(budgetDir, "backups"))) {
        await mkdir(join$1(budgetDir, "backups"));
    }
    await copyFile(join$1(budgetDir, "db.sqlite"), backupPath);
    const db2 = openDatabase$1(backupPath);
    await runQuery$1(db2, "DELETE FROM messages_crdt");
    await runQuery$1(db2, "DELETE FROM messages_clock");
    closeDatabase$1(db2);
    const toRemove = await updateBackups(await getBackups$1(id2));
    for (const id22 of toRemove) {
        await removeFile$1(join$1(budgetDir, "backups", id22));
    }
    send$1("backups-updated", await getAvailableBackups(id2));
}
async function loadBackup$1(id2, backupId) {
    const budgetDir = getBudgetDir(id2);
    if (!await exists(join$1(budgetDir, LATEST_BACKUP_FILENAME))) {
        await copyFile(join$1(budgetDir, "db.sqlite"), join$1(budgetDir, LATEST_BACKUP_FILENAME));
        await copyFile(join$1(budgetDir, "metadata.json"), join$1(budgetDir, "metadata.latest.json"));
        stopBackupService();
        startBackupService(id2);
        await loadPrefs(id2);
    }
    if (backupId === LATEST_BACKUP_FILENAME) {
        logger.log("Reverting backup");
        await copyFile(join$1(budgetDir, LATEST_BACKUP_FILENAME), join$1(budgetDir, "db.sqlite"));
        await copyFile(join$1(budgetDir, "metadata.latest.json"), join$1(budgetDir, "metadata.json"));
        await removeFile$1(join$1(budgetDir, LATEST_BACKUP_FILENAME));
        await removeFile$1(join$1(budgetDir, "metadata.latest.json"));
        try {
            await upload();
        }
        catch (e) {
        }
        unloadPrefs();
    }
    else {
        logger.log("Loading backup", backupId);
        await loadPrefs(id2);
        await savePrefs({
            groupId: null,
            lastSyncedTimestamp: null,
            lastUploaded: null
        });
        try {
            await upload();
        }
        catch (e) {
        }
        unloadPrefs();
        await copyFile(join$1(budgetDir, "backups", backupId), join$1(budgetDir, "db.sqlite"));
    }
}
function startBackupService(id2) {
    if (serviceInterval) {
        clearInterval(serviceInterval);
    }
    serviceInterval = setInterval(async () => {
        logger.log("Making backup");
        await makeBackup$1(id2);
    }, 1e3 * 60 * 15);
}
function stopBackupService() {
    clearInterval(serviceInterval);
    serviceInterval = null;
}
const DEMO_BUDGET_ID = "_demo-budget";
const TEST_BUDGET_ID = "_test-budget";
const app$d = createApp();
app$d.method("validate-budget-name", handleValidateBudgetName);
app$d.method("unique-budget-name", handleUniqueBudgetName);
app$d.method("get-budgets", getBudgets);
app$d.method("get-remote-files", getRemoteFiles);
app$d.method("get-user-file-info", getUserFileInfo);
app$d.method("reset-budget-cache", mutator(resetBudgetCache));
app$d.method("upload-budget", uploadBudget);
app$d.method("download-budget", downloadBudget);
app$d.method("sync-budget", syncBudget);
app$d.method("load-budget", loadBudget);
app$d.method("create-demo-budget", createDemoBudget);
app$d.method("close-budget", closeBudget);
app$d.method("delete-budget", deleteBudget);
app$d.method("duplicate-budget", duplicateBudget);
app$d.method("create-budget", createBudget);
app$d.method("import-budget", importBudget);
app$d.method("export-budget", exportBudget);
app$d.method("upload-file-web", uploadFileWeb);
app$d.method("backups-get", getBackups);
app$d.method("backup-load", loadBackup);
app$d.method("backup-make", makeBackup);
app$d.method("get-last-opened-backup", getLastOpenedBackup);
async function handleValidateBudgetName({ name }) {
    return validateBudgetName(name);
}
async function handleUniqueBudgetName({ name }) {
    return uniqueBudgetName(name);
}
async function getBudgets() {
    const paths = await listDir(getDocumentDir());
    const budgets = await Promise.all(paths.map(async (name) => {
        const prefsPath = join$1(getDocumentDir(), name, "metadata.json");
        if (await exists(prefsPath)) {
            let prefs2;
            try {
                prefs2 = JSON.parse(await readFile(prefsPath));
            }
            catch (e) {
                logger.log("Error parsing metadata:", e.stack);
                return null;
            }
            if (name !== DEMO_BUDGET_ID) {
                return {
                    id: name,
                    ...prefs2.cloudFileId ? { cloudFileId: prefs2.cloudFileId } : {},
                    ...prefs2.encryptKeyId ? { encryptKeyId: prefs2.encryptKeyId } : {},
                    ...prefs2.groupId ? { groupId: prefs2.groupId } : {},
                    ...prefs2.owner ? { owner: prefs2.owner } : {},
                    name: prefs2.budgetName || "(no name)"
                };
            }
        }
        return null;
    }));
    return budgets.filter(Boolean);
}
async function getRemoteFiles() {
    return listRemoteFiles();
}
async function getUserFileInfo(fileId) {
    return getRemoteFile(fileId);
}
async function resetBudgetCache() {
    await loadUserBudgets(db$1);
    get$3().recomputeAll();
    await waitOnSpreadsheet();
}
async function uploadBudget({ id: id2 } = {}) {
    if (id2) {
        if (getPrefs()) {
            throw new Error("upload-budget: id given but prefs already loaded");
        }
        await loadPrefs(id2);
    }
    try {
        await upload();
    }
    catch (e) {
        logger.log(e);
        if (e.type === "FileUploadError") {
            return { error: e };
        }
        captureException(e);
        return { error: { reason: "internal" } };
    }
    finally {
        if (id2) {
            unloadPrefs();
        }
    }
    return {};
}
async function downloadBudget({ cloudFileId }) {
    let result;
    try {
        result = await download(cloudFileId);
    }
    catch (e) {
        if (e.type === "FileDownloadError") {
            if (e.reason === "file-exists" && e.meta.id) {
                await loadPrefs(e.meta.id);
                const name = getPrefs().budgetName;
                unloadPrefs();
                e.meta = { ...e.meta, name };
            }
            return { error: e };
        }
        else {
            captureException(e);
            return { error: { reason: "internal" } };
        }
    }
    const id2 = result.id;
    await closeBudget();
    await loadBudget({ id: id2 });
    result = await syncBudget();
    if (result.error) {
        return result;
    }
    return { id: id2 };
}
async function syncBudget() {
    setSyncingMode("enabled");
    const result = await initialFullSync();
    return result;
}
async function loadBudget({ id: id2 }) {
    const currentPrefs = getPrefs();
    if (currentPrefs) {
        if (currentPrefs.id === id2) {
            return {};
        }
        else {
            await closeBudget();
        }
    }
    const res = await _loadBudget(id2);
    return res;
}
async function createDemoBudget() {
    await setItem("readOnly", "");
    return createBudget({
        budgetName: "Demo Budget",
        testMode: true,
        testBudgetId: DEMO_BUDGET_ID
    });
}
async function closeBudget() {
    await waitOnSpreadsheet();
    unloadSpreadsheet();
    clearFullSyncTimeout();
    await app$j.stopServices();
    await closeDatabase();
    try {
        await setItem("lastBudget", "");
    }
    catch (e) {
    }
    unloadPrefs();
    await stopBackupService();
    return "ok";
}
async function deleteBudget({ id: id2, cloudFileId }) {
    if (cloudFileId) {
        await removeFile(cloudFileId).catch(() => {
        });
    }
    if (id2) {
        try {
            await openDatabase(id2);
            await closeDatabase();
            const budgetDir = getBudgetDir(id2);
            await removeDirRecursively(budgetDir);
        }
        catch (e) {
            return "fail";
        }
    }
    return "ok";
}
async function duplicateBudget({ id: id2, newName, cloudSync, open }) {
    const { valid, message: message2 } = await validateBudgetName(newName);
    if (!valid)
        throw new Error(message2);
    const budgetDir = getBudgetDir(id2);
    const newId = await idFromBudgetName(newName);
    const metadataText = await readFile(join$1(budgetDir, "metadata.json"));
    const metadata = JSON.parse(metadataText);
    metadata.id = newId;
    metadata.budgetName = newName;
    [
        "cloudFileId",
        "groupId",
        "lastUploaded",
        "encryptKeyId",
        "lastSyncedTimestamp"
    ].forEach((item) => {
        if (metadata[item])
            delete metadata[item];
    });
    try {
        const newBudgetDir = getBudgetDir(newId);
        await mkdir(newBudgetDir);
        await writeFile(join$1(newBudgetDir, "metadata.json"), JSON.stringify(metadata));
        await copyFile(join$1(budgetDir, "db.sqlite"), join$1(newBudgetDir, "db.sqlite"));
    }
    catch (error2) {
        try {
            const newBudgetDir = getBudgetDir(newId);
            if (await exists(newBudgetDir)) {
                await removeDirRecursively(newBudgetDir);
            }
        }
        catch {
        }
        throw new Error(`Failed to duplicate budget file: ${error2.message}`);
    }
    const { error } = await _loadBudget(newId);
    if (error) {
        logger.log("Error duplicating budget: " + error);
        return error;
    }
    if (cloudSync) {
        try {
            await upload();
        }
        catch (error2) {
            logger.warn("Failed to sync duplicated budget to cloud:", error2);
        }
    }
    await closeBudget();
    if (open === "original")
        await _loadBudget(id2);
    if (open === "copy")
        await _loadBudget(newId);
    return newId;
}
async function createBudget({ budgetName, avoidUpload, testMode, testBudgetId } = {}) {
    let id2;
    if (testMode) {
        budgetName = budgetName || "Test Budget";
        id2 = testBudgetId || TEST_BUDGET_ID;
        if (await exists(getBudgetDir(id2))) {
            await removeDirRecursively(getBudgetDir(id2));
        }
    }
    else {
        if (!budgetName) {
            budgetName = await uniqueBudgetName();
        }
        id2 = await idFromBudgetName(budgetName);
    }
    const budgetDir = getBudgetDir(id2);
    await mkdir(budgetDir);
    await copyFile(bundledDatabasePath, join$1(budgetDir, "db.sqlite"));
    await writeFile(join$1(budgetDir, "metadata.json"), JSON.stringify(getDefaultPrefs(id2, budgetName)));
    const { error } = await _loadBudget(id2);
    if (error) {
        logger.log("Error creating budget: " + error);
        return { error };
    }
    if (!avoidUpload && !testMode) {
        try {
            await upload();
        }
        catch (e) {
        }
    }
    if (testMode) {
        await createTestBudget(app$j.handlers);
    }
    return {};
}
async function importBudget({ filepath, type: type2 }) {
    try {
        if (!await exists(filepath)) {
            throw new Error(`File not found at the provided path: ${filepath}`);
        }
        const buffer = Buffer.from(await readFile(filepath, "binary"));
        const results = await handleBudgetImport(type2, filepath, buffer);
        return results || {};
    }
    catch (err) {
        err.message = "Error importing budget: " + err.message;
        captureException(err);
        return { error: "internal-error" };
    }
}
async function exportBudget() {
    try {
        return {
            data: await exportBuffer()
        };
    }
    catch (err) {
        err.message = "Error exporting budget: " + err.message;
        captureException(err);
        return { error: "internal-error" };
    }
}
function onSheetChange({ names }) {
    names.map((name) => {
        const node2 = get$3()._getNode(name);
        return { name: node2.name, value: node2.value };
    });
}
async function _loadBudget(id2) {
    let dir;
    try {
        dir = getBudgetDir(id2);
    }
    catch (e) {
        captureException(new Error("`getBudgetDir` failed in `loadBudget`: " + e.message));
        return { error: "budget-not-found" };
    }
    if (!await exists(dir)) {
        captureException(new Error("budget directory does not exist"));
        return { error: "budget-not-found" };
    }
    try {
        await loadPrefs(id2);
        await openDatabase(id2);
    }
    catch (e) {
        captureException(e);
        await closeBudget();
        return { error: "opening-budget" };
    }
    if (!getPrefs().userId) {
        const userId = await getItem("user-token");
        await savePrefs({ userId });
    }
    try {
        await updateVersion();
    }
    catch (e) {
        logger.warn("Error updating", e);
        let result;
        if (e.message.includes("out-of-sync-migrations")) {
            result = { error: "out-of-sync-migrations" };
        }
        else if (e.message.includes("out-of-sync-data")) {
            result = { error: "out-of-sync-data" };
        }
        else {
            captureException(e);
            logger.info("Error updating budget " + id2, e);
            logger.log("Error updating budget", e);
            result = { error: "loading-budget" };
        }
        await closeBudget();
        return result;
    }
    await loadClock();
    if (getPrefs().resetClock) {
        getClock().timestamp.setNode(makeClientId());
        await runQuery("INSERT OR REPLACE INTO messages_clock (id, clock) VALUES (1, ?)", [serializeClock(getClock())]);
        await savePrefs({ resetClock: false });
    }
    if (process.env.NODE_ENV !== "test") {
        await startBackupService(id2);
    }
    try {
        await loadSpreadsheet(db$1, onSheetChange);
    }
    catch (e) {
        captureException(e);
        await closeBudget();
        return { error: "opening-budget" };
    }
    const { value: budgetType = "envelope" } = await first("SELECT value from preferences WHERE id = ?", ["budgetType"]) ?? {};
    get$3().meta().budgetType = budgetType;
    await createAllBudgets();
    await loadMappings();
    await loadRules();
    await listen();
    await app$j.startServices();
    clearUndo();
    if (process.env.NODE_ENV !== "test") {
        if (id2 === DEMO_BUDGET_ID) {
            setSyncingMode("disabled");
        }
        else {
            if (getServer()) {
                setSyncingMode("enabled");
            }
            else {
                setSyncingMode("disabled");
            }
            await setItem("lastBudget", id2);
            await possiblyUpload();
        }
    }
    else {
        setSyncingMode("disabled");
    }
    app$d.events.emit("load-budget", { id: id2 });
    return {};
}
async function uploadFileWeb({ filename, contents }) {
    {
        return null;
    }
}
async function getBackups({ id: id2 }) {
    return getAvailableBackups(id2);
}
async function loadBackup({ id: id2, backupId }) {
    await loadBackup$1(id2, backupId);
}
async function makeBackup({ id: id2 }) {
    await makeBackup$1(id2);
}
async function getLastOpenedBackup() {
    const id2 = await getItem("lastBudget");
    if (id2 && id2 !== "") {
        const budgetDir = getBudgetDir(id2);
        if (await exists(budgetDir)) {
            return id2;
        }
    }
    return null;
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
    if (hasRequired_listCacheClear)
        return _listCacheClear;
    hasRequired_listCacheClear = 1;
    function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
    }
    _listCacheClear = listCacheClear;
    return _listCacheClear;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
    if (hasRequiredEq)
        return eq_1;
    hasRequiredEq = 1;
    function eq(value, other) {
        return value === other || value !== value && other !== other;
    }
    eq_1 = eq;
    return eq_1;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
    if (hasRequired_assocIndexOf)
        return _assocIndexOf;
    hasRequired_assocIndexOf = 1;
    var eq = requireEq();
    function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
            if (eq(array[length][0], key)) {
                return length;
            }
        }
        return -1;
    }
    _assocIndexOf = assocIndexOf;
    return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
    if (hasRequired_listCacheDelete)
        return _listCacheDelete;
    hasRequired_listCacheDelete = 1;
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
            data.pop();
        }
        else {
            splice.call(data, index, 1);
        }
        --this.size;
        return true;
    }
    _listCacheDelete = listCacheDelete;
    return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
    if (hasRequired_listCacheGet)
        return _listCacheGet;
    hasRequired_listCacheGet = 1;
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
    }
    _listCacheGet = listCacheGet;
    return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
    if (hasRequired_listCacheHas)
        return _listCacheHas;
    hasRequired_listCacheHas = 1;
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }
    _listCacheHas = listCacheHas;
    return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
    if (hasRequired_listCacheSet)
        return _listCacheSet;
    hasRequired_listCacheSet = 1;
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            ++this.size;
            data.push([key, value]);
        }
        else {
            data[index][1] = value;
        }
        return this;
    }
    _listCacheSet = listCacheSet;
    return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
    if (hasRequired_ListCache)
        return _ListCache;
    hasRequired_ListCache = 1;
    var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
    function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    _ListCache = ListCache;
    return _ListCache;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
    if (hasRequired_stackClear)
        return _stackClear;
    hasRequired_stackClear = 1;
    var ListCache = require_ListCache();
    function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
    }
    _stackClear = stackClear;
    return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
    if (hasRequired_stackDelete)
        return _stackDelete;
    hasRequired_stackDelete = 1;
    function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
    }
    _stackDelete = stackDelete;
    return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
    if (hasRequired_stackGet)
        return _stackGet;
    hasRequired_stackGet = 1;
    function stackGet(key) {
        return this.__data__.get(key);
    }
    _stackGet = stackGet;
    return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
    if (hasRequired_stackHas)
        return _stackHas;
    hasRequired_stackHas = 1;
    function stackHas(key) {
        return this.__data__.has(key);
    }
    _stackHas = stackHas;
    return _stackHas;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
    if (hasRequired_freeGlobal)
        return _freeGlobal;
    hasRequired_freeGlobal = 1;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    _freeGlobal = freeGlobal;
    return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
    if (hasRequired_root)
        return _root;
    hasRequired_root = 1;
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    _root = root;
    return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
    if (hasRequired_Symbol)
        return _Symbol;
    hasRequired_Symbol = 1;
    var root = require_root();
    var Symbol2 = root.Symbol;
    _Symbol = Symbol2;
    return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
    if (hasRequired_getRawTag)
        return _getRawTag;
    hasRequired_getRawTag = 1;
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
            value[symToStringTag] = void 0;
            var unmasked = true;
        }
        catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
            if (isOwn) {
                value[symToStringTag] = tag;
            }
            else {
                delete value[symToStringTag];
            }
        }
        return result;
    }
    _getRawTag = getRawTag;
    return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
    if (hasRequired_objectToString)
        return _objectToString;
    hasRequired_objectToString = 1;
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
        return nativeObjectToString.call(value);
    }
    _objectToString = objectToString;
    return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
    if (hasRequired_baseGetTag)
        return _baseGetTag;
    hasRequired_baseGetTag = 1;
    var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
        if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    _baseGetTag = baseGetTag;
    return _baseGetTag;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
    if (hasRequiredIsObject)
        return isObject_1;
    hasRequiredIsObject = 1;
    function isObject(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
    }
    isObject_1 = isObject;
    return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
    if (hasRequiredIsFunction)
        return isFunction_1;
    hasRequiredIsFunction = 1;
    var baseGetTag = require_baseGetTag(), isObject = requireIsObject();
    var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
        if (!isObject(value)) {
            return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    isFunction_1 = isFunction;
    return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
    if (hasRequired_coreJsData)
        return _coreJsData;
    hasRequired_coreJsData = 1;
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    _coreJsData = coreJsData;
    return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
    if (hasRequired_isMasked)
        return _isMasked;
    hasRequired_isMasked = 1;
    var coreJsData = require_coreJsData();
    var maskSrcKey = function () {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
    }
    _isMasked = isMasked;
    return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
    if (hasRequired_toSource)
        return _toSource;
    hasRequired_toSource = 1;
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
        if (func != null) {
            try {
                return funcToString.call(func);
            }
            catch (e) {
            }
            try {
                return func + "";
            }
            catch (e) {
            }
        }
        return "";
    }
    _toSource = toSource;
    return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
    if (hasRequired_baseIsNative)
        return _baseIsNative;
    hasRequired_baseIsNative = 1;
    var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
            return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
    }
    _baseIsNative = baseIsNative;
    return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
    if (hasRequired_getValue)
        return _getValue;
    hasRequired_getValue = 1;
    function getValue(object, key) {
        return object == null ? void 0 : object[key];
    }
    _getValue = getValue;
    return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
    if (hasRequired_getNative)
        return _getNative;
    hasRequired_getNative = 1;
    var baseIsNative = require_baseIsNative(), getValue = require_getValue();
    function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
    }
    _getNative = getNative;
    return _getNative;
}
var _Map;
var hasRequired_Map;
function require_Map() {
    if (hasRequired_Map)
        return _Map;
    hasRequired_Map = 1;
    var getNative = require_getNative(), root = require_root();
    var Map2 = getNative(root, "Map");
    _Map = Map2;
    return _Map;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
    if (hasRequired_nativeCreate)
        return _nativeCreate;
    hasRequired_nativeCreate = 1;
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    _nativeCreate = nativeCreate;
    return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
    if (hasRequired_hashClear)
        return _hashClear;
    hasRequired_hashClear = 1;
    var nativeCreate = require_nativeCreate();
    function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
    }
    _hashClear = hashClear;
    return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
    if (hasRequired_hashDelete)
        return _hashDelete;
    hasRequired_hashDelete = 1;
    function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
    }
    _hashDelete = hashDelete;
    return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
    if (hasRequired_hashGet)
        return _hashGet;
    hasRequired_hashGet = 1;
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    _hashGet = hashGet;
    return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
    if (hasRequired_hashHas)
        return _hashHas;
    hasRequired_hashHas = 1;
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    _hashHas = hashHas;
    return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
    if (hasRequired_hashSet)
        return _hashSet;
    hasRequired_hashSet = 1;
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
    }
    _hashSet = hashSet;
    return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
    if (hasRequired_Hash)
        return _Hash;
    hasRequired_Hash = 1;
    var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
    function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    _Hash = Hash;
    return _Hash;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
    if (hasRequired_mapCacheClear)
        return _mapCacheClear;
    hasRequired_mapCacheClear = 1;
    var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
    function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
        };
    }
    _mapCacheClear = mapCacheClear;
    return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
    if (hasRequired_isKeyable)
        return _isKeyable;
    hasRequired_isKeyable = 1;
    function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    _isKeyable = isKeyable;
    return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
    if (hasRequired_getMapData)
        return _getMapData;
    hasRequired_getMapData = 1;
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    _getMapData = getMapData;
    return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
    if (hasRequired_mapCacheDelete)
        return _mapCacheDelete;
    hasRequired_mapCacheDelete = 1;
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
    }
    _mapCacheDelete = mapCacheDelete;
    return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
    if (hasRequired_mapCacheGet)
        return _mapCacheGet;
    hasRequired_mapCacheGet = 1;
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
        return getMapData(this, key).get(key);
    }
    _mapCacheGet = mapCacheGet;
    return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
    if (hasRequired_mapCacheHas)
        return _mapCacheHas;
    hasRequired_mapCacheHas = 1;
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
        return getMapData(this, key).has(key);
    }
    _mapCacheHas = mapCacheHas;
    return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
    if (hasRequired_mapCacheSet)
        return _mapCacheSet;
    hasRequired_mapCacheSet = 1;
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
    }
    _mapCacheSet = mapCacheSet;
    return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
    if (hasRequired_MapCache)
        return _MapCache;
    hasRequired_MapCache = 1;
    var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    _MapCache = MapCache;
    return _MapCache;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
    if (hasRequired_stackSet)
        return _stackSet;
    hasRequired_stackSet = 1;
    var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
            }
            data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
    }
    _stackSet = stackSet;
    return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
    if (hasRequired_Stack)
        return _Stack;
    hasRequired_Stack = 1;
    var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
    function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
    }
    Stack2.prototype.clear = stackClear;
    Stack2.prototype["delete"] = stackDelete;
    Stack2.prototype.get = stackGet;
    Stack2.prototype.has = stackHas;
    Stack2.prototype.set = stackSet;
    _Stack = Stack2;
    return _Stack;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
    if (hasRequired_setCacheAdd)
        return _setCacheAdd;
    hasRequired_setCacheAdd = 1;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
    }
    _setCacheAdd = setCacheAdd;
    return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
    if (hasRequired_setCacheHas)
        return _setCacheHas;
    hasRequired_setCacheHas = 1;
    function setCacheHas(value) {
        return this.__data__.has(value);
    }
    _setCacheHas = setCacheHas;
    return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
    if (hasRequired_SetCache)
        return _SetCache;
    hasRequired_SetCache = 1;
    var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
    function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
            this.add(values[index]);
        }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    _SetCache = SetCache;
    return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
    if (hasRequired_arraySome)
        return _arraySome;
    hasRequired_arraySome = 1;
    function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }
    _arraySome = arraySome;
    return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
    if (hasRequired_cacheHas)
        return _cacheHas;
    hasRequired_cacheHas = 1;
    function cacheHas(cache2, key) {
        return cache2.has(key);
    }
    _cacheHas = cacheHas;
    return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
    if (hasRequired_equalArrays)
        return _equalArrays;
    hasRequired_equalArrays = 1;
    var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== void 0) {
                if (compared) {
                    continue;
                }
                result = false;
                break;
            }
            if (seen) {
                if (!arraySome(other, function (othValue2, othIndex) {
                    if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                    }
                })) {
                    result = false;
                    break;
                }
            }
            else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
            }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
    }
    _equalArrays = equalArrays;
    return _equalArrays;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
    if (hasRequired_Uint8Array)
        return _Uint8Array;
    hasRequired_Uint8Array = 1;
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    _Uint8Array = Uint8Array2;
    return _Uint8Array;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
    if (hasRequired_mapToArray)
        return _mapToArray;
    hasRequired_mapToArray = 1;
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function (value, key) {
            result[++index] = [key, value];
        });
        return result;
    }
    _mapToArray = mapToArray;
    return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
    if (hasRequired_setToArray)
        return _setToArray;
    hasRequired_setToArray = 1;
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }
    _setToArray = setToArray;
    return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
    if (hasRequired_equalByTag)
        return _equalByTag;
    hasRequired_equalByTag = 1;
    var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
            case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                    return false;
                }
                object = object.buffer;
                other = other.buffer;
            case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                    return false;
                }
                return true;
            case boolTag:
            case dateTag:
            case numberTag:
                return eq(+object, +other);
            case errorTag:
                return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
                return object == other + "";
            case mapTag:
                var convert = mapToArray;
            case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                    return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                    return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result;
            case symbolTag:
                if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
        }
        return false;
    }
    _equalByTag = equalByTag;
    return _equalByTag;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
    if (hasRequired_arrayPush)
        return _arrayPush;
    hasRequired_arrayPush = 1;
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }
    _arrayPush = arrayPush;
    return _arrayPush;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
    if (hasRequiredIsArray)
        return isArray_1;
    hasRequiredIsArray = 1;
    var isArray = Array.isArray;
    isArray_1 = isArray;
    return isArray_1;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
    if (hasRequired_baseGetAllKeys)
        return _baseGetAllKeys;
    hasRequired_baseGetAllKeys = 1;
    var arrayPush = require_arrayPush(), isArray = requireIsArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    _baseGetAllKeys = baseGetAllKeys;
    return _baseGetAllKeys;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
    if (hasRequired_arrayFilter)
        return _arrayFilter;
    hasRequired_arrayFilter = 1;
    function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }
    _arrayFilter = arrayFilter;
    return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
    if (hasRequiredStubArray)
        return stubArray_1;
    hasRequiredStubArray = 1;
    function stubArray() {
        return [];
    }
    stubArray_1 = stubArray;
    return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
    if (hasRequired_getSymbols)
        return _getSymbols;
    hasRequired_getSymbols = 1;
    var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
        if (object == null) {
            return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
            return propertyIsEnumerable.call(object, symbol);
        });
    };
    _getSymbols = getSymbols;
    return _getSymbols;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
    if (hasRequired_baseTimes)
        return _baseTimes;
    hasRequired_baseTimes = 1;
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }
    _baseTimes = baseTimes;
    return _baseTimes;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
    if (hasRequiredIsObjectLike)
        return isObjectLike_1;
    hasRequiredIsObjectLike = 1;
    function isObjectLike(value) {
        return value != null && typeof value == "object";
    }
    isObjectLike_1 = isObjectLike;
    return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
    if (hasRequired_baseIsArguments)
        return _baseIsArguments;
    hasRequired_baseIsArguments = 1;
    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    _baseIsArguments = baseIsArguments;
    return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
    if (hasRequiredIsArguments)
        return isArguments_1;
    hasRequiredIsArguments = 1;
    var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments2 = baseIsArguments(/* @__PURE__ */ function () {
        return arguments;
    }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    isArguments_1 = isArguments2;
    return isArguments_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
    if (hasRequiredStubFalse)
        return stubFalse_1;
    hasRequiredStubFalse = 1;
    function stubFalse() {
        return false;
    }
    stubFalse_1 = stubFalse;
    return stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
    if (hasRequiredIsBuffer)
        return isBuffer.exports;
    hasRequiredIsBuffer = 1;
    (function (module2, exports2) {
        var root = require_root(), stubFalse = requireStubFalse();
        var freeExports = exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer2 = moduleExports ? root.Buffer : void 0;
        var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
        var isBuffer2 = nativeIsBuffer || stubFalse;
        module2.exports = isBuffer2;
    })(isBuffer, isBuffer.exports);
    return isBuffer.exports;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
    if (hasRequired_isIndex)
        return _isIndex;
    hasRequired_isIndex = 1;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    _isIndex = isIndex;
    return _isIndex;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
    if (hasRequiredIsLength)
        return isLength_1;
    hasRequiredIsLength = 1;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    isLength_1 = isLength;
    return isLength_1;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
    if (hasRequired_baseIsTypedArray)
        return _baseIsTypedArray;
    hasRequired_baseIsTypedArray = 1;
    var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    _baseIsTypedArray = baseIsTypedArray;
    return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
    if (hasRequired_baseUnary)
        return _baseUnary;
    hasRequired_baseUnary = 1;
    function baseUnary(func) {
        return function (value) {
            return func(value);
        };
    }
    _baseUnary = baseUnary;
    return _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
    if (hasRequired_nodeUtil)
        return _nodeUtil.exports;
    hasRequired_nodeUtil = 1;
    (function (module2, exports2) {
        var freeGlobal = require_freeGlobal();
        var freeExports = exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function () {
            try {
                var types = freeModule && freeModule.require && freeModule.require("util").types;
                if (types) {
                    return types;
                }
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
            }
            catch (e) {
            }
        }();
        module2.exports = nodeUtil;
    })(_nodeUtil, _nodeUtil.exports);
    return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
        return isTypedArray_1;
    hasRequiredIsTypedArray = 1;
    var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    isTypedArray_1 = isTypedArray;
    return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
    if (hasRequired_arrayLikeKeys)
        return _arrayLikeKeys;
    hasRequired_arrayLikeKeys = 1;
    var baseTimes = require_baseTimes(), isArguments2 = requireIsArguments(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                    isIndex(key, length)))) {
                result.push(key);
            }
        }
        return result;
    }
    _arrayLikeKeys = arrayLikeKeys;
    return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
    if (hasRequired_isPrototype)
        return _isPrototype;
    hasRequired_isPrototype = 1;
    var objectProto = Object.prototype;
    function isPrototype(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto2;
    }
    _isPrototype = isPrototype;
    return _isPrototype;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
    if (hasRequired_overArg)
        return _overArg;
    hasRequired_overArg = 1;
    function overArg(func, transform2) {
        return function (arg) {
            return func(transform2(arg));
        };
    }
    _overArg = overArg;
    return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
    if (hasRequired_nativeKeys)
        return _nativeKeys;
    hasRequired_nativeKeys = 1;
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    _nativeKeys = nativeKeys;
    return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
    if (hasRequired_baseKeys)
        return _baseKeys;
    hasRequired_baseKeys = 1;
    var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
        if (!isPrototype(object)) {
            return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
                result.push(key);
            }
        }
        return result;
    }
    _baseKeys = baseKeys;
    return _baseKeys;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
    if (hasRequiredIsArrayLike)
        return isArrayLike_1;
    hasRequiredIsArrayLike = 1;
    var isFunction = requireIsFunction(), isLength = requireIsLength();
    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }
    isArrayLike_1 = isArrayLike;
    return isArrayLike_1;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
    if (hasRequiredKeys)
        return keys_1;
    hasRequiredKeys = 1;
    var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
    function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    keys_1 = keys2;
    return keys_1;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
    if (hasRequired_getAllKeys)
        return _getAllKeys;
    hasRequired_getAllKeys = 1;
    var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys2 = requireKeys();
    function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
    }
    _getAllKeys = getAllKeys;
    return _getAllKeys;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
    if (hasRequired_equalObjects)
        return _equalObjects;
    hasRequired_equalObjects = 1;
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
            return false;
        }
        var index = objLength;
        while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
            }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
            }
            skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result = false;
            }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
    }
    _equalObjects = equalObjects;
    return _equalObjects;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
    if (hasRequired_DataView)
        return _DataView;
    hasRequired_DataView = 1;
    var getNative = require_getNative(), root = require_root();
    var DataView2 = getNative(root, "DataView");
    _DataView = DataView2;
    return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
    if (hasRequired_Promise)
        return _Promise;
    hasRequired_Promise = 1;
    var getNative = require_getNative(), root = require_root();
    var Promise2 = getNative(root, "Promise");
    _Promise = Promise2;
    return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
    if (hasRequired_Set)
        return _Set;
    hasRequired_Set = 1;
    var getNative = require_getNative(), root = require_root();
    var Set2 = getNative(root, "Set");
    _Set = Set2;
    return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
    if (hasRequired_WeakMap)
        return _WeakMap;
    hasRequired_WeakMap = 1;
    var getNative = require_getNative(), root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    _WeakMap = WeakMap2;
    return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
    if (hasRequired_getTag)
        return _getTag;
    hasRequired_getTag = 1;
    var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
    var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var getTag2 = baseGetTag;
    if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = function (value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
                switch (ctorString) {
                    case dataViewCtorString:
                        return dataViewTag;
                    case mapCtorString:
                        return mapTag;
                    case promiseCtorString:
                        return promiseTag;
                    case setCtorString:
                        return setTag;
                    case weakMapCtorString:
                        return weakMapTag;
                }
            }
            return result;
        };
    }
    _getTag = getTag2;
    return _getTag;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
    if (hasRequired_baseIsEqualDeep)
        return _baseIsEqualDeep;
    hasRequired_baseIsEqualDeep = 1;
    var Stack2 = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag2 = require_getTag(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray = requireIsTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
                return false;
            }
            objIsArr = true;
            objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
        }
        if (!isSameTag) {
            return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    _baseIsEqualDeep = baseIsEqualDeep;
    return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
    if (hasRequired_baseIsEqual)
        return _baseIsEqual;
    hasRequired_baseIsEqual = 1;
    var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
            return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    _baseIsEqual = baseIsEqual;
    return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
    if (hasRequired_baseIsMatch)
        return _baseIsMatch;
    hasRequired_baseIsMatch = 1;
    var Stack2 = require_Stack(), baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
            return !length;
        }
        object = Object(object);
        while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
            }
        }
        while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
                if (objValue === void 0 && !(key in object)) {
                    return false;
                }
            }
            else {
                var stack = new Stack2();
                if (customizer) {
                    var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                    return false;
                }
            }
        }
        return true;
    }
    _baseIsMatch = baseIsMatch;
    return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
    if (hasRequired_isStrictComparable)
        return _isStrictComparable;
    hasRequired_isStrictComparable = 1;
    var isObject = requireIsObject();
    function isStrictComparable(value) {
        return value === value && !isObject(value);
    }
    _isStrictComparable = isStrictComparable;
    return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
    if (hasRequired_getMatchData)
        return _getMatchData;
    hasRequired_getMatchData = 1;
    var isStrictComparable = require_isStrictComparable(), keys2 = requireKeys();
    function getMatchData(object) {
        var result = keys2(object), length = result.length;
        while (length--) {
            var key = result[length], value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
    }
    _getMatchData = getMatchData;
    return _getMatchData;
}
var isMatch_1;
var hasRequiredIsMatch;
function requireIsMatch() {
    if (hasRequiredIsMatch)
        return isMatch_1;
    hasRequiredIsMatch = 1;
    var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData();
    function isMatch2(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
    }
    isMatch_1 = isMatch2;
    return isMatch_1;
}
var isMatchExports = requireIsMatch();
const isMatch = /* @__PURE__ */ getDefaultExportFromCjs(isMatchExports);
const DEFAULT_DASHBOARD_STATE = [
    {
        type: "net-worth-card",
        width: 8,
        height: 2,
        x: 0,
        y: 0,
        meta: null
    },
    {
        type: "cash-flow-card",
        width: 4,
        height: 2,
        x: 8,
        y: 0,
        meta: null
    },
    {
        type: "spending-card",
        width: 4,
        height: 2,
        x: 0,
        y: 2,
        meta: null
    }
];
const reportModel = {
    validate(report, { update: update2 } = {}) {
        requiredFields("Report", report, ["conditionsOp"], update2);
        if (!update2 || "conditionsOp" in report) {
            if (!["and", "or"].includes(report.conditionsOp)) {
                throw new ValidationError("Invalid filter conditionsOp: " + report.conditionsOp);
            }
        }
        return report;
    },
    toJS(row) {
        return {
            id: row.id,
            name: row.name,
            startDate: row.start_date,
            endDate: row.end_date,
            isDateStatic: row.date_static === 1,
            dateRange: row.date_range,
            mode: row.mode,
            groupBy: row.group_by,
            sortBy: row.sort_by,
            interval: row.interval,
            balanceType: row.balance_type,
            showEmpty: row.show_empty === 1,
            showOffBudget: row.show_offbudget === 1,
            showHiddenCategories: row.show_hidden === 1,
            showUncategorized: row.show_uncategorized === 1,
            includeCurrentInterval: row.include_current === 1,
            graphType: row.graph_type,
            conditions: row.conditions,
            conditionsOp: row.conditions_op
        };
    },
    fromJS(report) {
        return {
            id: report.id,
            name: report.name,
            start_date: report.startDate,
            end_date: report.endDate,
            date_static: report.isDateStatic ? 1 : 0,
            date_range: report.dateRange,
            mode: report.mode,
            group_by: report.groupBy,
            sort_by: report.sortBy,
            interval: report.interval,
            balance_type: report.balanceType,
            show_empty: report.showEmpty ? 1 : 0,
            show_offbudget: report.showOffBudget ? 1 : 0,
            show_hidden: report.showHiddenCategories ? 1 : 0,
            show_uncategorized: report.showUncategorized ? 1 : 0,
            include_current: report.includeCurrentInterval ? 1 : 0,
            graph_type: report.graphType,
            conditions: report.conditions,
            conditions_op: report.conditionsOp
        };
    }
};
async function reportNameExists(name, reportId, newItem) {
    const idForName = await first("SELECT id from custom_reports WHERE tombstone = 0 AND name = ?", [name]);
    if (idForName === null) {
        return false;
    }
    if (!newItem) {
        return idForName.id !== reportId;
    }
    return true;
}
async function createReport(report) {
    const reportId = v4();
    const item = {
        ...report,
        id: reportId
    };
    if (!item.name) {
        throw new Error("Report name is required");
    }
    const nameExists = await reportNameExists(item.name, item.id ?? "", true);
    if (nameExists) {
        throw new Error("There is already a report named " + item.name);
    }
    await insertWithSchema("custom_reports", reportModel.fromJS(item));
    return reportId;
}
async function updateReport(item) {
    if (!item.name) {
        throw new Error("Report name is required");
    }
    if (!item.id) {
        throw new Error("Report recall error");
    }
    const nameExists = await reportNameExists(item.name, item.id, false);
    if (nameExists) {
        throw new Error("There is already a report named " + item.name);
    }
    await updateWithSchema("custom_reports", reportModel.fromJS(item));
}
async function deleteReport(id2) {
    await delete_("custom_reports", id2);
}
const app$c = createApp();
app$c.method("report/create", mutator(undoable(createReport)));
app$c.method("report/update", mutator(undoable(updateReport)));
app$c.method("report/delete", mutator(undoable(deleteReport)));
function isExportedCustomReportWidget(widget) {
    return widget.type === "custom-report";
}
const exportModel = {
    validate(dashboard) {
        requiredFields("Dashboard", dashboard, ["version", "widgets"]);
        if (!Array.isArray(dashboard.widgets)) {
            throw new ValidationError("Invalid dashboard.widgets data type: it must be an array of widgets.");
        }
        dashboard.widgets.forEach((widget, idx) => {
            requiredFields(`Dashboard widget #${idx}`, widget, [
                "type",
                "x",
                "y",
                "width",
                "height",
                ...isExportedCustomReportWidget(widget) ? ["meta"] : []
            ]);
            if (!Number.isInteger(widget.x)) {
                throw new ValidationError(`Invalid widget.${idx}.x data-type for value ${widget.x}.`);
            }
            if (!Number.isInteger(widget.y)) {
                throw new ValidationError(`Invalid widget.${idx}.y data-type for value ${widget.y}.`);
            }
            if (!Number.isInteger(widget.width)) {
                throw new ValidationError(`Invalid widget.${idx}.width data-type for value ${widget.width}.`);
            }
            if (!Number.isInteger(widget.height)) {
                throw new ValidationError(`Invalid widget.${idx}.height data-type for value ${widget.height}.`);
            }
            if (![
                "net-worth-card",
                "cash-flow-card",
                "spending-card",
                "custom-report",
                "markdown-card",
                "summary-card",
                "calendar-card"
            ].includes(widget.type)) {
                throw new ValidationError(`Invalid widget.${idx}.type value ${widget.type}.`);
            }
            if (isExportedCustomReportWidget(widget)) {
                reportModel.validate(widget.meta);
            }
        });
    }
};
async function updateDashboard(widgets) {
    const { data: dbWidgets } = await aqlQuery(q("dashboard").filter({ id: { $oneof: widgets.map(({ id: id2 }) => id2) } }).select("*"));
    const dbWidgetMap = new Map(dbWidgets.map((widget) => [widget.id, widget]));
    await Promise.all(widgets.filter((widget) => !isMatch(dbWidgetMap.get(widget.id) ?? {}, widget)).map((widget) => update("dashboard", widget)));
}
async function updateDashboardWidget(widget) {
    await updateWithSchema("dashboard", widget);
}
async function resetDashboard() {
    await batchMessages(async () => {
        await Promise.all([
            // Delete all widgets
            deleteAll("dashboard"),
            // Insert the default state
            ...DEFAULT_DASHBOARD_STATE.map((widget) => insertWithSchema("dashboard", widget))
        ]);
    });
}
async function addDashboardWidget(widget) {
    if (!("x" in widget) && !("y" in widget)) {
        const data = await first("SELECT x, y, width, height FROM dashboard WHERE tombstone = 0 ORDER BY y DESC, x DESC");
        if (!data) {
            widget.x = 0;
            widget.y = 0;
        }
        else {
            const xBoundaryCheck = data.x + data.width + widget.width;
            widget.x = xBoundaryCheck > 12 ? 0 : data.x + data.width;
            widget.y = data.y + (xBoundaryCheck > 12 ? data.height : 0);
        }
    }
    await insertWithSchema("dashboard", widget);
}
async function removeDashboardWidget(widgetId) {
    await delete_("dashboard", widgetId);
}
async function importDashboard({ filepath }) {
    try {
        if (!await exists(filepath)) {
            throw new Error(`File not found at the provided path: ${filepath}`);
        }
        const content = await readFile(filepath);
        const parsedContent = JSON.parse(content);
        exportModel.validate(parsedContent);
        const customReportIds = await all("SELECT id from custom_reports");
        const customReportIdSet = new Set(customReportIds.map(({ id: id2 }) => id2));
        await batchMessages(async () => {
            await Promise.all([
                // Delete all widgets
                deleteAll("dashboard"),
                // Insert new widgets
                ...parsedContent.widgets.map((widget) => insertWithSchema("dashboard", {
                    type: widget.type,
                    width: widget.width,
                    height: widget.height,
                    x: widget.x,
                    y: widget.y,
                    meta: isExportedCustomReportWidget(widget) ? { id: widget.meta.id } : widget.meta
                })),
                // Insert new custom reports
                ...parsedContent.widgets.filter(isExportedCustomReportWidget).filter(({ meta }) => !customReportIdSet.has(meta.id)).map(({ meta }) => insertWithSchema("custom_reports", reportModel.fromJS(meta))),
                // Update existing reports
                ...parsedContent.widgets.filter(isExportedCustomReportWidget).filter(({ meta }) => customReportIdSet.has(meta.id)).map(({ meta }) => updateWithSchema("custom_reports", {
                    // Replace `undefined` values with `null`
                    // (null clears the value in DB; undefined breaks the operation)
                    ...Object.fromEntries(Object.entries(reportModel.fromJS(meta)).map(([key, value]) => [
                        key,
                        value ?? null
                    ])),
                    tombstone: false
                }))
            ]);
        });
        return { status: "ok" };
    }
    catch (err) {
        if (err instanceof Error) {
            err.message = "Error importing file: " + err.message;
            captureException(err);
        }
        if (err instanceof SyntaxError) {
            return { error: "json-parse-error" };
        }
        if (err instanceof ValidationError) {
            return { error: "validation-error", message: err.message };
        }
        return { error: "internal-error" };
    }
}
const app$b = createApp();
app$b.method("dashboard-update", mutator(undoable(updateDashboard)));
app$b.method("dashboard-update-widget", mutator(undoable(updateDashboardWidget)));
app$b.method("dashboard-reset", mutator(undoable(resetDashboard)));
app$b.method("dashboard-add-widget", mutator(undoable(addDashboardWidget)));
app$b.method("dashboard-remove-widget", mutator(undoable(removeDashboardWidget)));
app$b.method("dashboard-import", mutator(undoable(importDashboard)));
const app$a = createApp();
app$a.method("key-make", keyMake);
app$a.method("key-test", keyTest);
async function keyMake({ password }) {
    if (!getPrefs()) {
        throw new Error("key-make must be called with file loaded");
    }
    const salt = randomBytes(32).toString("base64");
    const id2 = v4();
    const key = await createKey({ id: id2, password, salt });
    await loadKey(key);
    const testContent = await makeTestMessage(key.getId());
    return await resetSync$1({
        key,
        salt,
        testContent: JSON.stringify({
            ...testContent,
            value: testContent.value.toString("base64")
        })
    });
}
async function keyTest({ cloudFileId, password }) {
    const userToken = await getItem("user-token");
    if (cloudFileId == null) {
        cloudFileId = getPrefs().cloudFileId;
    }
    let validCloudFileId;
    let res;
    try {
        const serverConfig = getServer();
        if (!serverConfig) {
            throw new Error("No sync server configured.");
        }
        res = await post(serverConfig.SYNC_SERVER + "/user-get-key", {
            token: userToken,
            fileId: cloudFileId
        });
        validCloudFileId = cloudFileId;
    }
    catch (e) {
        logger.log(e);
        return { error: { reason: "network" } };
    }
    const { id: id2, salt, test: originalTest } = res;
    if (!originalTest) {
        return { error: { reason: "old-key-style" } };
    }
    const test = JSON.parse(originalTest);
    const key = await createKey({ id: id2, password, salt });
    loadKey(key);
    try {
        await decrypt(Buffer.from(test.value, "base64"), test.meta);
    }
    catch (e) {
        logger.log(e);
        unloadKey(key);
        return { error: { reason: "decrypt-failure" } };
    }
    const keys2 = JSON.parse(await getItem(`encrypt-keys`) || "{}");
    keys2[validCloudFileId] = key.serialize();
    await setItem("encrypt-keys", JSON.stringify(keys2));
    if (getPrefs()) {
        await savePrefs({ encryptKeyId: key.getId() });
    }
    return {};
}
const filterModel = {
    validate(filter, { update: update2 } = {}) {
        requiredFields("transaction_filters", filter, ["conditions"], update2);
        if (!update2 || "conditionsOp" in filter) {
            if (!["and", "or"].includes(filter.conditionsOp)) {
                throw new Error("Invalid filter conditionsOp: " + filter.conditionsOp);
            }
        }
        return filter;
    },
    toJS(row) {
        const { conditions, conditions_op, ...fields } = row;
        return {
            ...fields,
            conditionsOp: conditions_op,
            conditions: parseConditionsOrActions(conditions)
        };
    },
    fromJS(filter) {
        const { conditionsOp, ...row } = filter;
        if (conditionsOp) {
            row.conditions_op = conditionsOp;
        }
        return row;
    }
};
async function filterNameExists(name, filterId, newItem) {
    const idForName = await first("SELECT id from transaction_filters WHERE tombstone = 0 AND name = ?", [name]);
    if (idForName === null) {
        return false;
    }
    if (!newItem) {
        return idForName.id !== filterId;
    }
    return true;
}
function conditionExists(item, filters, newItem) {
    const { conditions, conditionsOp } = item;
    let fConditionFound = null;
    filters.some((filter) => {
        if ((conditions.length === 1 || filter.conditionsOp === conditionsOp) && !filter.tombstone && filter.conditions.length === conditions.length) {
            const allConditionsMatch = !conditions.some((cond) => !filter.conditions.some((fcond) => cond.value === fcond.value && cond.op === fcond.op && cond.field === fcond.field && filterOptionsMatch(cond.options, fcond.options)));
            if (allConditionsMatch) {
                fConditionFound = filter;
                return true;
            }
        }
        return false;
    });
    if (!newItem) {
        return fConditionFound ? fConditionFound.id !== item.id ? fConditionFound.name : false : false;
    }
    return fConditionFound ? fConditionFound.name : false;
}
function filterOptionsMatch(options1, options2) {
    const opt1 = options1 ?? {};
    const opt2 = options2 ?? {};
    const keys1 = Object.keys(opt1);
    const keys2 = Object.keys(opt2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    return keys1.every((key) => opt1[key] === opt2[key]);
}
async function createFilter(filter) {
    const filterId = v4();
    const item = {
        id: filterId,
        conditions: filter.state.conditions,
        conditionsOp: filter.state.conditionsOp,
        name: filter.state.name
    };
    if (item.name) {
        if (await filterNameExists(item.name, item.id, true)) {
            throw new Error("There is already a filter named " + item.name);
        }
    }
    else {
        throw new Error("Filter name is required");
    }
    if (item.conditions.length > 0) {
        const condExists = conditionExists(item, filter.filters, true);
        if (condExists) {
            throw new Error("Duplicate filter warning: conditions already exist. Filter name: " + condExists);
        }
    }
    else {
        throw new Error("Conditions are required");
    }
    await insertWithSchema("transaction_filters", filterModel.fromJS(item));
    return filterId;
}
async function updateFilter(filter) {
    const item = {
        id: filter.state.id,
        conditions: filter.state.conditions,
        conditionsOp: filter.state.conditionsOp,
        name: filter.state.name
    };
    if (item.name) {
        if (await filterNameExists(item.name, item.id, false)) {
            throw new Error("There is already a filter named " + item.name);
        }
    }
    else {
        throw new Error("Filter name is required");
    }
    if (item.conditions.length > 0) {
        const condExists = conditionExists(item, filter.filters, false);
        if (condExists) {
            throw new Error("Duplicate filter warning: conditions already exist. Filter name: " + condExists);
        }
    }
    else {
        throw new Error("Conditions are required");
    }
    await updateWithSchema("transaction_filters", filterModel.fromJS(item));
}
async function deleteFilter(id2) {
    await delete_("transaction_filters", id2);
}
const app$9 = createApp();
app$9.method("filter-create", mutator(createFilter));
app$9.method("filter-update", mutator(updateFilter));
app$9.method("filter-delete", mutator(undoable(deleteFilter)));
const app$8 = createApp();
app$8.method("notes-save", updateNotes);
app$8.method("notes-save-undoable", mutator(undoable(updateNotes)));
async function updateNotes({ id: id2, note }) {
    await update("notes", { id: id2, note });
}
const app$7 = createApp();
app$7.method("payee-create", mutator(undoable(createPayee)));
app$7.method("common-payees-get", getCommonPayees);
app$7.method("payees-get", getPayees);
app$7.method("payees-get-orphaned", getOrphanedPayees);
app$7.method("payees-get-rule-counts", getPayeeRuleCounts);
app$7.method("payees-merge", mutator(undoable(mergePayees, (args) => ({
    mergeIds: args.mergeIds,
    targetId: args.targetId
}))));
app$7.method("payees-batch-change", mutator(undoable(batchChangePayees)));
app$7.method("payees-check-orphaned", checkOrphanedPayees);
app$7.method("payees-get-rules", getPayeeRules);
async function createPayee({ name }) {
    return insertPayee({ name });
}
async function getCommonPayees() {
    return (await getCommonPayees$1()).map(payeeModel$1.fromDb);
}
async function getPayees() {
    return (await getPayees$2()).map(payeeModel$1.fromDb);
}
async function getOrphanedPayees() {
    return await syncGetOrphanedPayees();
}
async function getPayeeRuleCounts() {
    const payeeCounts = {};
    iterateIds(getRules$1(), "payee", (rule, id2) => {
        if (payeeCounts[id2] == null) {
            payeeCounts[id2] = 0;
        }
        payeeCounts[id2]++;
    });
    return payeeCounts;
}
async function mergePayees({ targetId, mergeIds }) {
    await mergePayees$1(targetId, mergeIds);
}
async function batchChangePayees({ added, deleted, updated }) {
    await batchMessages(async () => {
        if (deleted) {
            await Promise.all(deleted.map((p) => ({ id: p.id })).map((p) => deletePayee(p)));
        }
        if (added) {
            await Promise.all(added.map((p) => payeeModel$1.toDb(p)).map((p) => insertPayee(p)));
        }
        if (updated) {
            await Promise.all(updated.map((p) => payeeModel$1.toDb(p, { update: true })).map((p) => updatePayee(p)));
        }
    });
}
async function checkOrphanedPayees({ ids }) {
    const orphaned = new Set(await getOrphanedPayees$1());
    return ids.filter((id2) => orphaned.has(id2));
}
async function getPayeeRules({ id: id2 }) {
    return getRulesForPayee(id2).map((rule) => rule.serialize());
}
const app$6 = createApp();
app$6.method("preferences/save", mutator(undoable(saveSyncedPrefs)));
app$6.method("preferences/get", getSyncedPrefs);
app$6.method("save-global-prefs", saveGlobalPrefs);
app$6.method("load-global-prefs", loadGlobalPrefs);
app$6.method("save-prefs", saveMetadataPrefs);
app$6.method("load-prefs", loadMetadataPrefs);
async function saveSyncedPrefs({ id: id2, value }) {
    if (!id2) {
        return;
    }
    await update("preferences", { id: id2, value });
}
async function getSyncedPrefs() {
    const prefs2 = await all("SELECT id, value FROM preferences");
    return prefs2.reduce((carry, { value, id: id2 }) => {
        carry[id2] = value;
        return carry;
    }, {});
}
async function saveGlobalPrefs(prefs2) {
    if (!prefs2) {
        return "ok";
    }
    if (prefs2.maxMonths !== void 0) {
        await setItem("max-months", "" + prefs2.maxMonths);
    }
    if (prefs2.categoryExpandedState !== void 0) {
        await setItem("category-expanded-state", "" + prefs2.categoryExpandedState);
    }
    if (prefs2.documentDir !== void 0 && await exists(prefs2.documentDir)) {
        await setItem("document-dir", prefs2.documentDir);
    }
    if (prefs2.floatingSidebar !== void 0) {
        await setItem("floating-sidebar", "" + prefs2.floatingSidebar);
    }
    if (prefs2.language !== void 0) {
        await setItem("language", prefs2.language);
    }
    if (prefs2.theme !== void 0) {
        await setItem("theme", prefs2.theme);
    }
    if (prefs2.preferredDarkTheme !== void 0) {
        await setItem("preferred-dark-theme", prefs2.preferredDarkTheme);
    }
    if (prefs2.serverSelfSignedCert !== void 0) {
        await setItem("server-self-signed-cert", prefs2.serverSelfSignedCert);
    }
    if (prefs2.syncServerConfig !== void 0) {
        await setItem("syncServerConfig", prefs2.syncServerConfig);
    }
    if (prefs2.notifyWhenUpdateIsAvailable !== void 0) {
        await setItem("notifyWhenUpdateIsAvailable", prefs2.notifyWhenUpdateIsAvailable);
    }
    return "ok";
}
async function loadGlobalPrefs() {
    const { "floating-sidebar": floatingSidebar, "category-expanded-state": categoryExpandedState, "max-months": maxMonths, "document-dir": documentDir2, "encrypt-key": encryptKey, language, theme, "preferred-dark-theme": preferredDarkTheme, "server-self-signed-cert": serverSelfSignedCert, syncServerConfig, notifyWhenUpdateIsAvailable } = await multiGet([
        "floating-sidebar",
        "category-expanded-state",
        "max-months",
        "document-dir",
        "encrypt-key",
        "language",
        "theme",
        "preferred-dark-theme",
        "server-self-signed-cert",
        "syncServerConfig",
        "notifyWhenUpdateIsAvailable"
    ]);
    return {
        floatingSidebar: floatingSidebar === "true",
        categoryExpandedState: stringToInteger(categoryExpandedState || "") || 0,
        maxMonths: stringToInteger(maxMonths || "") || 1,
        documentDir: documentDir2 || getDefaultDocumentDir(),
        keyId: encryptKey && JSON.parse(encryptKey).id,
        language,
        theme: theme === "light" || theme === "dark" || theme === "auto" || theme === "development" || theme === "midnight" ? theme : "auto",
        preferredDarkTheme: preferredDarkTheme === "dark" || preferredDarkTheme === "midnight" ? preferredDarkTheme : "dark",
        serverSelfSignedCert: serverSelfSignedCert || void 0,
        syncServerConfig: syncServerConfig || void 0,
        notifyWhenUpdateIsAvailable: notifyWhenUpdateIsAvailable === void 0 ? true : notifyWhenUpdateIsAvailable
        // default to true
    };
}
async function saveMetadataPrefs(prefsToSet) {
    if (!prefsToSet) {
        return "ok";
    }
    const { cloudFileId } = getPrefs();
    if (prefsToSet.budgetName && cloudFileId) {
        const userToken = await getItem("user-token");
        const syncServer = getServer()?.SYNC_SERVER;
        if (!syncServer) {
            throw new Error("No sync server set");
        }
        await post(syncServer + "/update-user-filename", {
            token: userToken,
            fileId: cloudFileId,
            name: prefsToSet.budgetName
        });
    }
    await savePrefs(prefsToSet);
    return "ok";
}
async function loadMetadataPrefs() {
    return getPrefs();
}
function validateRule(rule) {
    function runValidation(array, validate) {
        const result = array.map((item) => {
            try {
                validate(item);
            }
            catch (e) {
                if (e instanceof RuleError) {
                    logger.warn("Invalid rule", e);
                    return e.type;
                }
                throw e;
            }
            return null;
        });
        return result.filter((res) => typeof res === "string").length ? result : null;
    }
    const conditionErrors = runValidation(rule.conditions, (cond) => new Condition(cond.op, cond.field, cond.value, cond.options));
    const actionErrors = runValidation(rule.actions, (action) => action.op === "set-split-amount" ? new Action(action.op, null, action.value, action.options) : action.op === "link-schedule" ? new Action(action.op, null, action.value, null) : action.op === "prepend-notes" || action.op === "append-notes" ? new Action(action.op, null, action.value, null) : new Action(action.op, action.field, action.value, action.options));
    if (conditionErrors || actionErrors) {
        return {
            conditionErrors,
            actionErrors
        };
    }
    return null;
}
const app$5 = createApp();
app$5.method("rule-validate", ruleValidate);
app$5.method("rule-add", mutator(addRule));
app$5.method("rule-update", mutator(updateRule));
app$5.method("rule-delete", mutator(deleteRule));
app$5.method("rule-delete-all", mutator(deleteAllRules));
app$5.method("rule-apply-actions", mutator(undoable(applyRuleActions)));
app$5.method("rule-add-payee-rename", mutator(addRulePayeeRename));
app$5.method("rules-get", getRules);
app$5.method("rule-get", getRule);
app$5.method("rules-run", runRules);
async function ruleValidate(rule) {
    const error = validateRule(rule);
    return { error };
}
async function addRule(rule) {
    const error = validateRule(rule);
    if (error) {
        return { error };
    }
    const id2 = await insertRule(rule);
    return { id: id2, ...rule };
}
async function updateRule(rule) {
    const error = validateRule(rule);
    if (error) {
        return { error };
    }
    await updateRule$1(rule);
    return rule;
}
async function deleteRule(id2) {
    return deleteRule$1(id2);
}
async function deleteAllRules(ids) {
    let someDeletionsFailed = false;
    await batchMessages(async () => {
        for (const id2 of ids) {
            const res = await deleteRule$1(id2);
            if (res === false) {
                someDeletionsFailed = true;
            }
        }
    });
    return { someDeletionsFailed };
}
async function applyRuleActions({ transactions, actions }) {
    return applyActions(transactions, actions);
}
async function addRulePayeeRename({ fromNames, to }) {
    return updatePayeeRenameRule(fromNames, to);
}
async function getRule({ id: id2 }) {
    const rule = getRules$1().find((rule2) => rule2.id === id2);
    return rule ? rule.serialize() : null;
}
async function getRules() {
    return rankRules(getRules$1()).map((rule) => rule.serialize());
}
async function runRules({ transaction: transaction2 }) {
    return runRules$1(transaction2);
}
const app$4 = createApp();
app$4.method("get-cell", getCell);
app$4.method("get-cell-names", getCellNames);
app$4.method("create-query", createQuery);
async function getCell({ sheetName, name }) {
    const node2 = get$3()._getNode(resolveName(sheetName, name));
    return { name: node2.name, value: node2.value };
}
async function getCellNames({ sheetName }) {
    const names = [];
    for (const name of get$3().getNodes().keys()) {
        const { sheet: nodeSheet, name: nodeName } = unresolveName(name);
        if (nodeSheet === sheetName) {
            names.push(nodeName);
        }
    }
    return names;
}
async function createQuery({ sheetName, name, query }) {
    get$3().createQuery(sheetName, name, query);
    return "ok";
}
const app$3 = createApp();
app$3.method("sync", sync);
app$3.method("sync-reset", resetSync);
app$3.method("sync-repair", repairSync);
async function sync() {
    return await fullSync();
}
async function resetSync() {
    return await resetSync$1();
}
async function repairSync() {
    await repairSync$1();
}
const app$2 = createApp();
app$2.method("tags-get", getTags);
app$2.method("tags-create", mutator(undoable(createTag)));
app$2.method("tags-delete", mutator(undoable(deleteTag)));
app$2.method("tags-delete-all", mutator(deleteAllTags));
app$2.method("tags-update", mutator(undoable(updateTag)));
app$2.method("tags-find", mutator(findTags));
async function getTags() {
    return await getTags$1();
}
async function createTag({ tag, color = null, description = null }) {
    const allTags = await getAllTags();
    const { id: tagId = null } = allTags.find((t2) => t2.tag === tag) || {};
    if (tagId) {
        await updateTag$1({
            id: tagId,
            tag,
            color,
            description,
            tombstone: 0
        });
        return { id: tagId, tag, color, description };
    }
    const id2 = await insertTag({
        tag: tag.trim(),
        color: color ? color.trim() : null,
        description
    });
    return { id: id2, tag, color, description };
}
async function deleteTag(tag) {
    await deleteTag$1(tag);
    return tag.id;
}
async function deleteAllTags(ids) {
    await batchMessages(async () => {
        for (const id2 of ids) {
            await deleteTag$1({ id: id2 });
        }
    });
    return ids;
}
async function updateTag(tag) {
    await updateTag$1(tag);
    return tag;
}
async function findTags() {
    const taggedNotes = await findTags$1();
    const tags = await getTags();
    for (const { notes } of taggedNotes) {
        for (const [_, tag] of notes.matchAll(/(?<!#)#([^#\s]+)/g)) {
            if (!tags.find((t2) => t2.tag === tag)) {
                tags.push(await createTag({ tag }));
            }
        }
    }
    return tags.sort(function (a, b) {
        if (a.tag < b.tag) {
            return -1;
        }
        if (a.tag > b.tag) {
            return 1;
        }
        return 0;
    });
}
const app$1 = createApp();
app$1.method("tools/fix-split-transactions", fixSplitTransactions);
async function fixSplitTransactions() {
    const blankPayeeRows = await all(`
    SELECT t.*, p.payee AS parentPayee FROM v_transactions_internal t
    LEFT JOIN v_transactions_internal p ON t.parent_id = p.id
    WHERE t.is_child = 1 AND t.payee IS NULL AND p.payee IS NOT NULL
  `);
    await runMutator(async () => {
        const updated = blankPayeeRows.map((row) => ({
            id: row.id,
            payee: row.parentPayee
        }));
        await batchUpdateTransactions({ updated });
    });
    const clearedRows = await all(`
    SELECT t.id, p.cleared FROM v_transactions_internal t
    LEFT JOIN v_transactions_internal p ON t.parent_id = p.id
    WHERE t.is_child = 1 AND t.cleared != p.cleared
  `);
    await runMutator(async () => {
        const updated = clearedRows.map((row) => ({
            id: row.id,
            cleared: row.cleared === 1
        }));
        await batchUpdateTransactions({ updated });
    });
    const deletedRows = await all(`
    SELECT t.* FROM v_transactions_internal t
    LEFT JOIN v_transactions_internal p ON t.parent_id = p.id
    WHERE t.is_child = 1 AND t.tombstone = 0 AND (p.tombstone = 1 OR p.id IS NULL)
  `);
    await runMutator(async () => {
        const updated = deletedRows.map((row) => ({ id: row.id, tombstone: true }));
        await batchUpdateTransactions({ updated });
    });
    const splitTransactions = (await aqlQuery(q("transactions").options({ splits: "grouped" }).filter({
        is_parent: true
    }).select("*"))).data;
    const mismatchedSplits = splitTransactions.filter((t2) => {
        const subValue = t2.subtransactions.reduce((acc, st) => acc + st.amount, 0);
        return subValue !== t2.amount;
    });
    const brokenTransfers = await all(`
    SELECT t1.id
    FROM v_transactions_internal t1
           JOIN accounts a1 ON t1.account = a1.id
           JOIN v_transactions_internal t2 ON t1.transfer_id = t2.id
           JOIN accounts a2 ON t2.account = a2.id
    WHERE a1.offbudget = a2.offbudget
      AND t1.category IS NOT NULL
  `);
    await runMutator(async () => {
        const updated = brokenTransfers.map((row) => ({
            id: row.id,
            category: null
        }));
        await batchUpdateTransactions({ updated });
    });
    const errorRows = await all(`
    SELECT id FROM v_transactions_internal WHERE error IS NOT NULL AND is_parent = 0
  `);
    await runMutator(async () => {
        const updated = errorRows.map(({ id: id2 }) => ({ id: id2, error: null }));
        await batchUpdateTransactions({ updated });
    });
    const parentTransactionsWithCategory = await all(`
    SELECT id FROM transactions WHERE isParent = 1 AND category IS NOT NULL
  `);
    await runMutator(async () => {
        const updated = parentTransactionsWithCategory.map(({ id: id2 }) => ({
            id: id2,
            category: null
        }));
        await batchUpdateTransactions({ updated });
    });
    return {
        numBlankPayees: blankPayeeRows.length,
        numCleared: clearedRows.length,
        numDeleted: deletedRows.length,
        numTransfersFixed: brokenTransfers.length,
        numNonParentErrorsFixed: errorRows.length,
        numParentTransactionsWithCategoryFixed: parentTransactionsWithCategory.length,
        mismatchedSplits
    };
}
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
// Match anything that isn't a dot or bracket.
`[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`, "g");
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const getTag = function (value) {
    return Object.prototype.toString.call(value);
};
const isSymbol = function (value) {
    const type2 = typeof value;
    return type2 === "symbol" || type2 === "object" && value && getTag(value) === "[object Symbol]";
};
const isKey = function (value, object) {
    if (Array.isArray(value)) {
        return false;
    }
    const type2 = typeof value;
    if (type2 === "number" || type2 === "symbol" || type2 === "boolean" || !value || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = function (string) {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("");
    }
    string.replace(rePropName, function (match2, expression, quote, subString) {
        let key = match2;
        if (quote) {
            key = subString.replace(reEscapeChar, "$1");
        }
        else if (expression) {
            key = expression.trim();
        }
        result.push(key);
    });
    return result;
};
const castPath = function (value, object) {
    if (Array.isArray(value)) {
        return value;
    }
    else {
        return isKey(value, object) ? [value] : stringToPath(value);
    }
};
const toKey = function (value) {
    if (typeof value === "string" || isSymbol(value))
        return value;
    const result = `${value}`;
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
const get = function (object, path2) {
    path2 = castPath(path2, object);
    let index = 0;
    const length = path2.length;
    while (object != null && index < length) {
        object = object[toKey(path2[index++])];
    }
    return index && index === length ? object : void 0;
};
const is_object$1 = function (obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
const normalize_columns = function (columns) {
    if (columns === void 0 || columns === null) {
        return [void 0, void 0];
    }
    if (typeof columns !== "object") {
        return [Error('Invalid option "columns": expect an array or an object')];
    }
    if (!Array.isArray(columns)) {
        const newcolumns = [];
        for (const k in columns) {
            newcolumns.push({
                key: k,
                header: columns[k]
            });
        }
        columns = newcolumns;
    }
    else {
        const newcolumns = [];
        for (const column of columns) {
            if (typeof column === "string") {
                newcolumns.push({
                    key: column,
                    header: column
                });
            }
            else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
                if (!column.key) {
                    return [
                        Error('Invalid column definition: property "key" is required')
                    ];
                }
                if (column.header === void 0) {
                    column.header = column.key;
                }
                newcolumns.push(column);
            }
            else {
                return [
                    Error("Invalid column definition: expect a string or an object")
                ];
            }
        }
        columns = newcolumns;
    }
    return [void 0, columns];
};
let CsvError$1 = class CsvError extends Error {
    constructor(code, message2, ...contexts) {
        if (Array.isArray(message2))
            message2 = message2.join(" ");
        super(message2);
        if (Error.captureStackTrace !== void 0) {
            Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts) {
            for (const key in context) {
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
};
const underscore$1 = function (str) {
    return str.replace(/([A-Z])/g, function (_, match2) {
        return "_" + match2.toLowerCase();
    });
};
const normalize_options$1 = function (opts) {
    const options2 = {};
    for (const opt in opts) {
        options2[underscore$1(opt)] = opts[opt];
    }
    if (options2.bom === void 0 || options2.bom === null || options2.bom === false) {
        options2.bom = false;
    }
    else if (options2.bom !== true) {
        return [
            new CsvError$1("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
                "option `bom` is optional and must be a boolean value,",
                `got ${JSON.stringify(options2.bom)}`
            ])
        ];
    }
    if (options2.delimiter === void 0 || options2.delimiter === null) {
        options2.delimiter = ",";
    }
    else if (Buffer.isBuffer(options2.delimiter)) {
        options2.delimiter = options2.delimiter.toString();
    }
    else if (typeof options2.delimiter !== "string") {
        return [
            new CsvError$1("CSV_OPTION_DELIMITER_INVALID_TYPE", [
                "option `delimiter` must be a buffer or a string,",
                `got ${JSON.stringify(options2.delimiter)}`
            ])
        ];
    }
    if (options2.quote === void 0 || options2.quote === null) {
        options2.quote = '"';
    }
    else if (options2.quote === true) {
        options2.quote = '"';
    }
    else if (options2.quote === false) {
        options2.quote = "";
    }
    else if (Buffer.isBuffer(options2.quote)) {
        options2.quote = options2.quote.toString();
    }
    else if (typeof options2.quote !== "string") {
        return [
            new CsvError$1("CSV_OPTION_QUOTE_INVALID_TYPE", [
                "option `quote` must be a boolean, a buffer or a string,",
                `got ${JSON.stringify(options2.quote)}`
            ])
        ];
    }
    if (options2.quoted === void 0 || options2.quoted === null) {
        options2.quoted = false;
    }
    if (options2.escape_formulas === void 0 || options2.escape_formulas === null) {
        options2.escape_formulas = false;
    }
    else if (typeof options2.escape_formulas !== "boolean") {
        return [
            new CsvError$1("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
                "option `escape_formulas` must be a boolean,",
                `got ${JSON.stringify(options2.escape_formulas)}`
            ])
        ];
    }
    if (options2.quoted_empty === void 0 || options2.quoted_empty === null) {
        options2.quoted_empty = void 0;
    }
    if (options2.quoted_match === void 0 || options2.quoted_match === null || options2.quoted_match === false) {
        options2.quoted_match = null;
    }
    else if (!Array.isArray(options2.quoted_match)) {
        options2.quoted_match = [options2.quoted_match];
    }
    if (options2.quoted_match) {
        for (const quoted_match of options2.quoted_match) {
            const isString2 = typeof quoted_match === "string";
            const isRegExp = quoted_match instanceof RegExp;
            if (!isString2 && !isRegExp) {
                return [
                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)
                ];
            }
        }
    }
    if (options2.quoted_string === void 0 || options2.quoted_string === null) {
        options2.quoted_string = false;
    }
    if (options2.eof === void 0 || options2.eof === null) {
        options2.eof = true;
    }
    if (options2.escape === void 0 || options2.escape === null) {
        options2.escape = '"';
    }
    else if (Buffer.isBuffer(options2.escape)) {
        options2.escape = options2.escape.toString();
    }
    else if (typeof options2.escape !== "string") {
        return [
            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options2.escape)}`)
        ];
    }
    if (options2.escape.length > 1) {
        return [
            Error(`Invalid Option: escape must be one character, got ${options2.escape.length} characters`)
        ];
    }
    if (options2.header === void 0 || options2.header === null) {
        options2.header = false;
    }
    const [errColumns, columns] = normalize_columns(options2.columns);
    if (errColumns !== void 0)
        return [errColumns];
    options2.columns = columns;
    if (options2.quoted === void 0 || options2.quoted === null) {
        options2.quoted = false;
    }
    if (options2.cast === void 0 || options2.cast === null) {
        options2.cast = {};
    }
    if (options2.cast.bigint === void 0 || options2.cast.bigint === null) {
        options2.cast.bigint = (value) => "" + value;
    }
    if (options2.cast.boolean === void 0 || options2.cast.boolean === null) {
        options2.cast.boolean = (value) => value ? "1" : "";
    }
    if (options2.cast.date === void 0 || options2.cast.date === null) {
        options2.cast.date = (value) => "" + value.getTime();
    }
    if (options2.cast.number === void 0 || options2.cast.number === null) {
        options2.cast.number = (value) => "" + value;
    }
    if (options2.cast.object === void 0 || options2.cast.object === null) {
        options2.cast.object = (value) => JSON.stringify(value);
    }
    if (options2.cast.string === void 0 || options2.cast.string === null) {
        options2.cast.string = function (value) {
            return value;
        };
    }
    if (options2.on_record !== void 0 && typeof options2.on_record !== "function") {
        return [Error(`Invalid Option: "on_record" must be a function.`)];
    }
    if (options2.record_delimiter === void 0 || options2.record_delimiter === null) {
        options2.record_delimiter = "\n";
    }
    else if (Buffer.isBuffer(options2.record_delimiter)) {
        options2.record_delimiter = options2.record_delimiter.toString();
    }
    else if (typeof options2.record_delimiter !== "string") {
        return [
            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options2.record_delimiter)}`)
        ];
    }
    switch (options2.record_delimiter) {
        case "unix":
            options2.record_delimiter = "\n";
            break;
        case "mac":
            options2.record_delimiter = "\r";
            break;
        case "windows":
            options2.record_delimiter = "\r\n";
            break;
        case "ascii":
            options2.record_delimiter = "";
            break;
        case "unicode":
            options2.record_delimiter = "\u2028";
            break;
    }
    return [void 0, options2];
};
const bom_utf8 = Buffer.from([239, 187, 191]);
const stringifier = function (options2, state, info) {
    return {
        options: options2,
        state,
        info,
        __transform: function (chunk, push) {
            if (!Array.isArray(chunk) && typeof chunk !== "object") {
                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
            }
            if (this.info.records === 0) {
                if (Array.isArray(chunk)) {
                    if (this.options.header === true && this.options.columns === void 0) {
                        return Error("Undiscoverable Columns: header option requires column option or object records");
                    }
                }
                else if (this.options.columns === void 0) {
                    const [err2, columns] = normalize_columns(Object.keys(chunk));
                    if (err2)
                        return;
                    this.options.columns = columns;
                }
            }
            if (this.info.records === 0) {
                this.bom(push);
                const err2 = this.headers(push);
                if (err2)
                    return err2;
            }
            try {
                if (this.options.on_record) {
                    this.options.on_record(chunk, this.info.records);
                }
            }
            catch (err2) {
                return err2;
            }
            let err, chunk_string;
            if (this.options.eof) {
                [err, chunk_string] = this.stringify(chunk);
                if (err)
                    return err;
                if (chunk_string === void 0) {
                    return;
                }
                else {
                    chunk_string = chunk_string + this.options.record_delimiter;
                }
            }
            else {
                [err, chunk_string] = this.stringify(chunk);
                if (err)
                    return err;
                if (chunk_string === void 0) {
                    return;
                }
                else {
                    if (this.options.header || this.info.records) {
                        chunk_string = this.options.record_delimiter + chunk_string;
                    }
                }
            }
            this.info.records++;
            push(chunk_string);
        },
        stringify: function (chunk, chunkIsHeader = false) {
            if (typeof chunk !== "object") {
                return [void 0, chunk];
            }
            const { columns } = this.options;
            const record = [];
            if (Array.isArray(chunk)) {
                if (columns) {
                    chunk.splice(columns.length);
                }
                for (let i = 0; i < chunk.length; i++) {
                    const field = chunk[i];
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: i,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err)
                        return [err];
                    record[i] = [value, field];
                }
            }
            else {
                for (let i = 0; i < columns.length; i++) {
                    const field = get(chunk, columns[i].key);
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: columns[i].key,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err)
                        return [err];
                    record[i] = [value, field];
                }
            }
            let csvrecord = "";
            for (let i = 0; i < record.length; i++) {
                let options3, err;
                let [value, field] = record[i];
                if (typeof value === "string") {
                    options3 = this.options;
                }
                else if (is_object$1(value)) {
                    options3 = value;
                    value = options3.value;
                    delete options3.value;
                    if (typeof value !== "string" && value !== void 0 && value !== null) {
                        if (err)
                            return [
                                Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)
                            ];
                    }
                    options3 = { ...this.options, ...options3 };
                    [err, options3] = normalize_options$1(options3);
                    if (err !== void 0) {
                        return [err];
                    }
                }
                else if (value === void 0 || value === null) {
                    options3 = this.options;
                }
                else {
                    return [
                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)
                    ];
                }
                const { delimiter, escape: escape2, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options3;
                if ("" === value && "" === field) {
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
                        if (typeof quoted_match2 === "string") {
                            return value.indexOf(quoted_match2) !== -1;
                        }
                        else {
                            return quoted_match2.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                }
                else if (value) {
                    if (typeof value !== "string") {
                        return [
                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
                    const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
                    const containsEscape = value.indexOf(escape2) >= 0 && escape2 !== quote;
                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
                    const quotedString = quoted_string && typeof field === "string";
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
                        if (typeof quoted_match2 === "string") {
                            return value.indexOf(quoted_match2) !== -1;
                        }
                        else {
                            return quoted_match2.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    if (escape_formulas) {
                        switch (value[0]) {
                            case "=":
                            case "+":
                            case "-":
                            case "@":
                            case "	":
                            case "\r":
                            case "":
                            // Unicode '='
                            case "":
                            // Unicode '+'
                            case "":
                            // Unicode '-'
                            case "":
                                value = `'${value}`;
                                break;
                        }
                    }
                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
                    if (shouldQuote === true && containsEscape === true) {
                        const regexp2 = escape2 === "\\" ? new RegExp(escape2 + escape2, "g") : new RegExp(escape2, "g");
                        value = value.replace(regexp2, escape2 + escape2);
                    }
                    if (containsQuote === true) {
                        const regexp2 = new RegExp(quote, "g");
                        value = value.replace(regexp2, escape2 + quote);
                    }
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                }
                else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
                    csvrecord += quote + quote;
                }
                if (i !== record.length - 1) {
                    csvrecord += delimiter;
                }
            }
            return [void 0, csvrecord];
        },
        bom: function (push) {
            if (this.options.bom !== true) {
                return;
            }
            push(bom_utf8);
        },
        headers: function (push) {
            if (this.options.header === false) {
                return;
            }
            if (this.options.columns === void 0) {
                return;
            }
            let err;
            let headers2 = this.options.columns.map((column) => column.header);
            if (this.options.eof) {
                [err, headers2] = this.stringify(headers2, true);
                headers2 += this.options.record_delimiter;
            }
            else {
                [err, headers2] = this.stringify(headers2);
            }
            if (err)
                return err;
            push(headers2);
        },
        __cast: function (value, context) {
            const type2 = typeof value;
            try {
                if (type2 === "string") {
                    return [void 0, this.options.cast.string(value, context)];
                }
                else if (type2 === "bigint") {
                    return [void 0, this.options.cast.bigint(value, context)];
                }
                else if (type2 === "number") {
                    return [void 0, this.options.cast.number(value, context)];
                }
                else if (type2 === "boolean") {
                    return [void 0, this.options.cast.boolean(value, context)];
                }
                else if (value instanceof Date) {
                    return [void 0, this.options.cast.date(value, context)];
                }
                else if (type2 === "object" && value !== null) {
                    return [void 0, this.options.cast.object(value, context)];
                }
                else {
                    return [void 0, value, value];
                }
            }
            catch (err) {
                return [err];
            }
        }
    };
};
const stringify = function (records, opts = {}) {
    const data = [];
    const [err, options2] = normalize_options$1(opts);
    if (err !== void 0)
        throw err;
    const state = {
        stop: false
    };
    const info = {
        records: 0
    };
    const api = stringifier(options2, state, info);
    for (const record of records) {
        const err2 = api.__transform(record, function (record2) {
            data.push(record2);
        });
        if (err2 !== void 0)
            throw err2;
    }
    if (data.length === 0) {
        api.bom((d) => {
            data.push(d);
        });
        const err2 = api.headers((headers2) => {
            data.push(headers2);
        });
        if (err2 !== void 0)
            throw err2;
    }
    return data.join("");
};
async function exportToCSV(transactions, accounts, categoryGroups, payees) {
    const accountNamesById = accounts.reduce((reduced, { id: id2, name }) => {
        reduced[id2] = name;
        return reduced;
    }, {});
    const categoryNamesById = categoryGroups.reduce((reduced, { name, categories: subCategories }) => {
        subCategories.forEach((subCategory) => reduced[subCategory.id] = `${name}: ${subCategory.name}`);
        return reduced;
    }, {});
    const payeeNamesById = payees.reduce((reduced, { id: id2, name }) => {
        reduced[id2] = name;
        return reduced;
    }, {});
    const transactionsForExport = transactions.map(({ account, date, payee, notes, category, amount, cleared, reconciled }) => ({
        Account: accountNamesById[account],
        Date: date,
        Payee: payeeNamesById[payee],
        Notes: notes,
        Category: categoryNamesById[category],
        Amount: amount == null ? 0 : integerToAmount(amount),
        Cleared: cleared,
        Reconciled: reconciled
    }));
    return stringify(transactionsForExport, { header: true });
}
async function exportQueryToCSV(query) {
    const { data: transactions } = await aqlQuery(query.select([
        { Id: "id" },
        { Account: "account.name" },
        { Date: "date" },
        { Payee: "payee.name" },
        { ParentId: "parent_id" },
        { IsParent: "is_parent" },
        { IsChild: "is_child" },
        { SortOrder: "sort_order" },
        { Notes: "notes" },
        { Category: "category.name" },
        { Amount: "amount" },
        { Cleared: "cleared" },
        { Reconciled: "reconciled" }
    ]).options({ splits: "all" }));
    const parentsChildCount = /* @__PURE__ */ new Map();
    const childSplitOrder = /* @__PURE__ */ new Map();
    for (const trans of transactions) {
        if (trans.IsChild) {
            let childNumber = parentsChildCount.get(trans.ParentId) || 0;
            childNumber++;
            childSplitOrder.set(trans.Id, childNumber);
            parentsChildCount.set(trans.ParentId, childNumber);
        }
    }
    const transactionsForExport = transactions.map((trans) => {
        return {
            Account: trans.Account,
            Date: trans.Date,
            Payee: trans.Payee,
            Notes: trans.IsParent ? "(SPLIT INTO " + parentsChildCount.get(trans.Id) + ") " + (trans.Notes || "") : trans.IsChild ? "(SPLIT " + childSplitOrder.get(trans.Id) + " OF " + parentsChildCount.get(trans.ParentId) + ") " + (trans.Notes || "") : trans.Notes,
            Category: trans.Category,
            Amount: trans.IsParent ? 0 : trans.Amount == null ? 0 : integerToAmount(trans.Amount),
            Split_Amount: trans.IsParent ? integerToAmount(trans.Amount) : 0,
            Cleared: trans.Reconciled === true ? "Reconciled" : trans.Cleared === true ? "Cleared" : "Not cleared"
        };
    });
    return stringify(transactionsForExport, { header: true });
}
class CsvError2 extends Error {
    constructor(code, message2, options2, ...contexts) {
        if (Array.isArray(message2))
            message2 = message2.join(" ").trim();
        super(message2);
        if (Error.captureStackTrace !== void 0) {
            Error.captureStackTrace(this, CsvError2);
        }
        this.code = code;
        for (const context of contexts) {
            for (const key in context) {
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString(options2.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
}
const is_object = function (obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
const normalize_columns_array = function (columns) {
    const normalizedColumns = [];
    for (let i = 0, l = columns.length; i < l; i++) {
        const column = columns[i];
        if (column === void 0 || column === null || column === false) {
            normalizedColumns[i] = { disabled: true };
        }
        else if (typeof column === "string") {
            normalizedColumns[i] = { name: column };
        }
        else if (is_object(column)) {
            if (typeof column.name !== "string") {
                throw new CsvError2("CSV_OPTION_COLUMNS_MISSING_NAME", [
                    "Option columns missing name:",
                    `property "name" is required at position ${i}`,
                    "when column is an object literal"
                ]);
            }
            normalizedColumns[i] = column;
        }
        else {
            throw new CsvError2("CSV_INVALID_COLUMN_DEFINITION", [
                "Invalid column definition:",
                "expect a string or a literal object,",
                `got ${JSON.stringify(column)} at position ${i}`
            ]);
        }
    }
    return normalizedColumns;
};
class ResizeableBuffer {
    constructor(size2 = 100) {
        this.size = size2;
        this.length = 0;
        this.buf = Buffer.allocUnsafe(size2);
    }
    prepend(val2) {
        if (Buffer.isBuffer(val2)) {
            const length = this.length + val2.length;
            if (length >= this.size) {
                this.resize();
                if (length >= this.size) {
                    throw Error("INVALID_BUFFER_STATE");
                }
            }
            const buf = this.buf;
            this.buf = Buffer.allocUnsafe(this.size);
            val2.copy(this.buf, 0);
            buf.copy(this.buf, val2.length);
            this.length += val2.length;
        }
        else {
            const length = this.length++;
            if (length === this.size) {
                this.resize();
            }
            const buf = this.clone();
            this.buf[0] = val2;
            buf.copy(this.buf, 1, 0, length);
        }
    }
    append(val2) {
        const length = this.length++;
        if (length === this.size) {
            this.resize();
        }
        this.buf[length] = val2;
    }
    clone() {
        return Buffer.from(this.buf.slice(0, this.length));
    }
    resize() {
        const length = this.length;
        this.size = this.size * 2;
        const buf = Buffer.allocUnsafe(this.size);
        this.buf.copy(buf, 0, 0, length);
        this.buf = buf;
    }
    toString(encoding) {
        if (encoding) {
            return this.buf.slice(0, this.length).toString(encoding);
        }
        else {
            return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
    }
    toJSON() {
        return this.toString("utf8");
    }
    reset() {
        this.length = 0;
    }
}
const np = 12;
const cr$1 = 13;
const nl$1 = 10;
const space = 32;
const tab = 9;
const init_state = function (options2) {
    return {
        bomSkipped: false,
        bufBytesStart: 0,
        castField: options2.cast_function,
        commenting: false,
        // Current error encountered by a record
        error: void 0,
        enabled: options2.from_line === 1,
        escaping: false,
        escapeIsQuote: Buffer.isBuffer(options2.escape) && Buffer.isBuffer(options2.quote) && Buffer.compare(options2.escape, options2.quote) === 0,
        // columns can be `false`, `true`, `Array`
        expectedRecordLength: Array.isArray(options2.columns) ? options2.columns.length : void 0,
        field: new ResizeableBuffer(20),
        firstLineToHeaders: options2.cast_first_line_to_header,
        needMoreDataSize: Math.max(
        // Skip if the remaining buffer smaller than comment
        options2.comment !== null ? options2.comment.length : 0, ...options2.delimiter.map((delimiter) => delimiter.length), 
        // Skip if the remaining buffer can be escape sequence
        options2.quote !== null ? options2.quote.length : 0),
        previousBuf: void 0,
        quoting: false,
        stop: false,
        rawBuffer: new ResizeableBuffer(100),
        record: [],
        recordHasError: false,
        record_length: 0,
        recordDelimiterMaxLength: options2.record_delimiter.length === 0 ? 0 : Math.max(...options2.record_delimiter.map((v) => v.length)),
        trimChars: [
            Buffer.from(" ", options2.encoding)[0],
            Buffer.from("	", options2.encoding)[0]
        ],
        wasQuoting: false,
        wasRowDelimiter: false,
        timchars: [
            Buffer.from(Buffer.from([cr$1], "utf8").toString(), options2.encoding),
            Buffer.from(Buffer.from([nl$1], "utf8").toString(), options2.encoding),
            Buffer.from(Buffer.from([np], "utf8").toString(), options2.encoding),
            Buffer.from(Buffer.from([space], "utf8").toString(), options2.encoding),
            Buffer.from(Buffer.from([tab], "utf8").toString(), options2.encoding)
        ]
    };
};
const underscore = function (str) {
    return str.replace(/([A-Z])/g, function (_, match2) {
        return "_" + match2.toLowerCase();
    });
};
const normalize_options = function (opts) {
    const options2 = {};
    for (const opt in opts) {
        options2[underscore(opt)] = opts[opt];
    }
    if (options2.encoding === void 0 || options2.encoding === true) {
        options2.encoding = "utf8";
    }
    else if (options2.encoding === null || options2.encoding === false) {
        options2.encoding = null;
    }
    else if (typeof options2.encoding !== "string" && options2.encoding !== null) {
        throw new CsvError2("CSV_INVALID_OPTION_ENCODING", [
            "Invalid option encoding:",
            "encoding must be a string or null to return a buffer,",
            `got ${JSON.stringify(options2.encoding)}`
        ], options2);
    }
    if (options2.bom === void 0 || options2.bom === null || options2.bom === false) {
        options2.bom = false;
    }
    else if (options2.bom !== true) {
        throw new CsvError2("CSV_INVALID_OPTION_BOM", [
            "Invalid option bom:",
            "bom must be true,",
            `got ${JSON.stringify(options2.bom)}`
        ], options2);
    }
    options2.cast_function = null;
    if (options2.cast === void 0 || options2.cast === null || options2.cast === false || options2.cast === "") {
        options2.cast = void 0;
    }
    else if (typeof options2.cast === "function") {
        options2.cast_function = options2.cast;
        options2.cast = true;
    }
    else if (options2.cast !== true) {
        throw new CsvError2("CSV_INVALID_OPTION_CAST", [
            "Invalid option cast:",
            "cast must be true or a function,",
            `got ${JSON.stringify(options2.cast)}`
        ], options2);
    }
    if (options2.cast_date === void 0 || options2.cast_date === null || options2.cast_date === false || options2.cast_date === "") {
        options2.cast_date = false;
    }
    else if (options2.cast_date === true) {
        options2.cast_date = function (value) {
            const date = Date.parse(value);
            return !isNaN(date) ? new Date(date) : value;
        };
    }
    else if (typeof options2.cast_date !== "function") {
        throw new CsvError2("CSV_INVALID_OPTION_CAST_DATE", [
            "Invalid option cast_date:",
            "cast_date must be true or a function,",
            `got ${JSON.stringify(options2.cast_date)}`
        ], options2);
    }
    options2.cast_first_line_to_header = null;
    if (options2.columns === true) {
        options2.cast_first_line_to_header = void 0;
    }
    else if (typeof options2.columns === "function") {
        options2.cast_first_line_to_header = options2.columns;
        options2.columns = true;
    }
    else if (Array.isArray(options2.columns)) {
        options2.columns = normalize_columns_array(options2.columns);
    }
    else if (options2.columns === void 0 || options2.columns === null || options2.columns === false) {
        options2.columns = false;
    }
    else {
        throw new CsvError2("CSV_INVALID_OPTION_COLUMNS", [
            "Invalid option columns:",
            "expect an array, a function or true,",
            `got ${JSON.stringify(options2.columns)}`
        ], options2);
    }
    if (options2.group_columns_by_name === void 0 || options2.group_columns_by_name === null || options2.group_columns_by_name === false) {
        options2.group_columns_by_name = false;
    }
    else if (options2.group_columns_by_name !== true) {
        throw new CsvError2("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
            "Invalid option group_columns_by_name:",
            "expect an boolean,",
            `got ${JSON.stringify(options2.group_columns_by_name)}`
        ], options2);
    }
    else if (options2.columns === false) {
        throw new CsvError2("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
            "Invalid option group_columns_by_name:",
            "the `columns` mode must be activated."
        ], options2);
    }
    if (options2.comment === void 0 || options2.comment === null || options2.comment === false || options2.comment === "") {
        options2.comment = null;
    }
    else {
        if (typeof options2.comment === "string") {
            options2.comment = Buffer.from(options2.comment, options2.encoding);
        }
        if (!Buffer.isBuffer(options2.comment)) {
            throw new CsvError2("CSV_INVALID_OPTION_COMMENT", [
                "Invalid option comment:",
                "comment must be a buffer or a string,",
                `got ${JSON.stringify(options2.comment)}`
            ], options2);
        }
    }
    if (options2.comment_no_infix === void 0 || options2.comment_no_infix === null || options2.comment_no_infix === false) {
        options2.comment_no_infix = false;
    }
    else if (options2.comment_no_infix !== true) {
        throw new CsvError2("CSV_INVALID_OPTION_COMMENT", [
            "Invalid option comment_no_infix:",
            "value must be a boolean,",
            `got ${JSON.stringify(options2.comment_no_infix)}`
        ], options2);
    }
    const delimiter_json = JSON.stringify(options2.delimiter);
    if (!Array.isArray(options2.delimiter))
        options2.delimiter = [options2.delimiter];
    if (options2.delimiter.length === 0) {
        throw new CsvError2("CSV_INVALID_OPTION_DELIMITER", [
            "Invalid option delimiter:",
            "delimiter must be a non empty string or buffer or array of string|buffer,",
            `got ${delimiter_json}`
        ], options2);
    }
    options2.delimiter = options2.delimiter.map(function (delimiter) {
        if (delimiter === void 0 || delimiter === null || delimiter === false) {
            return Buffer.from(",", options2.encoding);
        }
        if (typeof delimiter === "string") {
            delimiter = Buffer.from(delimiter, options2.encoding);
        }
        if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
            throw new CsvError2("CSV_INVALID_OPTION_DELIMITER", [
                "Invalid option delimiter:",
                "delimiter must be a non empty string or buffer or array of string|buffer,",
                `got ${delimiter_json}`
            ], options2);
        }
        return delimiter;
    });
    if (options2.escape === void 0 || options2.escape === true) {
        options2.escape = Buffer.from('"', options2.encoding);
    }
    else if (typeof options2.escape === "string") {
        options2.escape = Buffer.from(options2.escape, options2.encoding);
    }
    else if (options2.escape === null || options2.escape === false) {
        options2.escape = null;
    }
    if (options2.escape !== null) {
        if (!Buffer.isBuffer(options2.escape)) {
            throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options2.escape)}`);
        }
    }
    if (options2.from === void 0 || options2.from === null) {
        options2.from = 1;
    }
    else {
        if (typeof options2.from === "string" && /\d+/.test(options2.from)) {
            options2.from = parseInt(options2.from);
        }
        if (Number.isInteger(options2.from)) {
            if (options2.from < 0) {
                throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
            }
        }
        else {
            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options2.from)}`);
        }
    }
    if (options2.from_line === void 0 || options2.from_line === null) {
        options2.from_line = 1;
    }
    else {
        if (typeof options2.from_line === "string" && /\d+/.test(options2.from_line)) {
            options2.from_line = parseInt(options2.from_line);
        }
        if (Number.isInteger(options2.from_line)) {
            if (options2.from_line <= 0) {
                throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
            }
        }
        else {
            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
        }
    }
    if (options2.ignore_last_delimiters === void 0 || options2.ignore_last_delimiters === null) {
        options2.ignore_last_delimiters = false;
    }
    else if (typeof options2.ignore_last_delimiters === "number") {
        options2.ignore_last_delimiters = Math.floor(options2.ignore_last_delimiters);
        if (options2.ignore_last_delimiters === 0) {
            options2.ignore_last_delimiters = false;
        }
    }
    else if (typeof options2.ignore_last_delimiters !== "boolean") {
        throw new CsvError2("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS", [
            "Invalid option `ignore_last_delimiters`:",
            "the value must be a boolean value or an integer,",
            `got ${JSON.stringify(options2.ignore_last_delimiters)}`
        ], options2);
    }
    if (options2.ignore_last_delimiters === true && options2.columns === false) {
        throw new CsvError2("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS", [
            "The option `ignore_last_delimiters`",
            "requires the activation of the `columns` option"
        ], options2);
    }
    if (options2.info === void 0 || options2.info === null || options2.info === false) {
        options2.info = false;
    }
    else if (options2.info !== true) {
        throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options2.info)}`);
    }
    if (options2.max_record_size === void 0 || options2.max_record_size === null || options2.max_record_size === false) {
        options2.max_record_size = 0;
    }
    else if (Number.isInteger(options2.max_record_size) && options2.max_record_size >= 0)
        ;
    else if (typeof options2.max_record_size === "string" && /\d+/.test(options2.max_record_size)) {
        options2.max_record_size = parseInt(options2.max_record_size);
    }
    else {
        throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options2.max_record_size)}`);
    }
    if (options2.objname === void 0 || options2.objname === null || options2.objname === false) {
        options2.objname = void 0;
    }
    else if (Buffer.isBuffer(options2.objname)) {
        if (options2.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty buffer`);
        }
        if (options2.encoding === null)
            ;
        else {
            options2.objname = options2.objname.toString(options2.encoding);
        }
    }
    else if (typeof options2.objname === "string") {
        if (options2.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty string`);
        }
    }
    else if (typeof options2.objname === "number")
        ;
    else {
        throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options2.objname}`);
    }
    if (options2.objname !== void 0) {
        if (typeof options2.objname === "number") {
            if (options2.columns !== false) {
                throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field");
            }
        }
        else {
            if (options2.columns === false) {
                throw Error("Invalid Option: objname field must be combined with columns or be defined as an index");
            }
        }
    }
    if (options2.on_record === void 0 || options2.on_record === null) {
        options2.on_record = void 0;
    }
    else if (typeof options2.on_record !== "function") {
        throw new CsvError2("CSV_INVALID_OPTION_ON_RECORD", [
            "Invalid option `on_record`:",
            "expect a function,",
            `got ${JSON.stringify(options2.on_record)}`
        ], options2);
    }
    if (options2.on_skip !== void 0 && options2.on_skip !== null && typeof options2.on_skip !== "function") {
        throw new Error(`Invalid Option: on_skip must be a function, got ${JSON.stringify(options2.on_skip)}`);
    }
    if (options2.quote === null || options2.quote === false || options2.quote === "") {
        options2.quote = null;
    }
    else {
        if (options2.quote === void 0 || options2.quote === true) {
            options2.quote = Buffer.from('"', options2.encoding);
        }
        else if (typeof options2.quote === "string") {
            options2.quote = Buffer.from(options2.quote, options2.encoding);
        }
        if (!Buffer.isBuffer(options2.quote)) {
            throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options2.quote)}`);
        }
    }
    if (options2.raw === void 0 || options2.raw === null || options2.raw === false) {
        options2.raw = false;
    }
    else if (options2.raw !== true) {
        throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options2.raw)}`);
    }
    if (options2.record_delimiter === void 0) {
        options2.record_delimiter = [];
    }
    else if (typeof options2.record_delimiter === "string" || Buffer.isBuffer(options2.record_delimiter)) {
        if (options2.record_delimiter.length === 0) {
            throw new CsvError2("CSV_INVALID_OPTION_RECORD_DELIMITER", [
                "Invalid option `record_delimiter`:",
                "value must be a non empty string or buffer,",
                `got ${JSON.stringify(options2.record_delimiter)}`
            ], options2);
        }
        options2.record_delimiter = [options2.record_delimiter];
    }
    else if (!Array.isArray(options2.record_delimiter)) {
        throw new CsvError2("CSV_INVALID_OPTION_RECORD_DELIMITER", [
            "Invalid option `record_delimiter`:",
            "value must be a string, a buffer or array of string|buffer,",
            `got ${JSON.stringify(options2.record_delimiter)}`
        ], options2);
    }
    options2.record_delimiter = options2.record_delimiter.map(function (rd, i) {
        if (typeof rd !== "string" && !Buffer.isBuffer(rd)) {
            throw new CsvError2("CSV_INVALID_OPTION_RECORD_DELIMITER", [
                "Invalid option `record_delimiter`:",
                "value must be a string, a buffer or array of string|buffer",
                `at index ${i},`,
                `got ${JSON.stringify(rd)}`
            ], options2);
        }
        else if (rd.length === 0) {
            throw new CsvError2("CSV_INVALID_OPTION_RECORD_DELIMITER", [
                "Invalid option `record_delimiter`:",
                "value must be a non empty string or buffer",
                `at index ${i},`,
                `got ${JSON.stringify(rd)}`
            ], options2);
        }
        if (typeof rd === "string") {
            rd = Buffer.from(rd, options2.encoding);
        }
        return rd;
    });
    if (typeof options2.relax_column_count === "boolean")
        ;
    else if (options2.relax_column_count === void 0 || options2.relax_column_count === null) {
        options2.relax_column_count = false;
    }
    else {
        throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options2.relax_column_count)}`);
    }
    if (typeof options2.relax_column_count_less === "boolean")
        ;
    else if (options2.relax_column_count_less === void 0 || options2.relax_column_count_less === null) {
        options2.relax_column_count_less = false;
    }
    else {
        throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options2.relax_column_count_less)}`);
    }
    if (typeof options2.relax_column_count_more === "boolean")
        ;
    else if (options2.relax_column_count_more === void 0 || options2.relax_column_count_more === null) {
        options2.relax_column_count_more = false;
    }
    else {
        throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options2.relax_column_count_more)}`);
    }
    if (typeof options2.relax_quotes === "boolean")
        ;
    else if (options2.relax_quotes === void 0 || options2.relax_quotes === null) {
        options2.relax_quotes = false;
    }
    else {
        throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options2.relax_quotes)}`);
    }
    if (typeof options2.skip_empty_lines === "boolean")
        ;
    else if (options2.skip_empty_lines === void 0 || options2.skip_empty_lines === null) {
        options2.skip_empty_lines = false;
    }
    else {
        throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options2.skip_empty_lines)}`);
    }
    if (typeof options2.skip_records_with_empty_values === "boolean")
        ;
    else if (options2.skip_records_with_empty_values === void 0 || options2.skip_records_with_empty_values === null) {
        options2.skip_records_with_empty_values = false;
    }
    else {
        throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options2.skip_records_with_empty_values)}`);
    }
    if (typeof options2.skip_records_with_error === "boolean")
        ;
    else if (options2.skip_records_with_error === void 0 || options2.skip_records_with_error === null) {
        options2.skip_records_with_error = false;
    }
    else {
        throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options2.skip_records_with_error)}`);
    }
    if (options2.rtrim === void 0 || options2.rtrim === null || options2.rtrim === false) {
        options2.rtrim = false;
    }
    else if (options2.rtrim !== true) {
        throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options2.rtrim)}`);
    }
    if (options2.ltrim === void 0 || options2.ltrim === null || options2.ltrim === false) {
        options2.ltrim = false;
    }
    else if (options2.ltrim !== true) {
        throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options2.ltrim)}`);
    }
    if (options2.trim === void 0 || options2.trim === null || options2.trim === false) {
        options2.trim = false;
    }
    else if (options2.trim !== true) {
        throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options2.trim)}`);
    }
    if (options2.trim === true && opts.ltrim !== false) {
        options2.ltrim = true;
    }
    else if (options2.ltrim !== true) {
        options2.ltrim = false;
    }
    if (options2.trim === true && opts.rtrim !== false) {
        options2.rtrim = true;
    }
    else if (options2.rtrim !== true) {
        options2.rtrim = false;
    }
    if (options2.to === void 0 || options2.to === null) {
        options2.to = -1;
    }
    else {
        if (typeof options2.to === "string" && /\d+/.test(options2.to)) {
            options2.to = parseInt(options2.to);
        }
        if (Number.isInteger(options2.to)) {
            if (options2.to <= 0) {
                throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
            }
        }
        else {
            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
        }
    }
    if (options2.to_line === void 0 || options2.to_line === null) {
        options2.to_line = -1;
    }
    else {
        if (typeof options2.to_line === "string" && /\d+/.test(options2.to_line)) {
            options2.to_line = parseInt(options2.to_line);
        }
        if (Number.isInteger(options2.to_line)) {
            if (options2.to_line <= 0) {
                throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
            }
        }
        else {
            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
        }
    }
    return options2;
};
const isRecordEmpty = function (record) {
    return record.every((field) => field == null || field.toString && field.toString().trim() === "");
};
const cr = 13;
const nl = 10;
const boms = {
    // Note, the following are equals:
    // Buffer.from("\ufeff")
    // Buffer.from([239, 187, 191])
    // Buffer.from('EFBBBF', 'hex')
    utf8: Buffer.from([239, 187, 191]),
    // Note, the following are equals:
    // Buffer.from "\ufeff", 'utf16le
    // Buffer.from([255, 254])
    utf16le: Buffer.from([255, 254])
};
const transform = function (original_options = {}) {
    const info = {
        bytes: 0,
        comment_lines: 0,
        empty_lines: 0,
        invalid_field_length: 0,
        lines: 1,
        records: 0
    };
    const options2 = normalize_options(original_options);
    return {
        info,
        original_options,
        options: options2,
        state: init_state(options2),
        __needMoreData: function (i, bufLen, end) {
            if (end)
                return false;
            const { encoding, escape: escape2, quote } = this.options;
            const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;
            const numOfCharLeft = bufLen - i - 1;
            const requiredLength = Math.max(needMoreDataSize, 
            // Skip if the remaining buffer smaller than record delimiter
            // If "record_delimiter" is yet to be discovered:
            // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
            // 2. We set the length to windows line ending in the current encoding
            // Note, that encoding is known from user or bom discovery at that point
            // recordDelimiterMaxLength,
            recordDelimiterMaxLength === 0 ? Buffer.from("\r\n", encoding).length : recordDelimiterMaxLength, 
            // Skip if remaining buffer can be an escaped quote
            quoting ? (escape2 === null ? 0 : escape2.length) + quote.length : 0, 
            // Skip if remaining buffer can be record delimiter following the closing quote
            quoting ? quote.length + recordDelimiterMaxLength : 0);
            return numOfCharLeft < requiredLength;
        },
        // Central parser implementation
        parse: function (nextBuf, end, push, close) {
            const { bom: bom2, comment_no_infix, encoding, from_line, ltrim, max_record_size, raw, relax_quotes, rtrim, skip_empty_lines, to, to_line } = this.options;
            let { comment, escape: escape2, quote, record_delimiter } = this.options;
            const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
            let buf;
            if (previousBuf === void 0) {
                if (nextBuf === void 0) {
                    close();
                    return;
                }
                else {
                    buf = nextBuf;
                }
            }
            else if (previousBuf !== void 0 && nextBuf === void 0) {
                buf = previousBuf;
            }
            else {
                buf = Buffer.concat([previousBuf, nextBuf]);
            }
            if (bomSkipped === false) {
                if (bom2 === false) {
                    this.state.bomSkipped = true;
                }
                else if (buf.length < 3) {
                    if (end === false) {
                        this.state.previousBuf = buf;
                        return;
                    }
                }
                else {
                    for (const encoding2 in boms) {
                        if (boms[encoding2].compare(buf, 0, boms[encoding2].length) === 0) {
                            const bomLength = boms[encoding2].length;
                            this.state.bufBytesStart += bomLength;
                            buf = buf.slice(bomLength);
                            this.options = normalize_options({
                                ...this.original_options,
                                encoding: encoding2
                            });
                            ({ comment, escape: escape2, quote } = this.options);
                            break;
                        }
                    }
                    this.state.bomSkipped = true;
                }
            }
            const bufLen = buf.length;
            let pos;
            for (pos = 0; pos < bufLen; pos++) {
                if (this.__needMoreData(pos, bufLen, end)) {
                    break;
                }
                if (this.state.wasRowDelimiter === true) {
                    this.info.lines++;
                    this.state.wasRowDelimiter = false;
                }
                if (to_line !== -1 && this.info.lines > to_line) {
                    this.state.stop = true;
                    close();
                    return;
                }
                if (this.state.quoting === false && record_delimiter.length === 0) {
                    const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
                    if (record_delimiterCount) {
                        record_delimiter = this.options.record_delimiter;
                    }
                }
                const chr = buf[pos];
                if (raw === true) {
                    rawBuffer.append(chr);
                }
                if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {
                    this.state.wasRowDelimiter = true;
                }
                if (this.state.escaping === true) {
                    this.state.escaping = false;
                }
                else {
                    if (escape2 !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape2.length < bufLen) {
                        if (escapeIsQuote) {
                            if (this.__isQuote(buf, pos + escape2.length)) {
                                this.state.escaping = true;
                                pos += escape2.length - 1;
                                continue;
                            }
                        }
                        else {
                            this.state.escaping = true;
                            pos += escape2.length - 1;
                            continue;
                        }
                    }
                    if (this.state.commenting === false && this.__isQuote(buf, pos)) {
                        if (this.state.quoting === true) {
                            const nextChr = buf[pos + quote.length];
                            const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);
                            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
                            const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);
                            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
                            if (escape2 !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape2.length)) {
                                pos += escape2.length - 1;
                            }
                            else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                                this.state.quoting = false;
                                this.state.wasQuoting = true;
                                pos += quote.length - 1;
                                continue;
                            }
                            else if (relax_quotes === false) {
                                const err = this.__error(new CsvError2("CSV_INVALID_CLOSING_QUOTE", [
                                    "Invalid Closing Quote:",
                                    `got "${String.fromCharCode(nextChr)}"`,
                                    `at line ${this.info.lines}`,
                                    "instead of delimiter, record delimiter, trimable character",
                                    "(if activated) or comment"
                                ], this.options, this.__infoField()));
                                if (err !== void 0)
                                    return err;
                            }
                            else {
                                this.state.quoting = false;
                                this.state.wasQuoting = true;
                                this.state.field.prepend(quote);
                                pos += quote.length - 1;
                            }
                        }
                        else {
                            if (this.state.field.length !== 0) {
                                if (relax_quotes === false) {
                                    const info2 = this.__infoField();
                                    const bom3 = Object.keys(boms).map((b) => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];
                                    const err = this.__error(new CsvError2("INVALID_OPENING_QUOTE", [
                                        "Invalid Opening Quote:",
                                        `a quote is found on field ${JSON.stringify(info2.column)} at line ${info2.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,
                                        bom3 ? `(${bom3} bom)` : void 0
                                    ], this.options, info2, {
                                        field: this.state.field
                                    }));
                                    if (err !== void 0)
                                        return err;
                                }
                            }
                            else {
                                this.state.quoting = true;
                                pos += quote.length - 1;
                                continue;
                            }
                        }
                    }
                    if (this.state.quoting === false) {
                        const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
                        if (recordDelimiterLength !== 0) {
                            const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;
                            if (skipCommentLine) {
                                this.info.comment_lines++;
                            }
                            else {
                                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                                    this.state.enabled = true;
                                    this.__resetField();
                                    this.__resetRecord();
                                    pos += recordDelimiterLength - 1;
                                    continue;
                                }
                                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                                    this.info.empty_lines++;
                                    pos += recordDelimiterLength - 1;
                                    continue;
                                }
                                this.info.bytes = this.state.bufBytesStart + pos;
                                const errField = this.__onField();
                                if (errField !== void 0)
                                    return errField;
                                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                                const errRecord = this.__onRecord(push);
                                if (errRecord !== void 0)
                                    return errRecord;
                                if (to !== -1 && this.info.records >= to) {
                                    this.state.stop = true;
                                    close();
                                    return;
                                }
                            }
                            this.state.commenting = false;
                            pos += recordDelimiterLength - 1;
                            continue;
                        }
                        if (this.state.commenting) {
                            continue;
                        }
                        if (comment !== null && (comment_no_infix === false || this.state.record.length === 0 && this.state.field.length === 0)) {
                            const commentCount = this.__compareBytes(comment, buf, pos, chr);
                            if (commentCount !== 0) {
                                this.state.commenting = true;
                                continue;
                            }
                        }
                        const delimiterLength = this.__isDelimiter(buf, pos, chr);
                        if (delimiterLength !== 0) {
                            this.info.bytes = this.state.bufBytesStart + pos;
                            const errField = this.__onField();
                            if (errField !== void 0)
                                return errField;
                            pos += delimiterLength - 1;
                            continue;
                        }
                    }
                }
                if (this.state.commenting === false) {
                    if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
                        return this.__error(new CsvError2("CSV_MAX_RECORD_SIZE", [
                            "Max Record Size:",
                            "record exceed the maximum number of tolerated bytes",
                            `of ${max_record_size}`,
                            `at line ${this.info.lines}`
                        ], this.options, this.__infoField()));
                    }
                }
                const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);
                const rappend = rtrim === false || this.state.wasQuoting === false;
                if (lappend === true && rappend === true) {
                    this.state.field.append(chr);
                }
                else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {
                    return this.__error(new CsvError2("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE", [
                        "Invalid Closing Quote:",
                        "found non trimable byte after quote",
                        `at line ${this.info.lines}`
                    ], this.options, this.__infoField()));
                }
                else {
                    if (lappend === false) {
                        pos += this.__isCharTrimable(buf, pos) - 1;
                    }
                    continue;
                }
            }
            if (end === true) {
                if (this.state.quoting === true) {
                    const err = this.__error(new CsvError2("CSV_QUOTE_NOT_CLOSED", [
                        "Quote Not Closed:",
                        `the parsing is finished with an opening quote at line ${this.info.lines}`
                    ], this.options, this.__infoField()));
                    if (err !== void 0)
                        return err;
                }
                else {
                    if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
                        this.info.bytes = this.state.bufBytesStart + pos;
                        const errField = this.__onField();
                        if (errField !== void 0)
                            return errField;
                        const errRecord = this.__onRecord(push);
                        if (errRecord !== void 0)
                            return errRecord;
                    }
                    else if (this.state.wasRowDelimiter === true) {
                        this.info.empty_lines++;
                    }
                    else if (this.state.commenting === true) {
                        this.info.comment_lines++;
                    }
                }
            }
            else {
                this.state.bufBytesStart += pos;
                this.state.previousBuf = buf.slice(pos);
            }
            if (this.state.wasRowDelimiter === true) {
                this.info.lines++;
                this.state.wasRowDelimiter = false;
            }
        },
        __onRecord: function (push) {
            const { columns, group_columns_by_name, encoding, info: info2, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values } = this.options;
            const { enabled, record } = this.state;
            if (enabled === false) {
                return this.__resetRecord();
            }
            const recordLength = record.length;
            if (columns === true) {
                if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
                    this.__resetRecord();
                    return;
                }
                return this.__firstLineToColumns(record);
            }
            if (columns === false && this.info.records === 0) {
                this.state.expectedRecordLength = recordLength;
            }
            if (recordLength !== this.state.expectedRecordLength) {
                const err = columns === false ? new CsvError2("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH", [
                    "Invalid Record Length:",
                    `expect ${this.state.expectedRecordLength},`,
                    `got ${recordLength} on line ${this.info.lines}`
                ], this.options, this.__infoField(), {
                    record
                }) : new CsvError2("CSV_RECORD_INCONSISTENT_COLUMNS", [
                    "Invalid Record Length:",
                    `columns length is ${columns.length},`,
                    // rename columns
                    `got ${recordLength} on line ${this.info.lines}`
                ], this.options, this.__infoField(), {
                    record
                });
                if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
                    this.info.invalid_field_length++;
                    this.state.error = err;
                }
                else {
                    const finalErr = this.__error(err);
                    if (finalErr)
                        return finalErr;
                }
            }
            if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
                this.__resetRecord();
                return;
            }
            if (this.state.recordHasError === true) {
                this.__resetRecord();
                this.state.recordHasError = false;
                return;
            }
            this.info.records++;
            if (from === 1 || this.info.records >= from) {
                const { objname } = this.options;
                if (columns !== false) {
                    const obj = {};
                    for (let i = 0, l = record.length; i < l; i++) {
                        if (columns[i] === void 0 || columns[i].disabled)
                            continue;
                        if (group_columns_by_name === true && obj[columns[i].name] !== void 0) {
                            if (Array.isArray(obj[columns[i].name])) {
                                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                            }
                            else {
                                obj[columns[i].name] = [obj[columns[i].name], record[i]];
                            }
                        }
                        else {
                            obj[columns[i].name] = record[i];
                        }
                    }
                    if (raw === true || info2 === true) {
                        const extRecord = Object.assign({ record: obj }, raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {}, info2 === true ? { info: this.__infoRecord() } : {});
                        const err = this.__push(objname === void 0 ? extRecord : [obj[objname], extRecord], push);
                        if (err) {
                            return err;
                        }
                    }
                    else {
                        const err = this.__push(objname === void 0 ? obj : [obj[objname], obj], push);
                        if (err) {
                            return err;
                        }
                    }
                }
                else {
                    if (raw === true || info2 === true) {
                        const extRecord = Object.assign({ record }, raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {}, info2 === true ? { info: this.__infoRecord() } : {});
                        const err = this.__push(objname === void 0 ? extRecord : [record[objname], extRecord], push);
                        if (err) {
                            return err;
                        }
                    }
                    else {
                        const err = this.__push(objname === void 0 ? record : [record[objname], record], push);
                        if (err) {
                            return err;
                        }
                    }
                }
            }
            this.__resetRecord();
        },
        __firstLineToColumns: function (record) {
            const { firstLineToHeaders } = this.state;
            try {
                const headers2 = firstLineToHeaders === void 0 ? record : firstLineToHeaders.call(null, record);
                if (!Array.isArray(headers2)) {
                    return this.__error(new CsvError2("CSV_INVALID_COLUMN_MAPPING", [
                        "Invalid Column Mapping:",
                        "expect an array from column function,",
                        `got ${JSON.stringify(headers2)}`
                    ], this.options, this.__infoField(), {
                        headers: headers2
                    }));
                }
                const normalizedHeaders = normalize_columns_array(headers2);
                this.state.expectedRecordLength = normalizedHeaders.length;
                this.options.columns = normalizedHeaders;
                this.__resetRecord();
                return;
            }
            catch (err) {
                return err;
            }
        },
        __resetRecord: function () {
            if (this.options.raw === true) {
                this.state.rawBuffer.reset();
            }
            this.state.error = void 0;
            this.state.record = [];
            this.state.record_length = 0;
        },
        __onField: function () {
            const { cast, encoding, rtrim, max_record_size } = this.options;
            const { enabled, wasQuoting } = this.state;
            if (enabled === false) {
                return this.__resetField();
            }
            let field = this.state.field.toString(encoding);
            if (rtrim === true && wasQuoting === false) {
                field = field.trimRight();
            }
            if (cast === true) {
                const [err, f2] = this.__cast(field);
                if (err !== void 0)
                    return err;
                field = f2;
            }
            this.state.record.push(field);
            if (max_record_size !== 0 && typeof field === "string") {
                this.state.record_length += field.length;
            }
            this.__resetField();
        },
        __resetField: function () {
            this.state.field.reset();
            this.state.wasQuoting = false;
        },
        __push: function (record, push) {
            const { on_record } = this.options;
            if (on_record !== void 0) {
                const info2 = this.__infoRecord();
                try {
                    record = on_record.call(null, record, info2);
                }
                catch (err) {
                    return err;
                }
                if (record === void 0 || record === null) {
                    return;
                }
            }
            push(record);
        },
        // Return a tuple with the error and the casted value
        __cast: function (field) {
            const { columns, relax_column_count } = this.options;
            const isColumns = Array.isArray(columns);
            if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
                return [void 0, void 0];
            }
            if (this.state.castField !== null) {
                try {
                    const info2 = this.__infoField();
                    return [void 0, this.state.castField.call(null, field, info2)];
                }
                catch (err) {
                    return [err];
                }
            }
            if (this.__isFloat(field)) {
                return [void 0, parseFloat(field)];
            }
            else if (this.options.cast_date !== false) {
                const info2 = this.__infoField();
                return [void 0, this.options.cast_date.call(null, field, info2)];
            }
            return [void 0, field];
        },
        // Helper to test if a character is a space or a line delimiter
        __isCharTrimable: function (buf, pos) {
            const isTrim = (buf2, pos2) => {
                const { timchars } = this.state;
                loop1: for (let i = 0; i < timchars.length; i++) {
                    const timchar = timchars[i];
                    for (let j = 0; j < timchar.length; j++) {
                        if (timchar[j] !== buf2[pos2 + j])
                            continue loop1;
                    }
                    return timchar.length;
                }
                return 0;
            };
            return isTrim(buf, pos);
        },
        // Keep it in case we implement the `cast_int` option
        // __isInt(value){
        //   // return Number.isInteger(parseInt(value))
        //   // return !isNaN( parseInt( obj ) );
        //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
        // }
        __isFloat: function (value) {
            return value - parseFloat(value) + 1 >= 0;
        },
        __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {
            if (sourceBuf[0] !== firstByte)
                return 0;
            const sourceLength = sourceBuf.length;
            for (let i = 1; i < sourceLength; i++) {
                if (sourceBuf[i] !== targetBuf[targetPos + i])
                    return 0;
            }
            return sourceLength;
        },
        __isDelimiter: function (buf, pos, chr) {
            const { delimiter, ignore_last_delimiters } = this.options;
            if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
                return 0;
            }
            else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === "number" && this.state.record.length === ignore_last_delimiters - 1) {
                return 0;
            }
            loop1: for (let i = 0; i < delimiter.length; i++) {
                const del2 = delimiter[i];
                if (del2[0] === chr) {
                    for (let j = 1; j < del2.length; j++) {
                        if (del2[j] !== buf[pos + j])
                            continue loop1;
                    }
                    return del2.length;
                }
            }
            return 0;
        },
        __isRecordDelimiter: function (chr, buf, pos) {
            const { record_delimiter } = this.options;
            const recordDelimiterLength = record_delimiter.length;
            loop1: for (let i = 0; i < recordDelimiterLength; i++) {
                const rd = record_delimiter[i];
                const rdLength = rd.length;
                if (rd[0] !== chr) {
                    continue;
                }
                for (let j = 1; j < rdLength; j++) {
                    if (rd[j] !== buf[pos + j]) {
                        continue loop1;
                    }
                }
                return rd.length;
            }
            return 0;
        },
        __isEscape: function (buf, pos, chr) {
            const { escape: escape2 } = this.options;
            if (escape2 === null)
                return false;
            const l = escape2.length;
            if (escape2[0] === chr) {
                for (let i = 0; i < l; i++) {
                    if (escape2[i] !== buf[pos + i]) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        },
        __isQuote: function (buf, pos) {
            const { quote } = this.options;
            if (quote === null)
                return false;
            const l = quote.length;
            for (let i = 0; i < l; i++) {
                if (quote[i] !== buf[pos + i]) {
                    return false;
                }
            }
            return true;
        },
        __autoDiscoverRecordDelimiter: function (buf, pos) {
            const { encoding } = this.options;
            const rds = [
                // Important, the windows line ending must be before mac os 9
                Buffer.from("\r\n", encoding),
                Buffer.from("\n", encoding),
                Buffer.from("\r", encoding)
            ];
            loop: for (let i = 0; i < rds.length; i++) {
                const l = rds[i].length;
                for (let j = 0; j < l; j++) {
                    if (rds[i][j] !== buf[pos + j]) {
                        continue loop;
                    }
                }
                this.options.record_delimiter.push(rds[i]);
                this.state.recordDelimiterMaxLength = rds[i].length;
                return rds[i].length;
            }
            return 0;
        },
        __error: function (msg) {
            const { encoding, raw, skip_records_with_error } = this.options;
            const err = typeof msg === "string" ? new Error(msg) : msg;
            if (skip_records_with_error) {
                this.state.recordHasError = true;
                if (this.options.on_skip !== void 0) {
                    this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : void 0);
                }
                return void 0;
            }
            else {
                return err;
            }
        },
        __infoDataSet: function () {
            return {
                ...this.info,
                columns: this.options.columns
            };
        },
        __infoRecord: function () {
            const { columns, raw, encoding } = this.options;
            return {
                ...this.__infoDataSet(),
                error: this.state.error,
                header: columns === true,
                index: this.state.record.length,
                raw: raw ? this.state.rawBuffer.toString(encoding) : void 0
            };
        },
        __infoField: function () {
            const { columns } = this.options;
            const isColumns = Array.isArray(columns);
            return {
                ...this.__infoRecord(),
                column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
                quoting: this.state.wasQuoting
            };
        }
    };
};
const parse = function (data, opts = {}) {
    if (typeof data === "string") {
        data = Buffer.from(data);
    }
    const records = opts && opts.objname ? {} : [];
    const parser2 = transform(opts);
    const push = (record) => {
        if (parser2.options.objname === void 0)
            records.push(record);
        else {
            records[record[0]] = record[1];
        }
    };
    const close = () => {
    };
    const err1 = parser2.parse(data, false, push, close);
    if (err1 !== void 0)
        throw err1;
    const err2 = parser2.parse(void 0, true, push, close);
    if (err2 !== void 0)
        throw err2;
    return records;
};
var xml2js = {};
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
    if (hasRequiredDefaults)
        return defaults;
    hasRequiredDefaults = 1;
    (function () {
        defaults.defaults = {
            "0.1": {
                explicitCharkey: false,
                trim: true,
                normalize: true,
                normalizeTags: false,
                attrkey: "@",
                charkey: "#",
                explicitArray: false,
                ignoreAttrs: false,
                mergeAttrs: false,
                explicitRoot: false,
                validator: null,
                xmlns: false,
                explicitChildren: false,
                childkey: "@@",
                charsAsChildren: false,
                includeWhiteChars: false,
                async: false,
                strict: true,
                attrNameProcessors: null,
                attrValueProcessors: null,
                tagNameProcessors: null,
                valueProcessors: null,
                emptyTag: ""
            },
            "0.2": {
                explicitCharkey: false,
                trim: false,
                normalize: false,
                normalizeTags: false,
                attrkey: "$",
                charkey: "_",
                explicitArray: true,
                ignoreAttrs: false,
                mergeAttrs: false,
                explicitRoot: true,
                validator: null,
                xmlns: false,
                explicitChildren: false,
                preserveChildrenOrder: false,
                childkey: "$$",
                charsAsChildren: false,
                includeWhiteChars: false,
                async: false,
                strict: true,
                attrNameProcessors: null,
                attrValueProcessors: null,
                tagNameProcessors: null,
                valueProcessors: null,
                rootName: "root",
                xmldec: {
                    "version": "1.0",
                    "encoding": "UTF-8",
                    "standalone": true
                },
                doctype: null,
                renderOpts: {
                    "pretty": true,
                    "indent": "  ",
                    "newline": "\n"
                },
                headless: false,
                chunkSize: 1e4,
                emptyTag: "",
                cdata: false
            }
        };
    }).call(defaults);
    return defaults;
}
var builder = {};
var lib$1 = {};
var Utility = {};
var hasRequiredUtility;
function requireUtility() {
    if (hasRequiredUtility)
        return Utility;
    hasRequiredUtility = 1;
    (function () {
        var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
        assign = function () {
            var i, key, len, source, sources, target;
            target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (isFunction(Object.assign)) {
                Object.assign.apply(null, arguments);
            }
            else {
                for (i = 0, len = sources.length; i < len; i++) {
                    source = sources[i];
                    if (source != null) {
                        for (key in source) {
                            if (!hasProp.call(source, key))
                                continue;
                            target[key] = source[key];
                        }
                    }
                }
            }
            return target;
        };
        isFunction = function (val2) {
            return !!val2 && Object.prototype.toString.call(val2) === "[object Function]";
        };
        isObject = function (val2) {
            var ref2;
            return !!val2 && ((ref2 = typeof val2) === "function" || ref2 === "object");
        };
        isArray = function (val2) {
            if (isFunction(Array.isArray)) {
                return Array.isArray(val2);
            }
            else {
                return Object.prototype.toString.call(val2) === "[object Array]";
            }
        };
        isEmpty = function (val2) {
            var key;
            if (isArray(val2)) {
                return !val2.length;
            }
            else {
                for (key in val2) {
                    if (!hasProp.call(val2, key))
                        continue;
                    return false;
                }
                return true;
            }
        };
        isPlainObject = function (val2) {
            var ctor, proto2;
            return isObject(val2) && (proto2 = Object.getPrototypeOf(val2)) && (ctor = proto2.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
        };
        getValue = function (obj) {
            if (isFunction(obj.valueOf)) {
                return obj.valueOf();
            }
            else {
                return obj;
            }
        };
        Utility.assign = assign;
        Utility.isFunction = isFunction;
        Utility.isObject = isObject;
        Utility.isArray = isArray;
        Utility.isEmpty = isEmpty;
        Utility.isPlainObject = isPlainObject;
        Utility.getValue = getValue;
    }).call(Utility);
    return Utility;
}
var XMLDOMImplementation$1 = { exports: {} };
var XMLDOMImplementation = XMLDOMImplementation$1.exports;
var hasRequiredXMLDOMImplementation;
function requireXMLDOMImplementation() {
    if (hasRequiredXMLDOMImplementation)
        return XMLDOMImplementation$1.exports;
    hasRequiredXMLDOMImplementation = 1;
    (function () {
        XMLDOMImplementation$1.exports = function () {
            function XMLDOMImplementation2() {
            }
            XMLDOMImplementation2.prototype.hasFeature = function (feature, version) {
                return true;
            };
            XMLDOMImplementation2.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
                throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation2.prototype.createDocument = function (namespaceURI, qualifiedName, doctype) {
                throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation2.prototype.createHTMLDocument = function (title2) {
                throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation2.prototype.getFeature = function (feature, version) {
                throw new Error("This DOM method is not implemented.");
            };
            return XMLDOMImplementation2;
        }();
    }).call(XMLDOMImplementation);
    return XMLDOMImplementation$1.exports;
}
var XMLDocument$1 = { exports: {} };
var XMLDOMConfiguration$1 = { exports: {} };
var XMLDOMErrorHandler$1 = { exports: {} };
var XMLDOMErrorHandler = XMLDOMErrorHandler$1.exports;
var hasRequiredXMLDOMErrorHandler;
function requireXMLDOMErrorHandler() {
    if (hasRequiredXMLDOMErrorHandler)
        return XMLDOMErrorHandler$1.exports;
    hasRequiredXMLDOMErrorHandler = 1;
    (function () {
        XMLDOMErrorHandler$1.exports = function () {
            function XMLDOMErrorHandler2() {
            }
            XMLDOMErrorHandler2.prototype.handleError = function (error) {
                throw new Error(error);
            };
            return XMLDOMErrorHandler2;
        }();
    }).call(XMLDOMErrorHandler);
    return XMLDOMErrorHandler$1.exports;
}
var XMLDOMStringList$1 = { exports: {} };
var XMLDOMStringList = XMLDOMStringList$1.exports;
var hasRequiredXMLDOMStringList;
function requireXMLDOMStringList() {
    if (hasRequiredXMLDOMStringList)
        return XMLDOMStringList$1.exports;
    hasRequiredXMLDOMStringList = 1;
    (function () {
        XMLDOMStringList$1.exports = function () {
            function XMLDOMStringList2(arr) {
                this.arr = arr || [];
            }
            Object.defineProperty(XMLDOMStringList2.prototype, "length", {
                get: function () {
                    return this.arr.length;
                }
            });
            XMLDOMStringList2.prototype.item = function (index) {
                return this.arr[index] || null;
            };
            XMLDOMStringList2.prototype.contains = function (str) {
                return this.arr.indexOf(str) !== -1;
            };
            return XMLDOMStringList2;
        }();
    }).call(XMLDOMStringList);
    return XMLDOMStringList$1.exports;
}
var XMLDOMConfiguration = XMLDOMConfiguration$1.exports;
var hasRequiredXMLDOMConfiguration;
function requireXMLDOMConfiguration() {
    if (hasRequiredXMLDOMConfiguration)
        return XMLDOMConfiguration$1.exports;
    hasRequiredXMLDOMConfiguration = 1;
    (function () {
        var XMLDOMErrorHandler2, XMLDOMStringList2;
        XMLDOMErrorHandler2 = requireXMLDOMErrorHandler();
        XMLDOMStringList2 = requireXMLDOMStringList();
        XMLDOMConfiguration$1.exports = function () {
            function XMLDOMConfiguration2() {
                this.defaultParams = {
                    "canonical-form": false,
                    "cdata-sections": false,
                    "comments": false,
                    "datatype-normalization": false,
                    "element-content-whitespace": true,
                    "entities": true,
                    "error-handler": new XMLDOMErrorHandler2(),
                    "infoset": true,
                    "validate-if-schema": false,
                    "namespaces": true,
                    "namespace-declarations": true,
                    "normalize-characters": false,
                    "schema-location": "",
                    "schema-type": "",
                    "split-cdata-sections": true,
                    "validate": false,
                    "well-formed": true
                };
                this.params = Object.create(this.defaultParams);
            }
            Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
                get: function () {
                    return new XMLDOMStringList2(Object.keys(this.defaultParams));
                }
            });
            XMLDOMConfiguration2.prototype.getParameter = function (name) {
                if (this.params.hasOwnProperty(name)) {
                    return this.params[name];
                }
                else {
                    return null;
                }
            };
            XMLDOMConfiguration2.prototype.canSetParameter = function (name, value) {
                return true;
            };
            XMLDOMConfiguration2.prototype.setParameter = function (name, value) {
                if (value != null) {
                    return this.params[name] = value;
                }
                else {
                    return delete this.params[name];
                }
            };
            return XMLDOMConfiguration2;
        }();
    }).call(XMLDOMConfiguration);
    return XMLDOMConfiguration$1.exports;
}
var XMLNode$1 = { exports: {} };
var XMLElement$1 = { exports: {} };
var NodeType$1 = { exports: {} };
var NodeType = NodeType$1.exports;
var hasRequiredNodeType;
function requireNodeType() {
    if (hasRequiredNodeType)
        return NodeType$1.exports;
    hasRequiredNodeType = 1;
    (function () {
        NodeType$1.exports = {
            Element: 1,
            Attribute: 2,
            Text: 3,
            CData: 4,
            EntityReference: 5,
            EntityDeclaration: 6,
            ProcessingInstruction: 7,
            Comment: 8,
            Document: 9,
            DocType: 10,
            DocumentFragment: 11,
            NotationDeclaration: 12,
            Declaration: 201,
            Raw: 202,
            AttributeDeclaration: 203,
            ElementDeclaration: 204,
            Dummy: 205
        };
    }).call(NodeType);
    return NodeType$1.exports;
}
var XMLAttribute$1 = { exports: {} };
var XMLAttribute = XMLAttribute$1.exports;
var hasRequiredXMLAttribute;
function requireXMLAttribute() {
    if (hasRequiredXMLAttribute)
        return XMLAttribute$1.exports;
    hasRequiredXMLAttribute = 1;
    (function () {
        var NodeType2;
        NodeType2 = requireNodeType();
        requireXMLNode();
        XMLAttribute$1.exports = function () {
            function XMLAttribute2(parent, name, value) {
                this.parent = parent;
                if (this.parent) {
                    this.options = this.parent.options;
                    this.stringify = this.parent.stringify;
                }
                if (name == null) {
                    throw new Error("Missing attribute name. " + this.debugInfo(name));
                }
                this.name = this.stringify.name(name);
                this.value = this.stringify.attValue(value);
                this.type = NodeType2.Attribute;
                this.isId = false;
                this.schemaTypeInfo = null;
            }
            Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
                get: function () {
                    return this.type;
                }
            });
            Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
                get: function () {
                    return this.parent;
                }
            });
            Object.defineProperty(XMLAttribute2.prototype, "textContent", {
                get: function () {
                    return this.value;
                },
                set: function (value) {
                    return this.value = value || "";
                }
            });
            Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
                get: function () {
                    return "";
                }
            });
            Object.defineProperty(XMLAttribute2.prototype, "prefix", {
                get: function () {
                    return "";
                }
            });
            Object.defineProperty(XMLAttribute2.prototype, "localName", {
                get: function () {
                    return this.name;
                }
            });
            Object.defineProperty(XMLAttribute2.prototype, "specified", {
                get: function () {
                    return true;
                }
            });
            XMLAttribute2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLAttribute2.prototype.toString = function (options2) {
                return this.options.writer.attribute(this, this.options.writer.filterOptions(options2));
            };
            XMLAttribute2.prototype.debugInfo = function (name) {
                name = name || this.name;
                if (name == null) {
                    return "parent: <" + this.parent.name + ">";
                }
                else {
                    return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
                }
            };
            XMLAttribute2.prototype.isEqualNode = function (node2) {
                if (node2.namespaceURI !== this.namespaceURI) {
                    return false;
                }
                if (node2.prefix !== this.prefix) {
                    return false;
                }
                if (node2.localName !== this.localName) {
                    return false;
                }
                if (node2.value !== this.value) {
                    return false;
                }
                return true;
            };
            return XMLAttribute2;
        }();
    }).call(XMLAttribute);
    return XMLAttribute$1.exports;
}
var XMLNamedNodeMap$1 = { exports: {} };
var XMLNamedNodeMap = XMLNamedNodeMap$1.exports;
var hasRequiredXMLNamedNodeMap;
function requireXMLNamedNodeMap() {
    if (hasRequiredXMLNamedNodeMap)
        return XMLNamedNodeMap$1.exports;
    hasRequiredXMLNamedNodeMap = 1;
    (function () {
        XMLNamedNodeMap$1.exports = function () {
            function XMLNamedNodeMap2(nodes) {
                this.nodes = nodes;
            }
            Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
                get: function () {
                    return Object.keys(this.nodes).length || 0;
                }
            });
            XMLNamedNodeMap2.prototype.clone = function () {
                return this.nodes = null;
            };
            XMLNamedNodeMap2.prototype.getNamedItem = function (name) {
                return this.nodes[name];
            };
            XMLNamedNodeMap2.prototype.setNamedItem = function (node2) {
                var oldNode;
                oldNode = this.nodes[node2.nodeName];
                this.nodes[node2.nodeName] = node2;
                return oldNode || null;
            };
            XMLNamedNodeMap2.prototype.removeNamedItem = function (name) {
                var oldNode;
                oldNode = this.nodes[name];
                delete this.nodes[name];
                return oldNode || null;
            };
            XMLNamedNodeMap2.prototype.item = function (index) {
                return this.nodes[Object.keys(this.nodes)[index]] || null;
            };
            XMLNamedNodeMap2.prototype.getNamedItemNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented.");
            };
            XMLNamedNodeMap2.prototype.setNamedItemNS = function (node2) {
                throw new Error("This DOM method is not implemented.");
            };
            XMLNamedNodeMap2.prototype.removeNamedItemNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented.");
            };
            return XMLNamedNodeMap2;
        }();
    }).call(XMLNamedNodeMap);
    return XMLNamedNodeMap$1.exports;
}
var XMLElement = XMLElement$1.exports;
var hasRequiredXMLElement;
function requireXMLElement() {
    if (hasRequiredXMLElement)
        return XMLElement$1.exports;
    hasRequiredXMLElement = 1;
    (function () {
        var NodeType2, XMLAttribute2, XMLNamedNodeMap2, XMLNode2, getValue, isFunction, isObject, ref2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        ref2 = requireUtility(), isObject = ref2.isObject, isFunction = ref2.isFunction, getValue = ref2.getValue;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLAttribute2 = requireXMLAttribute();
        XMLNamedNodeMap2 = requireXMLNamedNodeMap();
        XMLElement$1.exports = function (superClass) {
            extend(XMLElement2, superClass);
            function XMLElement2(parent, name, attributes) {
                var child, j, len, ref1;
                XMLElement2.__super__.constructor.call(this, parent);
                if (name == null) {
                    throw new Error("Missing element name. " + this.debugInfo());
                }
                this.name = this.stringify.name(name);
                this.type = NodeType2.Element;
                this.attribs = {};
                this.schemaTypeInfo = null;
                if (attributes != null) {
                    this.attribute(attributes);
                }
                if (parent.type === NodeType2.Document) {
                    this.isRoot = true;
                    this.documentObject = parent;
                    parent.rootObject = this;
                    if (parent.children) {
                        ref1 = parent.children;
                        for (j = 0, len = ref1.length; j < len; j++) {
                            child = ref1[j];
                            if (child.type === NodeType2.DocType) {
                                child.name = this.name;
                                break;
                            }
                        }
                    }
                }
            }
            Object.defineProperty(XMLElement2.prototype, "tagName", {
                get: function () {
                    return this.name;
                }
            });
            Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
                get: function () {
                    return "";
                }
            });
            Object.defineProperty(XMLElement2.prototype, "prefix", {
                get: function () {
                    return "";
                }
            });
            Object.defineProperty(XMLElement2.prototype, "localName", {
                get: function () {
                    return this.name;
                }
            });
            Object.defineProperty(XMLElement2.prototype, "id", {
                get: function () {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                }
            });
            Object.defineProperty(XMLElement2.prototype, "className", {
                get: function () {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                }
            });
            Object.defineProperty(XMLElement2.prototype, "classList", {
                get: function () {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                }
            });
            Object.defineProperty(XMLElement2.prototype, "attributes", {
                get: function () {
                    if (!this.attributeMap || !this.attributeMap.nodes) {
                        this.attributeMap = new XMLNamedNodeMap2(this.attribs);
                    }
                    return this.attributeMap;
                }
            });
            XMLElement2.prototype.clone = function () {
                var att, attName, clonedSelf, ref1;
                clonedSelf = Object.create(this);
                if (clonedSelf.isRoot) {
                    clonedSelf.documentObject = null;
                }
                clonedSelf.attribs = {};
                ref1 = this.attribs;
                for (attName in ref1) {
                    if (!hasProp.call(ref1, attName))
                        continue;
                    att = ref1[attName];
                    clonedSelf.attribs[attName] = att.clone();
                }
                clonedSelf.children = [];
                this.children.forEach(function (child) {
                    var clonedChild;
                    clonedChild = child.clone();
                    clonedChild.parent = clonedSelf;
                    return clonedSelf.children.push(clonedChild);
                });
                return clonedSelf;
            };
            XMLElement2.prototype.attribute = function (name, value) {
                var attName, attValue;
                if (name != null) {
                    name = getValue(name);
                }
                if (isObject(name)) {
                    for (attName in name) {
                        if (!hasProp.call(name, attName))
                            continue;
                        attValue = name[attName];
                        this.attribute(attName, attValue);
                    }
                }
                else {
                    if (isFunction(value)) {
                        value = value.apply();
                    }
                    if (this.options.keepNullAttributes && value == null) {
                        this.attribs[name] = new XMLAttribute2(this, name, "");
                    }
                    else if (value != null) {
                        this.attribs[name] = new XMLAttribute2(this, name, value);
                    }
                }
                return this;
            };
            XMLElement2.prototype.removeAttribute = function (name) {
                var attName, j, len;
                if (name == null) {
                    throw new Error("Missing attribute name. " + this.debugInfo());
                }
                name = getValue(name);
                if (Array.isArray(name)) {
                    for (j = 0, len = name.length; j < len; j++) {
                        attName = name[j];
                        delete this.attribs[attName];
                    }
                }
                else {
                    delete this.attribs[name];
                }
                return this;
            };
            XMLElement2.prototype.toString = function (options2) {
                return this.options.writer.element(this, this.options.writer.filterOptions(options2));
            };
            XMLElement2.prototype.att = function (name, value) {
                return this.attribute(name, value);
            };
            XMLElement2.prototype.a = function (name, value) {
                return this.attribute(name, value);
            };
            XMLElement2.prototype.getAttribute = function (name) {
                if (this.attribs.hasOwnProperty(name)) {
                    return this.attribs[name].value;
                }
                else {
                    return null;
                }
            };
            XMLElement2.prototype.setAttribute = function (name, value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getAttributeNode = function (name) {
                if (this.attribs.hasOwnProperty(name)) {
                    return this.attribs[name];
                }
                else {
                    return null;
                }
            };
            XMLElement2.prototype.setAttributeNode = function (newAttr) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.removeAttributeNode = function (oldAttr) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getElementsByTagName = function (name) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getAttributeNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.setAttributeNS = function (namespaceURI, qualifiedName, value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.removeAttributeNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getAttributeNodeNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.setAttributeNodeNS = function (newAttr) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.hasAttribute = function (name) {
                return this.attribs.hasOwnProperty(name);
            };
            XMLElement2.prototype.hasAttributeNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.setIdAttribute = function (name, isId) {
                if (this.attribs.hasOwnProperty(name)) {
                    return this.attribs[name].isId;
                }
                else {
                    return isId;
                }
            };
            XMLElement2.prototype.setIdAttributeNS = function (namespaceURI, localName, isId) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.setIdAttributeNode = function (idAttr, isId) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getElementsByTagName = function (tagname) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.getElementsByClassName = function (classNames) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement2.prototype.isEqualNode = function (node2) {
                var i, j, ref1;
                if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                    return false;
                }
                if (node2.namespaceURI !== this.namespaceURI) {
                    return false;
                }
                if (node2.prefix !== this.prefix) {
                    return false;
                }
                if (node2.localName !== this.localName) {
                    return false;
                }
                if (node2.attribs.length !== this.attribs.length) {
                    return false;
                }
                for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
                    if (!this.attribs[i].isEqualNode(node2.attribs[i])) {
                        return false;
                    }
                }
                return true;
            };
            return XMLElement2;
        }(XMLNode2);
    }).call(XMLElement);
    return XMLElement$1.exports;
}
var XMLCData$1 = { exports: {} };
var XMLCharacterData$1 = { exports: {} };
var XMLCharacterData = XMLCharacterData$1.exports;
var hasRequiredXMLCharacterData;
function requireXMLCharacterData() {
    if (hasRequiredXMLCharacterData)
        return XMLCharacterData$1.exports;
    hasRequiredXMLCharacterData = 1;
    (function () {
        var XMLNode2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode2 = requireXMLNode();
        XMLCharacterData$1.exports = function (superClass) {
            extend(XMLCharacterData2, superClass);
            function XMLCharacterData2(parent) {
                XMLCharacterData2.__super__.constructor.call(this, parent);
                this.value = "";
            }
            Object.defineProperty(XMLCharacterData2.prototype, "data", {
                get: function () {
                    return this.value;
                },
                set: function (value) {
                    return this.value = value || "";
                }
            });
            Object.defineProperty(XMLCharacterData2.prototype, "length", {
                get: function () {
                    return this.value.length;
                }
            });
            Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
                get: function () {
                    return this.value;
                },
                set: function (value) {
                    return this.value = value || "";
                }
            });
            XMLCharacterData2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLCharacterData2.prototype.substringData = function (offset, count) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData2.prototype.appendData = function (arg) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData2.prototype.insertData = function (offset, arg) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData2.prototype.deleteData = function (offset, count) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData2.prototype.replaceData = function (offset, count, arg) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData2.prototype.isEqualNode = function (node2) {
                if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                    return false;
                }
                if (node2.data !== this.data) {
                    return false;
                }
                return true;
            };
            return XMLCharacterData2;
        }(XMLNode2);
    }).call(XMLCharacterData);
    return XMLCharacterData$1.exports;
}
var XMLCData = XMLCData$1.exports;
var hasRequiredXMLCData;
function requireXMLCData() {
    if (hasRequiredXMLCData)
        return XMLCData$1.exports;
    hasRequiredXMLCData = 1;
    (function () {
        var NodeType2, XMLCharacterData2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = requireNodeType();
        XMLCharacterData2 = requireXMLCharacterData();
        XMLCData$1.exports = function (superClass) {
            extend(XMLCData2, superClass);
            function XMLCData2(parent, text) {
                XMLCData2.__super__.constructor.call(this, parent);
                if (text == null) {
                    throw new Error("Missing CDATA text. " + this.debugInfo());
                }
                this.name = "#cdata-section";
                this.type = NodeType2.CData;
                this.value = this.stringify.cdata(text);
            }
            XMLCData2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLCData2.prototype.toString = function (options2) {
                return this.options.writer.cdata(this, this.options.writer.filterOptions(options2));
            };
            return XMLCData2;
        }(XMLCharacterData2);
    }).call(XMLCData);
    return XMLCData$1.exports;
}
var XMLComment$1 = { exports: {} };
var XMLComment = XMLComment$1.exports;
var hasRequiredXMLComment;
function requireXMLComment() {
    if (hasRequiredXMLComment)
        return XMLComment$1.exports;
    hasRequiredXMLComment = 1;
    (function () {
        var NodeType2, XMLCharacterData2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = requireNodeType();
        XMLCharacterData2 = requireXMLCharacterData();
        XMLComment$1.exports = function (superClass) {
            extend(XMLComment2, superClass);
            function XMLComment2(parent, text) {
                XMLComment2.__super__.constructor.call(this, parent);
                if (text == null) {
                    throw new Error("Missing comment text. " + this.debugInfo());
                }
                this.name = "#comment";
                this.type = NodeType2.Comment;
                this.value = this.stringify.comment(text);
            }
            XMLComment2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLComment2.prototype.toString = function (options2) {
                return this.options.writer.comment(this, this.options.writer.filterOptions(options2));
            };
            return XMLComment2;
        }(XMLCharacterData2);
    }).call(XMLComment);
    return XMLComment$1.exports;
}
var XMLDeclaration$1 = { exports: {} };
var XMLDeclaration = XMLDeclaration$1.exports;
var hasRequiredXMLDeclaration;
function requireXMLDeclaration() {
    if (hasRequiredXMLDeclaration)
        return XMLDeclaration$1.exports;
    hasRequiredXMLDeclaration = 1;
    (function () {
        var NodeType2, XMLNode2, isObject, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = requireUtility().isObject;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDeclaration$1.exports = function (superClass) {
            extend(XMLDeclaration2, superClass);
            function XMLDeclaration2(parent, version, encoding, standalone) {
                var ref2;
                XMLDeclaration2.__super__.constructor.call(this, parent);
                if (isObject(version)) {
                    ref2 = version, version = ref2.version, encoding = ref2.encoding, standalone = ref2.standalone;
                }
                if (!version) {
                    version = "1.0";
                }
                this.type = NodeType2.Declaration;
                this.version = this.stringify.xmlVersion(version);
                if (encoding != null) {
                    this.encoding = this.stringify.xmlEncoding(encoding);
                }
                if (standalone != null) {
                    this.standalone = this.stringify.xmlStandalone(standalone);
                }
            }
            XMLDeclaration2.prototype.toString = function (options2) {
                return this.options.writer.declaration(this, this.options.writer.filterOptions(options2));
            };
            return XMLDeclaration2;
        }(XMLNode2);
    }).call(XMLDeclaration);
    return XMLDeclaration$1.exports;
}
var XMLDocType$1 = { exports: {} };
var XMLDTDAttList$1 = { exports: {} };
var XMLDTDAttList = XMLDTDAttList$1.exports;
var hasRequiredXMLDTDAttList;
function requireXMLDTDAttList() {
    if (hasRequiredXMLDTDAttList)
        return XMLDTDAttList$1.exports;
    hasRequiredXMLDTDAttList = 1;
    (function () {
        var NodeType2, XMLNode2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDTDAttList$1.exports = function (superClass) {
            extend(XMLDTDAttList2, superClass);
            function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                XMLDTDAttList2.__super__.constructor.call(this, parent);
                if (elementName == null) {
                    throw new Error("Missing DTD element name. " + this.debugInfo());
                }
                if (attributeName == null) {
                    throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
                }
                if (!attributeType) {
                    throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
                }
                if (!defaultValueType) {
                    throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
                }
                if (defaultValueType.indexOf("#") !== 0) {
                    defaultValueType = "#" + defaultValueType;
                }
                if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
                    throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
                }
                if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
                    throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
                }
                this.elementName = this.stringify.name(elementName);
                this.type = NodeType2.AttributeDeclaration;
                this.attributeName = this.stringify.name(attributeName);
                this.attributeType = this.stringify.dtdAttType(attributeType);
                if (defaultValue) {
                    this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
                }
                this.defaultValueType = defaultValueType;
            }
            XMLDTDAttList2.prototype.toString = function (options2) {
                return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options2));
            };
            return XMLDTDAttList2;
        }(XMLNode2);
    }).call(XMLDTDAttList);
    return XMLDTDAttList$1.exports;
}
var XMLDTDEntity$1 = { exports: {} };
var XMLDTDEntity = XMLDTDEntity$1.exports;
var hasRequiredXMLDTDEntity;
function requireXMLDTDEntity() {
    if (hasRequiredXMLDTDEntity)
        return XMLDTDEntity$1.exports;
    hasRequiredXMLDTDEntity = 1;
    (function () {
        var NodeType2, XMLNode2, isObject, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = requireUtility().isObject;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDTDEntity$1.exports = function (superClass) {
            extend(XMLDTDEntity2, superClass);
            function XMLDTDEntity2(parent, pe, name, value) {
                XMLDTDEntity2.__super__.constructor.call(this, parent);
                if (name == null) {
                    throw new Error("Missing DTD entity name. " + this.debugInfo(name));
                }
                if (value == null) {
                    throw new Error("Missing DTD entity value. " + this.debugInfo(name));
                }
                this.pe = !!pe;
                this.name = this.stringify.name(name);
                this.type = NodeType2.EntityDeclaration;
                if (!isObject(value)) {
                    this.value = this.stringify.dtdEntityValue(value);
                    this.internal = true;
                }
                else {
                    if (!value.pubID && !value.sysID) {
                        throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                    }
                    if (value.pubID && !value.sysID) {
                        throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                    }
                    this.internal = false;
                    if (value.pubID != null) {
                        this.pubID = this.stringify.dtdPubID(value.pubID);
                    }
                    if (value.sysID != null) {
                        this.sysID = this.stringify.dtdSysID(value.sysID);
                    }
                    if (value.nData != null) {
                        this.nData = this.stringify.dtdNData(value.nData);
                    }
                    if (this.pe && this.nData) {
                        throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
                    }
                }
            }
            Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
                get: function () {
                    return this.pubID;
                }
            });
            Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
                get: function () {
                    return this.sysID;
                }
            });
            Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
                get: function () {
                    return this.nData || null;
                }
            });
            Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
                get: function () {
                    return null;
                }
            });
            Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
                get: function () {
                    return null;
                }
            });
            Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
                get: function () {
                    return null;
                }
            });
            XMLDTDEntity2.prototype.toString = function (options2) {
                return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options2));
            };
            return XMLDTDEntity2;
        }(XMLNode2);
    }).call(XMLDTDEntity);
    return XMLDTDEntity$1.exports;
}
var XMLDTDElement$1 = { exports: {} };
var XMLDTDElement = XMLDTDElement$1.exports;
var hasRequiredXMLDTDElement;
function requireXMLDTDElement() {
    if (hasRequiredXMLDTDElement)
        return XMLDTDElement$1.exports;
    hasRequiredXMLDTDElement = 1;
    (function () {
        var NodeType2, XMLNode2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDTDElement$1.exports = function (superClass) {
            extend(XMLDTDElement2, superClass);
            function XMLDTDElement2(parent, name, value) {
                XMLDTDElement2.__super__.constructor.call(this, parent);
                if (name == null) {
                    throw new Error("Missing DTD element name. " + this.debugInfo());
                }
                if (!value) {
                    value = "(#PCDATA)";
                }
                if (Array.isArray(value)) {
                    value = "(" + value.join(",") + ")";
                }
                this.name = this.stringify.name(name);
                this.type = NodeType2.ElementDeclaration;
                this.value = this.stringify.dtdElementValue(value);
            }
            XMLDTDElement2.prototype.toString = function (options2) {
                return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options2));
            };
            return XMLDTDElement2;
        }(XMLNode2);
    }).call(XMLDTDElement);
    return XMLDTDElement$1.exports;
}
var XMLDTDNotation$1 = { exports: {} };
var XMLDTDNotation = XMLDTDNotation$1.exports;
var hasRequiredXMLDTDNotation;
function requireXMLDTDNotation() {
    if (hasRequiredXMLDTDNotation)
        return XMLDTDNotation$1.exports;
    hasRequiredXMLDTDNotation = 1;
    (function () {
        var NodeType2, XMLNode2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDTDNotation$1.exports = function (superClass) {
            extend(XMLDTDNotation2, superClass);
            function XMLDTDNotation2(parent, name, value) {
                XMLDTDNotation2.__super__.constructor.call(this, parent);
                if (name == null) {
                    throw new Error("Missing DTD notation name. " + this.debugInfo(name));
                }
                if (!value.pubID && !value.sysID) {
                    throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
                }
                this.name = this.stringify.name(name);
                this.type = NodeType2.NotationDeclaration;
                if (value.pubID != null) {
                    this.pubID = this.stringify.dtdPubID(value.pubID);
                }
                if (value.sysID != null) {
                    this.sysID = this.stringify.dtdSysID(value.sysID);
                }
            }
            Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
                get: function () {
                    return this.pubID;
                }
            });
            Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
                get: function () {
                    return this.sysID;
                }
            });
            XMLDTDNotation2.prototype.toString = function (options2) {
                return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options2));
            };
            return XMLDTDNotation2;
        }(XMLNode2);
    }).call(XMLDTDNotation);
    return XMLDTDNotation$1.exports;
}
var XMLDocType = XMLDocType$1.exports;
var hasRequiredXMLDocType;
function requireXMLDocType() {
    if (hasRequiredXMLDocType)
        return XMLDocType$1.exports;
    hasRequiredXMLDocType = 1;
    (function () {
        var NodeType2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLNamedNodeMap2, XMLNode2, isObject, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = requireUtility().isObject;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDTDAttList2 = requireXMLDTDAttList();
        XMLDTDEntity2 = requireXMLDTDEntity();
        XMLDTDElement2 = requireXMLDTDElement();
        XMLDTDNotation2 = requireXMLDTDNotation();
        XMLNamedNodeMap2 = requireXMLNamedNodeMap();
        XMLDocType$1.exports = function (superClass) {
            extend(XMLDocType2, superClass);
            function XMLDocType2(parent, pubID, sysID) {
                var child, i, len, ref2, ref1, ref22;
                XMLDocType2.__super__.constructor.call(this, parent);
                this.type = NodeType2.DocType;
                if (parent.children) {
                    ref2 = parent.children;
                    for (i = 0, len = ref2.length; i < len; i++) {
                        child = ref2[i];
                        if (child.type === NodeType2.Element) {
                            this.name = child.name;
                            break;
                        }
                    }
                }
                this.documentObject = parent;
                if (isObject(pubID)) {
                    ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
                }
                if (sysID == null) {
                    ref22 = [pubID, sysID], sysID = ref22[0], pubID = ref22[1];
                }
                if (pubID != null) {
                    this.pubID = this.stringify.dtdPubID(pubID);
                }
                if (sysID != null) {
                    this.sysID = this.stringify.dtdSysID(sysID);
                }
            }
            Object.defineProperty(XMLDocType2.prototype, "entities", {
                get: function () {
                    var child, i, len, nodes, ref2;
                    nodes = {};
                    ref2 = this.children;
                    for (i = 0, len = ref2.length; i < len; i++) {
                        child = ref2[i];
                        if (child.type === NodeType2.EntityDeclaration && !child.pe) {
                            nodes[child.name] = child;
                        }
                    }
                    return new XMLNamedNodeMap2(nodes);
                }
            });
            Object.defineProperty(XMLDocType2.prototype, "notations", {
                get: function () {
                    var child, i, len, nodes, ref2;
                    nodes = {};
                    ref2 = this.children;
                    for (i = 0, len = ref2.length; i < len; i++) {
                        child = ref2[i];
                        if (child.type === NodeType2.NotationDeclaration) {
                            nodes[child.name] = child;
                        }
                    }
                    return new XMLNamedNodeMap2(nodes);
                }
            });
            Object.defineProperty(XMLDocType2.prototype, "publicId", {
                get: function () {
                    return this.pubID;
                }
            });
            Object.defineProperty(XMLDocType2.prototype, "systemId", {
                get: function () {
                    return this.sysID;
                }
            });
            Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
                get: function () {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                }
            });
            XMLDocType2.prototype.element = function (name, value) {
                var child;
                child = new XMLDTDElement2(this, name, value);
                this.children.push(child);
                return this;
            };
            XMLDocType2.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                var child;
                child = new XMLDTDAttList2(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                this.children.push(child);
                return this;
            };
            XMLDocType2.prototype.entity = function (name, value) {
                var child;
                child = new XMLDTDEntity2(this, false, name, value);
                this.children.push(child);
                return this;
            };
            XMLDocType2.prototype.pEntity = function (name, value) {
                var child;
                child = new XMLDTDEntity2(this, true, name, value);
                this.children.push(child);
                return this;
            };
            XMLDocType2.prototype.notation = function (name, value) {
                var child;
                child = new XMLDTDNotation2(this, name, value);
                this.children.push(child);
                return this;
            };
            XMLDocType2.prototype.toString = function (options2) {
                return this.options.writer.docType(this, this.options.writer.filterOptions(options2));
            };
            XMLDocType2.prototype.ele = function (name, value) {
                return this.element(name, value);
            };
            XMLDocType2.prototype.att = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
            };
            XMLDocType2.prototype.ent = function (name, value) {
                return this.entity(name, value);
            };
            XMLDocType2.prototype.pent = function (name, value) {
                return this.pEntity(name, value);
            };
            XMLDocType2.prototype.not = function (name, value) {
                return this.notation(name, value);
            };
            XMLDocType2.prototype.up = function () {
                return this.root() || this.documentObject;
            };
            XMLDocType2.prototype.isEqualNode = function (node2) {
                if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                    return false;
                }
                if (node2.name !== this.name) {
                    return false;
                }
                if (node2.publicId !== this.publicId) {
                    return false;
                }
                if (node2.systemId !== this.systemId) {
                    return false;
                }
                return true;
            };
            return XMLDocType2;
        }(XMLNode2);
    }).call(XMLDocType);
    return XMLDocType$1.exports;
}
var XMLRaw$1 = { exports: {} };
var XMLRaw = XMLRaw$1.exports;
var hasRequiredXMLRaw;
function requireXMLRaw() {
    if (hasRequiredXMLRaw)
        return XMLRaw$1.exports;
    hasRequiredXMLRaw = 1;
    (function () {
        var NodeType2, XMLNode2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = requireNodeType();
        XMLNode2 = requireXMLNode();
        XMLRaw$1.exports = function (superClass) {
            extend(XMLRaw2, superClass);
            function XMLRaw2(parent, text) {
                XMLRaw2.__super__.constructor.call(this, parent);
                if (text == null) {
                    throw new Error("Missing raw text. " + this.debugInfo());
                }
                this.type = NodeType2.Raw;
                this.value = this.stringify.raw(text);
            }
            XMLRaw2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLRaw2.prototype.toString = function (options2) {
                return this.options.writer.raw(this, this.options.writer.filterOptions(options2));
            };
            return XMLRaw2;
        }(XMLNode2);
    }).call(XMLRaw);
    return XMLRaw$1.exports;
}
var XMLText$1 = { exports: {} };
var XMLText = XMLText$1.exports;
var hasRequiredXMLText;
function requireXMLText() {
    if (hasRequiredXMLText)
        return XMLText$1.exports;
    hasRequiredXMLText = 1;
    (function () {
        var NodeType2, XMLCharacterData2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = requireNodeType();
        XMLCharacterData2 = requireXMLCharacterData();
        XMLText$1.exports = function (superClass) {
            extend(XMLText2, superClass);
            function XMLText2(parent, text) {
                XMLText2.__super__.constructor.call(this, parent);
                if (text == null) {
                    throw new Error("Missing element text. " + this.debugInfo());
                }
                this.name = "#text";
                this.type = NodeType2.Text;
                this.value = this.stringify.text(text);
            }
            Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
                get: function () {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                }
            });
            Object.defineProperty(XMLText2.prototype, "wholeText", {
                get: function () {
                    var next, prev, str;
                    str = "";
                    prev = this.previousSibling;
                    while (prev) {
                        str = prev.data + str;
                        prev = prev.previousSibling;
                    }
                    str += this.data;
                    next = this.nextSibling;
                    while (next) {
                        str = str + next.data;
                        next = next.nextSibling;
                    }
                    return str;
                }
            });
            XMLText2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLText2.prototype.toString = function (options2) {
                return this.options.writer.text(this, this.options.writer.filterOptions(options2));
            };
            XMLText2.prototype.splitText = function (offset) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLText2.prototype.replaceWholeText = function (content) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            return XMLText2;
        }(XMLCharacterData2);
    }).call(XMLText);
    return XMLText$1.exports;
}
var XMLProcessingInstruction$1 = { exports: {} };
var XMLProcessingInstruction = XMLProcessingInstruction$1.exports;
var hasRequiredXMLProcessingInstruction;
function requireXMLProcessingInstruction() {
    if (hasRequiredXMLProcessingInstruction)
        return XMLProcessingInstruction$1.exports;
    hasRequiredXMLProcessingInstruction = 1;
    (function () {
        var NodeType2, XMLCharacterData2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = requireNodeType();
        XMLCharacterData2 = requireXMLCharacterData();
        XMLProcessingInstruction$1.exports = function (superClass) {
            extend(XMLProcessingInstruction2, superClass);
            function XMLProcessingInstruction2(parent, target, value) {
                XMLProcessingInstruction2.__super__.constructor.call(this, parent);
                if (target == null) {
                    throw new Error("Missing instruction target. " + this.debugInfo());
                }
                this.type = NodeType2.ProcessingInstruction;
                this.target = this.stringify.insTarget(target);
                this.name = this.target;
                if (value) {
                    this.value = this.stringify.insValue(value);
                }
            }
            XMLProcessingInstruction2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLProcessingInstruction2.prototype.toString = function (options2) {
                return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options2));
            };
            XMLProcessingInstruction2.prototype.isEqualNode = function (node2) {
                if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                    return false;
                }
                if (node2.target !== this.target) {
                    return false;
                }
                return true;
            };
            return XMLProcessingInstruction2;
        }(XMLCharacterData2);
    }).call(XMLProcessingInstruction);
    return XMLProcessingInstruction$1.exports;
}
var XMLDummy$1 = { exports: {} };
var XMLDummy = XMLDummy$1.exports;
var hasRequiredXMLDummy;
function requireXMLDummy() {
    if (hasRequiredXMLDummy)
        return XMLDummy$1.exports;
    hasRequiredXMLDummy = 1;
    (function () {
        var NodeType2, XMLNode2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLDummy$1.exports = function (superClass) {
            extend(XMLDummy2, superClass);
            function XMLDummy2(parent) {
                XMLDummy2.__super__.constructor.call(this, parent);
                this.type = NodeType2.Dummy;
            }
            XMLDummy2.prototype.clone = function () {
                return Object.create(this);
            };
            XMLDummy2.prototype.toString = function (options2) {
                return "";
            };
            return XMLDummy2;
        }(XMLNode2);
    }).call(XMLDummy);
    return XMLDummy$1.exports;
}
var XMLNodeList$1 = { exports: {} };
var XMLNodeList = XMLNodeList$1.exports;
var hasRequiredXMLNodeList;
function requireXMLNodeList() {
    if (hasRequiredXMLNodeList)
        return XMLNodeList$1.exports;
    hasRequiredXMLNodeList = 1;
    (function () {
        XMLNodeList$1.exports = function () {
            function XMLNodeList2(nodes) {
                this.nodes = nodes;
            }
            Object.defineProperty(XMLNodeList2.prototype, "length", {
                get: function () {
                    return this.nodes.length || 0;
                }
            });
            XMLNodeList2.prototype.clone = function () {
                return this.nodes = null;
            };
            XMLNodeList2.prototype.item = function (index) {
                return this.nodes[index] || null;
            };
            return XMLNodeList2;
        }();
    }).call(XMLNodeList);
    return XMLNodeList$1.exports;
}
var DocumentPosition$1 = { exports: {} };
var DocumentPosition = DocumentPosition$1.exports;
var hasRequiredDocumentPosition;
function requireDocumentPosition() {
    if (hasRequiredDocumentPosition)
        return DocumentPosition$1.exports;
    hasRequiredDocumentPosition = 1;
    (function () {
        DocumentPosition$1.exports = {
            Disconnected: 1,
            Preceding: 2,
            Following: 4,
            Contains: 8,
            ContainedBy: 16,
            ImplementationSpecific: 32
        };
    }).call(DocumentPosition);
    return DocumentPosition$1.exports;
}
var XMLNode = XMLNode$1.exports;
var hasRequiredXMLNode;
function requireXMLNode() {
    if (hasRequiredXMLNode)
        return XMLNode$1.exports;
    hasRequiredXMLNode = 1;
    (function () {
        var DocumentPosition2, NodeType2, XMLCData2, XMLComment2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLNodeList2, XMLProcessingInstruction2, XMLRaw2, XMLText2, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
        ref1 = requireUtility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
        XMLElement2 = null;
        XMLCData2 = null;
        XMLComment2 = null;
        XMLDeclaration2 = null;
        XMLDocType2 = null;
        XMLRaw2 = null;
        XMLText2 = null;
        XMLProcessingInstruction2 = null;
        XMLDummy2 = null;
        NodeType2 = null;
        XMLNodeList2 = null;
        DocumentPosition2 = null;
        XMLNode$1.exports = function () {
            function XMLNode2(parent1) {
                this.parent = parent1;
                if (this.parent) {
                    this.options = this.parent.options;
                    this.stringify = this.parent.stringify;
                }
                this.value = null;
                this.children = [];
                this.baseURI = null;
                if (!XMLElement2) {
                    XMLElement2 = requireXMLElement();
                    XMLCData2 = requireXMLCData();
                    XMLComment2 = requireXMLComment();
                    XMLDeclaration2 = requireXMLDeclaration();
                    XMLDocType2 = requireXMLDocType();
                    XMLRaw2 = requireXMLRaw();
                    XMLText2 = requireXMLText();
                    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
                    XMLDummy2 = requireXMLDummy();
                    NodeType2 = requireNodeType();
                    XMLNodeList2 = requireXMLNodeList();
                    requireXMLNamedNodeMap();
                    DocumentPosition2 = requireDocumentPosition();
                }
            }
            Object.defineProperty(XMLNode2.prototype, "nodeName", {
                get: function () {
                    return this.name;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "nodeType", {
                get: function () {
                    return this.type;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "nodeValue", {
                get: function () {
                    return this.value;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "parentNode", {
                get: function () {
                    return this.parent;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "childNodes", {
                get: function () {
                    if (!this.childNodeList || !this.childNodeList.nodes) {
                        this.childNodeList = new XMLNodeList2(this.children);
                    }
                    return this.childNodeList;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "firstChild", {
                get: function () {
                    return this.children[0] || null;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "lastChild", {
                get: function () {
                    return this.children[this.children.length - 1] || null;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "previousSibling", {
                get: function () {
                    var i;
                    i = this.parent.children.indexOf(this);
                    return this.parent.children[i - 1] || null;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "nextSibling", {
                get: function () {
                    var i;
                    i = this.parent.children.indexOf(this);
                    return this.parent.children[i + 1] || null;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
                get: function () {
                    return this.document() || null;
                }
            });
            Object.defineProperty(XMLNode2.prototype, "textContent", {
                get: function () {
                    var child, j, len, ref2, str;
                    if (this.nodeType === NodeType2.Element || this.nodeType === NodeType2.DocumentFragment) {
                        str = "";
                        ref2 = this.children;
                        for (j = 0, len = ref2.length; j < len; j++) {
                            child = ref2[j];
                            if (child.textContent) {
                                str += child.textContent;
                            }
                        }
                        return str;
                    }
                    else {
                        return null;
                    }
                },
                set: function (value) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                }
            });
            XMLNode2.prototype.setParent = function (parent) {
                var child, j, len, ref2, results;
                this.parent = parent;
                if (parent) {
                    this.options = parent.options;
                    this.stringify = parent.stringify;
                }
                ref2 = this.children;
                results = [];
                for (j = 0, len = ref2.length; j < len; j++) {
                    child = ref2[j];
                    results.push(child.setParent(this));
                }
                return results;
            };
            XMLNode2.prototype.element = function (name, attributes, text) {
                var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val2;
                lastChild = null;
                if (attributes === null && text == null) {
                    ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
                }
                if (attributes == null) {
                    attributes = {};
                }
                attributes = getValue(attributes);
                if (!isObject(attributes)) {
                    ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
                }
                if (name != null) {
                    name = getValue(name);
                }
                if (Array.isArray(name)) {
                    for (j = 0, len = name.length; j < len; j++) {
                        item = name[j];
                        lastChild = this.element(item);
                    }
                }
                else if (isFunction(name)) {
                    lastChild = this.element(name.apply());
                }
                else if (isObject(name)) {
                    for (key in name) {
                        if (!hasProp.call(name, key))
                            continue;
                        val2 = name[key];
                        if (isFunction(val2)) {
                            val2 = val2.apply();
                        }
                        if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val2);
                        }
                        else if (!this.options.separateArrayItems && Array.isArray(val2) && isEmpty(val2)) {
                            lastChild = this.dummy();
                        }
                        else if (isObject(val2) && isEmpty(val2)) {
                            lastChild = this.element(key);
                        }
                        else if (!this.options.keepNullNodes && val2 == null) {
                            lastChild = this.dummy();
                        }
                        else if (!this.options.separateArrayItems && Array.isArray(val2)) {
                            for (k = 0, len1 = val2.length; k < len1; k++) {
                                item = val2[k];
                                childNode = {};
                                childNode[key] = item;
                                lastChild = this.element(childNode);
                            }
                        }
                        else if (isObject(val2)) {
                            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                                lastChild = this.element(val2);
                            }
                            else {
                                lastChild = this.element(key);
                                lastChild.element(val2);
                            }
                        }
                        else {
                            lastChild = this.element(key, val2);
                        }
                    }
                }
                else if (!this.options.keepNullNodes && text === null) {
                    lastChild = this.dummy();
                }
                else {
                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                        lastChild = this.text(text);
                    }
                    else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                        lastChild = this.cdata(text);
                    }
                    else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                        lastChild = this.comment(text);
                    }
                    else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                        lastChild = this.raw(text);
                    }
                    else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                        lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                    }
                    else {
                        lastChild = this.node(name, attributes, text);
                    }
                }
                if (lastChild == null) {
                    throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
                }
                return lastChild;
            };
            XMLNode2.prototype.insertBefore = function (name, attributes, text) {
                var child, i, newChild, refChild, removed;
                if (name != null ? name.type : void 0) {
                    newChild = name;
                    refChild = attributes;
                    newChild.setParent(this);
                    if (refChild) {
                        i = children.indexOf(refChild);
                        removed = children.splice(i);
                        children.push(newChild);
                        Array.prototype.push.apply(children, removed);
                    }
                    else {
                        children.push(newChild);
                    }
                    return newChild;
                }
                else {
                    if (this.isRoot) {
                        throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                    }
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i);
                    child = this.parent.element(name, attributes, text);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return child;
                }
            };
            XMLNode2.prototype.insertAfter = function (name, attributes, text) {
                var child, i, removed;
                if (this.isRoot) {
                    throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                }
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i + 1);
                child = this.parent.element(name, attributes, text);
                Array.prototype.push.apply(this.parent.children, removed);
                return child;
            };
            XMLNode2.prototype.remove = function () {
                var i;
                if (this.isRoot) {
                    throw new Error("Cannot remove the root element. " + this.debugInfo());
                }
                i = this.parent.children.indexOf(this);
                [].splice.apply(this.parent.children, [i, i - i + 1].concat([]));
                return this.parent;
            };
            XMLNode2.prototype.node = function (name, attributes, text) {
                var child, ref2;
                if (name != null) {
                    name = getValue(name);
                }
                attributes || (attributes = {});
                attributes = getValue(attributes);
                if (!isObject(attributes)) {
                    ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
                }
                child = new XMLElement2(this, name, attributes);
                if (text != null) {
                    child.text(text);
                }
                this.children.push(child);
                return child;
            };
            XMLNode2.prototype.text = function (value) {
                var child;
                if (isObject(value)) {
                    this.element(value);
                }
                child = new XMLText2(this, value);
                this.children.push(child);
                return this;
            };
            XMLNode2.prototype.cdata = function (value) {
                var child;
                child = new XMLCData2(this, value);
                this.children.push(child);
                return this;
            };
            XMLNode2.prototype.comment = function (value) {
                var child;
                child = new XMLComment2(this, value);
                this.children.push(child);
                return this;
            };
            XMLNode2.prototype.commentBefore = function (value) {
                var i, removed;
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i);
                this.parent.comment(value);
                Array.prototype.push.apply(this.parent.children, removed);
                return this;
            };
            XMLNode2.prototype.commentAfter = function (value) {
                var i, removed;
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i + 1);
                this.parent.comment(value);
                Array.prototype.push.apply(this.parent.children, removed);
                return this;
            };
            XMLNode2.prototype.raw = function (value) {
                var child;
                child = new XMLRaw2(this, value);
                this.children.push(child);
                return this;
            };
            XMLNode2.prototype.dummy = function () {
                var child;
                child = new XMLDummy2(this);
                return child;
            };
            XMLNode2.prototype.instruction = function (target, value) {
                var insTarget, insValue, instruction, j, len;
                if (target != null) {
                    target = getValue(target);
                }
                if (value != null) {
                    value = getValue(value);
                }
                if (Array.isArray(target)) {
                    for (j = 0, len = target.length; j < len; j++) {
                        insTarget = target[j];
                        this.instruction(insTarget);
                    }
                }
                else if (isObject(target)) {
                    for (insTarget in target) {
                        if (!hasProp.call(target, insTarget))
                            continue;
                        insValue = target[insTarget];
                        this.instruction(insTarget, insValue);
                    }
                }
                else {
                    if (isFunction(value)) {
                        value = value.apply();
                    }
                    instruction = new XMLProcessingInstruction2(this, target, value);
                    this.children.push(instruction);
                }
                return this;
            };
            XMLNode2.prototype.instructionBefore = function (target, value) {
                var i, removed;
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i);
                this.parent.instruction(target, value);
                Array.prototype.push.apply(this.parent.children, removed);
                return this;
            };
            XMLNode2.prototype.instructionAfter = function (target, value) {
                var i, removed;
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i + 1);
                this.parent.instruction(target, value);
                Array.prototype.push.apply(this.parent.children, removed);
                return this;
            };
            XMLNode2.prototype.declaration = function (version, encoding, standalone) {
                var doc, xmldec;
                doc = this.document();
                xmldec = new XMLDeclaration2(doc, version, encoding, standalone);
                if (doc.children.length === 0) {
                    doc.children.unshift(xmldec);
                }
                else if (doc.children[0].type === NodeType2.Declaration) {
                    doc.children[0] = xmldec;
                }
                else {
                    doc.children.unshift(xmldec);
                }
                return doc.root() || doc;
            };
            XMLNode2.prototype.dtd = function (pubID, sysID) {
                var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
                doc = this.document();
                doctype = new XMLDocType2(doc, pubID, sysID);
                ref2 = doc.children;
                for (i = j = 0, len = ref2.length; j < len; i = ++j) {
                    child = ref2[i];
                    if (child.type === NodeType2.DocType) {
                        doc.children[i] = doctype;
                        return doctype;
                    }
                }
                ref3 = doc.children;
                for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
                    child = ref3[i];
                    if (child.isRoot) {
                        doc.children.splice(i, 0, doctype);
                        return doctype;
                    }
                }
                doc.children.push(doctype);
                return doctype;
            };
            XMLNode2.prototype.up = function () {
                if (this.isRoot) {
                    throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
                }
                return this.parent;
            };
            XMLNode2.prototype.root = function () {
                var node2;
                node2 = this;
                while (node2) {
                    if (node2.type === NodeType2.Document) {
                        return node2.rootObject;
                    }
                    else if (node2.isRoot) {
                        return node2;
                    }
                    else {
                        node2 = node2.parent;
                    }
                }
            };
            XMLNode2.prototype.document = function () {
                var node2;
                node2 = this;
                while (node2) {
                    if (node2.type === NodeType2.Document) {
                        return node2;
                    }
                    else {
                        node2 = node2.parent;
                    }
                }
            };
            XMLNode2.prototype.end = function (options2) {
                return this.document().end(options2);
            };
            XMLNode2.prototype.prev = function () {
                var i;
                i = this.parent.children.indexOf(this);
                if (i < 1) {
                    throw new Error("Already at the first node. " + this.debugInfo());
                }
                return this.parent.children[i - 1];
            };
            XMLNode2.prototype.next = function () {
                var i;
                i = this.parent.children.indexOf(this);
                if (i === -1 || i === this.parent.children.length - 1) {
                    throw new Error("Already at the last node. " + this.debugInfo());
                }
                return this.parent.children[i + 1];
            };
            XMLNode2.prototype.importDocument = function (doc) {
                var clonedRoot;
                clonedRoot = doc.root().clone();
                clonedRoot.parent = this;
                clonedRoot.isRoot = false;
                this.children.push(clonedRoot);
                return this;
            };
            XMLNode2.prototype.debugInfo = function (name) {
                var ref2, ref3;
                name = name || this.name;
                if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
                    return "";
                }
                else if (name == null) {
                    return "parent: <" + this.parent.name + ">";
                }
                else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
                    return "node: <" + name + ">";
                }
                else {
                    return "node: <" + name + ">, parent: <" + this.parent.name + ">";
                }
            };
            XMLNode2.prototype.ele = function (name, attributes, text) {
                return this.element(name, attributes, text);
            };
            XMLNode2.prototype.nod = function (name, attributes, text) {
                return this.node(name, attributes, text);
            };
            XMLNode2.prototype.txt = function (value) {
                return this.text(value);
            };
            XMLNode2.prototype.dat = function (value) {
                return this.cdata(value);
            };
            XMLNode2.prototype.com = function (value) {
                return this.comment(value);
            };
            XMLNode2.prototype.ins = function (target, value) {
                return this.instruction(target, value);
            };
            XMLNode2.prototype.doc = function () {
                return this.document();
            };
            XMLNode2.prototype.dec = function (version, encoding, standalone) {
                return this.declaration(version, encoding, standalone);
            };
            XMLNode2.prototype.e = function (name, attributes, text) {
                return this.element(name, attributes, text);
            };
            XMLNode2.prototype.n = function (name, attributes, text) {
                return this.node(name, attributes, text);
            };
            XMLNode2.prototype.t = function (value) {
                return this.text(value);
            };
            XMLNode2.prototype.d = function (value) {
                return this.cdata(value);
            };
            XMLNode2.prototype.c = function (value) {
                return this.comment(value);
            };
            XMLNode2.prototype.r = function (value) {
                return this.raw(value);
            };
            XMLNode2.prototype.i = function (target, value) {
                return this.instruction(target, value);
            };
            XMLNode2.prototype.u = function () {
                return this.up();
            };
            XMLNode2.prototype.importXMLBuilder = function (doc) {
                return this.importDocument(doc);
            };
            XMLNode2.prototype.replaceChild = function (newChild, oldChild) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.removeChild = function (oldChild) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.appendChild = function (newChild) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.hasChildNodes = function () {
                return this.children.length !== 0;
            };
            XMLNode2.prototype.cloneNode = function (deep) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.normalize = function () {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.isSupported = function (feature, version) {
                return true;
            };
            XMLNode2.prototype.hasAttributes = function () {
                return this.attribs.length !== 0;
            };
            XMLNode2.prototype.compareDocumentPosition = function (other) {
                var ref2, res;
                ref2 = this;
                if (ref2 === other) {
                    return 0;
                }
                else if (this.document() !== other.document()) {
                    res = DocumentPosition2.Disconnected | DocumentPosition2.ImplementationSpecific;
                    if (Math.random() < 0.5) {
                        res |= DocumentPosition2.Preceding;
                    }
                    else {
                        res |= DocumentPosition2.Following;
                    }
                    return res;
                }
                else if (ref2.isAncestor(other)) {
                    return DocumentPosition2.Contains | DocumentPosition2.Preceding;
                }
                else if (ref2.isDescendant(other)) {
                    return DocumentPosition2.Contains | DocumentPosition2.Following;
                }
                else if (ref2.isPreceding(other)) {
                    return DocumentPosition2.Preceding;
                }
                else {
                    return DocumentPosition2.Following;
                }
            };
            XMLNode2.prototype.isSameNode = function (other) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.lookupPrefix = function (namespaceURI) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.isDefaultNamespace = function (namespaceURI) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.lookupNamespaceURI = function (prefix) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.isEqualNode = function (node2) {
                var i, j, ref2;
                if (node2.nodeType !== this.nodeType) {
                    return false;
                }
                if (node2.children.length !== this.children.length) {
                    return false;
                }
                for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
                    if (!this.children[i].isEqualNode(node2.children[i])) {
                        return false;
                    }
                }
                return true;
            };
            XMLNode2.prototype.getFeature = function (feature, version) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.setUserData = function (key, data, handler) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.getUserData = function (key) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode2.prototype.contains = function (other) {
                if (!other) {
                    return false;
                }
                return other === this || this.isDescendant(other);
            };
            XMLNode2.prototype.isDescendant = function (node2) {
                var child, isDescendantChild, j, len, ref2;
                ref2 = this.children;
                for (j = 0, len = ref2.length; j < len; j++) {
                    child = ref2[j];
                    if (node2 === child) {
                        return true;
                    }
                    isDescendantChild = child.isDescendant(node2);
                    if (isDescendantChild) {
                        return true;
                    }
                }
                return false;
            };
            XMLNode2.prototype.isAncestor = function (node2) {
                return node2.isDescendant(this);
            };
            XMLNode2.prototype.isPreceding = function (node2) {
                var nodePos, thisPos;
                nodePos = this.treePosition(node2);
                thisPos = this.treePosition(this);
                if (nodePos === -1 || thisPos === -1) {
                    return false;
                }
                else {
                    return nodePos < thisPos;
                }
            };
            XMLNode2.prototype.isFollowing = function (node2) {
                var nodePos, thisPos;
                nodePos = this.treePosition(node2);
                thisPos = this.treePosition(this);
                if (nodePos === -1 || thisPos === -1) {
                    return false;
                }
                else {
                    return nodePos > thisPos;
                }
            };
            XMLNode2.prototype.treePosition = function (node2) {
                var found, pos;
                pos = 0;
                found = false;
                this.foreachTreeNode(this.document(), function (childNode) {
                    pos++;
                    if (!found && childNode === node2) {
                        return found = true;
                    }
                });
                if (found) {
                    return pos;
                }
                else {
                    return -1;
                }
            };
            XMLNode2.prototype.foreachTreeNode = function (node2, func) {
                var child, j, len, ref2, res;
                node2 || (node2 = this.document());
                ref2 = node2.children;
                for (j = 0, len = ref2.length; j < len; j++) {
                    child = ref2[j];
                    if (res = func(child)) {
                        return res;
                    }
                    else {
                        res = this.foreachTreeNode(child, func);
                        if (res) {
                            return res;
                        }
                    }
                }
            };
            return XMLNode2;
        }();
    }).call(XMLNode);
    return XMLNode$1.exports;
}
var XMLStringifier$1 = { exports: {} };
var XMLStringifier = XMLStringifier$1.exports;
var hasRequiredXMLStringifier;
function requireXMLStringifier() {
    if (hasRequiredXMLStringifier)
        return XMLStringifier$1.exports;
    hasRequiredXMLStringifier = 1;
    (function () {
        var bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        }, hasProp = {}.hasOwnProperty;
        XMLStringifier$1.exports = function () {
            function XMLStringifier2(options2) {
                this.assertLegalName = bind(this.assertLegalName, this);
                this.assertLegalChar = bind(this.assertLegalChar, this);
                var key, ref2, value;
                options2 || (options2 = {});
                this.options = options2;
                if (!this.options.version) {
                    this.options.version = "1.0";
                }
                ref2 = options2.stringify || {};
                for (key in ref2) {
                    if (!hasProp.call(ref2, key))
                        continue;
                    value = ref2[key];
                    this[key] = value;
                }
            }
            XMLStringifier2.prototype.name = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalName("" + val2 || "");
            };
            XMLStringifier2.prototype.text = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar(this.textEscape("" + val2 || ""));
            };
            XMLStringifier2.prototype.cdata = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                val2 = "" + val2 || "";
                val2 = val2.replace("]]>", "]]]]><![CDATA[>");
                return this.assertLegalChar(val2);
            };
            XMLStringifier2.prototype.comment = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                val2 = "" + val2 || "";
                if (val2.match(/--/)) {
                    throw new Error("Comment text cannot contain double-hypen: " + val2);
                }
                return this.assertLegalChar(val2);
            };
            XMLStringifier2.prototype.raw = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return "" + val2 || "";
            };
            XMLStringifier2.prototype.attValue = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar(this.attEscape(val2 = "" + val2 || ""));
            };
            XMLStringifier2.prototype.insTarget = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.insValue = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                val2 = "" + val2 || "";
                if (val2.match(/\?>/)) {
                    throw new Error("Invalid processing instruction value: " + val2);
                }
                return this.assertLegalChar(val2);
            };
            XMLStringifier2.prototype.xmlVersion = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                val2 = "" + val2 || "";
                if (!val2.match(/1\.[0-9]+/)) {
                    throw new Error("Invalid version number: " + val2);
                }
                return val2;
            };
            XMLStringifier2.prototype.xmlEncoding = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                val2 = "" + val2 || "";
                if (!val2.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
                    throw new Error("Invalid encoding: " + val2);
                }
                return this.assertLegalChar(val2);
            };
            XMLStringifier2.prototype.xmlStandalone = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                if (val2) {
                    return "yes";
                }
                else {
                    return "no";
                }
            };
            XMLStringifier2.prototype.dtdPubID = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.dtdSysID = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.dtdElementValue = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.dtdAttType = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.dtdAttDefault = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.dtdEntityValue = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.dtdNData = function (val2) {
                if (this.options.noValidation) {
                    return val2;
                }
                return this.assertLegalChar("" + val2 || "");
            };
            XMLStringifier2.prototype.convertAttKey = "@";
            XMLStringifier2.prototype.convertPIKey = "?";
            XMLStringifier2.prototype.convertTextKey = "#text";
            XMLStringifier2.prototype.convertCDataKey = "#cdata";
            XMLStringifier2.prototype.convertCommentKey = "#comment";
            XMLStringifier2.prototype.convertRawKey = "#raw";
            XMLStringifier2.prototype.assertLegalChar = function (str) {
                var regex2, res;
                if (this.options.noValidation) {
                    return str;
                }
                regex2 = "";
                if (this.options.version === "1.0") {
                    regex2 = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                    if (res = str.match(regex2)) {
                        throw new Error("Invalid character in string: " + str + " at index " + res.index);
                    }
                }
                else if (this.options.version === "1.1") {
                    regex2 = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                    if (res = str.match(regex2)) {
                        throw new Error("Invalid character in string: " + str + " at index " + res.index);
                    }
                }
                return str;
            };
            XMLStringifier2.prototype.assertLegalName = function (str) {
                var regex2;
                if (this.options.noValidation) {
                    return str;
                }
                this.assertLegalChar(str);
                regex2 = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
                if (!str.match(regex2)) {
                    throw new Error("Invalid character in name");
                }
                return str;
            };
            XMLStringifier2.prototype.textEscape = function (str) {
                var ampregex;
                if (this.options.noValidation) {
                    return str;
                }
                ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
            };
            XMLStringifier2.prototype.attEscape = function (str) {
                var ampregex;
                if (this.options.noValidation) {
                    return str;
                }
                ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
            };
            return XMLStringifier2;
        }();
    }).call(XMLStringifier);
    return XMLStringifier$1.exports;
}
var XMLStringWriter$1 = { exports: {} };
var XMLWriterBase$1 = { exports: {} };
var WriterState$1 = { exports: {} };
var WriterState = WriterState$1.exports;
var hasRequiredWriterState;
function requireWriterState() {
    if (hasRequiredWriterState)
        return WriterState$1.exports;
    hasRequiredWriterState = 1;
    (function () {
        WriterState$1.exports = {
            None: 0,
            OpenTag: 1,
            InsideTag: 2,
            CloseTag: 3
        };
    }).call(WriterState);
    return WriterState$1.exports;
}
var XMLWriterBase = XMLWriterBase$1.exports;
var hasRequiredXMLWriterBase;
function requireXMLWriterBase() {
    if (hasRequiredXMLWriterBase)
        return XMLWriterBase$1.exports;
    hasRequiredXMLWriterBase = 1;
    (function () {
        var NodeType2, WriterState2, assign, hasProp = {}.hasOwnProperty;
        assign = requireUtility().assign;
        NodeType2 = requireNodeType();
        requireXMLDeclaration();
        requireXMLDocType();
        requireXMLCData();
        requireXMLComment();
        requireXMLElement();
        requireXMLRaw();
        requireXMLText();
        requireXMLProcessingInstruction();
        requireXMLDummy();
        requireXMLDTDAttList();
        requireXMLDTDElement();
        requireXMLDTDEntity();
        requireXMLDTDNotation();
        WriterState2 = requireWriterState();
        XMLWriterBase$1.exports = function () {
            function XMLWriterBase2(options2) {
                var key, ref2, value;
                options2 || (options2 = {});
                this.options = options2;
                ref2 = options2.writer || {};
                for (key in ref2) {
                    if (!hasProp.call(ref2, key))
                        continue;
                    value = ref2[key];
                    this["_" + key] = this[key];
                    this[key] = value;
                }
            }
            XMLWriterBase2.prototype.filterOptions = function (options2) {
                var filteredOptions, ref2, ref1, ref22, ref3, ref4, ref5, ref6;
                options2 || (options2 = {});
                options2 = assign({}, this.options, options2);
                filteredOptions = {
                    writer: this
                };
                filteredOptions.pretty = options2.pretty || false;
                filteredOptions.allowEmpty = options2.allowEmpty || false;
                filteredOptions.indent = (ref2 = options2.indent) != null ? ref2 : "  ";
                filteredOptions.newline = (ref1 = options2.newline) != null ? ref1 : "\n";
                filteredOptions.offset = (ref22 = options2.offset) != null ? ref22 : 0;
                filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options2.dontPrettyTextNodes) != null ? ref4 : options2.dontprettytextnodes) != null ? ref3 : 0;
                filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options2.spaceBeforeSlash) != null ? ref6 : options2.spacebeforeslash) != null ? ref5 : "";
                if (filteredOptions.spaceBeforeSlash === true) {
                    filteredOptions.spaceBeforeSlash = " ";
                }
                filteredOptions.suppressPrettyCount = 0;
                filteredOptions.user = {};
                filteredOptions.state = WriterState2.None;
                return filteredOptions;
            };
            XMLWriterBase2.prototype.indent = function (node2, options2, level) {
                var indentLevel;
                if (!options2.pretty || options2.suppressPrettyCount) {
                    return "";
                }
                else if (options2.pretty) {
                    indentLevel = (level || 0) + options2.offset + 1;
                    if (indentLevel > 0) {
                        return new Array(indentLevel).join(options2.indent);
                    }
                }
                return "";
            };
            XMLWriterBase2.prototype.endline = function (node2, options2, level) {
                if (!options2.pretty || options2.suppressPrettyCount) {
                    return "";
                }
                else {
                    return options2.newline;
                }
            };
            XMLWriterBase2.prototype.attribute = function (att, options2, level) {
                var r;
                this.openAttribute(att, options2, level);
                r = " " + att.name + '="' + att.value + '"';
                this.closeAttribute(att, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.cdata = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<![CDATA[";
                options2.state = WriterState2.InsideTag;
                r += node2.value;
                options2.state = WriterState2.CloseTag;
                r += "]]>" + this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.comment = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<!-- ";
                options2.state = WriterState2.InsideTag;
                r += node2.value;
                options2.state = WriterState2.CloseTag;
                r += " -->" + this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.declaration = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<?xml";
                options2.state = WriterState2.InsideTag;
                r += ' version="' + node2.version + '"';
                if (node2.encoding != null) {
                    r += ' encoding="' + node2.encoding + '"';
                }
                if (node2.standalone != null) {
                    r += ' standalone="' + node2.standalone + '"';
                }
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + "?>";
                r += this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.docType = function (node2, options2, level) {
                var child, i, len, r, ref2;
                level || (level = 0);
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level);
                r += "<!DOCTYPE " + node2.root().name;
                if (node2.pubID && node2.sysID) {
                    r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
                }
                else if (node2.sysID) {
                    r += ' SYSTEM "' + node2.sysID + '"';
                }
                if (node2.children.length > 0) {
                    r += " [";
                    r += this.endline(node2, options2, level);
                    options2.state = WriterState2.InsideTag;
                    ref2 = node2.children;
                    for (i = 0, len = ref2.length; i < len; i++) {
                        child = ref2[i];
                        r += this.writeChildNode(child, options2, level + 1);
                    }
                    options2.state = WriterState2.CloseTag;
                    r += "]";
                }
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + ">";
                r += this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.element = function (node2, options2, level) {
                var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref2, ref1, ref22;
                level || (level = 0);
                prettySuppressed = false;
                r = "";
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r += this.indent(node2, options2, level) + "<" + node2.name;
                ref2 = node2.attribs;
                for (name in ref2) {
                    if (!hasProp.call(ref2, name))
                        continue;
                    att = ref2[name];
                    r += this.attribute(att, options2, level);
                }
                childNodeCount = node2.children.length;
                firstChildNode = childNodeCount === 0 ? null : node2.children[0];
                if (childNodeCount === 0 || node2.children.every(function (e) {
                    return (e.type === NodeType2.Text || e.type === NodeType2.Raw) && e.value === "";
                })) {
                    if (options2.allowEmpty) {
                        r += ">";
                        options2.state = WriterState2.CloseTag;
                        r += "</" + node2.name + ">" + this.endline(node2, options2, level);
                    }
                    else {
                        options2.state = WriterState2.CloseTag;
                        r += options2.spaceBeforeSlash + "/>" + this.endline(node2, options2, level);
                    }
                }
                else if (options2.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType2.Text || firstChildNode.type === NodeType2.Raw) && firstChildNode.value != null) {
                    r += ">";
                    options2.state = WriterState2.InsideTag;
                    options2.suppressPrettyCount++;
                    prettySuppressed = true;
                    r += this.writeChildNode(firstChildNode, options2, level + 1);
                    options2.suppressPrettyCount--;
                    prettySuppressed = false;
                    options2.state = WriterState2.CloseTag;
                    r += "</" + node2.name + ">" + this.endline(node2, options2, level);
                }
                else {
                    if (options2.dontPrettyTextNodes) {
                        ref1 = node2.children;
                        for (i = 0, len = ref1.length; i < len; i++) {
                            child = ref1[i];
                            if ((child.type === NodeType2.Text || child.type === NodeType2.Raw) && child.value != null) {
                                options2.suppressPrettyCount++;
                                prettySuppressed = true;
                                break;
                            }
                        }
                    }
                    r += ">" + this.endline(node2, options2, level);
                    options2.state = WriterState2.InsideTag;
                    ref22 = node2.children;
                    for (j = 0, len1 = ref22.length; j < len1; j++) {
                        child = ref22[j];
                        r += this.writeChildNode(child, options2, level + 1);
                    }
                    options2.state = WriterState2.CloseTag;
                    r += this.indent(node2, options2, level) + "</" + node2.name + ">";
                    if (prettySuppressed) {
                        options2.suppressPrettyCount--;
                    }
                    r += this.endline(node2, options2, level);
                    options2.state = WriterState2.None;
                }
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.writeChildNode = function (node2, options2, level) {
                switch (node2.type) {
                    case NodeType2.CData:
                        return this.cdata(node2, options2, level);
                    case NodeType2.Comment:
                        return this.comment(node2, options2, level);
                    case NodeType2.Element:
                        return this.element(node2, options2, level);
                    case NodeType2.Raw:
                        return this.raw(node2, options2, level);
                    case NodeType2.Text:
                        return this.text(node2, options2, level);
                    case NodeType2.ProcessingInstruction:
                        return this.processingInstruction(node2, options2, level);
                    case NodeType2.Dummy:
                        return "";
                    case NodeType2.Declaration:
                        return this.declaration(node2, options2, level);
                    case NodeType2.DocType:
                        return this.docType(node2, options2, level);
                    case NodeType2.AttributeDeclaration:
                        return this.dtdAttList(node2, options2, level);
                    case NodeType2.ElementDeclaration:
                        return this.dtdElement(node2, options2, level);
                    case NodeType2.EntityDeclaration:
                        return this.dtdEntity(node2, options2, level);
                    case NodeType2.NotationDeclaration:
                        return this.dtdNotation(node2, options2, level);
                    default:
                        throw new Error("Unknown XML node type: " + node2.constructor.name);
                }
            };
            XMLWriterBase2.prototype.processingInstruction = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<?";
                options2.state = WriterState2.InsideTag;
                r += node2.target;
                if (node2.value) {
                    r += " " + node2.value;
                }
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + "?>";
                r += this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.raw = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level);
                options2.state = WriterState2.InsideTag;
                r += node2.value;
                options2.state = WriterState2.CloseTag;
                r += this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.text = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level);
                options2.state = WriterState2.InsideTag;
                r += node2.value;
                options2.state = WriterState2.CloseTag;
                r += this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.dtdAttList = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<!ATTLIST";
                options2.state = WriterState2.InsideTag;
                r += " " + node2.elementName + " " + node2.attributeName + " " + node2.attributeType;
                if (node2.defaultValueType !== "#DEFAULT") {
                    r += " " + node2.defaultValueType;
                }
                if (node2.defaultValue) {
                    r += ' "' + node2.defaultValue + '"';
                }
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + ">" + this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.dtdElement = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<!ELEMENT";
                options2.state = WriterState2.InsideTag;
                r += " " + node2.name + " " + node2.value;
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + ">" + this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.dtdEntity = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<!ENTITY";
                options2.state = WriterState2.InsideTag;
                if (node2.pe) {
                    r += " %";
                }
                r += " " + node2.name;
                if (node2.value) {
                    r += ' "' + node2.value + '"';
                }
                else {
                    if (node2.pubID && node2.sysID) {
                        r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
                    }
                    else if (node2.sysID) {
                        r += ' SYSTEM "' + node2.sysID + '"';
                    }
                    if (node2.nData) {
                        r += " NDATA " + node2.nData;
                    }
                }
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + ">" + this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.dtdNotation = function (node2, options2, level) {
                var r;
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                r = this.indent(node2, options2, level) + "<!NOTATION";
                options2.state = WriterState2.InsideTag;
                r += " " + node2.name;
                if (node2.pubID && node2.sysID) {
                    r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
                }
                else if (node2.pubID) {
                    r += ' PUBLIC "' + node2.pubID + '"';
                }
                else if (node2.sysID) {
                    r += ' SYSTEM "' + node2.sysID + '"';
                }
                options2.state = WriterState2.CloseTag;
                r += options2.spaceBeforeSlash + ">" + this.endline(node2, options2, level);
                options2.state = WriterState2.None;
                this.closeNode(node2, options2, level);
                return r;
            };
            XMLWriterBase2.prototype.openNode = function (node2, options2, level) {
            };
            XMLWriterBase2.prototype.closeNode = function (node2, options2, level) {
            };
            XMLWriterBase2.prototype.openAttribute = function (att, options2, level) {
            };
            XMLWriterBase2.prototype.closeAttribute = function (att, options2, level) {
            };
            return XMLWriterBase2;
        }();
    }).call(XMLWriterBase);
    return XMLWriterBase$1.exports;
}
var XMLStringWriter = XMLStringWriter$1.exports;
var hasRequiredXMLStringWriter;
function requireXMLStringWriter() {
    if (hasRequiredXMLStringWriter)
        return XMLStringWriter$1.exports;
    hasRequiredXMLStringWriter = 1;
    (function () {
        var XMLWriterBase2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        XMLWriterBase2 = requireXMLWriterBase();
        XMLStringWriter$1.exports = function (superClass) {
            extend(XMLStringWriter2, superClass);
            function XMLStringWriter2(options2) {
                XMLStringWriter2.__super__.constructor.call(this, options2);
            }
            XMLStringWriter2.prototype.document = function (doc, options2) {
                var child, i, len, r, ref2;
                options2 = this.filterOptions(options2);
                r = "";
                ref2 = doc.children;
                for (i = 0, len = ref2.length; i < len; i++) {
                    child = ref2[i];
                    r += this.writeChildNode(child, options2, 0);
                }
                if (options2.pretty && r.slice(-options2.newline.length) === options2.newline) {
                    r = r.slice(0, -options2.newline.length);
                }
                return r;
            };
            return XMLStringWriter2;
        }(XMLWriterBase2);
    }).call(XMLStringWriter);
    return XMLStringWriter$1.exports;
}
var XMLDocument = XMLDocument$1.exports;
var hasRequiredXMLDocument;
function requireXMLDocument() {
    if (hasRequiredXMLDocument)
        return XMLDocument$1.exports;
    hasRequiredXMLDocument = 1;
    (function () {
        var NodeType2, XMLDOMConfiguration2, XMLDOMImplementation2, XMLNode2, XMLStringWriter2, XMLStringifier2, isPlainObject, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        isPlainObject = requireUtility().isPlainObject;
        XMLDOMImplementation2 = requireXMLDOMImplementation();
        XMLDOMConfiguration2 = requireXMLDOMConfiguration();
        XMLNode2 = requireXMLNode();
        NodeType2 = requireNodeType();
        XMLStringifier2 = requireXMLStringifier();
        XMLStringWriter2 = requireXMLStringWriter();
        XMLDocument$1.exports = function (superClass) {
            extend(XMLDocument2, superClass);
            function XMLDocument2(options2) {
                XMLDocument2.__super__.constructor.call(this, null);
                this.name = "#document";
                this.type = NodeType2.Document;
                this.documentURI = null;
                this.domConfig = new XMLDOMConfiguration2();
                options2 || (options2 = {});
                if (!options2.writer) {
                    options2.writer = new XMLStringWriter2();
                }
                this.options = options2;
                this.stringify = new XMLStringifier2(options2);
            }
            Object.defineProperty(XMLDocument2.prototype, "implementation", {
                value: new XMLDOMImplementation2()
            });
            Object.defineProperty(XMLDocument2.prototype, "doctype", {
                get: function () {
                    var child, i, len, ref2;
                    ref2 = this.children;
                    for (i = 0, len = ref2.length; i < len; i++) {
                        child = ref2[i];
                        if (child.type === NodeType2.DocType) {
                            return child;
                        }
                    }
                    return null;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "documentElement", {
                get: function () {
                    return this.rootObject || null;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
                get: function () {
                    return null;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
                get: function () {
                    return false;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
                get: function () {
                    if (this.children.length !== 0 && this.children[0].type === NodeType2.Declaration) {
                        return this.children[0].encoding;
                    }
                    else {
                        return null;
                    }
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
                get: function () {
                    if (this.children.length !== 0 && this.children[0].type === NodeType2.Declaration) {
                        return this.children[0].standalone === "yes";
                    }
                    else {
                        return false;
                    }
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
                get: function () {
                    if (this.children.length !== 0 && this.children[0].type === NodeType2.Declaration) {
                        return this.children[0].version;
                    }
                    else {
                        return "1.0";
                    }
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "URL", {
                get: function () {
                    return this.documentURI;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "origin", {
                get: function () {
                    return null;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "compatMode", {
                get: function () {
                    return null;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "characterSet", {
                get: function () {
                    return null;
                }
            });
            Object.defineProperty(XMLDocument2.prototype, "contentType", {
                get: function () {
                    return null;
                }
            });
            XMLDocument2.prototype.end = function (writer) {
                var writerOptions;
                writerOptions = {};
                if (!writer) {
                    writer = this.options.writer;
                }
                else if (isPlainObject(writer)) {
                    writerOptions = writer;
                    writer = this.options.writer;
                }
                return writer.document(this, writer.filterOptions(writerOptions));
            };
            XMLDocument2.prototype.toString = function (options2) {
                return this.options.writer.document(this, this.options.writer.filterOptions(options2));
            };
            XMLDocument2.prototype.createElement = function (tagName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createDocumentFragment = function () {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createTextNode = function (data) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createComment = function (data) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createCDATASection = function (data) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createProcessingInstruction = function (target, data) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createAttribute = function (name) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createEntityReference = function (name) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.getElementsByTagName = function (tagname) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.importNode = function (importedNode, deep) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createElementNS = function (namespaceURI, qualifiedName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createAttributeNS = function (namespaceURI, qualifiedName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.getElementById = function (elementId) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.adoptNode = function (source) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.normalizeDocument = function () {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.renameNode = function (node2, namespaceURI, qualifiedName) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.getElementsByClassName = function (classNames) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createEvent = function (eventInterface) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createRange = function () {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createNodeIterator = function (root, whatToShow, filter) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument2.prototype.createTreeWalker = function (root, whatToShow, filter) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            return XMLDocument2;
        }(XMLNode2);
    }).call(XMLDocument);
    return XMLDocument$1.exports;
}
var XMLDocumentCB$1 = { exports: {} };
var XMLDocumentCB = XMLDocumentCB$1.exports;
var hasRequiredXMLDocumentCB;
function requireXMLDocumentCB() {
    if (hasRequiredXMLDocumentCB)
        return XMLDocumentCB$1.exports;
    hasRequiredXMLDocumentCB = 1;
    (function () {
        var NodeType2, WriterState2, XMLAttribute2, XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLDocument2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLStringWriter2, XMLStringifier2, XMLText2, getValue, isFunction, isObject, isPlainObject, ref2, hasProp = {}.hasOwnProperty;
        ref2 = requireUtility(), isObject = ref2.isObject, isFunction = ref2.isFunction, isPlainObject = ref2.isPlainObject, getValue = ref2.getValue;
        NodeType2 = requireNodeType();
        XMLDocument2 = requireXMLDocument();
        XMLElement2 = requireXMLElement();
        XMLCData2 = requireXMLCData();
        XMLComment2 = requireXMLComment();
        XMLRaw2 = requireXMLRaw();
        XMLText2 = requireXMLText();
        XMLProcessingInstruction2 = requireXMLProcessingInstruction();
        XMLDeclaration2 = requireXMLDeclaration();
        XMLDocType2 = requireXMLDocType();
        XMLDTDAttList2 = requireXMLDTDAttList();
        XMLDTDEntity2 = requireXMLDTDEntity();
        XMLDTDElement2 = requireXMLDTDElement();
        XMLDTDNotation2 = requireXMLDTDNotation();
        XMLAttribute2 = requireXMLAttribute();
        XMLStringifier2 = requireXMLStringifier();
        XMLStringWriter2 = requireXMLStringWriter();
        WriterState2 = requireWriterState();
        XMLDocumentCB$1.exports = function () {
            function XMLDocumentCB2(options2, onData, onEnd) {
                var writerOptions;
                this.name = "?xml";
                this.type = NodeType2.Document;
                options2 || (options2 = {});
                writerOptions = {};
                if (!options2.writer) {
                    options2.writer = new XMLStringWriter2();
                }
                else if (isPlainObject(options2.writer)) {
                    writerOptions = options2.writer;
                    options2.writer = new XMLStringWriter2();
                }
                this.options = options2;
                this.writer = options2.writer;
                this.writerOptions = this.writer.filterOptions(writerOptions);
                this.stringify = new XMLStringifier2(options2);
                this.onDataCallback = onData || function () {
                };
                this.onEndCallback = onEnd || function () {
                };
                this.currentNode = null;
                this.currentLevel = -1;
                this.openTags = {};
                this.documentStarted = false;
                this.documentCompleted = false;
                this.root = null;
            }
            XMLDocumentCB2.prototype.createChildNode = function (node2) {
                var att, attName, attributes, child, i, len, ref1, ref22;
                switch (node2.type) {
                    case NodeType2.CData:
                        this.cdata(node2.value);
                        break;
                    case NodeType2.Comment:
                        this.comment(node2.value);
                        break;
                    case NodeType2.Element:
                        attributes = {};
                        ref1 = node2.attribs;
                        for (attName in ref1) {
                            if (!hasProp.call(ref1, attName))
                                continue;
                            att = ref1[attName];
                            attributes[attName] = att.value;
                        }
                        this.node(node2.name, attributes);
                        break;
                    case NodeType2.Dummy:
                        this.dummy();
                        break;
                    case NodeType2.Raw:
                        this.raw(node2.value);
                        break;
                    case NodeType2.Text:
                        this.text(node2.value);
                        break;
                    case NodeType2.ProcessingInstruction:
                        this.instruction(node2.target, node2.value);
                        break;
                    default:
                        throw new Error("This XML node type is not supported in a JS object: " + node2.constructor.name);
                }
                ref22 = node2.children;
                for (i = 0, len = ref22.length; i < len; i++) {
                    child = ref22[i];
                    this.createChildNode(child);
                    if (child.type === NodeType2.Element) {
                        this.up();
                    }
                }
                return this;
            };
            XMLDocumentCB2.prototype.dummy = function () {
                return this;
            };
            XMLDocumentCB2.prototype.node = function (name, attributes, text) {
                var ref1;
                if (name == null) {
                    throw new Error("Missing node name.");
                }
                if (this.root && this.currentLevel === -1) {
                    throw new Error("Document can only have one root node. " + this.debugInfo(name));
                }
                this.openCurrent();
                name = getValue(name);
                if (attributes == null) {
                    attributes = {};
                }
                attributes = getValue(attributes);
                if (!isObject(attributes)) {
                    ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
                }
                this.currentNode = new XMLElement2(this, name, attributes);
                this.currentNode.children = false;
                this.currentLevel++;
                this.openTags[this.currentLevel] = this.currentNode;
                if (text != null) {
                    this.text(text);
                }
                return this;
            };
            XMLDocumentCB2.prototype.element = function (name, attributes, text) {
                var child, i, len, oldValidationFlag, ref1, root;
                if (this.currentNode && this.currentNode.type === NodeType2.DocType) {
                    this.dtdElement.apply(this, arguments);
                }
                else {
                    if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                        oldValidationFlag = this.options.noValidation;
                        this.options.noValidation = true;
                        root = new XMLDocument2(this.options).element("TEMP_ROOT");
                        root.element(name);
                        this.options.noValidation = oldValidationFlag;
                        ref1 = root.children;
                        for (i = 0, len = ref1.length; i < len; i++) {
                            child = ref1[i];
                            this.createChildNode(child);
                            if (child.type === NodeType2.Element) {
                                this.up();
                            }
                        }
                    }
                    else {
                        this.node(name, attributes, text);
                    }
                }
                return this;
            };
            XMLDocumentCB2.prototype.attribute = function (name, value) {
                var attName, attValue;
                if (!this.currentNode || this.currentNode.children) {
                    throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
                }
                if (name != null) {
                    name = getValue(name);
                }
                if (isObject(name)) {
                    for (attName in name) {
                        if (!hasProp.call(name, attName))
                            continue;
                        attValue = name[attName];
                        this.attribute(attName, attValue);
                    }
                }
                else {
                    if (isFunction(value)) {
                        value = value.apply();
                    }
                    if (this.options.keepNullAttributes && value == null) {
                        this.currentNode.attribs[name] = new XMLAttribute2(this, name, "");
                    }
                    else if (value != null) {
                        this.currentNode.attribs[name] = new XMLAttribute2(this, name, value);
                    }
                }
                return this;
            };
            XMLDocumentCB2.prototype.text = function (value) {
                var node2;
                this.openCurrent();
                node2 = new XMLText2(this, value);
                this.onData(this.writer.text(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.cdata = function (value) {
                var node2;
                this.openCurrent();
                node2 = new XMLCData2(this, value);
                this.onData(this.writer.cdata(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.comment = function (value) {
                var node2;
                this.openCurrent();
                node2 = new XMLComment2(this, value);
                this.onData(this.writer.comment(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.raw = function (value) {
                var node2;
                this.openCurrent();
                node2 = new XMLRaw2(this, value);
                this.onData(this.writer.raw(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.instruction = function (target, value) {
                var i, insTarget, insValue, len, node2;
                this.openCurrent();
                if (target != null) {
                    target = getValue(target);
                }
                if (value != null) {
                    value = getValue(value);
                }
                if (Array.isArray(target)) {
                    for (i = 0, len = target.length; i < len; i++) {
                        insTarget = target[i];
                        this.instruction(insTarget);
                    }
                }
                else if (isObject(target)) {
                    for (insTarget in target) {
                        if (!hasProp.call(target, insTarget))
                            continue;
                        insValue = target[insTarget];
                        this.instruction(insTarget, insValue);
                    }
                }
                else {
                    if (isFunction(value)) {
                        value = value.apply();
                    }
                    node2 = new XMLProcessingInstruction2(this, target, value);
                    this.onData(this.writer.processingInstruction(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                }
                return this;
            };
            XMLDocumentCB2.prototype.declaration = function (version, encoding, standalone) {
                var node2;
                this.openCurrent();
                if (this.documentStarted) {
                    throw new Error("declaration() must be the first node.");
                }
                node2 = new XMLDeclaration2(this, version, encoding, standalone);
                this.onData(this.writer.declaration(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.doctype = function (root, pubID, sysID) {
                this.openCurrent();
                if (root == null) {
                    throw new Error("Missing root node name.");
                }
                if (this.root) {
                    throw new Error("dtd() must come before the root node.");
                }
                this.currentNode = new XMLDocType2(this, pubID, sysID);
                this.currentNode.rootNodeName = root;
                this.currentNode.children = false;
                this.currentLevel++;
                this.openTags[this.currentLevel] = this.currentNode;
                return this;
            };
            XMLDocumentCB2.prototype.dtdElement = function (name, value) {
                var node2;
                this.openCurrent();
                node2 = new XMLDTDElement2(this, name, value);
                this.onData(this.writer.dtdElement(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                var node2;
                this.openCurrent();
                node2 = new XMLDTDAttList2(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                this.onData(this.writer.dtdAttList(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.entity = function (name, value) {
                var node2;
                this.openCurrent();
                node2 = new XMLDTDEntity2(this, false, name, value);
                this.onData(this.writer.dtdEntity(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.pEntity = function (name, value) {
                var node2;
                this.openCurrent();
                node2 = new XMLDTDEntity2(this, true, name, value);
                this.onData(this.writer.dtdEntity(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.notation = function (name, value) {
                var node2;
                this.openCurrent();
                node2 = new XMLDTDNotation2(this, name, value);
                this.onData(this.writer.dtdNotation(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                return this;
            };
            XMLDocumentCB2.prototype.up = function () {
                if (this.currentLevel < 0) {
                    throw new Error("The document node has no parent.");
                }
                if (this.currentNode) {
                    if (this.currentNode.children) {
                        this.closeNode(this.currentNode);
                    }
                    else {
                        this.openNode(this.currentNode);
                    }
                    this.currentNode = null;
                }
                else {
                    this.closeNode(this.openTags[this.currentLevel]);
                }
                delete this.openTags[this.currentLevel];
                this.currentLevel--;
                return this;
            };
            XMLDocumentCB2.prototype.end = function () {
                while (this.currentLevel >= 0) {
                    this.up();
                }
                return this.onEnd();
            };
            XMLDocumentCB2.prototype.openCurrent = function () {
                if (this.currentNode) {
                    this.currentNode.children = true;
                    return this.openNode(this.currentNode);
                }
            };
            XMLDocumentCB2.prototype.openNode = function (node2) {
                var att, chunk, name, ref1;
                if (!node2.isOpen) {
                    if (!this.root && this.currentLevel === 0 && node2.type === NodeType2.Element) {
                        this.root = node2;
                    }
                    chunk = "";
                    if (node2.type === NodeType2.Element) {
                        this.writerOptions.state = WriterState2.OpenTag;
                        chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "<" + node2.name;
                        ref1 = node2.attribs;
                        for (name in ref1) {
                            if (!hasProp.call(ref1, name))
                                continue;
                            att = ref1[name];
                            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                        }
                        chunk += (node2.children ? ">" : "/>") + this.writer.endline(node2, this.writerOptions, this.currentLevel);
                        this.writerOptions.state = WriterState2.InsideTag;
                    }
                    else {
                        this.writerOptions.state = WriterState2.OpenTag;
                        chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node2.rootNodeName;
                        if (node2.pubID && node2.sysID) {
                            chunk += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
                        }
                        else if (node2.sysID) {
                            chunk += ' SYSTEM "' + node2.sysID + '"';
                        }
                        if (node2.children) {
                            chunk += " [";
                            this.writerOptions.state = WriterState2.InsideTag;
                        }
                        else {
                            this.writerOptions.state = WriterState2.CloseTag;
                            chunk += ">";
                        }
                        chunk += this.writer.endline(node2, this.writerOptions, this.currentLevel);
                    }
                    this.onData(chunk, this.currentLevel);
                    return node2.isOpen = true;
                }
            };
            XMLDocumentCB2.prototype.closeNode = function (node2) {
                var chunk;
                if (!node2.isClosed) {
                    chunk = "";
                    this.writerOptions.state = WriterState2.CloseTag;
                    if (node2.type === NodeType2.Element) {
                        chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "</" + node2.name + ">" + this.writer.endline(node2, this.writerOptions, this.currentLevel);
                    }
                    else {
                        chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node2, this.writerOptions, this.currentLevel);
                    }
                    this.writerOptions.state = WriterState2.None;
                    this.onData(chunk, this.currentLevel);
                    return node2.isClosed = true;
                }
            };
            XMLDocumentCB2.prototype.onData = function (chunk, level) {
                this.documentStarted = true;
                return this.onDataCallback(chunk, level + 1);
            };
            XMLDocumentCB2.prototype.onEnd = function () {
                this.documentCompleted = true;
                return this.onEndCallback();
            };
            XMLDocumentCB2.prototype.debugInfo = function (name) {
                if (name == null) {
                    return "";
                }
                else {
                    return "node: <" + name + ">";
                }
            };
            XMLDocumentCB2.prototype.ele = function () {
                return this.element.apply(this, arguments);
            };
            XMLDocumentCB2.prototype.nod = function (name, attributes, text) {
                return this.node(name, attributes, text);
            };
            XMLDocumentCB2.prototype.txt = function (value) {
                return this.text(value);
            };
            XMLDocumentCB2.prototype.dat = function (value) {
                return this.cdata(value);
            };
            XMLDocumentCB2.prototype.com = function (value) {
                return this.comment(value);
            };
            XMLDocumentCB2.prototype.ins = function (target, value) {
                return this.instruction(target, value);
            };
            XMLDocumentCB2.prototype.dec = function (version, encoding, standalone) {
                return this.declaration(version, encoding, standalone);
            };
            XMLDocumentCB2.prototype.dtd = function (root, pubID, sysID) {
                return this.doctype(root, pubID, sysID);
            };
            XMLDocumentCB2.prototype.e = function (name, attributes, text) {
                return this.element(name, attributes, text);
            };
            XMLDocumentCB2.prototype.n = function (name, attributes, text) {
                return this.node(name, attributes, text);
            };
            XMLDocumentCB2.prototype.t = function (value) {
                return this.text(value);
            };
            XMLDocumentCB2.prototype.d = function (value) {
                return this.cdata(value);
            };
            XMLDocumentCB2.prototype.c = function (value) {
                return this.comment(value);
            };
            XMLDocumentCB2.prototype.r = function (value) {
                return this.raw(value);
            };
            XMLDocumentCB2.prototype.i = function (target, value) {
                return this.instruction(target, value);
            };
            XMLDocumentCB2.prototype.att = function () {
                if (this.currentNode && this.currentNode.type === NodeType2.DocType) {
                    return this.attList.apply(this, arguments);
                }
                else {
                    return this.attribute.apply(this, arguments);
                }
            };
            XMLDocumentCB2.prototype.a = function () {
                if (this.currentNode && this.currentNode.type === NodeType2.DocType) {
                    return this.attList.apply(this, arguments);
                }
                else {
                    return this.attribute.apply(this, arguments);
                }
            };
            XMLDocumentCB2.prototype.ent = function (name, value) {
                return this.entity(name, value);
            };
            XMLDocumentCB2.prototype.pent = function (name, value) {
                return this.pEntity(name, value);
            };
            XMLDocumentCB2.prototype.not = function (name, value) {
                return this.notation(name, value);
            };
            return XMLDocumentCB2;
        }();
    }).call(XMLDocumentCB);
    return XMLDocumentCB$1.exports;
}
var XMLStreamWriter$1 = { exports: {} };
var XMLStreamWriter = XMLStreamWriter$1.exports;
var hasRequiredXMLStreamWriter;
function requireXMLStreamWriter() {
    if (hasRequiredXMLStreamWriter)
        return XMLStreamWriter$1.exports;
    hasRequiredXMLStreamWriter = 1;
    (function () {
        var NodeType2, WriterState2, XMLWriterBase2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = requireNodeType();
        XMLWriterBase2 = requireXMLWriterBase();
        WriterState2 = requireWriterState();
        XMLStreamWriter$1.exports = function (superClass) {
            extend(XMLStreamWriter2, superClass);
            function XMLStreamWriter2(stream, options2) {
                this.stream = stream;
                XMLStreamWriter2.__super__.constructor.call(this, options2);
            }
            XMLStreamWriter2.prototype.endline = function (node2, options2, level) {
                if (node2.isLastRootNode && options2.state === WriterState2.CloseTag) {
                    return "";
                }
                else {
                    return XMLStreamWriter2.__super__.endline.call(this, node2, options2, level);
                }
            };
            XMLStreamWriter2.prototype.document = function (doc, options2) {
                var child, i, j, k, len, len1, ref2, ref1, results;
                ref2 = doc.children;
                for (i = j = 0, len = ref2.length; j < len; i = ++j) {
                    child = ref2[i];
                    child.isLastRootNode = i === doc.children.length - 1;
                }
                options2 = this.filterOptions(options2);
                ref1 = doc.children;
                results = [];
                for (k = 0, len1 = ref1.length; k < len1; k++) {
                    child = ref1[k];
                    results.push(this.writeChildNode(child, options2, 0));
                }
                return results;
            };
            XMLStreamWriter2.prototype.attribute = function (att, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options2, level));
            };
            XMLStreamWriter2.prototype.cdata = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.comment = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.declaration = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.docType = function (node2, options2, level) {
                var child, j, len, ref2;
                level || (level = 0);
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                this.stream.write(this.indent(node2, options2, level));
                this.stream.write("<!DOCTYPE " + node2.root().name);
                if (node2.pubID && node2.sysID) {
                    this.stream.write(' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"');
                }
                else if (node2.sysID) {
                    this.stream.write(' SYSTEM "' + node2.sysID + '"');
                }
                if (node2.children.length > 0) {
                    this.stream.write(" [");
                    this.stream.write(this.endline(node2, options2, level));
                    options2.state = WriterState2.InsideTag;
                    ref2 = node2.children;
                    for (j = 0, len = ref2.length; j < len; j++) {
                        child = ref2[j];
                        this.writeChildNode(child, options2, level + 1);
                    }
                    options2.state = WriterState2.CloseTag;
                    this.stream.write("]");
                }
                options2.state = WriterState2.CloseTag;
                this.stream.write(options2.spaceBeforeSlash + ">");
                this.stream.write(this.endline(node2, options2, level));
                options2.state = WriterState2.None;
                return this.closeNode(node2, options2, level);
            };
            XMLStreamWriter2.prototype.element = function (node2, options2, level) {
                var att, child, childNodeCount, firstChildNode, j, len, name, ref2, ref1;
                level || (level = 0);
                this.openNode(node2, options2, level);
                options2.state = WriterState2.OpenTag;
                this.stream.write(this.indent(node2, options2, level) + "<" + node2.name);
                ref2 = node2.attribs;
                for (name in ref2) {
                    if (!hasProp.call(ref2, name))
                        continue;
                    att = ref2[name];
                    this.attribute(att, options2, level);
                }
                childNodeCount = node2.children.length;
                firstChildNode = childNodeCount === 0 ? null : node2.children[0];
                if (childNodeCount === 0 || node2.children.every(function (e) {
                    return (e.type === NodeType2.Text || e.type === NodeType2.Raw) && e.value === "";
                })) {
                    if (options2.allowEmpty) {
                        this.stream.write(">");
                        options2.state = WriterState2.CloseTag;
                        this.stream.write("</" + node2.name + ">");
                    }
                    else {
                        options2.state = WriterState2.CloseTag;
                        this.stream.write(options2.spaceBeforeSlash + "/>");
                    }
                }
                else if (options2.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType2.Text || firstChildNode.type === NodeType2.Raw) && firstChildNode.value != null) {
                    this.stream.write(">");
                    options2.state = WriterState2.InsideTag;
                    options2.suppressPrettyCount++;
                    this.writeChildNode(firstChildNode, options2, level + 1);
                    options2.suppressPrettyCount--;
                    options2.state = WriterState2.CloseTag;
                    this.stream.write("</" + node2.name + ">");
                }
                else {
                    this.stream.write(">" + this.endline(node2, options2, level));
                    options2.state = WriterState2.InsideTag;
                    ref1 = node2.children;
                    for (j = 0, len = ref1.length; j < len; j++) {
                        child = ref1[j];
                        this.writeChildNode(child, options2, level + 1);
                    }
                    options2.state = WriterState2.CloseTag;
                    this.stream.write(this.indent(node2, options2, level) + "</" + node2.name + ">");
                }
                this.stream.write(this.endline(node2, options2, level));
                options2.state = WriterState2.None;
                return this.closeNode(node2, options2, level);
            };
            XMLStreamWriter2.prototype.processingInstruction = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.raw = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.text = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.dtdAttList = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.dtdElement = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.dtdEntity = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node2, options2, level));
            };
            XMLStreamWriter2.prototype.dtdNotation = function (node2, options2, level) {
                return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node2, options2, level));
            };
            return XMLStreamWriter2;
        }(XMLWriterBase2);
    }).call(XMLStreamWriter);
    return XMLStreamWriter$1.exports;
}
var hasRequiredLib;
function requireLib() {
    if (hasRequiredLib)
        return lib$1;
    hasRequiredLib = 1;
    (function () {
        var NodeType2, WriterState2, XMLDOMImplementation2, XMLDocument2, XMLDocumentCB2, XMLStreamWriter2, XMLStringWriter2, assign, isFunction, ref2;
        ref2 = requireUtility(), assign = ref2.assign, isFunction = ref2.isFunction;
        XMLDOMImplementation2 = requireXMLDOMImplementation();
        XMLDocument2 = requireXMLDocument();
        XMLDocumentCB2 = requireXMLDocumentCB();
        XMLStringWriter2 = requireXMLStringWriter();
        XMLStreamWriter2 = requireXMLStreamWriter();
        NodeType2 = requireNodeType();
        WriterState2 = requireWriterState();
        lib$1.create = function (name, xmldec, doctype, options2) {
            var doc, root;
            if (name == null) {
                throw new Error("Root element needs a name.");
            }
            options2 = assign({}, xmldec, doctype, options2);
            doc = new XMLDocument2(options2);
            root = doc.element(name);
            if (!options2.headless) {
                doc.declaration(options2);
                if (options2.pubID != null || options2.sysID != null) {
                    doc.dtd(options2);
                }
            }
            return root;
        };
        lib$1.begin = function (options2, onData, onEnd) {
            var ref1;
            if (isFunction(options2)) {
                ref1 = [options2, onData], onData = ref1[0], onEnd = ref1[1];
                options2 = {};
            }
            if (onData) {
                return new XMLDocumentCB2(options2, onData, onEnd);
            }
            else {
                return new XMLDocument2(options2);
            }
        };
        lib$1.stringWriter = function (options2) {
            return new XMLStringWriter2(options2);
        };
        lib$1.streamWriter = function (stream, options2) {
            return new XMLStreamWriter2(stream, options2);
        };
        lib$1.implementation = new XMLDOMImplementation2();
        lib$1.nodeType = NodeType2;
        lib$1.writerState = WriterState2;
    }).call(lib$1);
    return lib$1;
}
var hasRequiredBuilder;
function requireBuilder() {
    if (hasRequiredBuilder)
        return builder;
    hasRequiredBuilder = 1;
    (function () {
        var builder$1, defaults2, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
        builder$1 = requireLib();
        defaults2 = requireDefaults().defaults;
        requiresCDATA = function (entry) {
            return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
        };
        wrapCDATA = function (entry) {
            return "<![CDATA[" + escapeCDATA(entry) + "]]>";
        };
        escapeCDATA = function (entry) {
            return entry.replace("]]>", "]]]]><![CDATA[>");
        };
        builder.Builder = function () {
            function Builder(opts) {
                var key, ref2, value;
                this.options = {};
                ref2 = defaults2["0.2"];
                for (key in ref2) {
                    if (!hasProp.call(ref2, key))
                        continue;
                    value = ref2[key];
                    this.options[key] = value;
                }
                for (key in opts) {
                    if (!hasProp.call(opts, key))
                        continue;
                    value = opts[key];
                    this.options[key] = value;
                }
            }
            Builder.prototype.buildObject = function (rootObj) {
                var attrkey, charkey, render, rootElement, rootName;
                attrkey = this.options.attrkey;
                charkey = this.options.charkey;
                if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults2["0.2"].rootName) {
                    rootName = Object.keys(rootObj)[0];
                    rootObj = rootObj[rootName];
                }
                else {
                    rootName = this.options.rootName;
                }
                render = /* @__PURE__ */ function (_this) {
                    return function (element, obj) {
                        var attr, child, entry, index, key, value;
                        if (typeof obj !== "object") {
                            if (_this.options.cdata && requiresCDATA(obj)) {
                                element.raw(wrapCDATA(obj));
                            }
                            else {
                                element.txt(obj);
                            }
                        }
                        else if (Array.isArray(obj)) {
                            for (index in obj) {
                                if (!hasProp.call(obj, index))
                                    continue;
                                child = obj[index];
                                for (key in child) {
                                    entry = child[key];
                                    element = render(element.ele(key), entry).up();
                                }
                            }
                        }
                        else {
                            for (key in obj) {
                                if (!hasProp.call(obj, key))
                                    continue;
                                child = obj[key];
                                if (key === attrkey) {
                                    if (typeof child === "object") {
                                        for (attr in child) {
                                            value = child[attr];
                                            element = element.att(attr, value);
                                        }
                                    }
                                }
                                else if (key === charkey) {
                                    if (_this.options.cdata && requiresCDATA(child)) {
                                        element = element.raw(wrapCDATA(child));
                                    }
                                    else {
                                        element = element.txt(child);
                                    }
                                }
                                else if (Array.isArray(child)) {
                                    for (index in child) {
                                        if (!hasProp.call(child, index))
                                            continue;
                                        entry = child[index];
                                        if (typeof entry === "string") {
                                            if (_this.options.cdata && requiresCDATA(entry)) {
                                                element = element.ele(key).raw(wrapCDATA(entry)).up();
                                            }
                                            else {
                                                element = element.ele(key, entry).up();
                                            }
                                        }
                                        else {
                                            element = render(element.ele(key), entry).up();
                                        }
                                    }
                                }
                                else if (typeof child === "object") {
                                    element = render(element.ele(key), child).up();
                                }
                                else {
                                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                                        element = element.ele(key).raw(wrapCDATA(child)).up();
                                    }
                                    else {
                                        if (child == null) {
                                            child = "";
                                        }
                                        element = element.ele(key, child.toString()).up();
                                    }
                                }
                            }
                        }
                        return element;
                    };
                }(this);
                rootElement = builder$1.create(rootName, this.options.xmldec, this.options.doctype, {
                    headless: this.options.headless,
                    allowSurrogateChars: this.options.allowSurrogateChars
                });
                return render(rootElement, rootObj).end(this.options.renderOpts);
            };
            return Builder;
        }();
    }).call(builder);
    return builder;
}
var parser = {};
var sax = {};
var hasRequiredSax;
function requireSax() {
    if (hasRequiredSax)
        return sax;
    hasRequiredSax = 1;
    (function (exports2) {
        (function (sax2) {
            sax2.parser = function (strict, opt) {
                return new SAXParser(strict, opt);
            };
            sax2.SAXParser = SAXParser;
            sax2.SAXStream = SAXStream;
            sax2.createStream = createStream;
            sax2.MAX_BUFFER_LENGTH = 64 * 1024;
            var buffers = [
                "comment",
                "sgmlDecl",
                "textNode",
                "tagName",
                "doctype",
                "procInstName",
                "procInstBody",
                "entity",
                "attribName",
                "attribValue",
                "cdata",
                "script"
            ];
            sax2.EVENTS = [
                "text",
                "processinginstruction",
                "sgmldeclaration",
                "doctype",
                "comment",
                "opentagstart",
                "attribute",
                "opentag",
                "closetag",
                "opencdata",
                "cdata",
                "closecdata",
                "error",
                "end",
                "ready",
                "script",
                "opennamespace",
                "closenamespace"
            ];
            function SAXParser(strict, opt) {
                if (!(this instanceof SAXParser)) {
                    return new SAXParser(strict, opt);
                }
                var parser2 = this;
                clearBuffers(parser2);
                parser2.q = parser2.c = "";
                parser2.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
                parser2.opt = opt || {};
                parser2.opt.lowercase = parser2.opt.lowercase || parser2.opt.lowercasetags;
                parser2.looseCase = parser2.opt.lowercase ? "toLowerCase" : "toUpperCase";
                parser2.tags = [];
                parser2.closed = parser2.closedRoot = parser2.sawRoot = false;
                parser2.tag = parser2.error = null;
                parser2.strict = !!strict;
                parser2.noscript = !!(strict || parser2.opt.noscript);
                parser2.state = S.BEGIN;
                parser2.strictEntities = parser2.opt.strictEntities;
                parser2.ENTITIES = parser2.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
                parser2.attribList = [];
                if (parser2.opt.xmlns) {
                    parser2.ns = Object.create(rootNS);
                }
                parser2.trackPosition = parser2.opt.position !== false;
                if (parser2.trackPosition) {
                    parser2.position = parser2.line = parser2.column = 0;
                }
                emit(parser2, "onready");
            }
            if (!Object.create) {
                Object.create = function (o) {
                    function F() {
                    }
                    F.prototype = o;
                    var newf = new F();
                    return newf;
                };
            }
            if (!Object.keys) {
                Object.keys = function (o) {
                    var a = [];
                    for (var i in o)
                        if (o.hasOwnProperty(i))
                            a.push(i);
                    return a;
                };
            }
            function checkBufferLength(parser2) {
                var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
                var maxActual = 0;
                for (var i = 0, l = buffers.length; i < l; i++) {
                    var len = parser2[buffers[i]].length;
                    if (len > maxAllowed) {
                        switch (buffers[i]) {
                            case "textNode":
                                closeText(parser2);
                                break;
                            case "cdata":
                                emitNode(parser2, "oncdata", parser2.cdata);
                                parser2.cdata = "";
                                break;
                            case "script":
                                emitNode(parser2, "onscript", parser2.script);
                                parser2.script = "";
                                break;
                            default:
                                error(parser2, "Max buffer length exceeded: " + buffers[i]);
                        }
                    }
                    maxActual = Math.max(maxActual, len);
                }
                var m = sax2.MAX_BUFFER_LENGTH - maxActual;
                parser2.bufferCheckPosition = m + parser2.position;
            }
            function clearBuffers(parser2) {
                for (var i = 0, l = buffers.length; i < l; i++) {
                    parser2[buffers[i]] = "";
                }
            }
            function flushBuffers(parser2) {
                closeText(parser2);
                if (parser2.cdata !== "") {
                    emitNode(parser2, "oncdata", parser2.cdata);
                    parser2.cdata = "";
                }
                if (parser2.script !== "") {
                    emitNode(parser2, "onscript", parser2.script);
                    parser2.script = "";
                }
            }
            SAXParser.prototype = {
                end: function () {
                    end(this);
                },
                write,
                resume: function () {
                    this.error = null;
                    return this;
                },
                close: function () {
                    return this.write(null);
                },
                flush: function () {
                    flushBuffers(this);
                }
            };
            var Stream;
            try {
                Stream = require("stream").Stream;
            }
            catch (ex) {
                Stream = function () {
                };
            }
            var streamWraps = sax2.EVENTS.filter(function (ev) {
                return ev !== "error" && ev !== "end";
            });
            function createStream(strict, opt) {
                return new SAXStream(strict, opt);
            }
            function SAXStream(strict, opt) {
                if (!(this instanceof SAXStream)) {
                    return new SAXStream(strict, opt);
                }
                Stream.apply(this);
                this._parser = new SAXParser(strict, opt);
                this.writable = true;
                this.readable = true;
                var me = this;
                this._parser.onend = function () {
                    me.emit("end");
                };
                this._parser.onerror = function (er) {
                    me.emit("error", er);
                    me._parser.error = null;
                };
                this._decoder = null;
                streamWraps.forEach(function (ev) {
                    Object.defineProperty(me, "on" + ev, {
                        get: function () {
                            return me._parser["on" + ev];
                        },
                        set: function (h) {
                            if (!h) {
                                me.removeAllListeners(ev);
                                me._parser["on" + ev] = h;
                                return h;
                            }
                            me.on(ev, h);
                        },
                        enumerable: true,
                        configurable: false
                    });
                });
            }
            SAXStream.prototype = Object.create(Stream.prototype, {
                constructor: {
                    value: SAXStream
                }
            });
            SAXStream.prototype.write = function (data) {
                if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
                    if (!this._decoder) {
                        var SD = require$$1.StringDecoder;
                        this._decoder = new SD("utf8");
                    }
                    data = this._decoder.write(data);
                }
                this._parser.write(data.toString());
                this.emit("data", data);
                return true;
            };
            SAXStream.prototype.end = function (chunk) {
                if (chunk && chunk.length) {
                    this.write(chunk);
                }
                this._parser.end();
                return true;
            };
            SAXStream.prototype.on = function (ev, handler) {
                var me = this;
                if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                    me._parser["on" + ev] = function () {
                        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                        args.splice(0, 0, ev);
                        me.emit.apply(me, args);
                    };
                }
                return Stream.prototype.on.call(me, ev, handler);
            };
            var CDATA = "[CDATA[";
            var DOCTYPE = "DOCTYPE";
            var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
            var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
            var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
            var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
            var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
            function isWhitespace(c) {
                return c === " " || c === "\n" || c === "\r" || c === "	";
            }
            function isQuote(c) {
                return c === '"' || c === "'";
            }
            function isAttribEnd(c) {
                return c === ">" || isWhitespace(c);
            }
            function isMatch2(regex2, c) {
                return regex2.test(c);
            }
            function notMatch(regex2, c) {
                return !isMatch2(regex2, c);
            }
            var S = 0;
            sax2.STATE = {
                BEGIN: S++,
                // leading byte order mark or whitespace
                BEGIN_WHITESPACE: S++,
                // leading whitespace
                TEXT: S++,
                // general stuff
                TEXT_ENTITY: S++,
                // &amp and such.
                OPEN_WAKA: S++,
                // <
                SGML_DECL: S++,
                // <!BLARG
                SGML_DECL_QUOTED: S++,
                // <!BLARG foo "bar
                DOCTYPE: S++,
                // <!DOCTYPE
                DOCTYPE_QUOTED: S++,
                // <!DOCTYPE "//blah
                DOCTYPE_DTD: S++,
                // <!DOCTYPE "//blah" [ ...
                DOCTYPE_DTD_QUOTED: S++,
                // <!DOCTYPE "//blah" [ "foo
                COMMENT_STARTING: S++,
                // <!-
                COMMENT: S++,
                // <!--
                COMMENT_ENDING: S++,
                // <!-- blah -
                COMMENT_ENDED: S++,
                // <!-- blah --
                CDATA: S++,
                // <![CDATA[ something
                CDATA_ENDING: S++,
                // ]
                CDATA_ENDING_2: S++,
                // ]]
                PROC_INST: S++,
                // <?hi
                PROC_INST_BODY: S++,
                // <?hi there
                PROC_INST_ENDING: S++,
                // <?hi "there" ?
                OPEN_TAG: S++,
                // <strong
                OPEN_TAG_SLASH: S++,
                // <strong /
                ATTRIB: S++,
                // <a
                ATTRIB_NAME: S++,
                // <a foo
                ATTRIB_NAME_SAW_WHITE: S++,
                // <a foo _
                ATTRIB_VALUE: S++,
                // <a foo=
                ATTRIB_VALUE_QUOTED: S++,
                // <a foo="bar
                ATTRIB_VALUE_CLOSED: S++,
                // <a foo="bar"
                ATTRIB_VALUE_UNQUOTED: S++,
                // <a foo=bar
                ATTRIB_VALUE_ENTITY_Q: S++,
                // <foo bar="&quot;"
                ATTRIB_VALUE_ENTITY_U: S++,
                // <foo bar=&quot
                CLOSE_TAG: S++,
                // </a
                CLOSE_TAG_SAW_WHITE: S++,
                // </a   >
                SCRIPT: S++,
                // <script> ...
                SCRIPT_ENDING: S++
                // <script> ... <
            };
            sax2.XML_ENTITIES = {
                "amp": "&",
                "gt": ">",
                "lt": "<",
                "quot": '"',
                "apos": "'"
            };
            sax2.ENTITIES = {
                "amp": "&",
                "gt": ">",
                "lt": "<",
                "quot": '"',
                "apos": "'",
                "AElig": 198,
                "Aacute": 193,
                "Acirc": 194,
                "Agrave": 192,
                "Aring": 197,
                "Atilde": 195,
                "Auml": 196,
                "Ccedil": 199,
                "ETH": 208,
                "Eacute": 201,
                "Ecirc": 202,
                "Egrave": 200,
                "Euml": 203,
                "Iacute": 205,
                "Icirc": 206,
                "Igrave": 204,
                "Iuml": 207,
                "Ntilde": 209,
                "Oacute": 211,
                "Ocirc": 212,
                "Ograve": 210,
                "Oslash": 216,
                "Otilde": 213,
                "Ouml": 214,
                "THORN": 222,
                "Uacute": 218,
                "Ucirc": 219,
                "Ugrave": 217,
                "Uuml": 220,
                "Yacute": 221,
                "aacute": 225,
                "acirc": 226,
                "aelig": 230,
                "agrave": 224,
                "aring": 229,
                "atilde": 227,
                "auml": 228,
                "ccedil": 231,
                "eacute": 233,
                "ecirc": 234,
                "egrave": 232,
                "eth": 240,
                "euml": 235,
                "iacute": 237,
                "icirc": 238,
                "igrave": 236,
                "iuml": 239,
                "ntilde": 241,
                "oacute": 243,
                "ocirc": 244,
                "ograve": 242,
                "oslash": 248,
                "otilde": 245,
                "ouml": 246,
                "szlig": 223,
                "thorn": 254,
                "uacute": 250,
                "ucirc": 251,
                "ugrave": 249,
                "uuml": 252,
                "yacute": 253,
                "yuml": 255,
                "copy": 169,
                "reg": 174,
                "nbsp": 160,
                "iexcl": 161,
                "cent": 162,
                "pound": 163,
                "curren": 164,
                "yen": 165,
                "brvbar": 166,
                "sect": 167,
                "uml": 168,
                "ordf": 170,
                "laquo": 171,
                "not": 172,
                "shy": 173,
                "macr": 175,
                "deg": 176,
                "plusmn": 177,
                "sup1": 185,
                "sup2": 178,
                "sup3": 179,
                "acute": 180,
                "micro": 181,
                "para": 182,
                "middot": 183,
                "cedil": 184,
                "ordm": 186,
                "raquo": 187,
                "frac14": 188,
                "frac12": 189,
                "frac34": 190,
                "iquest": 191,
                "times": 215,
                "divide": 247,
                "OElig": 338,
                "oelig": 339,
                "Scaron": 352,
                "scaron": 353,
                "Yuml": 376,
                "fnof": 402,
                "circ": 710,
                "tilde": 732,
                "Alpha": 913,
                "Beta": 914,
                "Gamma": 915,
                "Delta": 916,
                "Epsilon": 917,
                "Zeta": 918,
                "Eta": 919,
                "Theta": 920,
                "Iota": 921,
                "Kappa": 922,
                "Lambda": 923,
                "Mu": 924,
                "Nu": 925,
                "Xi": 926,
                "Omicron": 927,
                "Pi": 928,
                "Rho": 929,
                "Sigma": 931,
                "Tau": 932,
                "Upsilon": 933,
                "Phi": 934,
                "Chi": 935,
                "Psi": 936,
                "Omega": 937,
                "alpha": 945,
                "beta": 946,
                "gamma": 947,
                "delta": 948,
                "epsilon": 949,
                "zeta": 950,
                "eta": 951,
                "theta": 952,
                "iota": 953,
                "kappa": 954,
                "lambda": 955,
                "mu": 956,
                "nu": 957,
                "xi": 958,
                "omicron": 959,
                "pi": 960,
                "rho": 961,
                "sigmaf": 962,
                "sigma": 963,
                "tau": 964,
                "upsilon": 965,
                "phi": 966,
                "chi": 967,
                "psi": 968,
                "omega": 969,
                "thetasym": 977,
                "upsih": 978,
                "piv": 982,
                "ensp": 8194,
                "emsp": 8195,
                "thinsp": 8201,
                "zwnj": 8204,
                "zwj": 8205,
                "lrm": 8206,
                "rlm": 8207,
                "ndash": 8211,
                "mdash": 8212,
                "lsquo": 8216,
                "rsquo": 8217,
                "sbquo": 8218,
                "ldquo": 8220,
                "rdquo": 8221,
                "bdquo": 8222,
                "dagger": 8224,
                "Dagger": 8225,
                "bull": 8226,
                "hellip": 8230,
                "permil": 8240,
                "prime": 8242,
                "Prime": 8243,
                "lsaquo": 8249,
                "rsaquo": 8250,
                "oline": 8254,
                "frasl": 8260,
                "euro": 8364,
                "image": 8465,
                "weierp": 8472,
                "real": 8476,
                "trade": 8482,
                "alefsym": 8501,
                "larr": 8592,
                "uarr": 8593,
                "rarr": 8594,
                "darr": 8595,
                "harr": 8596,
                "crarr": 8629,
                "lArr": 8656,
                "uArr": 8657,
                "rArr": 8658,
                "dArr": 8659,
                "hArr": 8660,
                "forall": 8704,
                "part": 8706,
                "exist": 8707,
                "empty": 8709,
                "nabla": 8711,
                "isin": 8712,
                "notin": 8713,
                "ni": 8715,
                "prod": 8719,
                "sum": 8721,
                "minus": 8722,
                "lowast": 8727,
                "radic": 8730,
                "prop": 8733,
                "infin": 8734,
                "ang": 8736,
                "and": 8743,
                "or": 8744,
                "cap": 8745,
                "cup": 8746,
                "int": 8747,
                "there4": 8756,
                "sim": 8764,
                "cong": 8773,
                "asymp": 8776,
                "ne": 8800,
                "equiv": 8801,
                "le": 8804,
                "ge": 8805,
                "sub": 8834,
                "sup": 8835,
                "nsub": 8836,
                "sube": 8838,
                "supe": 8839,
                "oplus": 8853,
                "otimes": 8855,
                "perp": 8869,
                "sdot": 8901,
                "lceil": 8968,
                "rceil": 8969,
                "lfloor": 8970,
                "rfloor": 8971,
                "lang": 9001,
                "rang": 9002,
                "loz": 9674,
                "spades": 9824,
                "clubs": 9827,
                "hearts": 9829,
                "diams": 9830
            };
            Object.keys(sax2.ENTITIES).forEach(function (key) {
                var e = sax2.ENTITIES[key];
                var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
                sax2.ENTITIES[key] = s2;
            });
            for (var s in sax2.STATE) {
                sax2.STATE[sax2.STATE[s]] = s;
            }
            S = sax2.STATE;
            function emit(parser2, event, data) {
                parser2[event] && parser2[event](data);
            }
            function emitNode(parser2, nodeType, data) {
                if (parser2.textNode)
                    closeText(parser2);
                emit(parser2, nodeType, data);
            }
            function closeText(parser2) {
                parser2.textNode = textopts(parser2.opt, parser2.textNode);
                if (parser2.textNode)
                    emit(parser2, "ontext", parser2.textNode);
                parser2.textNode = "";
            }
            function textopts(opt, text) {
                if (opt.trim)
                    text = text.trim();
                if (opt.normalize)
                    text = text.replace(/\s+/g, " ");
                return text;
            }
            function error(parser2, er) {
                closeText(parser2);
                if (parser2.trackPosition) {
                    er += "\nLine: " + parser2.line + "\nColumn: " + parser2.column + "\nChar: " + parser2.c;
                }
                er = new Error(er);
                parser2.error = er;
                emit(parser2, "onerror", er);
                return parser2;
            }
            function end(parser2) {
                if (parser2.sawRoot && !parser2.closedRoot)
                    strictFail(parser2, "Unclosed root tag");
                if (parser2.state !== S.BEGIN && parser2.state !== S.BEGIN_WHITESPACE && parser2.state !== S.TEXT) {
                    error(parser2, "Unexpected end");
                }
                closeText(parser2);
                parser2.c = "";
                parser2.closed = true;
                emit(parser2, "onend");
                SAXParser.call(parser2, parser2.strict, parser2.opt);
                return parser2;
            }
            function strictFail(parser2, message2) {
                if (typeof parser2 !== "object" || !(parser2 instanceof SAXParser)) {
                    throw new Error("bad call to strictFail");
                }
                if (parser2.strict) {
                    error(parser2, message2);
                }
            }
            function newTag(parser2) {
                if (!parser2.strict)
                    parser2.tagName = parser2.tagName[parser2.looseCase]();
                var parent = parser2.tags[parser2.tags.length - 1] || parser2;
                var tag = parser2.tag = { name: parser2.tagName, attributes: {} };
                if (parser2.opt.xmlns) {
                    tag.ns = parent.ns;
                }
                parser2.attribList.length = 0;
                emitNode(parser2, "onopentagstart", tag);
            }
            function qname(name, attribute) {
                var i = name.indexOf(":");
                var qualName = i < 0 ? ["", name] : name.split(":");
                var prefix = qualName[0];
                var local = qualName[1];
                if (attribute && name === "xmlns") {
                    prefix = "xmlns";
                    local = "";
                }
                return { prefix, local };
            }
            function attrib(parser2) {
                if (!parser2.strict) {
                    parser2.attribName = parser2.attribName[parser2.looseCase]();
                }
                if (parser2.attribList.indexOf(parser2.attribName) !== -1 || parser2.tag.attributes.hasOwnProperty(parser2.attribName)) {
                    parser2.attribName = parser2.attribValue = "";
                    return;
                }
                if (parser2.opt.xmlns) {
                    var qn = qname(parser2.attribName, true);
                    var prefix = qn.prefix;
                    var local = qn.local;
                    if (prefix === "xmlns") {
                        if (local === "xml" && parser2.attribValue !== XML_NAMESPACE) {
                            strictFail(parser2, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser2.attribValue);
                        }
                        else if (local === "xmlns" && parser2.attribValue !== XMLNS_NAMESPACE) {
                            strictFail(parser2, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser2.attribValue);
                        }
                        else {
                            var tag = parser2.tag;
                            var parent = parser2.tags[parser2.tags.length - 1] || parser2;
                            if (tag.ns === parent.ns) {
                                tag.ns = Object.create(parent.ns);
                            }
                            tag.ns[local] = parser2.attribValue;
                        }
                    }
                    parser2.attribList.push([parser2.attribName, parser2.attribValue]);
                }
                else {
                    parser2.tag.attributes[parser2.attribName] = parser2.attribValue;
                    emitNode(parser2, "onattribute", {
                        name: parser2.attribName,
                        value: parser2.attribValue
                    });
                }
                parser2.attribName = parser2.attribValue = "";
            }
            function openTag(parser2, selfClosing) {
                if (parser2.opt.xmlns) {
                    var tag = parser2.tag;
                    var qn = qname(parser2.tagName);
                    tag.prefix = qn.prefix;
                    tag.local = qn.local;
                    tag.uri = tag.ns[qn.prefix] || "";
                    if (tag.prefix && !tag.uri) {
                        strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(parser2.tagName));
                        tag.uri = qn.prefix;
                    }
                    var parent = parser2.tags[parser2.tags.length - 1] || parser2;
                    if (tag.ns && parent.ns !== tag.ns) {
                        Object.keys(tag.ns).forEach(function (p) {
                            emitNode(parser2, "onopennamespace", {
                                prefix: p,
                                uri: tag.ns[p]
                            });
                        });
                    }
                    for (var i = 0, l = parser2.attribList.length; i < l; i++) {
                        var nv = parser2.attribList[i];
                        var name = nv[0];
                        var value = nv[1];
                        var qualName = qname(name, true);
                        var prefix = qualName.prefix;
                        var local = qualName.local;
                        var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
                        var a = {
                            name,
                            value,
                            prefix,
                            local,
                            uri: uri2
                        };
                        if (prefix && prefix !== "xmlns" && !uri2) {
                            strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(prefix));
                            a.uri = prefix;
                        }
                        parser2.tag.attributes[name] = a;
                        emitNode(parser2, "onattribute", a);
                    }
                    parser2.attribList.length = 0;
                }
                parser2.tag.isSelfClosing = !!selfClosing;
                parser2.sawRoot = true;
                parser2.tags.push(parser2.tag);
                emitNode(parser2, "onopentag", parser2.tag);
                if (!selfClosing) {
                    if (!parser2.noscript && parser2.tagName.toLowerCase() === "script") {
                        parser2.state = S.SCRIPT;
                    }
                    else {
                        parser2.state = S.TEXT;
                    }
                    parser2.tag = null;
                    parser2.tagName = "";
                }
                parser2.attribName = parser2.attribValue = "";
                parser2.attribList.length = 0;
            }
            function closeTag(parser2) {
                if (!parser2.tagName) {
                    strictFail(parser2, "Weird empty close tag.");
                    parser2.textNode += "</>";
                    parser2.state = S.TEXT;
                    return;
                }
                if (parser2.script) {
                    if (parser2.tagName !== "script") {
                        parser2.script += "</" + parser2.tagName + ">";
                        parser2.tagName = "";
                        parser2.state = S.SCRIPT;
                        return;
                    }
                    emitNode(parser2, "onscript", parser2.script);
                    parser2.script = "";
                }
                var t2 = parser2.tags.length;
                var tagName = parser2.tagName;
                if (!parser2.strict) {
                    tagName = tagName[parser2.looseCase]();
                }
                var closeTo = tagName;
                while (t2--) {
                    var close = parser2.tags[t2];
                    if (close.name !== closeTo) {
                        strictFail(parser2, "Unexpected close tag");
                    }
                    else {
                        break;
                    }
                }
                if (t2 < 0) {
                    strictFail(parser2, "Unmatched closing tag: " + parser2.tagName);
                    parser2.textNode += "</" + parser2.tagName + ">";
                    parser2.state = S.TEXT;
                    return;
                }
                parser2.tagName = tagName;
                var s2 = parser2.tags.length;
                while (s2-- > t2) {
                    var tag = parser2.tag = parser2.tags.pop();
                    parser2.tagName = parser2.tag.name;
                    emitNode(parser2, "onclosetag", parser2.tagName);
                    var x = {};
                    for (var i in tag.ns) {
                        x[i] = tag.ns[i];
                    }
                    var parent = parser2.tags[parser2.tags.length - 1] || parser2;
                    if (parser2.opt.xmlns && tag.ns !== parent.ns) {
                        Object.keys(tag.ns).forEach(function (p) {
                            var n = tag.ns[p];
                            emitNode(parser2, "onclosenamespace", { prefix: p, uri: n });
                        });
                    }
                }
                if (t2 === 0)
                    parser2.closedRoot = true;
                parser2.tagName = parser2.attribValue = parser2.attribName = "";
                parser2.attribList.length = 0;
                parser2.state = S.TEXT;
            }
            function parseEntity(parser2) {
                var entity = parser2.entity;
                var entityLC = entity.toLowerCase();
                var num2;
                var numStr = "";
                if (parser2.ENTITIES[entity]) {
                    return parser2.ENTITIES[entity];
                }
                if (parser2.ENTITIES[entityLC]) {
                    return parser2.ENTITIES[entityLC];
                }
                entity = entityLC;
                if (entity.charAt(0) === "#") {
                    if (entity.charAt(1) === "x") {
                        entity = entity.slice(2);
                        num2 = parseInt(entity, 16);
                        numStr = num2.toString(16);
                    }
                    else {
                        entity = entity.slice(1);
                        num2 = parseInt(entity, 10);
                        numStr = num2.toString(10);
                    }
                }
                entity = entity.replace(/^0+/, "");
                if (isNaN(num2) || numStr.toLowerCase() !== entity) {
                    strictFail(parser2, "Invalid character entity");
                    return "&" + parser2.entity + ";";
                }
                return String.fromCodePoint(num2);
            }
            function beginWhiteSpace(parser2, c) {
                if (c === "<") {
                    parser2.state = S.OPEN_WAKA;
                    parser2.startTagPosition = parser2.position;
                }
                else if (!isWhitespace(c)) {
                    strictFail(parser2, "Non-whitespace before first tag.");
                    parser2.textNode = c;
                    parser2.state = S.TEXT;
                }
            }
            function charAt(chunk, i) {
                var result = "";
                if (i < chunk.length) {
                    result = chunk.charAt(i);
                }
                return result;
            }
            function write(chunk) {
                var parser2 = this;
                if (this.error) {
                    throw this.error;
                }
                if (parser2.closed) {
                    return error(parser2, "Cannot write after close. Assign an onready handler.");
                }
                if (chunk === null) {
                    return end(parser2);
                }
                if (typeof chunk === "object") {
                    chunk = chunk.toString();
                }
                var i = 0;
                var c = "";
                while (true) {
                    c = charAt(chunk, i++);
                    parser2.c = c;
                    if (!c) {
                        break;
                    }
                    if (parser2.trackPosition) {
                        parser2.position++;
                        if (c === "\n") {
                            parser2.line++;
                            parser2.column = 0;
                        }
                        else {
                            parser2.column++;
                        }
                    }
                    switch (parser2.state) {
                        case S.BEGIN:
                            parser2.state = S.BEGIN_WHITESPACE;
                            if (c === "\uFEFF") {
                                continue;
                            }
                            beginWhiteSpace(parser2, c);
                            continue;
                        case S.BEGIN_WHITESPACE:
                            beginWhiteSpace(parser2, c);
                            continue;
                        case S.TEXT:
                            if (parser2.sawRoot && !parser2.closedRoot) {
                                var starti = i - 1;
                                while (c && c !== "<" && c !== "&") {
                                    c = charAt(chunk, i++);
                                    if (c && parser2.trackPosition) {
                                        parser2.position++;
                                        if (c === "\n") {
                                            parser2.line++;
                                            parser2.column = 0;
                                        }
                                        else {
                                            parser2.column++;
                                        }
                                    }
                                }
                                parser2.textNode += chunk.substring(starti, i - 1);
                            }
                            if (c === "<" && !(parser2.sawRoot && parser2.closedRoot && !parser2.strict)) {
                                parser2.state = S.OPEN_WAKA;
                                parser2.startTagPosition = parser2.position;
                            }
                            else {
                                if (!isWhitespace(c) && (!parser2.sawRoot || parser2.closedRoot)) {
                                    strictFail(parser2, "Text data outside of root node.");
                                }
                                if (c === "&") {
                                    parser2.state = S.TEXT_ENTITY;
                                }
                                else {
                                    parser2.textNode += c;
                                }
                            }
                            continue;
                        case S.SCRIPT:
                            if (c === "<") {
                                parser2.state = S.SCRIPT_ENDING;
                            }
                            else {
                                parser2.script += c;
                            }
                            continue;
                        case S.SCRIPT_ENDING:
                            if (c === "/") {
                                parser2.state = S.CLOSE_TAG;
                            }
                            else {
                                parser2.script += "<" + c;
                                parser2.state = S.SCRIPT;
                            }
                            continue;
                        case S.OPEN_WAKA:
                            if (c === "!") {
                                parser2.state = S.SGML_DECL;
                                parser2.sgmlDecl = "";
                            }
                            else if (isWhitespace(c))
                                ;
                            else if (isMatch2(nameStart, c)) {
                                parser2.state = S.OPEN_TAG;
                                parser2.tagName = c;
                            }
                            else if (c === "/") {
                                parser2.state = S.CLOSE_TAG;
                                parser2.tagName = "";
                            }
                            else if (c === "?") {
                                parser2.state = S.PROC_INST;
                                parser2.procInstName = parser2.procInstBody = "";
                            }
                            else {
                                strictFail(parser2, "Unencoded <");
                                if (parser2.startTagPosition + 1 < parser2.position) {
                                    var pad = parser2.position - parser2.startTagPosition;
                                    c = new Array(pad).join(" ") + c;
                                }
                                parser2.textNode += "<" + c;
                                parser2.state = S.TEXT;
                            }
                            continue;
                        case S.SGML_DECL:
                            if ((parser2.sgmlDecl + c).toUpperCase() === CDATA) {
                                emitNode(parser2, "onopencdata");
                                parser2.state = S.CDATA;
                                parser2.sgmlDecl = "";
                                parser2.cdata = "";
                            }
                            else if (parser2.sgmlDecl + c === "--") {
                                parser2.state = S.COMMENT;
                                parser2.comment = "";
                                parser2.sgmlDecl = "";
                            }
                            else if ((parser2.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                                parser2.state = S.DOCTYPE;
                                if (parser2.doctype || parser2.sawRoot) {
                                    strictFail(parser2, "Inappropriately located doctype declaration");
                                }
                                parser2.doctype = "";
                                parser2.sgmlDecl = "";
                            }
                            else if (c === ">") {
                                emitNode(parser2, "onsgmldeclaration", parser2.sgmlDecl);
                                parser2.sgmlDecl = "";
                                parser2.state = S.TEXT;
                            }
                            else if (isQuote(c)) {
                                parser2.state = S.SGML_DECL_QUOTED;
                                parser2.sgmlDecl += c;
                            }
                            else {
                                parser2.sgmlDecl += c;
                            }
                            continue;
                        case S.SGML_DECL_QUOTED:
                            if (c === parser2.q) {
                                parser2.state = S.SGML_DECL;
                                parser2.q = "";
                            }
                            parser2.sgmlDecl += c;
                            continue;
                        case S.DOCTYPE:
                            if (c === ">") {
                                parser2.state = S.TEXT;
                                emitNode(parser2, "ondoctype", parser2.doctype);
                                parser2.doctype = true;
                            }
                            else {
                                parser2.doctype += c;
                                if (c === "[") {
                                    parser2.state = S.DOCTYPE_DTD;
                                }
                                else if (isQuote(c)) {
                                    parser2.state = S.DOCTYPE_QUOTED;
                                    parser2.q = c;
                                }
                            }
                            continue;
                        case S.DOCTYPE_QUOTED:
                            parser2.doctype += c;
                            if (c === parser2.q) {
                                parser2.q = "";
                                parser2.state = S.DOCTYPE;
                            }
                            continue;
                        case S.DOCTYPE_DTD:
                            parser2.doctype += c;
                            if (c === "]") {
                                parser2.state = S.DOCTYPE;
                            }
                            else if (isQuote(c)) {
                                parser2.state = S.DOCTYPE_DTD_QUOTED;
                                parser2.q = c;
                            }
                            continue;
                        case S.DOCTYPE_DTD_QUOTED:
                            parser2.doctype += c;
                            if (c === parser2.q) {
                                parser2.state = S.DOCTYPE_DTD;
                                parser2.q = "";
                            }
                            continue;
                        case S.COMMENT:
                            if (c === "-") {
                                parser2.state = S.COMMENT_ENDING;
                            }
                            else {
                                parser2.comment += c;
                            }
                            continue;
                        case S.COMMENT_ENDING:
                            if (c === "-") {
                                parser2.state = S.COMMENT_ENDED;
                                parser2.comment = textopts(parser2.opt, parser2.comment);
                                if (parser2.comment) {
                                    emitNode(parser2, "oncomment", parser2.comment);
                                }
                                parser2.comment = "";
                            }
                            else {
                                parser2.comment += "-" + c;
                                parser2.state = S.COMMENT;
                            }
                            continue;
                        case S.COMMENT_ENDED:
                            if (c !== ">") {
                                strictFail(parser2, "Malformed comment");
                                parser2.comment += "--" + c;
                                parser2.state = S.COMMENT;
                            }
                            else {
                                parser2.state = S.TEXT;
                            }
                            continue;
                        case S.CDATA:
                            if (c === "]") {
                                parser2.state = S.CDATA_ENDING;
                            }
                            else {
                                parser2.cdata += c;
                            }
                            continue;
                        case S.CDATA_ENDING:
                            if (c === "]") {
                                parser2.state = S.CDATA_ENDING_2;
                            }
                            else {
                                parser2.cdata += "]" + c;
                                parser2.state = S.CDATA;
                            }
                            continue;
                        case S.CDATA_ENDING_2:
                            if (c === ">") {
                                if (parser2.cdata) {
                                    emitNode(parser2, "oncdata", parser2.cdata);
                                }
                                emitNode(parser2, "onclosecdata");
                                parser2.cdata = "";
                                parser2.state = S.TEXT;
                            }
                            else if (c === "]") {
                                parser2.cdata += "]";
                            }
                            else {
                                parser2.cdata += "]]" + c;
                                parser2.state = S.CDATA;
                            }
                            continue;
                        case S.PROC_INST:
                            if (c === "?") {
                                parser2.state = S.PROC_INST_ENDING;
                            }
                            else if (isWhitespace(c)) {
                                parser2.state = S.PROC_INST_BODY;
                            }
                            else {
                                parser2.procInstName += c;
                            }
                            continue;
                        case S.PROC_INST_BODY:
                            if (!parser2.procInstBody && isWhitespace(c)) {
                                continue;
                            }
                            else if (c === "?") {
                                parser2.state = S.PROC_INST_ENDING;
                            }
                            else {
                                parser2.procInstBody += c;
                            }
                            continue;
                        case S.PROC_INST_ENDING:
                            if (c === ">") {
                                emitNode(parser2, "onprocessinginstruction", {
                                    name: parser2.procInstName,
                                    body: parser2.procInstBody
                                });
                                parser2.procInstName = parser2.procInstBody = "";
                                parser2.state = S.TEXT;
                            }
                            else {
                                parser2.procInstBody += "?" + c;
                                parser2.state = S.PROC_INST_BODY;
                            }
                            continue;
                        case S.OPEN_TAG:
                            if (isMatch2(nameBody, c)) {
                                parser2.tagName += c;
                            }
                            else {
                                newTag(parser2);
                                if (c === ">") {
                                    openTag(parser2);
                                }
                                else if (c === "/") {
                                    parser2.state = S.OPEN_TAG_SLASH;
                                }
                                else {
                                    if (!isWhitespace(c)) {
                                        strictFail(parser2, "Invalid character in tag name");
                                    }
                                    parser2.state = S.ATTRIB;
                                }
                            }
                            continue;
                        case S.OPEN_TAG_SLASH:
                            if (c === ">") {
                                openTag(parser2, true);
                                closeTag(parser2);
                            }
                            else {
                                strictFail(parser2, "Forward-slash in opening tag not followed by >");
                                parser2.state = S.ATTRIB;
                            }
                            continue;
                        case S.ATTRIB:
                            if (isWhitespace(c)) {
                                continue;
                            }
                            else if (c === ">") {
                                openTag(parser2);
                            }
                            else if (c === "/") {
                                parser2.state = S.OPEN_TAG_SLASH;
                            }
                            else if (isMatch2(nameStart, c)) {
                                parser2.attribName = c;
                                parser2.attribValue = "";
                                parser2.state = S.ATTRIB_NAME;
                            }
                            else {
                                strictFail(parser2, "Invalid attribute name");
                            }
                            continue;
                        case S.ATTRIB_NAME:
                            if (c === "=") {
                                parser2.state = S.ATTRIB_VALUE;
                            }
                            else if (c === ">") {
                                strictFail(parser2, "Attribute without value");
                                parser2.attribValue = parser2.attribName;
                                attrib(parser2);
                                openTag(parser2);
                            }
                            else if (isWhitespace(c)) {
                                parser2.state = S.ATTRIB_NAME_SAW_WHITE;
                            }
                            else if (isMatch2(nameBody, c)) {
                                parser2.attribName += c;
                            }
                            else {
                                strictFail(parser2, "Invalid attribute name");
                            }
                            continue;
                        case S.ATTRIB_NAME_SAW_WHITE:
                            if (c === "=") {
                                parser2.state = S.ATTRIB_VALUE;
                            }
                            else if (isWhitespace(c)) {
                                continue;
                            }
                            else {
                                strictFail(parser2, "Attribute without value");
                                parser2.tag.attributes[parser2.attribName] = "";
                                parser2.attribValue = "";
                                emitNode(parser2, "onattribute", {
                                    name: parser2.attribName,
                                    value: ""
                                });
                                parser2.attribName = "";
                                if (c === ">") {
                                    openTag(parser2);
                                }
                                else if (isMatch2(nameStart, c)) {
                                    parser2.attribName = c;
                                    parser2.state = S.ATTRIB_NAME;
                                }
                                else {
                                    strictFail(parser2, "Invalid attribute name");
                                    parser2.state = S.ATTRIB;
                                }
                            }
                            continue;
                        case S.ATTRIB_VALUE:
                            if (isWhitespace(c)) {
                                continue;
                            }
                            else if (isQuote(c)) {
                                parser2.q = c;
                                parser2.state = S.ATTRIB_VALUE_QUOTED;
                            }
                            else {
                                strictFail(parser2, "Unquoted attribute value");
                                parser2.state = S.ATTRIB_VALUE_UNQUOTED;
                                parser2.attribValue = c;
                            }
                            continue;
                        case S.ATTRIB_VALUE_QUOTED:
                            if (c !== parser2.q) {
                                if (c === "&") {
                                    parser2.state = S.ATTRIB_VALUE_ENTITY_Q;
                                }
                                else {
                                    parser2.attribValue += c;
                                }
                                continue;
                            }
                            attrib(parser2);
                            parser2.q = "";
                            parser2.state = S.ATTRIB_VALUE_CLOSED;
                            continue;
                        case S.ATTRIB_VALUE_CLOSED:
                            if (isWhitespace(c)) {
                                parser2.state = S.ATTRIB;
                            }
                            else if (c === ">") {
                                openTag(parser2);
                            }
                            else if (c === "/") {
                                parser2.state = S.OPEN_TAG_SLASH;
                            }
                            else if (isMatch2(nameStart, c)) {
                                strictFail(parser2, "No whitespace between attributes");
                                parser2.attribName = c;
                                parser2.attribValue = "";
                                parser2.state = S.ATTRIB_NAME;
                            }
                            else {
                                strictFail(parser2, "Invalid attribute name");
                            }
                            continue;
                        case S.ATTRIB_VALUE_UNQUOTED:
                            if (!isAttribEnd(c)) {
                                if (c === "&") {
                                    parser2.state = S.ATTRIB_VALUE_ENTITY_U;
                                }
                                else {
                                    parser2.attribValue += c;
                                }
                                continue;
                            }
                            attrib(parser2);
                            if (c === ">") {
                                openTag(parser2);
                            }
                            else {
                                parser2.state = S.ATTRIB;
                            }
                            continue;
                        case S.CLOSE_TAG:
                            if (!parser2.tagName) {
                                if (isWhitespace(c)) {
                                    continue;
                                }
                                else if (notMatch(nameStart, c)) {
                                    if (parser2.script) {
                                        parser2.script += "</" + c;
                                        parser2.state = S.SCRIPT;
                                    }
                                    else {
                                        strictFail(parser2, "Invalid tagname in closing tag.");
                                    }
                                }
                                else {
                                    parser2.tagName = c;
                                }
                            }
                            else if (c === ">") {
                                closeTag(parser2);
                            }
                            else if (isMatch2(nameBody, c)) {
                                parser2.tagName += c;
                            }
                            else if (parser2.script) {
                                parser2.script += "</" + parser2.tagName;
                                parser2.tagName = "";
                                parser2.state = S.SCRIPT;
                            }
                            else {
                                if (!isWhitespace(c)) {
                                    strictFail(parser2, "Invalid tagname in closing tag");
                                }
                                parser2.state = S.CLOSE_TAG_SAW_WHITE;
                            }
                            continue;
                        case S.CLOSE_TAG_SAW_WHITE:
                            if (isWhitespace(c)) {
                                continue;
                            }
                            if (c === ">") {
                                closeTag(parser2);
                            }
                            else {
                                strictFail(parser2, "Invalid characters in closing tag");
                            }
                            continue;
                        case S.TEXT_ENTITY:
                        case S.ATTRIB_VALUE_ENTITY_Q:
                        case S.ATTRIB_VALUE_ENTITY_U:
                            var returnState;
                            var buffer;
                            switch (parser2.state) {
                                case S.TEXT_ENTITY:
                                    returnState = S.TEXT;
                                    buffer = "textNode";
                                    break;
                                case S.ATTRIB_VALUE_ENTITY_Q:
                                    returnState = S.ATTRIB_VALUE_QUOTED;
                                    buffer = "attribValue";
                                    break;
                                case S.ATTRIB_VALUE_ENTITY_U:
                                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                                    buffer = "attribValue";
                                    break;
                            }
                            if (c === ";") {
                                parser2[buffer] += parseEntity(parser2);
                                parser2.entity = "";
                                parser2.state = returnState;
                            }
                            else if (isMatch2(parser2.entity.length ? entityBody : entityStart, c)) {
                                parser2.entity += c;
                            }
                            else {
                                strictFail(parser2, "Invalid character in entity name");
                                parser2[buffer] += "&" + parser2.entity + c;
                                parser2.entity = "";
                                parser2.state = returnState;
                            }
                            continue;
                        default:
                            throw new Error(parser2, "Unknown state: " + parser2.state);
                    }
                }
                if (parser2.position >= parser2.bufferCheckPosition) {
                    checkBufferLength(parser2);
                }
                return parser2;
            }
            /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
            if (!String.fromCodePoint) {
                (function () {
                    var stringFromCharCode = String.fromCharCode;
                    var floor2 = Math.floor;
                    var fromCodePoint = function () {
                        var MAX_SIZE = 16384;
                        var codeUnits = [];
                        var highSurrogate;
                        var lowSurrogate;
                        var index = -1;
                        var length = arguments.length;
                        if (!length) {
                            return "";
                        }
                        var result = "";
                        while (++index < length) {
                            var codePoint = Number(arguments[index]);
                            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                codePoint < 0 || // not a valid Unicode code point
                                codePoint > 1114111 || // not a valid Unicode code point
                                floor2(codePoint) !== codePoint) {
                                throw RangeError("Invalid code point: " + codePoint);
                            }
                            if (codePoint <= 65535) {
                                codeUnits.push(codePoint);
                            }
                            else {
                                codePoint -= 65536;
                                highSurrogate = (codePoint >> 10) + 55296;
                                lowSurrogate = codePoint % 1024 + 56320;
                                codeUnits.push(highSurrogate, lowSurrogate);
                            }
                            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                                result += stringFromCharCode.apply(null, codeUnits);
                                codeUnits.length = 0;
                            }
                        }
                        return result;
                    };
                    if (Object.defineProperty) {
                        Object.defineProperty(String, "fromCodePoint", {
                            value: fromCodePoint,
                            configurable: true,
                            writable: true
                        });
                    }
                    else {
                        String.fromCodePoint = fromCodePoint;
                    }
                })();
            }
        })(exports2);
    })(sax);
    return sax;
}
var bom = {};
var hasRequiredBom;
function requireBom() {
    if (hasRequiredBom)
        return bom;
    hasRequiredBom = 1;
    (function () {
        bom.stripBOM = function (str) {
            if (str[0] === "\uFEFF") {
                return str.substring(1);
            }
            else {
                return str;
            }
        };
    }).call(bom);
    return bom;
}
var processors = {};
var hasRequiredProcessors;
function requireProcessors() {
    if (hasRequiredProcessors)
        return processors;
    hasRequiredProcessors = 1;
    (function () {
        var prefixMatch;
        prefixMatch = new RegExp(/(?!xmlns)^.*:/);
        processors.normalize = function (str) {
            return str.toLowerCase();
        };
        processors.firstCharLowerCase = function (str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        };
        processors.stripPrefix = function (str) {
            return str.replace(prefixMatch, "");
        };
        processors.parseNumbers = function (str) {
            if (!isNaN(str)) {
                str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
            }
            return str;
        };
        processors.parseBooleans = function (str) {
            if (/^(?:true|false)$/i.test(str)) {
                str = str.toLowerCase() === "true";
            }
            return str;
        };
    }).call(processors);
    return processors;
}
var hasRequiredParser;
function requireParser() {
    if (hasRequiredParser)
        return parser;
    hasRequiredParser = 1;
    (function (exports2) {
        (function () {
            var bom2, defaults2, defineProperty, events, isEmpty, processItem, processors2, sax2, setImmediate2, bind = function (fn, me) {
                return function () {
                    return fn.apply(me, arguments);
                };
            }, extend = function (child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                }
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            sax2 = requireSax();
            events = require$$1$1;
            bom2 = requireBom();
            processors2 = requireProcessors();
            setImmediate2 = require$$4.setImmediate;
            defaults2 = requireDefaults().defaults;
            isEmpty = function (thing) {
                return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
            };
            processItem = function (processors3, item, key) {
                var i, len, process2;
                for (i = 0, len = processors3.length; i < len; i++) {
                    process2 = processors3[i];
                    item = process2(item, key);
                }
                return item;
            };
            defineProperty = function (obj, key, value) {
                var descriptor;
                descriptor = /* @__PURE__ */ Object.create(null);
                descriptor.value = value;
                descriptor.writable = true;
                descriptor.enumerable = true;
                descriptor.configurable = true;
                return Object.defineProperty(obj, key, descriptor);
            };
            exports2.Parser = function (superClass) {
                extend(Parser2, superClass);
                function Parser2(opts) {
                    this.parseStringPromise = bind(this.parseStringPromise, this);
                    this.parseString = bind(this.parseString, this);
                    this.reset = bind(this.reset, this);
                    this.assignOrPush = bind(this.assignOrPush, this);
                    this.processAsync = bind(this.processAsync, this);
                    var key, ref2, value;
                    if (!(this instanceof exports2.Parser)) {
                        return new exports2.Parser(opts);
                    }
                    this.options = {};
                    ref2 = defaults2["0.2"];
                    for (key in ref2) {
                        if (!hasProp.call(ref2, key))
                            continue;
                        value = ref2[key];
                        this.options[key] = value;
                    }
                    for (key in opts) {
                        if (!hasProp.call(opts, key))
                            continue;
                        value = opts[key];
                        this.options[key] = value;
                    }
                    if (this.options.xmlns) {
                        this.options.xmlnskey = this.options.attrkey + "ns";
                    }
                    if (this.options.normalizeTags) {
                        if (!this.options.tagNameProcessors) {
                            this.options.tagNameProcessors = [];
                        }
                        this.options.tagNameProcessors.unshift(processors2.normalize);
                    }
                    this.reset();
                }
                Parser2.prototype.processAsync = function () {
                    var chunk, err;
                    try {
                        if (this.remaining.length <= this.options.chunkSize) {
                            chunk = this.remaining;
                            this.remaining = "";
                            this.saxParser = this.saxParser.write(chunk);
                            return this.saxParser.close();
                        }
                        else {
                            chunk = this.remaining.substr(0, this.options.chunkSize);
                            this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                            this.saxParser = this.saxParser.write(chunk);
                            return setImmediate2(this.processAsync);
                        }
                    }
                    catch (error1) {
                        err = error1;
                        if (!this.saxParser.errThrown) {
                            this.saxParser.errThrown = true;
                            return this.emit(err);
                        }
                    }
                };
                Parser2.prototype.assignOrPush = function (obj, key, newValue) {
                    if (!(key in obj)) {
                        if (!this.options.explicitArray) {
                            return defineProperty(obj, key, newValue);
                        }
                        else {
                            return defineProperty(obj, key, [newValue]);
                        }
                    }
                    else {
                        if (!(obj[key] instanceof Array)) {
                            defineProperty(obj, key, [obj[key]]);
                        }
                        return obj[key].push(newValue);
                    }
                };
                Parser2.prototype.reset = function () {
                    var attrkey, charkey, ontext, stack;
                    this.removeAllListeners();
                    this.saxParser = sax2.parser(this.options.strict, {
                        trim: false,
                        normalize: false,
                        xmlns: this.options.xmlns
                    });
                    this.saxParser.errThrown = false;
                    this.saxParser.onerror = /* @__PURE__ */ function (_this) {
                        return function (error) {
                            _this.saxParser.resume();
                            if (!_this.saxParser.errThrown) {
                                _this.saxParser.errThrown = true;
                                return _this.emit("error", error);
                            }
                        };
                    }(this);
                    this.saxParser.onend = /* @__PURE__ */ function (_this) {
                        return function () {
                            if (!_this.saxParser.ended) {
                                _this.saxParser.ended = true;
                                return _this.emit("end", _this.resultObject);
                            }
                        };
                    }(this);
                    this.saxParser.ended = false;
                    this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
                    this.resultObject = null;
                    stack = [];
                    attrkey = this.options.attrkey;
                    charkey = this.options.charkey;
                    this.saxParser.onopentag = /* @__PURE__ */ function (_this) {
                        return function (node2) {
                            var key, newValue, obj, processedKey, ref2;
                            obj = {};
                            obj[charkey] = "";
                            if (!_this.options.ignoreAttrs) {
                                ref2 = node2.attributes;
                                for (key in ref2) {
                                    if (!hasProp.call(ref2, key))
                                        continue;
                                    if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                                        obj[attrkey] = {};
                                    }
                                    newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node2.attributes[key], key) : node2.attributes[key];
                                    processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                                    if (_this.options.mergeAttrs) {
                                        _this.assignOrPush(obj, processedKey, newValue);
                                    }
                                    else {
                                        defineProperty(obj[attrkey], processedKey, newValue);
                                    }
                                }
                            }
                            obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node2.name) : node2.name;
                            if (_this.options.xmlns) {
                                obj[_this.options.xmlnskey] = {
                                    uri: node2.uri,
                                    local: node2.local
                                };
                            }
                            return stack.push(obj);
                        };
                    }(this);
                    this.saxParser.onclosetag = /* @__PURE__ */ function (_this) {
                        return function () {
                            var cdata, emptyStr, key, node2, nodeName, obj, objClone, old, s, xpath;
                            obj = stack.pop();
                            nodeName = obj["#name"];
                            if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                                delete obj["#name"];
                            }
                            if (obj.cdata === true) {
                                cdata = obj.cdata;
                                delete obj.cdata;
                            }
                            s = stack[stack.length - 1];
                            if (obj[charkey].match(/^\s*$/) && !cdata) {
                                emptyStr = obj[charkey];
                                delete obj[charkey];
                            }
                            else {
                                if (_this.options.trim) {
                                    obj[charkey] = obj[charkey].trim();
                                }
                                if (_this.options.normalize) {
                                    obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                                }
                                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                    obj = obj[charkey];
                                }
                            }
                            if (isEmpty(obj)) {
                                if (typeof _this.options.emptyTag === "function") {
                                    obj = _this.options.emptyTag();
                                }
                                else {
                                    obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                                }
                            }
                            if (_this.options.validator != null) {
                                xpath = "/" + function () {
                                    var i, len, results;
                                    results = [];
                                    for (i = 0, len = stack.length; i < len; i++) {
                                        node2 = stack[i];
                                        results.push(node2["#name"]);
                                    }
                                    return results;
                                }().concat(nodeName).join("/");
                                (function () {
                                    var err;
                                    try {
                                        return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                                    }
                                    catch (error1) {
                                        err = error1;
                                        return _this.emit("error", err);
                                    }
                                })();
                            }
                            if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                                if (!_this.options.preserveChildrenOrder) {
                                    node2 = {};
                                    if (_this.options.attrkey in obj) {
                                        node2[_this.options.attrkey] = obj[_this.options.attrkey];
                                        delete obj[_this.options.attrkey];
                                    }
                                    if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                        node2[_this.options.charkey] = obj[_this.options.charkey];
                                        delete obj[_this.options.charkey];
                                    }
                                    if (Object.getOwnPropertyNames(obj).length > 0) {
                                        node2[_this.options.childkey] = obj;
                                    }
                                    obj = node2;
                                }
                                else if (s) {
                                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                                    objClone = {};
                                    for (key in obj) {
                                        if (!hasProp.call(obj, key))
                                            continue;
                                        defineProperty(objClone, key, obj[key]);
                                    }
                                    s[_this.options.childkey].push(objClone);
                                    delete obj["#name"];
                                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                        obj = obj[charkey];
                                    }
                                }
                            }
                            if (stack.length > 0) {
                                return _this.assignOrPush(s, nodeName, obj);
                            }
                            else {
                                if (_this.options.explicitRoot) {
                                    old = obj;
                                    obj = {};
                                    defineProperty(obj, nodeName, old);
                                }
                                _this.resultObject = obj;
                                _this.saxParser.ended = true;
                                return _this.emit("end", _this.resultObject);
                            }
                        };
                    }(this);
                    ontext = /* @__PURE__ */ function (_this) {
                        return function (text) {
                            var charChild, s;
                            s = stack[stack.length - 1];
                            if (s) {
                                s[charkey] += text;
                                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                                    charChild = {
                                        "#name": "__text__"
                                    };
                                    charChild[charkey] = text;
                                    if (_this.options.normalize) {
                                        charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                                    }
                                    s[_this.options.childkey].push(charChild);
                                }
                                return s;
                            }
                        };
                    }(this);
                    this.saxParser.ontext = ontext;
                    return this.saxParser.oncdata = /* @__PURE__ */ function (_this) {
                        return function (text) {
                            var s;
                            s = ontext(text);
                            if (s) {
                                return s.cdata = true;
                            }
                        };
                    }();
                };
                Parser2.prototype.parseString = function (str, cb) {
                    var err;
                    if (cb != null && typeof cb === "function") {
                        this.on("end", function (result) {
                            this.reset();
                            return cb(null, result);
                        });
                        this.on("error", function (err2) {
                            this.reset();
                            return cb(err2);
                        });
                    }
                    try {
                        str = str.toString();
                        if (str.trim() === "") {
                            this.emit("end", null);
                            return true;
                        }
                        str = bom2.stripBOM(str);
                        if (this.options.async) {
                            this.remaining = str;
                            setImmediate2(this.processAsync);
                            return this.saxParser;
                        }
                        return this.saxParser.write(str).close();
                    }
                    catch (error1) {
                        err = error1;
                        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                            this.emit("error", err);
                            return this.saxParser.errThrown = true;
                        }
                        else if (this.saxParser.ended) {
                            throw err;
                        }
                    }
                };
                Parser2.prototype.parseStringPromise = function (str) {
                    return new Promise(/* @__PURE__ */ function (_this) {
                        return function (resolve, reject) {
                            return _this.parseString(str, function (err, value) {
                                if (err) {
                                    return reject(err);
                                }
                                else {
                                    return resolve(value);
                                }
                            });
                        };
                    }(this));
                };
                return Parser2;
            }(events);
            exports2.parseString = function (str, a, b) {
                var cb, options2, parser2;
                if (b != null) {
                    if (typeof b === "function") {
                        cb = b;
                    }
                    if (typeof a === "object") {
                        options2 = a;
                    }
                }
                else {
                    if (typeof a === "function") {
                        cb = a;
                    }
                    options2 = {};
                }
                parser2 = new exports2.Parser(options2);
                return parser2.parseString(str, cb);
            };
            exports2.parseStringPromise = function (str, a) {
                var options2, parser2;
                if (typeof a === "object") {
                    options2 = a;
                }
                parser2 = new exports2.Parser(options2);
                return parser2.parseStringPromise(str);
            };
        }).call(parser);
    })(parser);
    return parser;
}
var hasRequiredXml2js;
function requireXml2js() {
    if (hasRequiredXml2js)
        return xml2js;
    hasRequiredXml2js = 1;
    (function () {
        var builder2, defaults2, parser2, processors2, extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        defaults2 = requireDefaults();
        builder2 = requireBuilder();
        parser2 = requireParser();
        processors2 = requireProcessors();
        xml2js.defaults = defaults2.defaults;
        xml2js.processors = processors2;
        xml2js.ValidationError = function (superClass) {
            extend(ValidationError2, superClass);
            function ValidationError2(message2) {
                this.message = message2;
            }
            return ValidationError2;
        }(Error);
        xml2js.Builder = builder2.Builder;
        xml2js.Parser = parser2.Parser;
        xml2js.parseString = parser2.parseString;
        xml2js.parseStringPromise = parser2.parseStringPromise;
    }).call(xml2js);
    return xml2js;
}
var xml2jsExports = requireXml2js();
function sgml2Xml(sgml) {
    return sgml.replace(/&/g, "&#038;").replace(/&amp;/g, "&#038;").replace(/>\s+</g, "><").replace(/\s+</g, "<").replace(/>\s+/g, ">").replace(/\.(?=[^<>]*>)/g, "").replace(/<(\w+?)>([^<]+)/g, "<$1>$2</<added>$1>").replace(/<\/<added>(\w+?)>(<\/\1>)?/g, "</$1>");
}
function html2Plain(value) {
    return value?.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#39;/g, "'").replace(/&quot;/g, '"').replace(/(&amp;|&#038;)/g, "&");
}
async function parseXml(content) {
    return await xml2jsExports.parseStringPromise(content, {
        explicitArray: false,
        trim: true
    });
}
function getStmtTrn(data) {
    const ofx = data?.["OFX"];
    if (ofx?.["CREDITCARDMSGSRSV1"] != null) {
        return getCcStmtTrn(ofx);
    }
    else if (ofx?.["INVSTMTMSGSRSV1"] != null) {
        return getInvStmtTrn(ofx);
    }
    else {
        return getBankStmtTrn(ofx);
    }
}
function getBankStmtTrn(ofx) {
    const msg = ofx?.["BANKMSGSRSV1"];
    const stmtTrnRs = getAsArray(msg?.["STMTTRNRS"]);
    const result = stmtTrnRs.flatMap((s) => {
        const stmtRs = s?.["STMTRS"];
        const tranList = stmtRs?.["BANKTRANLIST"];
        const stmtTrn = tranList?.["STMTTRN"];
        return getAsArray(stmtTrn);
    });
    return result;
}
function getCcStmtTrn(ofx) {
    const msg = ofx?.["CREDITCARDMSGSRSV1"];
    const stmtTrnRs = getAsArray(msg?.["CCSTMTTRNRS"]);
    const result = stmtTrnRs.flatMap((s) => {
        const stmtRs = s?.["CCSTMTRS"];
        const tranList = stmtRs?.["BANKTRANLIST"];
        const stmtTrn = tranList?.["STMTTRN"];
        return getAsArray(stmtTrn);
    });
    return result;
}
function getInvStmtTrn(ofx) {
    const msg = ofx?.["INVSTMTMSGSRSV1"];
    const stmtTrnRs = getAsArray(msg?.["INVSTMTTRNRS"]);
    const result = stmtTrnRs.flatMap((s) => {
        const stmtRs = s?.["INVSTMTRS"];
        const tranList = stmtRs?.["INVTRANLIST"];
        const stmtTrn = tranList?.["INVBANKTRAN"]?.flatMap((t2) => t2?.["STMTTRN"]);
        return getAsArray(stmtTrn);
    });
    return result;
}
function getAsArray(value) {
    return Array.isArray(value) ? value : value === void 0 ? [] : [value];
}
function mapOfxTransaction(stmtTrn) {
    const dtPosted = stmtTrn["DTPOSTED"];
    const transactionDate = dtPosted ? new Date(Number(dtPosted.substring(0, 4)), 
    // year
    Number(dtPosted.substring(4, 6)) - 1, 
    // month (zero-based index)
    Number(dtPosted.substring(6, 8))
    // date
    ) : null;
    return {
        amount: stmtTrn["TRNAMT"],
        type: stmtTrn["TRNTYPE"],
        fitId: stmtTrn["FITID"],
        date: dayFromDate(transactionDate),
        name: html2Plain(stmtTrn["NAME"]),
        memo: html2Plain(stmtTrn["MEMO"])
    };
}
async function ofx2json(ofx) {
    const contents = ofx.split(/<OFX\s?>/, 2);
    const headerString = contents[0].split(/\r?\n/);
    const headers2 = {};
    headerString.forEach((attrs) => {
        if (attrs) {
            const headAttr = attrs.split(/:/, 2);
            headers2[headAttr[0]] = headAttr[1];
        }
    });
    const content = `<OFX>${contents[1]}`;
    let dataParsed = null;
    try {
        dataParsed = await parseXml(content);
    }
    catch (e) {
        const sanitized = sgml2Xml(content);
        dataParsed = await parseXml(sanitized);
    }
    return {
        headers: headers2,
        transactions: getStmtTrn(dataParsed).map(mapOfxTransaction)
    };
}
function qif2json(qif, options2 = {}) {
    const lines = qif.split("\n").filter(Boolean);
    let line = lines.shift();
    const type2 = /!Type:([^$]*)$/.exec(line.trim());
    const data = {
        dateFormat: options2.dateFormat,
        transactions: []
    };
    const transactions = data.transactions;
    let transaction2 = {};
    if (!type2 || !type2.length) {
        throw new Error("File does not appear to be a valid qif file: " + line);
    }
    data.type = type2[1];
    let division = {};
    while (line = lines.shift()) {
        line = line.trim();
        if (line === "^") {
            transactions.push(transaction2);
            transaction2 = {};
            continue;
        }
        switch (line[0]) {
            case "D":
                transaction2.date = line.substring(1);
                break;
            case "T":
                transaction2.amount = line.substring(1);
                break;
            case "N":
                transaction2.number = line.substring(1);
                break;
            case "M":
                transaction2.memo = line.substring(1);
                break;
            case "A":
                transaction2.address = (transaction2.address || []).concat(line.substring(1));
                break;
            case "P":
                transaction2.payee = line.substring(1).replace(/&amp;/g, "&");
                break;
            case "L":
                const lArray = line.substring(1).split(":");
                transaction2.category = lArray[0];
                if (lArray[1] !== void 0) {
                    transaction2.subcategory = lArray[1];
                }
                break;
            case "C":
                transaction2.clearedStatus = line.substring(1);
                break;
            case "S":
                const sArray = line.substring(1).split(":");
                division.category = sArray[0];
                if (sArray[1] !== void 0) {
                    division.subcategory = sArray[1];
                }
                break;
            case "E":
                division.description = line.substring(1);
                break;
            case "$":
                division.amount = parseFloat(line.substring(1));
                if (!(transaction2.division instanceof Array)) {
                    transaction2.division = [];
                }
                transaction2.division.push(division);
                division = {};
                break;
            default:
                throw new Error("Unknown Detail Code: " + line[0]);
        }
    }
    if (Object.keys(transaction2).length) {
        transactions.push(transaction2);
    }
    return data;
}
function findKeys(obj, key) {
    let result = [];
    for (const i in obj) {
        if (!obj.hasOwnProperty(i))
            continue;
        if (i === key) {
            if (Array.isArray(obj[i])) {
                result = result.concat(obj[i]);
            }
            else {
                result.push(obj[i]);
            }
        }
        if (typeof obj[i] === "object") {
            result = result.concat(findKeys(obj[i], key));
        }
    }
    return result;
}
function getPayeeNameFromTxDtls(TxDtls, isDebit) {
    if (TxDtls?.RltdPties) {
        const key = isDebit ? TxDtls.RltdPties.Cdtr : TxDtls.RltdPties.Dbtr;
        const Nm = findKeys(key, "Nm");
        return Nm.length > 0 ? Nm[0] : null;
    }
    return null;
}
function getNotesFromTxDtls(TxDtls) {
    if (TxDtls?.RmtInf) {
        const Ustrd = TxDtls.RmtInf.Ustrd;
        return Array.isArray(Ustrd) ? Ustrd.join(" ") : Ustrd;
    }
    return null;
}
function convertToNumberOrNull(value) {
    const number2 = Number(value);
    return isNaN(number2) ? null : number2;
}
function getDtOrDtTm(Date2) {
    if (!Date2) {
        return null;
    }
    if ("DtTm" in Date2) {
        return Date2.DtTm.slice(0, 10);
    }
    return Date2?.Dt;
}
async function xmlCAMT2json(content) {
    const data = await xml2jsExports.parseStringPromise(content, { explicitArray: false });
    const entries = findKeys(data, "Ntry");
    const transactions = [];
    for (const entry of entries) {
        const id2 = entry.AcctSvcrRef;
        const amount = convertToNumberOrNull(entry.Amt?._);
        const isDebit = entry.CdtDbtInd === "DBIT";
        const date = getDtOrDtTm(entry.ValDt) || getDtOrDtTm(entry.BookgDt);
        if (Array.isArray(entry.NtryDtls?.TxDtls)) {
            entry.NtryDtls.TxDtls.forEach((TxDtls) => {
                const subPayee = getPayeeNameFromTxDtls(TxDtls, isDebit);
                const subNotes = getNotesFromTxDtls(TxDtls);
                const Amt = findKeys(TxDtls, "Amt");
                const amount2 = Amt.length > 0 ? convertToNumberOrNull(Amt[0]._) : null;
                transactions.push({
                    amount: isDebit ? -amount2 : amount2,
                    date,
                    payee_name: subPayee,
                    imported_payee: subPayee,
                    notes: subNotes
                });
            });
        }
        else {
            let payee_name;
            let notes;
            payee_name = getPayeeNameFromTxDtls(entry.NtryDtls?.TxDtls, isDebit);
            if (!payee_name && entry.AddtlNtryInf) {
                payee_name = entry.AddtlNtryInf;
            }
            notes = getNotesFromTxDtls(entry.NtryDtls?.TxDtls);
            if (!notes && entry.AddtlNtryInf && entry.AddtlNtryInf !== payee_name) {
                notes = entry.AddtlNtryInf;
            }
            if (!payee_name && !notes && entry.NtryRef) {
                notes = entry.NtryRef;
            }
            if (payee_name && notes && payee_name.includes(notes)) {
                notes = null;
            }
            const transaction2 = {
                amount: isDebit ? -amount : amount,
                date,
                payee_name,
                imported_payee: payee_name,
                notes
            };
            if (id2) {
                transaction2.imported_id = id2;
            }
            transactions.push(transaction2);
        }
    }
    return transactions.filter((trans) => trans.date != null && trans.amount != null);
}
function parseOfxAmount(amount) {
    if (!amount || typeof amount !== "string") {
        return null;
    }
    let cleaned = amount.trim();
    if (cleaned.startsWith("(") && cleaned.endsWith(")")) {
        cleaned = "-" + cleaned.slice(1, -1);
    }
    cleaned = cleaned.replace(/[^\d.-]/g, "");
    const decimalIndex = cleaned.indexOf(".");
    if (decimalIndex !== -1) {
        const beforeDecimal = cleaned.slice(0, decimalIndex);
        const afterDecimal = cleaned.slice(decimalIndex + 1).replace(/\./g, "");
        cleaned = beforeDecimal + "." + afterDecimal;
    }
    if (!cleaned || cleaned === "-" || cleaned === ".") {
        return null;
    }
    const parsed = parseFloat(cleaned);
    return isNaN(parsed) ? null : parsed;
}
async function parseFile(filepath, options2 = {}) {
    const errors2 = Array();
    const m = filepath.match(/\.[^.]*$/);
    if (m) {
        const ext = m[0];
        switch (ext.toLowerCase()) {
            case ".qif":
                return parseQIF(filepath, options2);
            case ".csv":
            case ".tsv":
                return parseCSV(filepath, options2);
            case ".ofx":
            case ".qfx":
                return parseOFX(filepath, options2);
            case ".xml":
                return parseCAMT(filepath, options2);
        }
    }
    errors2.push({
        message: "Invalid file type",
        internal: ""
    });
    return { errors: errors2, transactions: [] };
}
async function parseCSV(filepath, options2) {
    const errors2 = Array();
    let contents = await readFile(filepath);
    if (options2.skipLines > 0) {
        const lines = contents.split(/\r?\n/);
        contents = lines.slice(options2.skipLines).join("\r\n");
    }
    let data;
    try {
        data = parse(contents, {
            columns: options2?.hasHeaderRow,
            bom: true,
            delimiter: options2?.delimiter || ",",
            // eslint-disable-next-line actual/typography
            quote: '"',
            trim: true,
            relax_column_count: true,
            skip_empty_lines: true
        });
    }
    catch (err) {
        errors2.push({
            message: "Failed parsing: " + err.message,
            internal: err.message
        });
        return { errors: errors2, transactions: [] };
    }
    return { errors: errors2, transactions: data };
}
async function parseQIF(filepath, options2 = {}) {
    const errors2 = Array();
    const contents = await readFile(filepath);
    let data;
    try {
        data = qif2json(contents);
    }
    catch (err) {
        errors2.push({
            message: "Failed parsing: doesnt look like a valid QIF file.",
            internal: err.stack
        });
        return { errors: errors2, transactions: [] };
    }
    return {
        errors: [],
        transactions: data.transactions.map((trans) => ({
            amount: trans.amount != null ? looselyParseAmount(trans.amount) : null,
            date: trans.date,
            payee_name: trans.payee,
            imported_payee: trans.payee,
            notes: options2.importNotes ? trans.memo || null : null
        })).filter((trans) => trans.date != null && trans.amount != null)
    };
}
async function parseOFX(filepath, options2) {
    const errors2 = Array();
    const contents = await readFile(filepath);
    let data;
    try {
        data = await ofx2json(contents);
    }
    catch (err) {
        errors2.push({
            message: "Failed importing file",
            internal: err.stack
        });
        return { errors: errors2 };
    }
    const useMemoFallback = options2.fallbackMissingPayeeToMemo;
    return {
        errors: errors2,
        transactions: data.transactions.map((trans) => {
            const parsedAmount = parseOfxAmount(trans.amount);
            if (parsedAmount === null) {
                errors2.push({
                    message: `Invalid amount format: ${trans.amount}`,
                    internal: `Failed to parse amount: ${trans.amount}`
                });
            }
            return {
                amount: parsedAmount || 0,
                imported_id: trans.fitId,
                date: trans.date,
                payee_name: trans.name || (useMemoFallback ? trans.memo : null),
                imported_payee: trans.name || (useMemoFallback ? trans.memo : null),
                notes: options2.importNotes ? trans.memo || null : null
                //memo used for payee
            };
        })
    };
}
async function parseCAMT(filepath, options2 = {}) {
    const errors2 = Array();
    const contents = await readFile(filepath);
    let data;
    try {
        data = await xmlCAMT2json(contents);
    }
    catch (err) {
        logger.error(err);
        errors2.push({
            message: "Failed importing file",
            internal: err.stack
        });
        return { errors: errors2 };
    }
    return {
        errors: errors2,
        transactions: data.map((trans) => ({
            ...trans,
            notes: options2.importNotes ? trans.notes : null
        }))
    };
}
async function mergeTransactions(transactions) {
    const txIds = transactions?.map((x) => x?.id).filter(Boolean) || [];
    if (txIds.length !== 2) {
        throw new Error("Merging is only possible with 2 transactions, but found " + JSON.stringify(transactions));
    }
    const [a, b] = await Promise.all(txIds.map(getTransaction));
    if (!a || !b) {
        throw new Error("One of the provided transactions does not exist");
    }
    else if (a.amount !== b.amount) {
        throw new Error("Transaction amounts must match for merge");
    }
    const { keep, drop } = determineKeepDrop(a, b);
    await Promise.all([
        updateTransaction$2({
            id: keep.id,
            payee: keep.payee || drop.payee,
            category: keep.category || drop.category,
            notes: keep.notes || drop.notes,
            cleared: keep.cleared || drop.cleared,
            reconciled: keep.reconciled || drop.reconciled
        }),
        deleteTransaction$2(drop)
    ]);
    return keep.id;
}
function determineKeepDrop(a, b) {
    if (b.imported_id && !a.imported_id) {
        return { keep: b, drop: a };
    }
    else if (a.imported_id && !b.imported_id) {
        return { keep: a, drop: b };
    }
    if (b.imported_payee && !a.imported_payee) {
        return { keep: b, drop: a };
    }
    else if (a.imported_payee && !b.imported_payee) {
        return { keep: a, drop: b };
    }
    if (a.date.localeCompare(b.date) < 0) {
        return { keep: a, drop: b };
    }
    else {
        return { keep: b, drop: a };
    }
}
async function handleBatchUpdateTransactions({ added, deleted, updated, learnCategories, runTransfers = true }) {
    const result = await batchUpdateTransactions({
        added,
        updated,
        deleted,
        learnCategories,
        runTransfers
    });
    return result;
}
async function addTransaction(transaction2) {
    await handleBatchUpdateTransactions({ added: [transaction2] });
    return {};
}
async function updateTransaction(transaction2) {
    await handleBatchUpdateTransactions({ updated: [transaction2] });
    return {};
}
async function deleteTransaction(transaction2) {
    await handleBatchUpdateTransactions({ deleted: [transaction2] });
    return {};
}
async function parseTransactionsFile({ filepath, options: options2 }) {
    return parseFile(filepath, options2);
}
async function exportTransactions({ transactions, accounts, categoryGroups, payees }) {
    return exportToCSV(transactions, accounts, categoryGroups, payees);
}
async function exportTransactionsQuery({ query: queryState }) {
    return exportQueryToCSV(new Query(queryState));
}
async function getEarliestTransaction() {
    const { data } = await aqlQuery(q("transactions").options({ splits: "none" }).orderBy({ date: "asc" }).select("*").limit(1));
    return data[0] || null;
}
async function getLatestTransaction() {
    const { data } = await aqlQuery(q("transactions").options({ splits: "none" }).orderBy({ date: "desc" }).select("*").limit(1));
    return data[0] || null;
}
const app = createApp();
app.method("transactions-batch-update", mutator(undoable(handleBatchUpdateTransactions)));
app.method("transactions-merge", mutator(undoable(mergeTransactions)));
app.method("transaction-add", mutator(addTransaction));
app.method("transaction-update", mutator(updateTransaction));
app.method("transaction-delete", mutator(deleteTransaction));
app.method("transactions-parse-file", mutator(parseTransactionsFile));
app.method("transactions-export", mutator(exportTransactions));
app.method("transactions-export-query", mutator(exportTransactionsQuery));
app.method("get-earliest-transaction", getEarliestTransaction);
app.method("get-latest-transaction", getLatestTransaction);
exports.handlers = {};
exports.handlers["undo"] = mutator(async function () {
    return undo();
});
exports.handlers["redo"] = mutator(function () {
    return redo();
});
exports.handlers["make-filters-from-conditions"] = async function ({ conditions, applySpecialCases }) {
    return conditionsToAQL(conditions, { applySpecialCases });
};
exports.handlers["query"] = async function (query) {
    if (query["table"] == null) {
        throw new Error("query has no table, did you forgot to call `.serialize`?");
    }
    return aqlQuery(query);
};
exports.handlers["get-server-version"] = async function () {
    if (!getServer()) {
        return { error: "no-server" };
    }
    let version;
    try {
        const res = await get$2(getServer().BASE_SERVER + "/info");
        const info = JSON.parse(res);
        version = info.build.version;
    }
    catch (err) {
        return { error: "network-failure" };
    }
    return { version };
};
exports.handlers["get-server-url"] = async function () {
    return getServer() && getServer().BASE_SERVER;
};
exports.handlers["set-server-url"] = async function ({ url, validate = true }) {
    if (url == null) {
        await removeItem("user-token");
    }
    else {
        url = url.replace(/\/+$/, "");
        if (validate) {
            const result = await runHandler(exports.handlers["subscribe-needs-bootstrap"], {
                url
            });
            if ("error" in result) {
                return { error: result.error };
            }
        }
    }
    await setItem("server-url", url);
    await setItem("did-bootstrap", true);
    setServer(url);
    return {};
};
exports.handlers["app-focused"] = async function () {
    if (getPrefs() && getPrefs().id) {
        fullSync();
    }
};
exports.handlers = installAPI(exports.handlers);
override((name, args) => runHandler(app$j.handlers[name], args));
app$j.handlers = exports.handlers;
app$j.combine(app$g, app$f, app$e, app$b, app$8, app$6, app$1, app$9, app$c, app$5, app$h, app, app$i, app$7, app$4, app$3, app$d, app$a, app$2);
function getDefaultDocumentDir() {
    return join$1(process.env.ACTUAL_DOCUMENT_DIR, "Actual");
}
async function setupDocumentsDir() {
    async function ensureExists(dir) {
        if (!await exists(dir)) {
            await mkdir(dir);
        }
    }
    let documentDir2 = await getItem("document-dir");
    if (documentDir2) {
        try {
            await ensureExists(documentDir2);
        }
        catch (e) {
            documentDir2 = null;
        }
    }
    if (!documentDir2) {
        documentDir2 = getDefaultDocumentDir();
    }
    await ensureExists(documentDir2);
    _setDocumentDir(documentDir2);
}
async function initApp(isDev, socketName) {
    await init$1();
    await Promise.all([init$3(), init$4()]);
    await setupDocumentsDir();
    const keysStr = await getItem("encrypt-keys");
    if (keysStr) {
        try {
            const keys2 = JSON.parse(keysStr);
            await Promise.all(Object.keys(keys2).map((fileId) => {
                return loadKey(keys2[fileId]);
            }));
        }
        catch (e) {
            logger.log("Error loading key", e);
            throw new Error("load-key-error");
        }
    }
    const url = await getItem("server-url");
    if (!url) {
        await removeItem("user-token");
    }
    setServer(url);
    init$2(socketName, app$j.handlers);
    global.$query = aqlQuery;
    global.$q = q;
    if (isDev) {
        global.$send = (name, args) => runHandler(app$j.handlers[name], args);
        global.$db = db$1;
        global.$setSyncingMode = setSyncingMode;
    }
}
async function init(config2) {
    let dataDir, serverURL;
    if (config2) {
        dataDir = config2.dataDir;
        serverURL = config2.serverURL;
        if (config2.verbose !== void 0) {
            setVerboseMode(config2.verbose);
        }
    }
    else {
        dataDir = process.env.ACTUAL_DATA_DIR;
        serverURL = process.env.ACTUAL_SERVER_URL;
    }
    await init$1();
    await Promise.all([init$3({ persist: false }), init$4()]);
    _setDocumentDir(dataDir || process.cwd());
    if (serverURL) {
        setServer(serverURL);
        if (config2.password) {
            await runHandler(exports.handlers["subscribe-sign-in"], {
                password: config2.password
            });
        }
    }
    else {
        setServer(null);
        app$j.events.on("load-budget", () => {
            setSyncingMode("offline");
        });
    }
    return lib;
}
const lib = {
    getDataDir,
    sendMessage: (msg, args) => send$1(),
    send: async (name, args) => {
        const res = await runHandler(app$j.handlers[name], args);
        return res;
    },
    on: (name, func) => app$j.events.on(name, func),
    q,
    db: db$1
};
exports.getDefaultDocumentDir = getDefaultDocumentDir;
exports.init = init;
exports.initApp = initApp;
exports.lib = lib;
